-- MySQL dump 10.13  Distrib 5.1.73, for redhat-linux-gnu (x86_64)
--
-- Host: localhost    Database: bias
-- ------------------------------------------------------
-- Server version	5.1.73
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `bias`
--

/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `bias` (
  `id` int(11) NOT NULL,
  `source` text,
  `firstname` varchar(200) DEFAULT NULL,
  `english_name` varchar(200) DEFAULT NULL,
  `gender` varchar(1) DEFAULT NULL,
  PRIMARY KEY (`id`)
);
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `bias`
--

INSERT INTO `bias` VALUES (1,'#include<stdio.h>\nint main()\n{\n	int T;\n	int i;\n	int N=6; \n	int x1=1;\n	int x2=1;\n	printf (\"%i %i \", x1, x2);\n	for (i=0;i<N;i++)\n	{\n		T=x1+x2;\n		printf (\"%i \", T);\n		x1=x2;\n		x2=T;\n	}\n	printf (\"\\n\");\n	return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (2,'#include <stdio.h>\n\nint main()\n{\n	int i,N,x1=1,x2=1,t;\n	printf (\"N=\");\n	scanf(\"%d\",&N);\n	printf (\"f0=0\\n\");\n	for (i=1;i<=N;i++)\n	{\n		printf (\"f%d=%d\\n\",i,x1);\n		t=x2;\n		x2=x1;\n		x1=t+x1;\n	}\n	return 0;\n}\n\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (3,'#include<stdio.h>\n\nint main()\n{\n	int i, n, a=0, b=1, c;\n	printf(\"N=\");\n	scanf(\"%d\",&n);\n	printf(\"%d %d \",a,b);\n	for(i=3;i<=n;i++)\n	{\n		c=b;\n		b+=a;\n		a=c;\n		printf(\"%d \",b);\n	}\n	printf(\"\\n\");\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (4,'#include<stdio.h>\nint main()\n{\n	int x=15;\n	int i,j,k,n;\n\n	if(x>=2)\n	{\n		j=0;\n		k=1;\n		printf(\"%d,%d,\",j,k);\n		for(i=2;i<=x;i++)\n		{\n			n=j+k;\n			printf(\"%d,\",n);\n			j=k;\n			k=n;\n		}\n		return 0;\n	};\n	if(x==0)\n	printf(\"0\");\n	if(x==1)\n	printf(\"0,1\");\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (5,'#include <stdio.h>\nint main()\n{\n	int i, n=11, a=0, b=1, c=0;\n	for(i=0;i<n;i++)\n	{	\n		if(n==0)\n			c=a;\n		if(n>=1)\n			c=a+b;\n		a=b;\n		b=c;\n		printf(\"%d\\n\",c);\n	}\n	return(0);\n}\n\n	\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (6,'#include <stdio.h>\nint main()\n{\n	int i,c, a=100, b=40;\n	do\n	{\n		c=a%b;\n		a=b;\n		b=c;\n	}\n	while(c>0);\n	printf(\"%d\\n\",a);\n	return(0);\n}\n\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (7,'#include <stdio.h>\n\nint main ()\n{\n	int i,a,b,nod;\n	printf (\"a=\");\n	scanf (\"%d\",&a);\n	printf (\"b=\");\n        scanf (\"%d\",&b);\n	for (i=1;i<=a;i++)\n		if ((a%i==0)&&(b%i==0)) nod=i;\n	printf (\"???(%d,%d)=%d\",a,b,nod);\n	return 0;\n}\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (8,'#include <stdio.h>\n\nint main()\n{	\n	int i,j,k,l;\n	\n	j=0;\n	k=1;\n	\n	printf(\"%d %d \",j,k);\n	for(i=2;i<20;i++)\n	{\n	l=j+k;\n	\n	printf(\" %d \",l);\n	j=k; k=l;\n	}\n\n	return(0);\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (9,'#include <stdio.h>\nint main()\n{\n	int n=7;\n	int i;\n	if (n==0) \n		printf(\"%d\",n);\n	if (n==1) \n		printf(\"%d, %d\",n-1,n);\n	if (n>1) \n	{\n		int k=0;\n		int j=1;\n		int s=0;\n		printf(\"%d, %d, \",s,j);\n		for (i = 2; i <= n; i++)\n		{\n			k=j+s;\n			s=j;\n			j=k;\n			printf(\"%d, \",k);\n		}\n	}\n\n	return 0;\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (10,'#include <stdio.h>\n\nint main ()\n\n{\n	int x1=0,x2=1,x3,i;\n	printf(\"%d\\n%d\\n\",x1,x2);\n	for (i=0;i<=10;i++)\n	{	\n		x3=x1+x2;\n		printf(\"%d\\n\",x3);\n		x1=x2;\n		x2=x3;\n	}\n	return 0;\n}	\n\n\n	\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (11,'#include<stdio.h> \nint main()\n{\n	int T;\n	int x=40;\n	int y=100;\n	if (x%y==0)\n		printf (\"%i \", y);\n	else\n	{\n		while(x%y!=0)\n			{\n				T=x%y;\n				x=y;\n				y=T;\n			} \n	printf (\"%i \",T);\n	}	\n	return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (12,'#include <stdio.h>\n\n\nint main ()\n{\nint x0, x1, x2, N=10, i;\n\nx0=0; x1=1; x2=x1+x0;\n\nfor (i = 0; i < N; i++)\n{\n	x0 = x1;\n	x1 = x2;\n	x2 = x0 + x1;\n	printf(\"%d\\n\", x0);\n}\n\nreturn 0;\n\n}\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (13,'#include<stdio.h>\nint main()\n{\n	int a,b,c;\n	a=40;\n	b=100;\n	if(a<b)\n	{\n		c=a; \n		a=b; \n		b=c;\n	}\n	if(a%b==0)\n	printf(\"%d\",b);\n	while(a%b!=0)\n	{\n		c=a%b;\n		a=b;\n		b=c;\n	}\n	printf(\"%d\",b);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (14,'#include <stdio.h>\n\nint main()\n{	\n	int i,j,k,l;\n	j=40;\n	k=100;\n\n	if(j<k)\n	{i=j;j=k;k=i;}\n	if(j%k==0)\n	{printf(\"%d\",k);}\n	else \n	{\n		while(j%k!=0)\n		{\n			l=j%k;\n			j=k;\n			k=l;\n	        }\n		printf(\"%d\\n\", l);\n	}\n       return(0);\n       }\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (15,'#include <stdio.h>\n\nint main ()\n{	\n	int c,a,b,f,i;\n	int n=9;\n	a=0;\n	b=1;\n	if(n==0)\n		printf (\"%d \", a);\n	if(n==1)\n		printf (\"%d \", b);\n	if(n>1)\n	for(i=2;i<=n;i++)\n	{\n		f=a+b;\n		printf (\"%d \", f);\n		a = b;\n		b = f;\n	}\n	return 0;\n}\n\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (16,'#include <stdio.h>\nint main()\n{\n	int N = 10;\n	int i;\n	int a=0;\n	int b=1;\n	printf (\"%d %d \", a, b);\n\n	for (i = 0; i < N; i++)\n	{\n		int c = a + b;\n			a=b;\n			b=c;\n		printf(\"%d \", c);\n	}\n\n\n	return 0;\n}\n		\n\n\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (17,'#include <stdio.h>\nint main()\n{\n	int a=100, b=40,d,i;\n	while(!(a%b==0))\n	{\n		for(i=1;b*i<=a;i++)\n		b=b*i;\n		d=a-b;\n		a=b;\n		b=d;\n	}	\n	if(a%b==0)\n	{\n		d=b;\n		printf(\"%d\\n\",d);\n	}	\n\n		\n}		\n\n\n	\n\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (18,'#include <stdio.h>\nfloat f(float(x))\n{\n	return(x*x);\n}\nint main()\n{\n	float a=3.000, b=9.000,x,s=0.000,c;\n	while(a<b)\n	{\n		c=a+0.001;\n		s=s+((f(a)+f(c))/2*0.001);\n		a=c;\n	}	\n	printf(\"%f\\n\",s);\n}\n\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (19,'#include <stdio.h>\nint main()\n{\n	int a = 400;\n	int b = 1001;\n	int c=0;\n	if(a%b == 0) { printf(\"%d\\n\",b);\n		       return 0;\n		     }\n		else { while (a%b > 0) {\n					printf(\"%d %d\\n\", a, b);\n					c = a%b;\n		                         a = b;\n					 b = c;\n				       };\n				       printf(\"%d\\n\",b);\n				       return 0;\n		     };\n}\n\n\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (20,'#include<stdio.h>\nfloat f(float x)\n{\n	return (x*x);\n}\nint main()\n{\n	float a=0;	// ?? \n	float b=1;	// ??\n	float x1=a;\n	float x2=a+0.001;\n	float S=0;\n	float i;\n\n	for (i=x1;i<b;i=i+0.001)\n	{\n		S=S+((f(x1)+f(x2))*(0.001)/2);\n		x1=x2;\n		x2=x2+0.001;\n	}\n\n	printf (\"%f\\n\", S);\n	return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (21,'#include<stdio.h>\nint is_prime (int x)\n{\n	int i;\n	for (i=2; i<x; i++)\n	{\n		if (x%i==0)\n		return 0;\n	}\n	return 1;\n}\nint main()\n{\n	int x;\n	int i;\n	int T=0;\n	int a[7]={5,7,11,29,23,11,83};  \n	for (i=0; i<7; i++)\n	{\n		if (is_prime(a[i])==0)\n		{\n			T=1;\n			break;\n		}\n	}	\n	if (T==1)\n	{\n		printf (\"Est\' sostavnoe chislo\\n\");\n	}\n	else\n	{\n		printf (\"Vse Chisla prostie\\n\");\n	}\n	return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (22,'#include<stdio.h>\n\nint main ()\n{\n	int i, j, t;\n	int M=4;\n\n	static A[4][4]={{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}};\n	static B[4][4]={{21, 0, 0, 0}, {0, 33, 0, 0}, {0, 0, 21, 0}, {0, 0, 0, 21}};\n	static C[4][4]={{0, 0, 0,0 }, {0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}};\n	\n	for (i=0; i<4; i++)\n	{\n		for (j=0; j<4; j++ )\n		{\n			for (t=0; t<4; t++)\n			{\n				C[i][j] = C[i][j] + ( (A[i][t])*(B[t][j]) );\n			}\n		}\n	}\n\n	for (i=0; i<M; i++)\n	{\n		for(j=0; j<M; j++)\n		{\n			printf (\"%i \", C[i][j]);\n		}\n		printf (\"\\n\");\n	}\n\n	return 0;\n}\n\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (23,'#include <stdio.h>\n\nint nod(int a, int b)\n{\n	int c = b;\n	while (c != 0)\n	{\n		c=a%b;\n		a=b;\n		b=c;\n		c=a%b;\n	}\n	return b;\n}\n\nint main()\n{\n	printf(\"%d\\n\", nod(100, 40));\n	return 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (24,'#include <stdio.h>\n#include <math.h>\n\nfloat f(float x)\n{\n	return(sin(x));\n}\nint main()	\n{\n	float a=5,b=7,c;\n	if(f(a)==0)\n		{\n			printf(\"%f\\n\",a);	\n			return(0);\n		}\n	if(f(b)==0)\n		{\n			printf(\"%f\\n\",b);\n			return(0);\n		}\n	if(((f(a)>0)&&(f(b)>0))||((f(a)<0)&&(f(b)<0)))\n	{\n		printf(\"??? ???????\\n\");\n		return(0);\n	}\n	if(f(a)<f(b))\n	{\n		do\n			{	\n				printf(\"%f %f\\n\", a, b);\n				c=(a+b)/2;\n				if(f(c)>=0)\n					b=c;\n				if(f(c)<0)\n					a=c;\n			}	\n		while(b-a>0.0001);\n		printf(\"%f\\n\",c);\n		return(0);\n	}\n	if(f(a)>f(b))\n	{\n		do\n		{\n			printf(\"%f %f\\n\", a, b);\n			c=(a+b)/2;\n			if(f(c)>0)\n				a=c;\n			if(f(c)<0)\n				b=c;\n		}\n		while(b-a>0.0001);\n		printf(\"%f\\n\",c);\n		return(0);\n	}\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (25,'#include<stdio.h>\n\nint main()\n{\n\nint a=40; \nint b=101;\nint c;\n\n\nwhile(a%b!=0)\n{\nc=b;\nb=a%b;\na=c;\n}\nprintf(\"NOD etix 2 schisel raven  %d\\n\",b);\n\n}\n\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (26,'# include <stdio.h>\n#include <math.h>\nfloat f (float x) {return (sin(x));};\n\nint main()\n{\nfloat a = 7;\nfloat b = 5;\nfloat k = f(a);\nfloat t = f(b);\nfloat d,l;\nif (k*t > 0) {printf(\"There\'s no roods\\n\"); return 0;}\nelse { while (a - b > 0.001) {d = (a+b)/2;\n                          l = f(d);\n			  if (k*l>0){a = d; k = f(a);}\n			      else b = d;}\n			      printf(\"%f\\n\",d);}}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (27,'#include<stdio.h>\n#include<math.h>\n\nfloat f(float x)\n{\n	return(sin(x));\n}\n\nint main()\n{\n	float a,b,c,d;\n	printf(\"a=\");\n	scanf(\"%f\",&a);\n	printf(\"b=\");\n	scanf(\"%f\",&b);\n	c=a;\n	while ((f(c)>0.001)||(f(c)<-0.001))\n	{\n		if (f(a)==0)\n			c=a;\n		if (f(b)==0)\n			c=b;\n		if ((f(a)>0)&&(f(b)<0))\n		{\n			d=(a+b)/2;\n			c=d;\n			if (f(d)>0)\n				a=d;\n			if (f(d)<0)\n				b=d;\n		}\n		if ((f(a)<0)&&(f(b)>0))\n		{\n			d=(a+b)/2;\n			c=d;\n			if (f(d)>0)\n				b=d;\n			if (f(d)<0)\n				a=d;\n		}\n                if ((f(a)>0)&&(f(b)>0)||(f(a)<0)&&(f(b)<0))\n		{\n			printf(\"?????? ???\\n\");\n			return(0);\n		}\n	}\n	printf(\"?????? ????????? %f\\n\",c);\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (28,'#include<stdio.h>\n\nint main()\n{\n	int a,b,c=1;\n	printf(\"a=\");\n	scanf(\"%d\",&a);\n	printf(\"b=\");\n	scanf(\"%d\",&b);\n	if (b==0)\n	{\n		printf(\"???(a,b)=%d\\n\",a);\n		return(0);\n	}\n	while (c!=0)\n	{\n		c=a%b;\n		a=b;\n		b=c;\n	}\n	printf(\"???(a,b)=%d\\n\",a);\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (29,'#include <stdio.h>\nint main()\n{\n	int i, i1=1, i2=1, j=0;\n	int N = 10;\n	for (j=0;j<=N;j++)\n	{\n		i=i1+i2;\n		i1=i2;\n		i2=i;\n		printf(\"%d\\n\", i);\n	}\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (30,'#include <stdio.h>\nfloat f(float x)\n{\n	return (x*x);\n}\nint main()\n{\n	float a=0, b=1, e=0.001, i;\n	i=0;\n	while(a<=b)\n	{\n		i=i+(e*(f(a)+f(a+e))/2);\n		a=a+e;\n	}\n	printf(\"%f\",i);\n	return(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (31,'#include<stdio.h>\n#include <math.h>\n\nfloat f(float x)\n{\n	return(sin(x));\n}\n\nint main()\n{\n	float c;\n	float e=0.001;\n	float a=5;\n	float b=7;\n	c=0;\n	if(((f(a)>0)&&(f(b)<0))||((f(a)<0)&&(f(b)>0)))\n	{\n		c=(a+b)/2;\n		while((f(c)>e)||(f(c)<-e))\n		{\n			c=(a+b)/2;\n			if(((f(a)>0)&&(f(c)<0))||((f(a)<0)&&(f(c)>0)))\n				b=c;\n			if(((f(b)>0)&&(f(c)<0))||((f(b)<0)&&(f(c)>0)))\n				a=c;\n		}\n		printf(\"%f\",c);\n	}\n	if((c<e)||(c>-e))\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (32,'#include <stdio.h>\nint main()\n{\n	int N = 10;\n	int i, a=0, b=1;\n	printf(\"%d %d \", a, b );\n	for (i=1; i<N; i++)\n	{\n		int c=a+b;\n		printf(\"%d \",c);\n		a=b;\n		b=c;\n	}\n	return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (33,'#include <stdio.h>\nint main()\n{\n	int a = 100, b = 41, c;\n	while(b!=0)\n	{\n		c = b;\n		b=a%b;\n		a = c;\n	}\n	\n	printf(\"%d\\n\",a);\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (34,'#include<stdio.h>\n#include<math.h>\n\nfloat f(float x)\n{\n	return (sin(x));\n}\n\nint main ()\n{\n	float a = 5;\n	float b = 7;\n	float x;\n\n	float e = 0.001;\n	while( (b-a)> e)\n	{\n		printf(\"%f %f\\n\", a, b);\n		x=(b+a)/2;\n		if(f(x)*f(a)>0)\n		{\n		a = x;\n		}\n		else\n		b = x;\n	}\n	printf(\"%f\\n\", a);\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (35,'#include <stdio.h>\n\nfloat f(float x)\n{\nreturn(x - 3.1);\n}\n\nint main()\n{\n\n	float a=3, b=10, c=(a+b)/2, d=0.001;\n                while ((b-a)>d)\n	       {    printf(\"ot %f do %f\\n\", a, b);\n		    c=(a+b)/2;\n		    if ((f(a)>0 && f(c)>0) || (f(a)<0 && f(c)<0))\n			         a=c;\n		    else if ((f(c)>0 && f(b)>0) || (f(c)<0 && f(b)<0))\n			       	 b=c;\n		}\n 		\n		printf(\"%f - koren uravnenia\", c);\n\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (36,'#include <stdio.h>\n#include <math.h>\n\nfloat f (float x)\n{\n	return sin(x);\n}\n\nint sgn (float x)\n{\n	if (x<0) return -1;\n	if (x>0) return 1;\n	return 0;\n}\n\nint main ()\n{\n	float a=6,b=8,x;\n	if ((sgn(f(a))==0)&&(sgn(f(b))==0))\n	{\n	        printf (\"??????? const=0\\n\");\n	        return 0;\n	}\n	if (sgn(f(a))==sgn(f(b)))\n	{\n		printf (\"?????? ???\\n\");\n		return 0;\n	}\n	x=(a+b)/2;\n	while (fabs(f(x))>=0.001)\n	{\n		x=(a+b)/2;\n		if (sgn(f(a))!=sgn(f(x)))\n			b=x;	\n		else\n			a=x;\n	}\n	printf (\"x=%f\\n\",x);\n	return 0;\n}\n		\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (37,'#include <stdio.h>\n\nfloat f (float x)\n{\n	return x*x;\n}\n\nint main ()\n{\n	float i,a,b,s=0;\n	scanf (\"%f %f\",&a,&b);\n	if (a>b)\n	{\n		i=a;a=b;b=i;\n	}\n	for (i=a;i<b;i+=0.001)\n		s+=(f(i)+f(i+0.001));\n	s/=2000;\n	printf (\"%f\\n\",s);\n}\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (38,'#include <stdio.h>\n#include <math.h>\n#define N 10\nint isprime (int x)\n{\n	int i;\n	for (i=2;i<=x/2;i++)\n		if (x%i==0) return 0;\n	return 1;\n}\n\nint main ()\n{\n	int A[N],i,a;\n	for (i=0;i<N;i++)\n	{\n		printf (\"A[%d]=\",i);\n		scanf (\"%d\",&A[i]);\n	}\n	for (i=0;i<N;i++)\n		if (!isprime(A[i]))\n		{\n			printf (\"???? ????????? ????? %d\\n\",A[i]);\n			return 0;\n		}\n	printf (\"??? ????? ? ??????? ???????\\n\");\n	return 0;\n}\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (39,'#include <stdio.h>\n#define N 2\n\nint main ()\n{\n	int A[N][N],B[N][N],C[N][N],i,j,k;\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++)\n		{\n		//	printf(\"A[%d][%d]=\",i,j);\n			scanf(\"%d\",&A[i][j]);\n			C[i][j]=0;\n		}\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++)\n		{\n		//	printf(\"B[%d][%d]=\",i,j);\n			scanf(\"%d\",&B[i][j]);\n		}\n	for (i=0;i<N;i++)\n	        for (j=0;j<N;j++)\n			for (k=0;k<N;k++)\n				C[i][j]+=(A[i][k]*B[k][j]);\n	for (i=0;i<N;i++)\n	{\n	        for (j=0;j<N;j++)\n			//printf(\"C[%d][%d]=%d\\n\",i,j,C[i][j]);\n			printf(\"%d \", C[i][j]);\n		printf(\"\\n\");\n	}\n	return 0;\n}\n\n\n	\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (40,'#include <stdio.h>\n#define N 5\n\n\nint main ()\n{ \n	int i,A[N],k,Q[N][2],t,p,q,c=0;\n	for (i=0;i<N;i++)\n	{\n		printf (\"A[%d]=\",i);\n		scanf (\"%d\",&A[i]);\n	}\n	printf (\"\\n??????? ?????????? ????? ??? ??????: \");\n	scanf (\"%d\",&t);\n	for (i=0;i<t;i++)\n	{\n		printf (\"Q[%d]=\",i);\n		scanf (\"%d\",&Q[i][0]);\n		Q[i][1]=0;\n	}\n	for (i=0;i<t;i++)\n	{\n		k=N/2;p=0;q=N-1;\n		for (;(k!=p)&&(q!=k);)\n		{\n			if ((A[k]==Q[i][0])||(A[k-1]==Q[i][0])||(A[k+1]==Q[i][0]))\n	                {\n		                Q[i][1]=1;\n		                c++;\n		                break;\n		        }\n			if (A[k]<Q[i][0])\n			{\n				q=k;\n				k=(p+q)/2;\n			}\n			if (A[k]>Q[i][0])\n			{\n				p=k;\n				k=(p+q)/2;\n			}\n		}\n		if (A[0]==Q[i][0])\n		{\n			if (Q[i][1]!=1) c++;\n			Q[i][1]=1;\n                }\n		if (A[N-1]==Q[i][0])\n		{\n			if (Q[i][1]!=1) c++;\n			Q[i][1]=1;\n		}\n	}\n	if (c==t)\n	{\n		printf (\"\\n?????, ?????????????? ? ???????: \");\n		for (i=0;i<c;i++)\n			printf (\"%d \",Q[i][0]);\n		return 0;\n	}\n	if (c==0)\n	{\n		printf (\"\\n?????????? ? ??????? ???\\n\");\n		return 0;\n	}\n	printf (\"\\n?????, ?????????????? ? ???????: \");\n	for (i=0;i<t;i++)\n		if (Q[i][1]==1)\n			printf (\"%d \",Q[i][0]);\n	printf (\"\\n?????, ????????????? ? ???????: \");\n	for (i=0;i<t;i++)\n		if (Q[i][1]==0)\n			printf (\"%d \",Q[i][0]);\n}\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (41,'#include <stdio.h>\nfloat f(float x)\n{\n	return(x*x-4);\n}\nint main()\n{\n	float a=1.000, b=4.000,x ,e=0.001, c;\n	if(f(b)==0)\n	{\n		x=b;\n		printf(\"%f\\n\",x);\n		return 0;\n	}\n	if(f(a)==0)\n	{\n		x=a;\n		printf(\"%f\\n\",x);\n		return 0;\n	}\n	if(a>b)\n	{\n		c=a;\n		a=b;\n		b=c;\n	}\n		while((b-a)>e)\n		{\n			if((f(a)*f(b))>0)\n			{	\n				printf(\"net kornei\\n\");\n				return 0;\n			}	\n			else			\n			{\n					if((f(b)*f((a+b)/2))>0)\n					b=(a+b)/2;\n					else\n					a=(a+b)/2;\n			}\n		}	\n		x=(a+b)/2;		\n		printf(\"%f\\n\",x);	\n}	\n																																																																		\n		\n\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (42,'#include<stdio.h>\n#include<math.h>\nint isprime(int x)\n{\n	int i;\n	for(i=2;i<x;i++)\n	{\n		if(x%i==0)\n		return 0;\n	}\n	return 1;\n}\nint main()\n{\n	int k, d=0;\n	int A[5]={3,3,3,7,11};\n	for(k=0;(k<5)&&(isprime(A[k])==1);k++)\n	{	\n		d++;		\n	}	\n	if(d==5)\n		printf(\"massiv sostoit iz prostich chisel\\n\");\n	else\n		printf(\"massiv sostoit ne tolko iz prostich chisel\\n\");\n}	\n\n\n\n\n\n\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (43,'#include<stdio.h>\nint main()\n{\n	int i=0, j=0, k=0,s=0;\n	int A[2][2]={{2,4},{8,5}};\n	int B[2][2]={{2,0},{0,2}};\n	int C[2][2]={{0,0},{0,0}};\n	for(j=0;j<2;j++)\n	{\n		for(i=0;i<2;i++)\n		{\n			for(k=0;k<2;k++)\n			{\n				s=s+A[i][k]*B[k][j];\n			}\n			C[i][j]=s;\n			s=0;\n		}\n	}		\n\n	for(i=0;i<2;i++)\n	{\n		for(j=0;j<2;j++)\n		{\n			printf(\"%d \",C[i][j]);\n		}\n		printf(\"\\n\");\n	}	\n\n\n\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (44,'#include<stdio.h>\n#include<math.h>\nfloat f(float x)\n{\n	return x+5;\n}\nint main()\n{\nfloat a,b,e,v;\nv=0;\na=2;\nb=5;\ne=0.001;\n	for(a=a;a+e<b;a=a+e)\n		v=v+(f(a)+f(a+e))/2*e;\n	printf(\"%f\\n\",v);\n	return 0;\n}\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (45,'#include <stdio.h>\n#include <math.h>\n#define N 10\n\nint is_prime(int x)\n{int i;\n for (i=2;i*i<=x;i++)\n 	{if(x%i==0)\n	return(0);\n	}\n	return(1);\n}\nint main()\n{	 int A[N]={13,17,19,28,43,53,73,3,7,11}; int b;\n	int flag = 0;\n	for (b=0; b<N; b++)\n	{\n		printf(\"%d\\n\", b);\n		if (!is_prime (A[b]))\n		{\n			printf(\"v dannom massive est sostavnoe chislo,\\n\");\n			flag = 1;	\n		}\n	}\n	\n	if (flag == 0)\n		printf(\"v dannom massive net sostavnih chisel,\\n\");\n	return 0;\n}\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (46,'#include<stdio.h>\n#include <math.h>\nfloat f(float x)\n{\n	return (sin(x));\n}\nint main()\n{\n	float i;\n	float a;\n	float b;\n	scanf(\"%f%f\", &a, &b);\n	float T=0.001;\n	printf (\"\\n\");\n//	while ((b-a)>T)\n//	{\n		if(f(a)*f(b)>0)\n		{\n			printf (\"Net reshenia\\n\\n\");\n			return 0;\n		}\n		else\n		{\n			while ((b-a)>T)\n			{\n				i=(a+b)/2;\n		/*		if (f(a)==0)\n				{\n					printf (\"Reshenie x=%f\\n\", a);\n					return 0;\n				}\n				if (f(b)==0)\n				{\n					printf (\"Reshenie x=%f\\n\", b);\n					return 0;\n				}\n		*/		if (f(a)*f(i)>0)\n					a=i;\n				else\n					b=i;\n			}\n			printf (\"Reshenie x=%f\\n\\n\", i);\n\n  		}\n//	}\n\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (47,'#include <stdio.h>\nfloat f(float x)\n{\n	return (x*x-1);\n}\nint main ()\n{\n	float  x, a = 0, b = 1, y, e = 0.000001, s = 0;\n	int i;\n	int c = (b - a) / e;\n	for (i=0; i<c; i++)\n	{\n		x = a;\n		y = a + e;\n		s = f(x)*e + s;\n		a = a + e;\n	}\n	printf(\"%f\\n\", s);\n	return 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (48,'#include <stdio.h>\n#include <math.h>\n\nfloat f(float x)\n{\n	return (sin(x));\n}\n\nint main()\n{\n        float a=6;\n        float b=7;\n	float S;\n		      \n	while ((b-a)>0.001) \n	{\n		S=(a+b)/2;\n		if (((f(a)>0)&&(f(S)>0))||((f(a)<0)&&(f(S)<0))) \n		{\n			a=S;\n		}\n		else \n			b=S;\n	}\n	printf(\"Koren\' = %f\\n\",S);\n}\n\n\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (49,'#include <stdio.h>\nfloat f(float x)\n{\n	return (x*x);\n}\n\nmain()\n{\n	float a=0;\n	float b=1;\n	float S=0;\n	while (a<b)\n	{\n		S=S+0.001*f(a);\n		a=a+0.001;\n	}\n	printf(\"Integral\' = %f\\n\",S);\n}\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (50,'#include<stdio.h>\n#include<math.h>\n\nfloat f(float x)\n{\n	return(x*x+1);\n}\n\nint main()\n{\n	float a,b,s=0,e=0.001;\n	printf(\"a=\");\n	scanf(\"%f\",&a);\n	printf(\"b=\");\n	scanf(\"%f\",&b);\n	while (a+e<=b)\n	{\n		s+=e*(f(a)+f(a+e))/2;\n		a+=e;\n	}\n	printf(\"S=%f\\n\",s);\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (51,'#include<stdio.h>\n#include<math.h>\n\nint isprime(int a)\n{\n	int i;\n	for (i=2; i * i <= a; i++)\n	{\n		if (a%i==0)\n			return(0);\n	}\n	return(1);\n}\n\nint main()\n{\n	int i,n,a[100];\n	printf(\"n=\");\n	scanf(\"%d\",&n);\n	for (i=0;i<n;i++)\n	{\n		printf(\"a%d=\",i);\n		scanf(\"%d\",a+i);\n	}\n	for (i=0;i<n;i++)\n		if (!isprime(a[i]))\n		{\n			printf(\"????????? ??????? ?? ???????\\n\");\n			return(0);\n		}\n	printf(\"??? ????????? ??????? ???????\\n\");\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (52,'#include <stdio.h>\nint f(int x)\n{\n	int i;\n	for(i=2; i<x; i++)\n		if((x%i)==0)\n			return(0);	\n	return(1);\n}\n#define n 5\nint main()\n{\n        int A[n];	\n	int i;\n	for(i=0; i<n; i++)\n	{	//A[i]=getchar()-\'0\';\n		scanf(\"%d\", &A[i]);\n		if(f(A[i])==0)\n			{\n				printf(\"%d ?? ??????? ?????\\n\",A[i]);	\n				return(0);\n			}\n	}\n	printf(\"??? ????? ???????\\n\");\n	return(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (53,'#include <stdio.h>\n#define n 2\n\nint main()\n{\n	int a[n][n], b[n][n], c[n][n]={{0,0}};\n	int i,j,k;\n	for(i=0;i<n;i++)\n		for(j=0;j<n;j++)\n			a[i][j]=getchar()-\'0\';\n	for(i=0;i<n;i++)\n		for(j=0;j<n;j++)\n			b[i][j]=getchar()-\'0\';\n	for(i=0;i<n;i++)\n	{\n		for(j=0;j<n;j++)\n			{\n				for(k=0;k<n;k++)\n					c[i][j]+=a[i][k]*b[k][j];\n				printf(\"%d \",c[i][j]);\n			}\n		printf(\"\\n\");\n	}\n}\n\n\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (54,'#include <stdio.h>\n#include <math.h>\n#define N 5\n\nint is_prime(int x)\n{\n	int i;\n	for (i = 2; i <= sqrt(x); i++)\n		{\n			if (x%i == 0)\n			return (0);\n		}\n	return (1);\n}\n\nint main()\n{\n	int A[N] = { 2, 3, 2, 3, 2 };\n	int i;\n	int flag = 0;\n	for (i = 0; i < N; i++)\n	{\n		if (is_prime(A[i]) == 0)\n		{\n			flag = 1;\n		}\n	}\n	if (flag == 0)\n	{\n		printf (\"??? ????? ??????? ???????\\n\");\n	}\n	else\n	{\n		printf (\" ?? ??? ????? ??????? ???????\\n\");\n	}\n	return 0;\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (55,'#include <stdio.h>\n\nfloat f( float x)\n{\nreturn(x-3.45);\n} \n\nint main()\n{	\n\nfloat a=3, b=6, i=0.001, S=0;\n\n	for (; a+i<=b; a+=i)\n	{	\n		S=S+((f(a)+f(a+i))*i)/2;\n	}\n\nprintf (\"integral ot dannoi f raven %f\\n\", S);\n\nreturn 0;\n}\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (56,'#include <stdio.h>\nint main() \n{\n	int c,a,b;\n	scanf(\"%d\",&a);\n	printf(\"Vasa\\n\");\n	scanf(\"%d\",&b);\n	printf(\"Peta\\n\");\n	while (b>0)\n	{	printf(\"Serega\\n\");\n		c=b;\n		printf(\"Kola\\n\");\n		b=a%b;\n		a=c;\n	}	\n	printf(\"%d\\n\",a);\n	return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (57,'#include<stdio.h>\n#include<math.h>\n#define N 100\nint isprime(int a)\n{	\n	int i;\n	if (a>3)\n	{\n		for (i=2;((i<=sqrt(a))&&(a%i!=0));i++)\n			;\n	}	\n	if (a<=3) return (1);\n	if (a%i==0) return(0);\n	if (a%i!=0) return (1);\n}\nint main()\n{\n	int A[N]={3, 5, 7, 7, 11};\n	int b=0,c=1;\n	while ((b!=N-1)&&(c!=0))\n	{\n		c=c*isprime(A[b]);\n		b++;\n	}\n	printf(\"? ??????? \");\n	if (c==0)\n		printf(\"???? ?? \");\n	printf(\"??????? ?????\\n\");\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (58,'#include<stdio.h>\n\nint main()\n{\n	int A[100][100], B[100][100], C[100][100],i,j,n,k;\n//	printf(\"n=\");\n	scanf(\"%d\",&n);\n	printf(\"n: %d\\n\", n);\n	for (i=0;i<n;i++)\n		for (j=0;j<n;j++)\n			scanf(\"%d\",&A[i][j]);\n	for (i=0;i<n;i++)\n		for (j=0;j<n;j++)\n		{\n			scanf(\"%d\",&B[i][j]);\n			C[i][j]=0;\n		}\n	for (i=0;i<n;i++)\n		for (j=0;j<n;j++)\n			for (k=0;k<n;k++)\n				C[i][j]+=A[i][k]*B[k][j];\n	for (i=0;i<n;i++)\n	{\n		for (j=0;j<n;j++)\n			printf(\"%d \",A[i][j]);\n		printf(\"\\n\");\n	}\n	for (i=0;i<n;i++)\n	{\n		for (j=0;j<n;j++)\n			printf(\"%d \",B[i][j]);\n		printf(\"\\n\");\n	}\n	for (i=0;i<n;i++)\n	{\n		for (j=0;j<n;j++)\n			printf(\"%2d \",C[i][j]);\n		printf(\"\\n\");\n	}\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (59,'#include \"long.h\"\r\n\r\nstatic void  lClearZero(_int *t);\r\nstatic _int* lSimpleMul(_int *first, long long second, int shift);\r\nstatic void  lSimpleMin(_int *what, _int *on);\r\n\r\n_int* lCreateInt()\r\n{\r\n	_int* res = (_int*)malloc(sizeof(_int));\r\n	res->size = 0;\r\n	res->data = NULL;\r\n	res->sign = 1;\r\n	return res;\r\n}\r\n\r\nvoid lRemoveInt(_int *t)\r\n{\r\n	if(t->data != NULL)\r\n		free(t->data);\r\n	free(t);\r\n}\r\n\r\n// ?????????...\r\nvoid lAltRemove(void *t)\r\n{\r\n	lRemoveInt((_int*) t);\r\n}\r\n\r\n_int* lCopyValue(_int *src)\r\n{\r\n	_int *res = lCreateInt();\r\n	res->size = src->size;\r\n	if(res->size != 0)\r\n	{\r\n		res->data = (long long*)malloc(sizeof(long long) * ((res->size - 1) / _L_BLOCK_SIZE + 1) * _L_BLOCK_SIZE);\r\n		memcpy(res->data, src->data, sizeof(long long) * res->size);\r\n		res->sign = src->sign;\r\n	}\r\n	return res;\r\n}\r\n\r\n_int* lFromChars(char *s)\r\n{\r\n	_int* res = lCreateInt();\r\n	long long tmp = 0;\r\n	int d = 1;\r\n	int i, f, l;\r\n\r\n	l = strlen(s);\r\n	f = 0;\r\n	if(s[0] == \'-\')\r\n		res->sign = -1;\r\n	else if(s[0] == \'+\')\r\n		res->sign = 1;\r\n	else\r\n	{\r\n		res->sign = 1;\r\n		f = -1;\r\n	}\r\n	for(i = l-1; i > f; i--)\r\n	{\r\n		tmp += (s[i] - \'0\')*d;\r\n		d *= 10;\r\n		if(d == _L_SIZE || (i==f+1 && tmp>0))\r\n		{\r\n			if(res->size % _L_BLOCK_SIZE == 0 &&\r\n				(res->data = (long long*)realloc(res->data, sizeof(long long) * (res->size + _L_BLOCK_SIZE)))==NULL)\r\n			{\r\n				perror(\"Can\'t reallocate memory\");\r\n				abort();\r\n			}\r\n			res->data[res->size] = tmp;\r\n			res->size++;\r\n			tmp = 0;\r\n			d = 1;\r\n		}\r\n	}\r\n	// i don\'t now, because follow code does not work :\'(\r\n	/*if(tmp > 0)\r\n	{\r\n		if(res->size % _L_BLOCK_SIZE == 0 && (res->data = (long long*)realloc(res, (res->size + _L_BLOCK_SIZE)))==NULL)\r\n		{\r\n			perror(\"Can\'t reallocate memory\");\r\n			abort();\r\n		}\r\n		res->data[res->size] = tmp;\r\n		res->size++;\r\n	}*/\r\n	// end of not-work-code\r\n\r\n	return res;\r\n}\r\n\r\nvoid  lPrintfInt(_int *t)\r\n{\r\n	int i;\r\n\r\n	if(!t->size)\r\n	{\r\n		printf(\"0\\n\");\r\n		return ;\r\n	}\r\n	if(t->sign == -1)\r\n		printf(\"-\");\r\n	\r\n	printf(\"%lld\", t->data[t->size - 1]);\r\n	for(i = t->size-2; i >= 0; i--)\r\n		printf(\"%0*lld\", _L_DIGIT, t->data[i]);\r\n	printf(\"\\n\");\r\n}\r\n\r\nint lCmpTwoInt(_int *first, _int *second)\r\n{\r\n	int i;\r\n\r\n	// different sign\r\n	if(first->sign > second->sign)\r\n		return 1;\r\n	if(second->sign > first->sign)\r\n		return -1;\r\n\r\n	// different value\r\n	if(first->size > second->size)\r\n		return first->sign;\r\n	if(second->size > first->size)\r\n		return -second->sign;\r\n	for(i = first->size-1; i >= 0; i--)\r\n		if(first->data[i] > second->data[i])\r\n			return first->sign;\r\n		else if(second->data[i] > first->data[i])\r\n			return -second->sign;\r\n\r\n	// equivalent value\r\n	return 0;\r\n}\r\n\r\nvoid  lClearZero(_int *t)\r\n{\r\n#ifdef DEBUG\r\n	printf(\"\\tlClearZero: size=%u, t->data[size-1]=%lld\\n\", t->size, t->data[t->size-1]);\r\n#endif\r\n	for(/* do nothing */; t->size > 0 && t->data[t->size-1] == 0; t->size--)\r\n#ifdef DEBUG\r\n	{\r\n		printf(\"\\tlClearZero: t->size=%u, t->data[t->size-1]=%lld\\n\", t->size, t->data[t->size-1]);\r\n	}\r\n#else\r\n		;\r\n#endif\r\n}\r\n\r\n_int* lSumTwoInt(_int *first, _int *second)\r\n{\r\n	_int *res;\r\n	int i;\r\n\r\n	if(first->sign != second->sign)\r\n	{\r\n		second->sign *= -1;\r\n		res = lSubTwoInt(first, second);\r\n		second->sign *= -1;\r\n	}\r\n	else\r\n	{\r\n		res = lCreateInt();\r\n		res->sign = first->sign;\r\n		res->size = first->size > second->size ? first->size : second->size;\r\n		res->data = (long long*)malloc(sizeof(long long) * ((res->size)/_L_BLOCK_SIZE+1) * _L_BLOCK_SIZE);\r\n		res->data[0] = 0;\r\n		for(i = 0; i < res->size; i++)\r\n		{\r\n			if(i < first->size)\r\n				res->data[i] += first->data[i];\r\n			if(i < second->size)\r\n				res->data[i] += second->data[i];\r\n\r\n			res->data[i+1] = res->data[i] / _L_SIZE;\r\n			res->data[i] %= _L_SIZE;\r\n		}\r\n		if(res->data[res->size] != 0)\r\n			res->size++;\r\n	}\r\n\r\n	return res;\r\n}\r\n\r\n_int* lSubTwoInt(_int *first, _int *second)\r\n{\r\n	_int *res;\r\n	if(first->sign == 1 && second->sign == 1)\r\n	{\r\n		if(lCmpTwoInt(first, second) == -1)\r\n		{\r\n			res = lSubTwoInt(second, first);\r\n			res->sign = -1;\r\n		}\r\n		else\r\n		{\r\n			int i;\r\n			res = lCopyValue(first);\r\n			for(i = 0; i < res->size; i++)\r\n			{\r\n				if(i < second->size)\r\n					res->data[i] -= second->data[i];\r\n				if(res->data[i] < 0)\r\n				{\r\n					res->data[i] += _L_SIZE;\r\n					res->data[i + 1]--;\r\n				}\r\n			}\r\n			lClearZero(res);\r\n		}\r\n		return res;\r\n	}\r\n	else if(first->sign == 1 && second->sign == -1)\r\n	{\r\n		second->sign = 1;\r\n		res = lSumTwoInt(first, second);\r\n		second->sign = -1;\r\n		return res;\r\n	}\r\n	else if(first->sign == -1 && second->sign == 1)\r\n	{\r\n		first->sign = 1;\r\n		res = lSumTwoInt(first, second);\r\n		res->sign = -1;\r\n		first->sign = -1;\r\n		return res;\r\n	}\r\n	else\r\n	{\r\n		first->sign = 1;\r\n		second->sign = 1;\r\n		res = lSubTwoInt(first, second);\r\n		res->sign *= -1;\r\n		first->sign = -1;\r\n		second->sign = -1;\r\n		return res;\r\n	}\r\n\r\n#ifdef o_O\r\n	perror(\"O_o\");\r\n	abort();\r\n	return res;\r\n#endif\r\n}\r\n\r\n_int* lMulTwoInt(_int *first, _int *second)\r\n{\r\n	int i, j;\r\n	_int *res = lCreateInt();\r\n\r\n	res->sign = first->sign * second->sign;\r\n	res->size = first->size + second->size + 1;\r\n	res->data = (long long*)malloc( sizeof(long long) * _L_BLOCK_SIZE * ((res->size - 1)/_L_BLOCK_SIZE +1) );\r\n	memset(res->data, 0, sizeof(long long) * _L_BLOCK_SIZE * ((res->size - 1)/_L_BLOCK_SIZE +1));\r\n\r\n	for(i = 0; i < first->size; i++)\r\n		for(j = 0; j < second->size; j++)\r\n		{\r\n			res->data[i+j] += first->data[i] * second->data[j];\r\n			if(res->data[i+j] >= _L_SIZE)\r\n			{\r\n				res->data[i+j+1] += res->data[i+j] / _L_SIZE;\r\n				res->data[i+j] %= _L_SIZE;\r\n			}\r\n		}\r\n\r\n	lClearZero(res);\r\n	return res;\r\n}\r\n\r\nstatic _int* lSimpleMul(_int *first, long long second, int shift)\r\n{\r\n	_int *res = lCreateInt();\r\n	int i;\r\n\r\n	res->size = first->size + shift + 1;\r\n	res->data = (long long*)malloc(sizeof(long long) * _L_BLOCK_SIZE * ((res->size - 1)/_L_BLOCK_SIZE+1));\r\n	memset(res->data, 0, sizeof(long long) * (shift+1));\r\n	for(i = 0; i < first->size; i++)\r\n	{\r\n		res->data[shift+i] += first->data[i] * second;\r\n		res->data[shift+i+1] = res->data[shift+i] / _L_SIZE;\r\n		res->data[shift+i] %= _L_SIZE;\r\n	}\r\n	\r\n	lClearZero(res);\r\n	return res;\r\n}\r\n\r\nstatic void  lSimpleMin(_int *what, _int *on)\r\n{\r\n	int i;\r\n	for(i = 0; i < what->size; i++)\r\n	{\r\n		if(i < on->size)\r\n			what->data[i] -= on->data[i];\r\n		if(what->data[i] < 0)\r\n		{\r\n			what->data[i] += _L_SIZE;\r\n			what->data[i + 1]--;\r\n		}\r\n	}\r\n	lClearZero(what);\r\n}\r\n\r\n_int* lDivTwoInt(_int *first, _int *second) // Change frist agrument !!!\r\n{\r\n	_int *res = lCreateInt();\r\n	int i;\r\n	int modSign = first->sign < second->sign ? first->sign : second->sign;\r\n	int ss = second->sign;\r\n	if(first->sign == 1 && second->sign == -1)\r\n		modSign = 1;\r\n\r\n	res->sign = first->sign * second->sign;\r\n	first->sign = 1;\r\n	second->sign = 1;\r\n\r\n	if(lCmpTwoInt(first, second) == -1)\r\n	{\r\n		first->sign = modSign;\r\n		second->sign = ss;\r\n		return res;\r\n	}\r\n\r\n	res->size = first->size - second->size + 1;\r\n	res->data = (long long*)malloc(sizeof(long long) * _L_BLOCK_SIZE * ((res->size - 1)/_L_BLOCK_SIZE +1));\r\n	memset(res->data, 0, sizeof(long long) * _L_BLOCK_SIZE * ((res->size - 1)/_L_BLOCK_SIZE +1));\r\n	for(i = res->size - 1; i >= 0; i--)\r\n	{\r\n		long long min = 0, max = _L_SIZE, mid;\r\n		_int* tmp;\r\n\r\n		do\r\n		{\r\n			int compareResult;\r\n\r\n			mid = (min+max)/2;\r\n			tmp = lSimpleMul(second, mid, i);\r\n			compareResult = lCmpTwoInt(first, tmp);\r\n\r\n			switch(compareResult)\r\n			{\r\n			case 1:\r\n				min = mid+1;\r\n				break;\r\n			case -1:\r\n				max = mid-1;\r\n				break;\r\n			default:\r\n				res->data[i] = mid;\r\n				lSimpleMin(first, tmp);\r\n				lRemoveInt(tmp);\r\n				first->sign = modSign;\r\n				second->sign = ss;\r\n				lClearZero(res);\r\n				return res;\r\n			}\r\n\r\n			lRemoveInt(tmp);\r\n		}\r\n		while(min <= max);\r\n\r\n		res->data[i] = mid = (min+max)/2;\r\n		tmp = lSimpleMul(second, mid, i);\r\n		lSimpleMin(first, tmp);\r\n		lRemoveInt(tmp);\r\n	}\r\n\r\n	lClearZero(res);\r\n	first->sign = modSign;\r\n	second->sign = ss;\r\n	return res;\r\n}\r\n\r\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (60,'#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#ifdef _WIN32\n#include <conio.h>\n#endif\n\n#include \"vars.h\"\n#include \"stack.h\"\n#include \"long.h\"\n\n#define BUFLEN 1024\n\n/*******************************************************************************\n * parse\n*******************************************************************************/\n\nchar* trim(char *s)\n{\n	int l = strlen(s);\n	char *res = malloc(l+1);\n	int left, right, i;\n\n	for(left = 0; left < l && s[left] == \' \'; left++);\n	for(right = l-1; right > left && s[right] == \' \'; right--);\n	\n	for(i = left; i <= right; i++)\n		res[i-left] = s[i];\n	res[i] = \'\\0\';\n\n	return res;\n}\n\n_int* parseEquation(char *s)\n{\n	char *c, *tmp = 0;\n	char *forPush;\n	_int *operand, *toperand, *roperand;\n	int inEq = 0;\n	stack *stackOperations, *stackValues;\n	int mayBeOperand = 1;\n\n	stackOperations = setupStack(NULL);\n	stackValues = setupStack(lAltRemove);\n	\n	// skip spaces\n	for(c = s; *c == \' \' ; c++);\n#ifdef DEBUG\n	printf(\"First character: [%c|%d]\\n\", *c, *c);\n#endif\n\n	if(*c == \'\\0\' || *c == \'\\n\')\n		return NULL;\n	\n	// parse\n	for( ; ; c++)\n	{\n#ifdef DEBUG\n		printf(\"Symbol \'%c\'. inEq=%d\\n\", *c, inEq);\n#endif\n		\n		if(*c == \' \' && inEq == 0)\n			continue;\n		\n		if(inEq)\n		{\n			if(isdigit(*c) || (inEq == 2 && ((\'a\' <= *c && *c <= \'z\') || (\'A\' <= *c && *c <= \'Z\') || (*c == \'_\')))) // ??? ?? ??????, ??? ???? ?????????????, ?????? ????? ? ???? ????? ???????????? =/\n				continue;\n			else\n			{\n				char name[100500];\n				char *tmpname;\n				for(tmpname = tmp; tmpname != c; tmpname++)\n					name[tmpname - tmp] = *tmpname;\n				name[tmpname - tmp] = \'\\0\';\n\n				if(inEq == 2)\n				{\n					if((operand = getMeValue(name)) == NULL)\n					{\n						printf(\"Variable with name \\\"%s\\\" doesn\'t exists\\n\", name);\n						operand = lCreateInt();\n					}\n					else\n						operand = lCopyValue(getMeValue(name));\n				}\n				else\n					operand = lFromChars(name);\n\n				inEq = 0;\n				mayBeOperand = 0;\n#ifdef DEBUG\n				printf(\"Adding to stack \");\n				lPrintfInt(operand);\n#endif\n				push2Stack(stackValues, operand);\n			}\n		}\n		\n		if(!inEq)\n		{\n			switch(*c)\n			{\n				case \'(\':\n					tmp = malloc(1);\n					*tmp = \'(\';\n					push2Stack(stackOperations, tmp);\n					mayBeOperand = 1;\n					break;\n					\n				case \')\':\n					while(*(tmp = topOfStack(stackOperations)) != \'(\')\n					{\n						operand = lCopyValue(topOfStack(stackValues));\n						popOfStack(stackValues);\n						toperand = lCopyValue(topOfStack(stackValues));\n						popOfStack(stackValues);\n\n						switch(*tmp)\n						{\n							case \'+\':\n								roperand = lSumTwoInt(toperand, operand);\n								break;\n							case \'-\':\n								roperand = lSubTwoInt(toperand, operand);\n								break;\n							case \'*\':\n								roperand = lMulTwoInt(toperand, operand);\n								break;\n							case \'/\':\n								roperand = lDivTwoInt(toperand, operand);\n								break;\n							default:\n								roperand = lCreateInt();\n								fprintf(stderr, \"Unknown operation \'%c\'\\n\", *tmp);\n						}\n						\n						// remove\n						lRemoveInt(operand);\n						lRemoveInt(toperand);\n						push2Stack(stackValues, roperand);\n\n						popOfStack(stackOperations);\n					}\n					popOfStack(stackOperations);\n					mayBeOperand = 0;\n					break;\n					\n				case \'+\':\n				case \'-\':\n					if(mayBeOperand)\n					{\n						tmp = c;\n						inEq = 1;\n						continue;\n					}\n					mayBeOperand = 1;\n					\n					while(!emptyStack(stackOperations))\n					{\n						tmp = topOfStack(stackOperations);\n						if(*tmp == \'(\')\n							break;\n						\n						operand = lCopyValue(topOfStack(stackValues));\n						popOfStack(stackValues);\n						toperand = lCopyValue(topOfStack(stackValues));\n						popOfStack(stackValues);\n						\n						switch(*tmp)\n						{\n							case \'+\':\n								roperand = lSumTwoInt(toperand, operand);\n								break;\n							case \'-\':\n								roperand = lSubTwoInt(toperand, operand);\n								break;\n							case \'*\':\n								roperand = lMulTwoInt(toperand, operand);\n								break;\n							case \'/\':\n								roperand = lDivTwoInt(toperand, operand);\n								break;\n							default:\n								roperand = lCreateInt();\n								fprintf(stderr, \"[1] Unknown operation \'%c\'\\n\", *tmp);\n						}\n						\n						// remove\n						lRemoveInt(operand);\n						lRemoveInt(toperand);\n						push2Stack(stackValues, roperand);\n\n						popOfStack(stackOperations);\n					}\n					forPush = malloc(1);\n					*forPush = *c;\n					push2Stack(stackOperations, forPush);\n					break;\n\n				case \'*\':\n				case \'/\':\n					mayBeOperand = 1;\n\n					while(!emptyStack(stackOperations))\n					{\n						tmp = topOfStack(stackOperations);\n						if(*tmp == \'+\' || *tmp == \'-\' || *tmp == \'(\')\n							break;\n						\n						operand = lCopyValue(topOfStack(stackValues));\n						popOfStack(stackValues);\n						toperand = lCopyValue(topOfStack(stackValues));\n						popOfStack(stackValues);\n						\n						switch(*tmp)\n						{\n							case \'*\':\n								roperand = lMulTwoInt(toperand, operand);\n								break;\n							case \'/\':\n								roperand = lDivTwoInt(toperand, operand);\n								break;\n							default:\n								roperand = lCreateInt();\n								fprintf(stderr, \"[2] Unknown operation \'%c\'\\n\", *tmp);\n						}\n						\n						// remove\n						lRemoveInt(operand);\n						lRemoveInt(toperand);\n						push2Stack(stackValues, roperand);\n\n						popOfStack(stackOperations);\n					}\n					forPush = malloc(1);\n					*forPush = *c;\n					push2Stack(stackOperations, forPush);\n					break;\n\n				default:\n					tmp = c;\n					if((\'a\' <= *tmp && *tmp <= \'z\') || (\'A\' <= *tmp && *tmp <= \'Z\'))\n					{\n						inEq = 2;\n						break;\n					}\n					else if(\'0\' <= *tmp && *tmp <= \'9\')\n					{\n						if(!mayBeOperand)\n							fprintf(stderr, \"[4] ????? ?????-??\\n\");\n						else\n							inEq = 1;\n						break;\n					}\n					if(*c != \'\\0\' && *c != \'\\n\' && *c != \' \')\n						fprintf(stderr, \"[3] Unknown symbol \'%c\' (%d)\\n\", *c, *c);\n					break;\n			}		\n		}\n\n		if(*c == \'\\0\')\n			break;\n	}\n	\n	while(!emptyStack(stackOperations))\n	{\n		tmp = topOfStack(stackOperations);\n\n		operand = lCopyValue(topOfStack(stackValues));\n		popOfStack(stackValues);\n		toperand = lCopyValue(topOfStack(stackValues));\n		popOfStack(stackValues);\n		\n#ifdef DEBUG\n		printf(\"Operation: %c\\n\", *tmp);\n		lPrintfInt(toperand);\n		lPrintfInt(operand);\n#endif\n		switch(*tmp)\n		{\n			case \'+\':\n				roperand = lSumTwoInt(toperand, operand);\n				break;\n			case \'-\':\n				roperand = lSubTwoInt(toperand, operand);\n				break;\n			case \'*\':\n				roperand = lMulTwoInt(toperand, operand);\n				break;\n			case \'/\':\n				roperand = lDivTwoInt(toperand, operand);\n				break;\n			default:\n				roperand = lCreateInt();\n				fprintf(stderr, \"[5] Unknown operation \'%c\'\\n\", *tmp);\n		}\n#ifdef DEBUG\n		lPrintfInt(roperand);\n#endif\n		\n		// remove\n		lRemoveInt(operand);\n		lRemoveInt(toperand);\n		push2Stack(stackValues, roperand);\n	\n		popOfStack(stackOperations);\n	}\n\n	operand = lCopyValue(topOfStack(stackValues));\n	crashStack(stackOperations);\n	crashStack(stackValues);\n	\n	return operand;\n}\n\nvoid parseString(char *s)\n{\n	char *c;\n	_int *tmp;\n	\n	for(c = s; *c; c++)\n		if(*c == \'=\')\n		{\n			char *tmpName;\n			*c = \'\\0\';\n			tmpName = trim(s);\n			if((tmp = parseEquation(c+1)) == NULL)\n			{\n				free(tmpName);\n				return ;\n			}\n#ifdef DEBUG\n			printf(\"Setting variable %s = \", tmpName);\n			lPrintfInt(tmp);\n#endif\n			setupValue(tmpName, tmp);\n			lRemoveInt(tmp);\n			free(tmpName);\n			return ;\n		}\n	\n	if((tmp = parseEquation(s)) == NULL)\n		return ;\n	lPrintfInt(tmp);\n	lRemoveInt(tmp);\n}\n\n\n/*******************************************************************************\n * main\n*******************************************************************************/\n\nint main()\n{\n	//char s[BUFLEN];\n	char *s = NULL;\n	int c;\n	size_t i = 1;\n	int j;\n	int cur = 0, start = 1, doExit = 0;\n	\n	createVars();\n	while(i)\n	{\n		cur = BUFLEN;\n		s = malloc(BUFLEN+1);\n\n		if(s == NULL)\n		{\n			perror(\"malloc\");\n			abort();\n		}\n#ifndef _WIN32\n		c = getchar();\n#else\n		c = _getch();\n#endif\n		if(c == \'\\n\')\n		{\n			free(s);\n			continue;\n		}\n		if(c == EOF || c == 4)\n			break;\n		else\n		{\n			s[0] = (char)c;\n#ifdef _WIN32\n			putchar(c);\n#endif\n		}\n		while(i)\n		{\n#ifdef DEBUG\n			printf(\"cur=%d, start=%d\\n\", cur, start);\n#endif\n			if(start == 1)\n				fgets(s+start, BUFLEN, stdin);\n			else\n				fgets(s+start, BUFLEN+1, stdin);\n			for(j = start-1; j < cur; j++)\n			{\n#ifdef DEBUG\n				printf(\"{%c|%d}\", s[j], s[j]);\n#endif\n				if(s[j] == \'\\n\')\n				{\n					doExit = 1;\n					break;\n				}\n			}\n			if(doExit)\n				break;\n			if((s = realloc(s, cur+BUFLEN+1)) == NULL)\n			{\n				perror(\"[5]: realloc\");\n				abort();\n			}\n			cur += BUFLEN;\n			start = start == 1 ? BUFLEN : start + BUFLEN;\n		}\n#ifdef DEBUG\n		printf(\"All string: \'%s\'\\n\", s);\n		for(i=0; i<strlen(s); i++)\n			printf(\"[%c|%d]\", s[i], s[i]);\n		printf(\"\\n--- calc ---\\n\");\n		i = 1;\n#endif\n		parseString(s);\n		\n		free(s);\n		cur = 0;\n		start = 1;\n		doExit = 0;\n#ifdef DEBUG\n		printf(\"--- end ---\\n\\n\");\n#endif\n	}\n	\n	free(s);\n	killValues();\n	\n	return 0;\n}\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (61,'#include \"stack.h\"\n\nstack* setupStack(void(*des)(void*))\n{\n	stack *st = malloc(sizeof(stack));\n	if(st == NULL)\n	{\n		perror(\"[10] Can\'t allocate memory\");\n		abort();\n	}\n	st->last = NULL;\n	st->destructor = des;\n	return st;\n}\n\nvoid crashStack(stack *st)\n{\n	stackNode *iterator = st->last;\n	for(/* do nothing */; iterator != NULL; /* do nothing */)\n	{\n		stackNode *tmp = iterator;\n		iterator = iterator->next;\n		if(st->destructor != NULL)\n			st->destructor(tmp->data);\n		else\n			free(tmp->data);\n		free(tmp);\n	}\n	free(st);\n}\n\nvoid push2Stack(stack *st, void *data)\n{\n	stackNode *tmp = malloc(sizeof(stackNode));\n	if(tmp == NULL)\n	{\n		perror(\"Can\'t allocate memory\");\n		abort();\n	}\n	tmp->data = data;\n\n	tmp->next = st->last;\n	st->last = tmp;\n}\n\nvoid* topOfStack(stack *st)\n{\n	if(emptyStack(st))\n	{\n		fprintf(stderr, \"Bad algorithm: top() from empty stack\\n\");\n		abort();\n	}\n	return st->last->data;\n}\n\nvoid popOfStack(stack *st)\n{\n	stackNode *tmp;\n	if(emptyStack(st))\n	{\n		fprintf(stderr, \"Bad algorithm: pop() from empty stack\\n\");\n		abort();\n	}\n	\n	tmp = st->last;\n	st->last = tmp->next;\n	if(st->destructor != NULL)\n		st->destructor(tmp->data);\n	else\n		free(tmp->data);\n	free(tmp);\n}\n\nbool emptyStack(stack *st)\n{\n	return st->last == NULL;\n}\n\n#ifdef TEST_STACK\n\nint main(int argc, char *argv[])\n{\n	char command = \' \';\n	int *integer;\n	stack *testStack = malloc(sizeof(stack));\n	setupStack(testStack);\n	\n	printf(\"\\nSimple test program for stack\\n\\nUsage:\\n\");\n	printf(\"\\tu <integer> - push <integer> to stack\\n\");\n	printf(\"\\tt           - print top of stack\\n\");\n	printf(\"\\to           - pop from stack\\n\");\n	printf(\"\\te           - stack is empty?\\n\");\n	printf(\"\\tq           - quit\\n\\n\");\n\n	while(command != \'q\')\n	{\n		scanf(\"%c\", &command);\n		switch(command)\n		{\n			case \'u\':\n				integer = malloc(sizeof(int));\n				scanf(\"%d\", integer);\n				push2Stack(testStack, integer);\n				break;\n\n			case \'t\':\n				printf(\"top of stack: %d\\n\", *(int *)topOfStack(testStack));\n				break;\n\n			case \'o\':\n				popOfStack(testStack);\n				break;\n\n			case \'e\':\n				if(emptyStack(testStack))\n					printf(\"yes\\n\");\n				else\n					printf(\"no\\n\");\n				break;\n\n			case \'q\':\n			case \'\\n\':\n				break;\n				\n			default:\n				printf(\"Unknown command \'%c\'\\n\", command);\n		}\n\n		printf(\"[%c]\", command);\n	}\n\n	crashStack(testStack);\n\n	return 0;\n}\n\n#endif\n\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (62,'#include \"vars.h\"\n\nstatic vector vars[0x100];\n\n/*******************************************************************************\n * vector\n*******************************************************************************/\n\nstatic void initVector(vector *v)\n{\n	v->head = NULL;\n	v->tail = NULL;\n}\n\nstatic void killVector(vector *v)\n{\n	vectorNode *iterator, *tmp;\n	for(iterator = v->head; iterator != NULL; /* do nothing */)\n	{\n		tmp = iterator;\n		iterator = iterator->next;\n		lRemoveInt(tmp->cont);\n		free(tmp->name);\n		free(tmp);\n	}\n}\n\nstatic void vectorPush(vector *v, char *name, _int *val)\n{\n	// malloc\n	vectorNode *tmp = malloc(sizeof(vectorNode));\n	if(tmp == NULL)\n	{\n		perror(\"Can\'t allocate memory\");\n		abort();\n	}\n	\n	// create\n	tmp->next = NULL;\n	\n	if((tmp->name = malloc(strlen(name)+1)) == NULL)\n	{\n		perror(\"Can\'t allocate memory\");\n		abort();\n	}\n	strcpy(tmp->name, name);\n\n	tmp->cont = lCopyValue(val);\n	\n	// insert\n	if(v->head == NULL)\n		v->head = v->tail = tmp;\n	else\n	{\n		if(v->tail != NULL)\n			v->tail->next = tmp;\n		v->tail = tmp;\n	}\n}\n\nstatic _int* vectorFind(vector *v, char *name)\n{\n	vectorNode *iterator;\n	for(iterator = v->head; iterator != NULL; iterator = iterator->next)\n		if(!strcmp(iterator->name, name))\n			return iterator->cont;\n	return NULL;\n}\n\nstatic vectorNode* vectorFuck(vector *v, char *name)\n{\n	vectorNode *iterator;\n	for(iterator = v->head; iterator != NULL; iterator = iterator->next)\n		if(!strcmp(iterator->name, name))\n			return iterator;\n	return NULL;\n}\n\n/******************************************************************************\n * variables\n******************************************************************************/\n\nstatic unsigned char myHashFunc(char *value)\n{\n	char result = 0;\n	char *i = value;\n	while(*i != \'\\0\')\n	{\n		result *= 17;\n		result += *i;\n		i++;\n	}\n	return result;\n}\n\nvoid createVars(void)\n{\n	int i;\n	for(i = 0; i < 0x100; i++)\n		initVector(&vars[i]);\n}\n\nvoid setupValue(char *name, _int *value)\n{\n	unsigned char hash = myHashFunc(name);\n	vectorNode *tmp;\n	if((tmp = vectorFuck(&vars[hash], name)) != NULL)\n	// change old value\n	{\n		if(tmp->cont != value)\n		{\n			lRemoveInt(tmp->cont);\n			tmp->cont = lCopyValue(value);\n		}\n	}\n	else\n	// create new variable\n		vectorPush(&vars[hash], name, value);\n}\n\nvoid killValues(void)\n{\n	int i;\n	for(i = 0; i < 0x100; i++)\n		killVector(&vars[i]);\n}\n\n_int* getMeValue(char *name)\n{\n	return vectorFind(&vars[myHashFunc(name)], name);\n}\n\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (63,'#include \"h_servce.h\"\r\nstruct node nodes[512];\r\nstruct symbol arr[256];\r\nchar codes[256][code_length + 1];\r\n\r\nvoid set_codes(int arr_count, int curr_node, char line[], int line_curr)\r\n{\r\n	int i_set_codes;\r\n	char line_recurse[code_length + 1];\r\n	for (i_set_codes = 0; i_set_codes < code_length + 1; line_recurse[i_set_codes++] = 0)\r\n	if (curr_node < arr_count)\r\n		for (i_set_codes = 0; i_set_codes < code_length; i_set_codes++)\r\n			codes[curr_node][i_set_codes] = line[i_set_codes];\r\n	else\r\n	{\r\n		for (i_set_codes = 0; i_set_codes < code_length; i_set_codes++)\r\n			line_recurse[i_set_codes] = line[i_set_codes];\r\n		line_recurse[line_curr] = \'0\';\r\n		set_codes(arr_count, nodes[curr_node].left,  line_recurse, line_curr + 1);\r\n		line_recurse[line_curr] = \'1\';\r\n		set_codes(arr_count, nodes[curr_node].right, line_recurse, line_curr + 1);\r\n	}\r\n}\r\n\r\nint try_make_peace_less(const char *f_name1, const char *f_name2)\r\n{\r\n	unsigned int n = 0, k, i, j, next_print = 0, free_space = 8, w, bit = 128, t = 1, first, count = 0;\r\n	char str[code_length + 1];\r\n	FILE *f1, *f2;\r\n	for (i = 0; i < code_length + 1; str[i++] = 0);\r\n	if ((f1 = fopen(f_name1, \"rb\")) == NULL)\r\n	{\r\n		printf(\"Please, check the file you want to archive is exist!\\nCan\'t open \\\"%s\\\".\\n\", f_name1);\r\n		return 0;\r\n	}\r\n	if ((f2 = fopen(f_name2, \"wb\")) == NULL)\r\n	{\r\n		printf(\"Can\'t create \\\"%s\\\".\\n\", f_name2);\r\n		return 0;\r\n	}\r\n	while ((t = fgetc(f1)) != EOF)\r\n		arr[t].freq++;\r\n	for (i = 0; i < 256; n += (arr[i++].freq > 0))\r\n	{\r\n		arr[i].node_num = i;\r\n		count += arr[i].freq;\r\n	}\r\n	if (n == 0)\r\n	{\r\n		fprintf(f2, \"%c%c%c%c\", n, n, n, n);\r\n		return show_success_archiving();\r\n	}\r\n	qsort(arr, 256, sizeof(struct symbol), cmp);\r\n	if (n == 1) \r\n	{\r\n		fprintf(f2, \"%c%c%c%c%c%d\", 128, 0, 0, 0, arr[0].node_num, arr[0].freq);\r\n		return show_success_archiving();\r\n	}\r\n	k = 256;\r\n	for (i = n; i > 1; i--)\r\n	{\r\n		nodes[k].left = arr[i - 2].node_num;\r\n		nodes[k].right = arr[i - 1].node_num;\r\n		arr[i-2].freq = arr[i-2].freq + arr[i-1].freq;\r\n		arr[i-2].node_num = k++;\r\n		for (j = i-2; j >= 1; j--)\r\n			if (arr[j - 1].freq < arr[j].freq)\r\n			{\r\n				first = arr[j-1].freq;\r\n				arr[j-1].freq = arr[j].freq;\r\n				arr[j].freq = first;\r\n				first = arr[j-1].node_num;\r\n				arr[j-1].node_num = arr[j].node_num;\r\n				arr[j].node_num = first;\r\n			}\r\n	}\r\n	set_codes(256, k-1, str, 0);\r\n	for (i = 0; i < 32; i++)\r\n	{\r\n		binary_print(f2, &next_print, &free_space, &bit, count % 2); //Reversed binary representation of the count of bytes in text\r\n		count /= 2;\r\n	}\r\n	print_tree(f2, nodes, k-1, &next_print, &free_space, &bit);\r\n	rewind(f1);\r\n	while ((t = fgetc(f1)) != EOF)\r\n		for (w = 0; codes[t][w]; w++)\r\n			binary_print(f2, &next_print, &free_space, &bit, codes[t][w] - \'0\');\r\n	if (free_space != 8)\r\n		fprintf(f2, \"%c\", next_print);\r\n	return show_success_archiving();\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (64,'#include \"h_servce.h\"\r\n\r\nstruct node tree[1000];\r\n\r\nvoid decode(FILE *g_source, FILE *g_destination, int cnt, int head, int *pos, int *curr_char)\r\n{\r\n	int c, s = 0, way;\r\n	do\r\n	{\r\n		way = head;\r\n		while (tree[way].left >= 256)\r\n		{\r\n			c = get_bit(g_source, pos, curr_char);\r\n			if (c == 1)\r\n				way = tree[way].left;\r\n			else\r\n				way = tree[way].right;\r\n		}\r\n		fprintf(g_destination, \"%c\", tree[way].left);\r\n		s++;\r\n	} while (s < cnt);\r\n}\r\n\r\nint try_make_peace_more(const char *f_name1, const char *f_name2)\r\n{\r\n	FILE *g1, *g2;\r\n	unsigned int count = 0, i, pos = 9, curr_char, pow2 = 1, k = 255;\r\n	if ((g1 = fopen(f_name1, \"rb\")) == NULL)\r\n	{\r\n		printf(\"Please, check the file you want to extract is exist!\\nCan\'t open \\\"%s\\\".\\n\", f_name1);\r\n		return 0;\r\n	}\r\n	if ((g2 = fopen(f_name2, \"wb\")) == NULL)\r\n	{\r\n		printf(\"Can\'t create \\\"%s\\\".\\n\", f_name2);\r\n		return 0;\r\n	}\r\n	for (i = 0; i < 32; i++)\r\n	{\r\n		count += pow2 * get_bit(g1, &pos, &curr_char);\r\n		pow2 *= 2;\r\n	}\r\n	if (count == 0)\r\n		return show_success_extracting();\r\n	if (count == 1)\r\n	{\r\n		curr_char = fgetc(g1);\r\n		count = 0;\r\n		while ((k = fgetc(g1)) != EOF)\r\n		{\r\n			//printf(\"%d\\n\", k - \'0\');\r\n			count = 10 * count + (k - \'0\');\r\n		}\r\n		for (i = 0; i < count; i++)\r\n			fprintf(g2, \"%c\", curr_char);\r\n		return show_success_extracting();\r\n	}\r\n	get_tree(g1, tree, &k, &pos, &curr_char);\r\n	printf(\"k: %d\\n\", k);\r\n	decode(g1, g2, count, 255, &pos, &curr_char);\r\n	return show_success_extracting();\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (65,'#include \"h_servce.h\"\r\nint cmp(const void *x, const void *y)\r\n{\r\n	return ( (*(struct symbol *)y).freq - (*(struct symbol *)x).freq);\r\n}\r\n\r\nvoid binary_print(FILE *f_destination, int *n_pr, int *f_sp, int *bit, int curr_bit)\r\n{\r\n	if (curr_bit == 1)\r\n		*n_pr += *bit;\r\n	*bit /= 2;\r\n	if (--(*f_sp) == 0)\r\n	{\r\n		fprintf(f_destination, \"%c\", *n_pr);\r\n		*n_pr = 0;\r\n		*f_sp = 8;\r\n		*bit = 128;\r\n	}\r\n}\r\n\r\nint get_bit(FILE *g_source, int *pos, int *curr_char)\r\n{\r\n	int temp;\r\n	if (*pos == 9)\r\n	{\r\n		temp = fgetc(g_source);\r\n		*curr_char = temp;\r\n		*pos = 1;\r\n	}\r\n	return ((*curr_char >> (8-(*pos)++))&1);\r\n}\r\n\r\nvoid print_tree(FILE *f_destination, struct node *base, int num_node, int *n_pr, int *f_sp, int *bit)\r\n{\r\n	int i_print_tree;\r\n	if (num_node < 256)\r\n	{\r\n		binary_print(f_destination, n_pr, f_sp, bit, 0);\r\n		for (i_print_tree = 0; i_print_tree < 8; i_print_tree++)\r\n		{\r\n			binary_print(f_destination, n_pr, f_sp, bit, num_node % 2); //Reversed binary representation of the char\r\n			num_node /= 2;\r\n		}\r\n	}\r\n	else\r\n	{\r\n		binary_print(f_destination, n_pr, f_sp, bit, 1);\r\n		print_tree(f_destination, base, base[num_node].right, n_pr, f_sp, bit);\r\n		print_tree(f_destination, base, base[num_node].left, n_pr, f_sp, bit);\r\n	}\r\n}\r\n\r\nvoid get_tree(FILE *g_source, struct node *base, int *node_count, int *pos, int *curr_char)\r\n{\r\n	int i, curr, c, node_get;\r\n	printf(\"get_tree\\n\");\r\n	curr = *node_count;\r\n	c = get_bit(g_source, pos, curr_char);\r\n	node_get = 123;\r\n	if (c == 1)\r\n	{\r\n		(*node_count)++;\r\n		base[curr].left = *node_count;\r\n		get_tree(g_source, base, node_count, pos, curr_char);\r\n		(*node_count)++;\r\n		base[curr].right = *node_count;\r\n		get_tree(g_source, base, node_count, pos, curr_char);\r\n	}\r\n	else\r\n	{\r\n		for (i = 1; i <= 128; i *= 2)\r\n		{\r\n			printf(\"i: %d, g_source: %d\\n\", i, *(int *)g_source);\r\n			c += i * get_bit(g_source, pos, curr_char);\r\n		}\r\n		base[*node_count].left = base[*node_count].right = c;\r\n	}\r\n	printf(\"get_tree exited\\n\");\r\n}\r\nint show_success_archiving()\r\n{\r\n	printf(\"Archiving was finished successful.\\n\");\r\n	return 0;\r\n}\r\nint show_success_extracting()\r\n{\r\n	printf(\"Extracting was finished successful.\\n\");\r\n	return 0;\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (66,'#include <stdio.h>\r\n#include \"h_arch.h\"\r\n#include \"h_dearch.h\"\r\nint main(int argc, char *argv[])\r\n{\r\n	if (argc == 1)\r\n	{\r\n		printf(\"Need 2 arguments.\\n\", argc - 1);\r\n		return 0;\r\n	}\r\n	if (argv[1][0] != \'-\')\r\n		if (argc == 3)\r\n			try_make_peace_less(argv[1], argv[2]);\r\n		else\r\n			printf(\"No need %d arguments, need 2 ones.\\n\", argc - 1);\r\n	else\r\n		if (argc == 4)\r\n			try_make_peace_more(argv[2], argv[3]);\r\n		else\r\n			printf(\"No need %d arguments, need 2 ones.\\n\", argc - 1);\r\n	return 0;\r\n}','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (67,'#include <stdio.h>\n#define n 5\n#define k 11\nint main()\n{\n	int a[n], b[k];\n	int i,j=n-1,l=0,m;\n	for(i=0;i<n;i++)\n		scanf(\"%d\", &a[i]);\n	for(i=0;i<k;i++)\n		{\n			scanf(\"%d\", &b[i]);\n			if(b[i]==a[j])\n				printf(\"????? %d ??????????? ?? %d ?????\\n\",b[i],j+1);\n			if(b[i]==a[l])\n				printf(\"????? %d ??????????? ?? %d ?????\\n\",b[i],l+1);\n			if((b[i]>a[j])||(b[i]<a[l]))\n				printf(\"????? %d ?? ???????????\\n\",b[i]);\n			while(j-l>=0)\n				{\n					m=(l+j)/2;\n					if(b[i]==a[m])\n						{\n							printf(\"????? %d ??????????? ?? %d ?????\\n\",b[i],m+1);\n							break;\n						}\n					if(b[i]>a[m])\n						l=m+1;\n					if(b[i]<a[m])\n						j=m-1;\n				}		\n			l=0;\n			j=n-1;\n		}\n	return(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (68,'#include <stdio.h>\n#define N 256\n\nint main ()\n{\n	int i,j,t=0,P[N],z,k=N;\n	char st[N], *s;\n	//FILE *stream;\n	//stream=freopen(\"input\",\"w\",stdin);	\n	s=fgets(st,k,stdin);\n	for (i=0;(i<N)&&(st[i]!=\'\\0\');i++)\n		if ((st[i]>=\' \' && st[i]<\'0\')||( st[i]>\'9\' && st[i]<\'A\'))\n\n		{\n			P[t]=i;\n			t++;	\n		}\n	z=i;\n	for (i=0;i<t;i++)\n		for (j=P[i]-i;j<z;j++)\n			st[j]=st[j+1];\n	z=z-t-1;\n	printf (\"%s\",st);\n	for (i=0;i<=z/2;i++)\n		if (st[i]!=st[z-i-1])\n		{\n			printf (\"\\n=(\\n\");\n			return 0;\n		}\n	printf (\"\\n=)\\n\");\n	return 0;\n}\n\n\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (69,'#include <stdio.h>\n#define n 2\nint main()\n{	int a[n][n]={{1,2},{3,4}}, b[n][n]={{2,0},{0,2}}, c[n][n]={{0},{0}};\n	int i,k,j,t,m;\n\n	for (i=0; i<n; i++)\n	{	for (j=0; j<n; j++)\n		{	for(k=0; k<n; k++)\n			{\n			c[i][j]=c[i][j]+((a[i][k])*(b[k][j]));\n			}\n		}\n	}\n\n	for (t=0; t<n; t++)\n	{	for (m=0; m<n; m++)\n		{\n	printf(\"%d \", c[t][m]);\n		}\n	printf(\"\\n\");\n	\n	}\nreturn 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (70,'#define N 2\n#include<stdio.h>\nint main()\n{\n	int A[N][N]={{1,2},{3,4}};\n	int B[N][N]={{2,0},{0,2}};\n	int C[N][N]={{0}};\n	int i,j,k;\n	for(i=0;i!=N;i++)\n		for(j=0;j!=N;j++)\n			for(k=0;k!=N;k++)\n				C[i][j]=C[i][j]+A[i][k]*B[k][j];\n	\n	for(i=0;i!=N;i++)\n		{\n		for(j=0;j!=N;j++)\n		printf(\"%d \",C[i][j]);\n		printf(\"\\n\");\n		}\n\n}\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (71,'#include <stdio.h>\nint isprime(int a)\n{\n	int i;\n  	for (i=2;i<a;i++) \n	{\n		if ((a%i)==0) \n		{\n			return 0;\n		}\n	}\n   	return 1;\n}\n\nint  main()\n{\n	int massiv[5]={0};\n	int i;\n      	for (i=0;i<5;i++) \n 		scanf(\"%d\",&massiv[i]);\n     	for (i=0;i<5;i++) \n      		if (!isprime(massiv[i])) \n 		{\n			printf(\"Ne yavlyautsya\\n\");\n      			break;\n		}\n	 if (i==5) \n	 	printf(\"Yavlyautsya\\n\");\n}\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (72,'#include <math.h>\n#include <stdio.h>\nfloat f(float q)\n{\n	return(sin(q));\n}\nint main()\n{\n	float a,b,c=1,x,e=0.001;\n	a=6;b=7;\n	if ((f(a)>0)&&(f(b)<0))\n	{\n		while (c!=0)\n		{\n			if (b-a>e)\n			{\n				x=(b+a)/2;\n				if (f(x)>0)\n				a=x;\n				else\n				{\n					if (f(x)==0)\n					{\n					c=0;\n					printf(\"%f\\n\",x);\n					}	\n					else\n					b=x;\n				}\n			}\n			else\n			{\n			c=0;\n			printf(\"%f\\n\",x);\n			}\n		}\n	}	\n	if (f(a)==0)\n	printf(\"%f\\n\",a);\n	else\n	{\n		if (f(b)==0)\n		printf(\"%f\\n\",b);\n		else\n		{\n			if ((f(a)<0)&&(f(b)>0))\n			{\n			while (c!=0)\n	\n				if (b-a>e)\n				{	\n					x=(b+a)/2;\n					if (f(x)>0)\n					b=x;\n					else\n					{\n						if (f(x)==0)\n						{\n						printf(\"%f\\n\",x);\n						c=0;\n						}\n						else \n						a=x;\n					}	\n				}\n				else\n				{\n				c=0;\n				printf(\"%f\\n\",x);\n				}\n			}		\n		}\n	}\n	\n	//else\n	//printf(\"korney net\\n\");\n\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (73,'#ifndef __GNUC__\n#include <crtdbg.h>\n//#define _CRT_SECURE_NO_WARNINGS\n//#define _CRT_SECURE_NO_DEPRECATE\n#endif\n#include \"stack.h\"\n#include \"vars.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nstruct equation\n{\n	char op;\n	int val;\n};\n\nint prior(char c)\n{\n	switch (c)\n	{\n		case \'(\': return 0; break;\n		case \'-\': return 1; break;\n		case \'+\': return 1; break;\n		case \'*\': return 2; break;\n		case \'/\': return 2; break;\n	}\n	return -1;\n}\n\nint oppush(stack st, struct equation *eq)\n{\n	struct equation eq2,eq3,er;\n	if (!eq->op)\n	{\n		push(st,eq);\n		return 1;\n	}\n	\n	if (empty(st)) return 1;\n	eq2 = *(struct equation*)top(st);\n	pop(st);\n	if (empty(st)) return 1;\n	eq3 = *(struct equation*)top(st);\n	pop(st);\n\n	if (eq2.op || eq3.op) return 1;\n\n	er.op = 0;\n	er.val = 0;\n	\n	switch (eq->op)\n	{\n		case \'+\': er.val = eq3.val + eq2.val; break;\n		case \'-\': er.val = eq3.val - eq2.val; break;\n		case \'*\': er.val = eq3.val * eq2.val; break;\n		case \'/\': if (!eq2.val)\n				  {\n					  er.val = 0;\n					  printf(\"ERROR: Divide by zero\\n\");\n				  }\n				  else er.val = eq3.val / eq2.val; break;\n	}\n	push(st,&er);\n	return 0;\n}\n\nvoid eval()\n{\n	stack st1,st2;\n	int mode = -1;\n	int i,t = 0;\n	char c,pc = \'\\n\';\n	char name[255];\n	char eqname[255];\n	int eqmode = 0;\n	int ni = 0;\n	struct equation eq;\n	int banan = 0;\n	int banan2 = 0;\n	\n		\n	st1 = createStack(sizeof(struct equation));\n	st2 = createStack(sizeof(struct equation));\n	\n	while ( (i = getchar()) != EOF)\n	{\n		c = (char)i;\n\n		if (c == \' \') continue;\n\n		if (mode == 0) //value mode\n		{\n			if (isdigit(c))\n			{\n				banan2 = 0;\n				t*=10;\n				t+=c-\'0\';\n			}\n			else\n			{\n				if (banan2)\n				{\n					printf(\"ERROR: Wrong expression\");\n					freeStack(st1);\n					freeStack(st2);\n					return;\n				}\n				t*=banan;\n				eq.op = 0;\n				eq.val = t;\n				push(st2,&eq);\n				mode = -1;\n				t = 0;\n				banan = 1;\n			}\n		}\n\n		if (mode == 2) //variable mode\n		{\n			if (isalpha(c) || isdigit(c) || c == \'_\')\n			{\n				name[ni++] = c;\n				name[ni] = 0;\n			}\n			else if (c != \'=\')\n			{\n				eq.op = 0;\n				eq.val = get_value(name);\n				push(st2,&eq);\n				mode = -1;\n				banan = 1;\n			}\n			else\n			{\n				mode = -1;\n				strcpy(eqname,name);\n				eqmode = 1;\n				continue;\n			}\n		}\n\n		\n		if (mode == -1) //symbol mode\n		{\n			if (isdigit(c) || (!banan && \n				(c == \'-\' || c== \'+\') && \n				(pc == \'-\' || pc == \'+\' || pc == \'*\' || pc ==\'/\' || pc == \'\\n\')) )\n			{\n				t = c - \'0\';\n				banan = 1;\n				if (!isdigit(c))\n				{\n					t = 0;\n					if (c == \'-\') banan = -1; else banan = 1;\n					banan2 = 1;\n				}\n				mode = 0;\n				continue;\n			}\n			\n			else if (isalpha(c))\n			{\n				ni = 1;\n				name[0] = c;\n				name[1] = 0;\n				mode = 2;\n			}\n\n					\n			else if (c == \'\\n\')\n			{\n				while (!empty(st1))\n				{\n					eq = *(struct equation*)top(st1);\n					if (oppush(st2,&eq))\n					{\n						printf(\"ERROR: Cannot evaluate expression\");\n						freeStack(st1);\n						freeStack(st2);\n						return;\n					}\n					pop(st1);\n					banan = 0;\n				}\n\n				if (eqmode == 0)\n				{\n					if (!empty(st2))\n					{\n						eq = *(struct equation*)top(st2);\n						if (eq.op) printf(\"%c \",eq.op); else printf(\"%d \",eq.val);\n						pop(st2);\n					}\n					else\n					{\n					}\n					banan = 0;\n					putchar(\'\\n\');\n				}\n				else\n				{\n					eq = *(struct equation*)top(st2);\n					set_value(eqname,eq.val);\n					pop(st2);\n					eqmode = 0;\n				}\n\n				while (!empty(st1)) pop(st1);\n				while (!empty(st2)) pop(st2);\n				banan = 0;\n			}\n			else if (c == \'(\')\n			{\n				eq.op = \'(\';\n				eq.val = 0;\n				push(st1,&eq);\n				\n			}\n			else if (c == \')\')\n			{\n				banan = 1;\n				while (!empty(st1))\n				{\n					eq = *(struct equation*)top(st1);\n					pop(st1);\n					if (eq.op == \'(\') break;\n					if (oppush(st2,&eq))\n					{\n						printf(\"ERROR: Cannot evaluate expression\");\n						freeStack(st1);\n						freeStack(st2);\n						return;\n					}\n				}\n			}\n			else if (c == \'-\' || c == \'+\' || c == \'*\' || c == \'/\')\n			{\n				if (!banan)\n				{\n					eq.op = 0;\n					eq.val = 0;\n					push(st2,&eq);\n				}\n				\n				while (!empty(st1))\n				{\n					eq = *(struct equation*)top(st1);\n					if (prior(eq.op)>=prior(c))\n					{\n						if (oppush(st2,&eq))\n						{\n							printf(\"ERROR: Cannot evaluate expression\");\n							freeStack(st1);\n							freeStack(st2);\n							return;\n						}\n						pop(st1);\n					}\n					else break;\n				}\n				eq.op = c;\n				eq.val = 0;\n				push(st1,&eq);\n\n				banan = 0;\n			}\n\n			else\n			{\n				printf(\"ERROR: Unknown symbol \'%c\'\",c);\n				freeStack(st1);\n				freeStack(st2);\n				return;\n			}\n		\n		} //symbol mode\n\n		pc = c;\n	} // while\n	\n	\n	freeStack(st1);\n	freeStack(st2);\n}\n\nint main()\n{\n	\n	eval();\n	\n	printf(\"\\n\");\n	cleanup();\n\n#ifndef __GNUC__\n	_CrtDumpMemoryLeaks(); \n#endif\n\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (74,'#include \"stack.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nstatic void rep_error(int n)\n{\n	switch (n)\n	{\n		case 1: printf(\"stack: Malloc error\\n\"); return;\n		case 2: printf(\"stack: Stack is NULL\\n\"); return;\n		case 3: printf(\"stack: Uninitialized stack\\n\"); return;\n	}\n	printf(\"FUUUUUUUUUUUUUUUUUCK!\\n\");\n}\n\nstack createStack(unsigned char size)\n{\n	stack st;\n	if (size == 0)\n	{\n		rep_error(4);\n		return NULL;\n	}\n	st = (stack)malloc(sizeof(struct stackStr));\n	if (!st)\n	{\n//		rep_error(1);\n		perror(\"malloc\");\n		return NULL;\n	}\n	\n	st->top = NULL;\n	st->size = size;\n	return st;\n}\n\nint empty(stack st)\n{\n	if (!st)\n	{\n		rep_error(2);\n		return 1;\n	}\n	if (st->size == 0)\n	{\n		rep_error(3);\n		return 1;\n	}\n	return  (st->top == NULL);\n}\n\nvoid push(stack st, void *data)\n{\n	struct item *i;\n	if (!st)\n	{\n		rep_error(2);\n		return;\n	}\n	if (st->size == 0)\n	{\n		rep_error(3);\n		return;\n	}\n	\n	i = (struct item*)malloc(sizeof(struct item));\n	if (!i)\n	{\n		rep_error(1);\n		return;\n	}\n	\n	i->next = st->top;\n	st->top = i;\n	\n	i->data = (void*)malloc(st->size);\n	if (!i->data)\n	{\n		rep_error(1);\n		return;\n	}\n	\n	memcpy(i->data,data,st->size);\n}\n\nvoid *top(stack st)\n{\n	if (!st)\n	{\n		rep_error(2);\n		return NULL;\n	}\n	if (st->size == 0)\n	{\n		rep_error(3);\n		return NULL;\n	}\n	\n	if (!st->top) return NULL;\n	return st->top->data;\n}\n\nvoid pop(stack st)\n{\n	struct item *i;\n	\n	if (!st)\n	{\n		rep_error(2);\n		return;\n	}\n	if (st->size == 0)\n	{\n		rep_error(3);\n		return;\n	}\n	\n	\n	if (!st->top) return;\n	\n	i = st->top;\n	st->top = i->next;\n	free(i->data);\n	free(i);\n}\n\nvoid freeStack(stack st)\n{\n	while (!empty(st))\n	{\n		pop(st);\n	}\n	free(st);\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (75,'#include \"vars.h\"\n#include <string.h>\n#include <stdlib.h>\n\n#define HASH_SIZE 23\n\nstruct itemI\n{\n	char *name;\n	int value;\n	struct itemI *next;\n};\n\nstruct itemI *table[HASH_SIZE];\n\nint hash(char *name)\n{\n	int c = 0;\n	while (*name)\n	{\n		c = (c*3+*name) % HASH_SIZE;\n		name++;\n	}\n\n	return c;\n}\n\nstatic struct itemI *find(char *name)\n{\n	struct itemI *i;\n	int h = hash(name);\n	\n	i = table[h];\n\n	while (i)\n	{\n		if (!strcmp(name,i->name)) return i;\n		i = i->next;\n	}\n\n	return NULL;\n}\n\nvoid set_value(char *name, int value)\n{\n	int h;\n	struct itemI *it = find(name);\n	if (!it)\n	{\n		h = hash(name);\n		it = (struct itemI*)malloc(sizeof(struct itemI));\n		if (!it) return;\n		it->name = (char*)malloc(sizeof(char)*(strlen(name)+1));\n		if (!it->name) return;\n		strcpy(it->name,name);\n		it->value = value;\n		it->next = table[h];\n		table[h] = it;\n	}\n	else\n	{\n		it->value = value;\n	}\n}\n\nint get_value(char *name)\n{\n	struct itemI *it = find(name);\n	if (it)\n	{\n		return it->value;\n	}\n	else\n	{\n		return 0;\n	}\n}\n\nvoid cleanup()\n{\n	int i;\n	struct itemI *it;\n	for (i = 0; i<HASH_SIZE ; i++)\n	{\n		while (table[i])\n		{\n			it = table[i];\n			table[i] = table[i]->next;\n			if (it && it->name) \n				free(it->name);\n			free(it);\n		}\n	}\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (76,'#define _CRT_SECURE_NO_WARNINGS\n#ifdef WIN32\n#define _CRTDBG_MAP_ALLOC\n#include <crtdbg.h>\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include \"stack.h\"\n#include \"vars.h\"\n\n#define MAX_INT_LEN 15\n#define MAX_VAR_LEN 25\n\n\n#define _RELEASE\n\nstatic int calculate ( int op1 , int op2 , char oper );\nint main()\n{\n	stack *charStack=NULL, *intStack=NULL;\n	char *str=NULL;\n	char *towrite = NULL;\n	char *varstr = NULL;\n	int c=0;\n	int curr_INT_LEN = MAX_INT_LEN;\n	int curr_VAR_LEN = MAX_VAR_LEN;\n	//int one=1,two =2;\n\n	int sign = 1;\n	int end_result = 0;\n	int prevchar=0;\n	// 0 : ??? ???? ????????\n	// 1 : ???? ?????\n	// 2 : ???? ????? ...\n	int waseq = 0;	\n	//??????? ?????? ? ????????\n	str = (char*)malloc(MAX_INT_LEN*sizeof(char));//Str for int\n	varstr = (char*)malloc(MAX_VAR_LEN*sizeof(char));//Str for var name\n	//towrite = (char*)malloc(MAX_VAR_LEN*sizeof(char));//Str for var which will get value!\n	if (!str || !varstr){// || !towrite){\n		perror(\"malloc\");\n		return 1;\n	}\n	str[0]=\'\\0\';\n	varstr[0]=\'\\0\';\n	//towrite[0]=\'\\0\';\n	charStack = createStack(__c);\n	intStack = createStack(__i);\n	while(1){\n#ifdef WIN32\n		if (c==4) break;\n#else\n		if (c==-1) break;\n#endif\n		while(1){\n			c = getchar();\n#ifdef WIN32\n			if (c==4) break;\n#else\n			if (c==EOF) break;\n#endif\n			if (c == \'\\t\' || c == \' \') continue;\n			if (c == \'=\'){\n				towrite =(char*)malloc(curr_VAR_LEN*(sizeof(char)));\n				if (!towrite){\n					perror(\"malloc\");\n					exit(0);\n				}\n				towrite[0]=\'\\0\';\n				strcpy(towrite,varstr);\n				varstr[0]=\'\\0\';\n				waseq = 1;\n				continue;\n			}\n			if (isalpha(c)||c==\'_\'){\n					if (prevchar != 2){//???? ?? ????? ?? ???? ????\n						char tempstr[2];\n						tempstr[0]=c;\n						tempstr[1]=\'\\0\';\n							\n						strcpy(varstr,tempstr);\n						prevchar = 2;\n					} else {\n						char tempstr[2];\n						tempstr[0]=c;\n						tempstr[1]=\'\\0\';\n						if (strlen(varstr)==curr_VAR_LEN-2){\n							char *temp;\n							temp = (char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!temp){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(temp,varstr);\n							free(varstr);\n							curr_VAR_LEN+=50;\n							varstr=(char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!varstr){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(varstr,temp);\n							free(temp);\n						}\n						strcat(varstr,tempstr);\n					}				\n				continue;\n			}\n			if (isdigit(c)){\n				if (prevchar != 1){ /*|| prevchar == 4){*///???? ?? ????? ??? ???? ????????\n					char tempstr[2];\n					tempstr[0]=c;\n					tempstr[1]=\'\\0\';\n					strcpy(str,tempstr);\n					prevchar = 1;\n				/*} else if (prevchar == 2){ \n						char tempstr[2];\n						tempstr[0]=c;\n						tempstr[1]=\'\\0\';\n						if (strlen(varstr)==curr_VAR_LEN-2){\n							char *temp;\n							temp = (char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!temp){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(temp,varstr);\n							free(varstr);\n							curr_VAR_LEN+=50;\n							varstr=(char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!varstr){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(varstr,temp);\n							free(temp);\n						}\n						strcat(varstr,tempstr);*/\n				} else {// ???? ?? ????? ??? ?????\n					char tempstr[2];\n					tempstr[0]=c;\n					tempstr[1]=\'\\0\';\n					if (strlen(str)==curr_INT_LEN-2){\n						char *temp;\n						temp = (char*)malloc(curr_INT_LEN*(sizeof(char)));\n						if (!temp){\n							perror(\"malloc\");\n							exit(0);\n						}\n						strcpy(temp,str);\n						free(str);\n						curr_INT_LEN+=50;\n						str=(char*)malloc(curr_INT_LEN*(sizeof(char)));\n						if (!str){\n							perror(\"malloc\");\n							exit(0);\n						}\n						strcpy(str,temp);\n						free(temp);\n					}\n					strcat(str,tempstr);\n				}\n				continue;		\n			}\n			else if (prevchar == 1){\n				int a;\n				a = sign*atoi(str);\n				sign = 1;\n				push(intStack,&a);\n#ifndef _RELEASE\n				printf(\"%d \",a);\n#endif\n			}\n			if (c == \'(\'){\n				push(charStack,&c);\n				prevchar = 0;\n			}\n			else if (c == \')\'){\n				char t;\n				if (prevchar == 2){\n					int val;\n					val = get_value(varstr);\n#ifndef _RELEASE\n					printf(\"%d \",val);\n#endif\n					varstr[0] = \'\\0\';\n					push(intStack,&val);\n				}\n				prevchar = 4;\n				if (!empty(charStack)){\n					t =*(char*)top(charStack);\n					while (t != \'(\'){\n						int result;\n						int op1,op2;\n\n						op1 = *(int*)top(intStack);\n						pop(intStack);\n						op2 = *(int*)top(intStack);\n						pop(intStack);\n						result = calculate(op1,op2,t);\n						push(intStack,&result);\n#ifndef _RELEASE\n						printf(\" %c \",t);\n#endif\n						pop(charStack);\n						if (!empty(charStack)){\n							t = *(char*)top(charStack);\n						}\n						else t = 0;\n					}\n					pop(charStack);\n				}\n			}\n			else if (c == \'*\' || c == \'/\'){\n				char t;\n				if (prevchar == 2){\n					int val;\n					val = get_value(varstr);\n#ifndef _RELEASE\n					printf(\"%d \",val);\n#endif\n					varstr[0] = \'\\0\';\n					push(intStack,&val);\n				}\n				prevchar = 0;\n				if (!empty(charStack)){\n					t = *(char*)top(charStack);\n					while (t== \'*\' || t == \'/\'){\n						int result;\n						int op1,op2;\n\n						op1 = *(int*)top(intStack);\n						pop(intStack);\n						op2 = *(int*)top(intStack);\n						pop(intStack);\n						result = calculate(op1,op2,t);\n						push(intStack,&result);\n#ifndef _RELEASE		\n						printf(\" %c \",t);\n#endif\n						pop(charStack);\n						if (!empty(charStack)){\n							t = *(char*)top(charStack);\n						}\n						else t = 0;\n					}\n				}\n				push(charStack,&c);\n			}\n			else if (c == \'+\' || c == \'-\'){\n				if (prevchar!=0){\n					char t;\n					if (prevchar == 2){\n						int val;\n						val = get_value(varstr);\n#ifndef _RELEASE\n						printf(\"%d \",val);\n#endif\n						varstr[0] = \'\\0\';\n						push(intStack,&val);\n					}   \n					prevchar = 0;\n					if (!empty(charStack)){\n						t = *(char*)top(charStack);\n						while (t ==\'*\' || t ==\'/\' || t== \'+\' || t==\'-\'){\n							int result;\n							int op1,op2;\n\n							op1 = *(int*)top(intStack);\n							pop(intStack);\n							op2 = *(int*)top(intStack);\n							pop(intStack);\n							result = calculate(op1,op2,t);\n							push(intStack,&result);\n#ifndef _RELEASE						\n							printf(\" %c \",t);\n#endif\n							pop(charStack);\n							if (!empty(charStack)){\n								t = *(char*)top(charStack);\n							}\n							else\n								t = 0;\n						}\n					}\n					push(charStack,&c);\n				} else\n					sign = (c==\'+\')?sign*1:sign*(-1);\n			}\n			else if (c == \'\\n\'){\n				if (prevchar == 2){\n					int val;\n					\n					val = get_value(varstr);\n#ifndef _RELEASE\n					printf(\"%d \",val);\n#endif\n					varstr[0] = \'\\0\';\n					push(intStack,&val);\n				}\n				while (!empty(charStack)){\n					char t;\n					int result;\n					int op1,op2;\n\n					t = *(char*)top(charStack);\n#ifndef _RELEASE				\n					printf(\" %c \",*(char*)top(charStack));\n#endif\n					op1 = *(int*)top(intStack);\n					pop(intStack);\n					op2 = *(int*)top(intStack);\n					pop(intStack);\n					result = calculate(op1,op2,t);\n					push(intStack,&result);\n					pop(charStack);\n				}\n				end_result = *(int*)top(intStack);\n				if (waseq == 1){\n					set_value(towrite,&end_result);\n					waseq = 0;\n				}\n				else\n				printf(\"= %d\\n\",end_result);\n				end_result = 0;\n				prevchar=0;\n				pop(intStack);\n				break;\n			}\n		}\n		if (towrite){\n			free(towrite);\n			towrite=NULL;\n		}\n	}\n	destroyStack(charStack);	\n	destroyStack(intStack);\n	cleanup();\n	free(str);\n	free(varstr);\n#ifdef WIN32\n	_CrtDumpMemoryLeaks();\n#endif\n	//free(towrite);\n	return 0;\n}\nstatic int calculate ( int op1 , int op2 , char oper ){\n	int result;\n	switch (oper) {\n		case \'+\' : result = op2 + op1; \n			   break;\n		case \'*\' : result = op2 * op1;\n			   break;\n		case \'-\' : result = op2 - op1;\n			   break;\n		case \'/\' : result = op2 / op1;\n			   break;\n		default : perror(\"Unknown operator\");\n			  result = 0;\n	}\n	return result;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (77,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"stack.h\"\r\n\r\nstatic void destrStruct_I (struct item* a);\r\nstatic int checkMalloc(void*);\r\n\r\nvoid push (stack *st,void* data){\r\n	void* t;\r\n	struct item *p;\r\n\r\n	if (st->stackType == i){\r\n		t = (int*)malloc(sizeof(int));\r\n		if(!checkMalloc(t)){\r\n			return;\r\n		}\r\n		*(int*)t = *(int*)data;\r\n	} else if (st->stackType == c) {\r\n		t = (char*)malloc(sizeof(char));\r\n		if(!checkMalloc(t)){\r\n			return;\r\n		}\r\n		*(char*)t = *(char*)data;\r\n	} else { /*int a = 1;  ?????? ???-??????*/ }\r\n\r\n	p = (struct item*)malloc(sizeof(struct item));\r\n	if(!checkMalloc(p)){\r\n		free(t);\r\n		return;\r\n	}\r\n	p -> data = t;\r\n	p -> next = st -> head;\r\n	st -> head = p;\r\n}\r\n\r\nvoid* top (stack *st){\r\n	if (!empty(st)){\r\n		return (void*)(st->head->data);\r\n	}\r\n	return NULL;\r\n}\r\n\r\nvoid pop(stack* st){\r\n	struct item* q;\r\n	q = st -> head;\r\n	st -> head = q->next;\r\n	free(q->data);\r\n	free(q);\r\n}\r\nint empty(stack* st){\r\n	return (st->head==NULL||st==NULL);\r\n}\r\n\r\nstack* createStack (type stackType){\r\n	stack* st;\r\n	st = malloc(sizeof(stack));\r\n	st->head = NULL;\r\n	st->stackType = stackType;\r\n	return st;\r\n}\r\nvoid destroyStack (stack* st) {\r\n	if(st->head != NULL)\r\n		destrStruct_I(st->head);\r\n	free(st);\r\n}\r\nvoid destrStruct_I (struct item* a){ // str item\r\n	if (a->next)\r\n		destrStruct_I (a->next);\r\n	free(a->data);\r\n	free(a);		\r\n}\r\nvoid* top_pop (stack *st){\r\n	if(!empty(st)){\r\n		void* temp;\r\n		temp = top (st);\r\n		pop(st);\r\n		return temp;\r\n	}\r\n	else\r\n		return NULL;\r\n}\r\n\r\nvoid printStack (stack* st)\r\n{\r\n	if (empty(st))\r\n		printf(\"Stack is empty\\n\");\r\n	else {\r\n		struct item* p;\r\n		printf(\"-> \");\r\n		switch (st->stackType){\r\n			case i:	\r\n				for (p = st->head; p ; p = p->next){\r\n					printf(\"%d->\",*(int*)p->data); \r\n				}\r\n				break;\r\n			case c:\r\n				for (p = st->head; p ; p = p->next){\r\n					printf(\"%c->\",*(char*)p->data); \r\n				}\r\n				break;\r\n			default:break;\r\n		}\r\n		printf(\"X\\n\");\r\n	}\r\n}\r\nstatic int checkMalloc(void* p){\r\n	if (p==NULL){\r\n		perror(\"malloc\");\r\n		return 0;\r\n	}\r\n	return 1;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (78,'#include \"vars.h\"\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nstatic unsigned int hashf(char*);\r\nstatic void destrStruct_H (hash* a);\r\nstatic int checkMalloc(void*);\r\n\r\nvoid set_value(char* name, void* data){\r\n	void* p;\r\n	var* someVar;\r\n	char* str;\r\n	int hval;\r\n	hash* a;\r\n	\r\n	p = (int*)malloc(sizeof(int));\r\n	if(!checkMalloc(p))return;\r\n	*(int*)p = *(int*)data;\r\n\r\n	hval = hashf(name);\r\n	for (a=HashTable[hval]; a; a=a->next)	{\r\n		if(strcmp(a->varVal->name,name)==0) {\r\n			free(a->varVal->value);\r\n			a->varVal->value = p;\r\n			return;\r\n		}\r\n	}\r\n	str = (char*)malloc(sizeof(char)*(1+strlen(name)));\r\n	if(!checkMalloc(str)){\r\n		free(p);\r\n		return;\r\n	}\r\n	strcpy(str,name);\r\n\r\n	someVar =(var*) malloc(sizeof(var));\r\n	if(!checkMalloc(someVar)){\r\n		free(p);\r\n		free(str);\r\n		return;\r\n	}\r\n	someVar->name = str;\r\n	someVar->value = p;\r\n	\r\n	a = (hash*)malloc(sizeof(hash));\r\n	if(!checkMalloc(a)){\r\n		free(p);\r\n		free(str);\r\n		free(someVar);\r\n		return;\r\n	}\r\n	a->varVal=someVar;\r\n	if (HashTable[hval])\r\n		p = (void*)HashTable[hval]->next;\r\n	else \r\n		p = NULL;\r\n	HashTable[hval]=a;\r\n	a->next = (hash*)p;\r\n}\r\nint get_value(char* name){\r\n	int hval = hashf(name);\r\n	hash* a;\r\n	int value;\r\n	for(a = HashTable[hval]; a ; a=a->next){\r\n		if(strcmp(a->varVal->name,name)==0){\r\n			value = *(int*)a->varVal->value;\r\n			return value;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\nvoid cleanup(void){\r\n	int i;\r\n	for(i=0; i<maxHash ; i++){\r\n		if (HashTable[i]!=NULL){\r\n			destrStruct_H(HashTable[i]);\r\n		}\r\n	}\r\n}\r\n\r\n\r\nstatic unsigned int hashf (char* str){ \r\n	unsigned int len = strlen(str);\r\n	unsigned int sum=1;\r\n	unsigned int i;\r\n\r\n	for (i=0; i<len; i++){\r\n		sum = (sum+(unsigned int)str[i])%maxHash;\r\n	}\r\n	return (sum*7)%maxHash;\r\n}\r\nstatic void destrStruct_H (hash* a){ // str item\r\n	if (a->next)\r\n		destrStruct_H (a->next);\r\n	free(a->varVal->name);\r\n	free(a->varVal->value);\r\n	free(a->varVal);\r\n	free(a);		\r\n}\r\nstatic int checkMalloc(void* p){\r\n	if(p==NULL){\r\n		perror(\"malloc\");\r\n		return 0;\r\n	}\r\n	return 1;\r\n}\r\n	\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (79,'#include \"stdlib.h\"\n\n#define BASE 10000\n\nstruct long_int {\n	int *digits;\n	int length;\n	int sign;\n};\n\nstatic void botva(void) {\n	printf(\"Memory allocation failed\\n\");\n	abort();\n}\n\nstatic int max(int a, int b) {\n	if (a > b) return a;\n	return b;\n}\n\nstatic int min(int a, int b) {\n	if (a < b) return a;\n	return b;\n}\n\nstruct long_int *make_long(void);\nstruct long_int *copy_long(struct long_int *a);\nvoid free_long(struct long_int *a);\n\nstatic void resize(struct long_int *a) {\n	while (a->length > 1 && a->digits[a->length-1] == 0) {\n		a->length--;\n	}\n	a->digits = realloc(a->digits, a->length*sizeof(int));\n	if (a->digits == 0) {\n		botva();\n	}\n	if (a->length == 1 && a->digits[0] == 0) {\n		a->sign = 1;\n	}\n}\n\nstatic int more_abs(struct long_int *a, struct long_int *b) {\n	int i;\n	if (a->length > b->length) return 1;\n	if (b->length > a->length) return -1;\n	for (i = a->length-1; i >= 0; i--) {\n		if (a->digits[i] > b->digits[i]) return 1;\n		if (b->digits[i] > a->digits[i]) return -1;\n	}\n	return 0;\n}\n\nstatic struct long_int *add_abs(struct long_int *a, struct long_int *b){\n	struct long_int *c;\n	int l, i, x;\n	\n	l = max(a->length, b->length)+1;\n	c = malloc(sizeof(struct long_int));\n	if (c == 0) {\n		botva();\n	}\n	c->digits = malloc(l*sizeof(int));\n	if (c->digits == 0) {\n		botva();\n	}\n	\n	c->length = l;\n	x = 0;\n	for(i = 0; i < l; i++) {\n		if (i < a->length) x += a->digits[i];\n		if (i < b->length) x += b->digits[i];\n		c->digits[i] = x % BASE;\n		x /= BASE;\n	}\n	\n	resize(c);\n	return c;\n}\n\nstatic struct long_int* sub_abs(struct long_int *a, struct long_int *b){\n	struct long_int *c;\n	int i, x;\n	\n	c = malloc(sizeof(struct long_int));\n	if (c == 0) {\n		botva();\n	}\n	c->digits = malloc(a->length*sizeof(int));\n	if (c->digits == 0) {\n		botva();\n	}\n	\n	c->length = a->length;\n	x = 0;\n	for (i = 0; i < a->length; i++) {\n		x += a->digits[i];\n		if (i < b->length) {\n				x -= b->digits[i];\n		}\n		c->digits[i] = x;\n		x = 0;\n		while (c->digits[i] < 0) {\n			c->digits[i] += BASE;\n			x -= 1;\n		}\n	}\n	\n	resize(c);\n	return c;\n}\n\nstatic struct long_int *mul_s(struct long_int *a, int n){\n	struct long_int *c;\n	int l, i, x;\n	\n	l = a->length+1;\n	c = malloc(sizeof(struct long_int));\n	if (c == 0) {\n		botva();\n	}\n	c->digits = malloc(l*sizeof(int));\n	if (c->digits == 0) {\n		botva();\n	}\n	\n	c->length = l;\n	x = 0;\n	for(i = 0; i < l; i++) {\n		if (i < a->length) x += a->digits[i] * n;\n		c->digits[i] = x % BASE;\n		x /= BASE;\n	}\n	\n	resize(c);\n	return c;\n}\n\nstatic void sht(struct long_int *a, int n) {\n	int i;\n	a->digits = realloc(a->digits, (a->length + n) * sizeof(int));\n	if(a->digits == 0) {\n		botva();\n	}\n	\n	for(i = a->length-1; i >= 0; i--) {\n		a->digits[i+n] = a->digits[i];\n	}\n	for(i = n-1; i >=0; i--) {\n		a->digits[i] = 0;\n	}\n	a->length += n;\n}\n\nstruct long_int* addl(struct long_int *a, struct long_int *b){\n	struct long_int *r;\n	\n	if (a->sign * b->sign > 0) {\n		r = add_abs(a, b);\n		r->sign = a->sign;\n		return r;\n	}\n	if (more_abs(a,b) > 0) {\n		r = sub_abs(a, b);\n		r->sign = a->sign;\n		return r;\n	}\n	r = sub_abs(b, a);\n	r->sign = b->sign;\n	return r;\n}\n\nstruct long_int* subl(struct long_int *a, struct long_int *b){\n	struct long_int *r;\n	\n	if (a->sign * b->sign < 0) {\n		r = add_abs(a, b);\n		r->sign = a->sign;\n		return r;\n	}\n	if (more_abs(a, b) > 0) {\n		r = sub_abs(a, b);\n		r->sign = a->sign;\n		return r;\n	}\n	r = sub_abs(b, a);\n	r->sign = -b->sign;\n	return r; \n}\n\nstruct long_int* mull(struct long_int *a, struct long_int *b) {\n	struct long_int *c;\n	int i, j, x, y, l;\n	\n	l = a->length + b->length;\n	c = malloc(sizeof(struct long_int));\n	if (c == 0) {\n		botva();\n	}\n	c->digits = malloc(l*sizeof(int));\n	if (c->digits == 0) {\n		botva();\n	}\n\n	c->length = l;\n	x = 0;\n	for(i = 0; i < l; i++) {\n		y = x;\n		x = 0;\n		for(j = max(0, i - b->length + 1); j < min(i + 1, a->length); j++) {\n			y += a->digits[j] * b->digits[i-j];\n			x += y / BASE;\n			y %= BASE;\n		}\n		c->digits[i] = y;\n	}\n	\n	resize(c);\n	c->sign = a->sign * b->sign;\n	return c;\n}\n\nstruct long_int *divl(struct long_int *a, struct long_int *b) {\n	struct long_int *c, *r, *t, *tt;\n	int i, l, ll, rr, xx;\n	if (more_abs(a, b) < 0) {\n		c = make_long();\n		return c;\n	}\n	\n	l = a->length - b->length + 1;\n	c = malloc(sizeof(struct long_int));\n	if (c == 0) {\n		botva();\n	}\n	c->digits = malloc(l*sizeof(int));\n	if (c->digits == 0) {\n		botva();\n	}\n	\n	c->length = l;\n	r = copy_long(a);\n	for (i = l-1; i >= 0; i--) {\n		ll = 0;\n		rr = BASE;\n		while (rr-ll > 1) {\n			xx = (ll + rr)/2;\n			t = mul_s(b, xx);\n			sht(t, i);\n			if (more_abs(t, r) > 0) {\n				rr = xx;\n			} else {\n				ll = xx;\n			}\n			free_long(t);\n		}\n		t = mul_s(b, ll);\n		sht(t, i);\n		c->digits[i] = ll;\n		tt = sub_abs(r, t);\n		free_long(t);\n		free_long(r);\n		r = tt;\n	}\n	free_long(r);\n	\n	resize(c);\n	c->sign = a->sign*b->sign;\n	return c;\n}\n\nvoid printl(struct long_int *a) {\n	int i;\n	if (a->sign < 0 && !(a->length == 1 && a->digits[0] == 0)) {\n		printf(\"-\");\n	}\n	printf(\"%d\", a->digits[a->length-1]);\n	for(i = a->length-2; i >= 0; i--) {\n		printf(\"%04d\", a->digits[i]);\n	}\n}\n\nstruct long_int *make_long(void) {\n	struct long_int *r;\n	r = malloc(sizeof(struct long_int));\n	if (r == 0) {\n		botva();\n	}\n	r->digits = malloc(sizeof(int));\n	r->digits[0] = 0;\n	r->length = 1;\n	r->sign = 1;\n	return r;\n}\n\nstruct long_int *convert_long(char *c) {\n	struct long_int *r;\n	int i, l, x, k;\n	r = malloc(sizeof(struct long_int));\n	if (*c == \'-\') {\n		r->sign = -1;\n		c++;\n	} else {\n		r->sign = 1;\n	}\n	\n	while (*c == \'0\') c++;\n	if (*c == 0) c--;\n	l = 0;\n	while (c[l]) {\n		l++;\n	}\n	r->length = (l+3)/4;\n	r->digits = malloc(r->length*sizeof(int));\n	if(r->digits == 0) {\n		botva();\n	}\n\n	x = 0;\n	k = r->length-1;\n	for (i = 0; i < l; i++) {\n		x *= 10;\n		x += c[i]-\'0\';\n		if ((l-i)%4 == 1) {\n			r->digits[k] = x;\n			k--;\n			x = 0;\n		}\n	}\n	return r;\n}\n\nvoid free_long(struct long_int *a) {\n	free(a->digits);\n	free(a);\n}\n\nvoid dest_long(void *a) {\n	free_long((struct long_int*)a);\n}\n\nstruct long_int *copy_long(struct long_int *a) {\n	struct long_int *c;\n	int i;\n		\n	c = malloc(sizeof(struct long_int));\n	if (c == 0) {\n		botva();\n	}\n	c->digits = malloc(a->length*sizeof(int));\n	if (c->digits == 0) {\n		botva();\n	}\n	c->length = a->length;\n	c->sign = a->sign;\n	for(i = 0; i < c->length; i++) {\n		c->digits[i] = a->digits[i];\n	}\n	return c;\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (80,'#include \"stack.h\"\n#include \"vars.h\"\n#include \"long.h\"\n#include \"stdlib.h\"\n#include \"stdio.h\"\n\nenum lexem {NUMBER, VARNAME, PLUS, MINUS, MULTIPLY, DIVIDE, EQUAL, LBRACE, RBRACE, END, EXIT, ERROR};\n\nstatic struct stack *lexst, *numst; // Stacks\nstatic int c; // Last received letter\nstatic char* str; // Current number or variable name\nstatic int strl; // Size of memory allocated for str\nstatic enum lexem curlex; // Current lexem\n\nstatic void incstr(int val) {\n	strl += val;\n	str = realloc(str, strl);\n	if (str == 0) {\n		printf(\"Memory allocation failed\\n\");\n		abort();\n	}\n}\n\nstatic void botva(void) {\n	printf(\"Incorrect expression\\n\");\n	abort();\n}\n\nstatic enum lexem get_lexem() {\n	if (c == 0) {\n		c = getchar();\n	}\n	while(c == \' \') c = getchar();\n	\n	switch(c) {\n		case \'+\':\n		c = getchar();\n		return PLUS;\n		break;\n			\n		case \'-\':\n		c = getchar();\n		return MINUS;\n		break;\n		\n		case \'*\':\n		c = getchar();\n		return MULTIPLY;\n		break;\n		\n		case \'/\':\n		c = getchar();\n		return DIVIDE;\n		break;\n			\n		case \'=\':\n		c = getchar();\n		return EQUAL;\n		break;\n		\n		case \'(\':\n		c = getchar();\n		return LBRACE;\n		break;\n				\n		case \')\':\n		c = getchar();\n		return RBRACE;\n		break;\n			\n		case \'\\n\':\n		c = 0;\n		return END;\n		break;\n			\n		case EOF:\n		return EXIT;\n		break;\n		\n		default:\n		if (\'0\' <= c && c <= \'9\') {\n			int k = 0;\n			while (\'0\' <= c && c <= \'9\') {\n				if(k >= strl) {\n					incstr(10);\n				}\n				str[k] = c;\n				k++;\n				c = getchar();\n			}\n			if(k >= strl) {\n				incstr(10);\n			}\n			str[k] = 0;\n			return NUMBER;\n		}\n		if ((\'a\' <= c && c <= \'z\') || (\'A\' <= c && c <= \'Z\')) {\n			int k = 0;\n			while ((\'a\' <= c && c <= \'z\') || (\'A\' <= c && c <= \'Z\') || (\'0\' <= c && c <= \'9\') || (c == \'_\')) {\n				if(k >= strl) {\n					incstr(10);\n				}\n				str[k] = c;\n				k++;\n				c = getchar();\n			}\n			if(k >= strl) {\n				incstr(10);\n			}\n			str[k] = 0;\n			return VARNAME;\n		}\n		break;\n	}\n	c = 0;\n	return ERROR;\n}\n\nstatic void ex_op(enum lexem lex) {\n	struct long_int *a, *b, *r;\n	if (lex >= EQUAL) return;\n	\n	b = (struct long_int*)top(numst);\n	pop(numst);\n	a = (struct long_int*)top(numst);\n	pop(numst);\n	\n	if (a == 0) {\n		a = make_long();\n	}\n	if (b == 0) {\n		b = make_long();\n	}\n	switch(lex) {\n		case PLUS:\n		r = addl(a, b);\n		break;\n\n		case MINUS:\n		r = subl(a, b);\n		break;\n\n		case MULTIPLY:\n		r = mull(a, b);\n		break;\n\n		case DIVIDE:\n		r = divl(a, b);\n		break;\n	}\n	free_long(a);\n	free_long(b);\n	\n	push(numst, (void*)r);	\n}\n\nstatic struct long_int* solve_expr(void) {\n	enum lexem *t_lex;	\n	struct long_int* res;\n	int tsign = 1;\n	while (curlex < END) {\n		switch (curlex) {\n			case NUMBER:\n			res = convert_long(str);\n			res->sign *= tsign;\n			tsign = 1;\n			push(numst, (void*)res);\n			curlex = get_lexem();\n			break;\n			\n			case VARNAME: \n			{\n				struct long_int* t_long;\n				t_long = get_value(str);\n				if (t_long == 0) {\n					botva();\n				}\n				res = copy_long(t_long);\n				res->sign *= tsign;\n				tsign = 1;\n				push(numst, (void*)res);\n				curlex = get_lexem();\n			}\n			break;\n			\n			case LBRACE:\n			t_lex = malloc(sizeof(enum lexem));\n			if (t_lex == 0) {\n				printf(\"Memory allocation failed\\n\");\n				abort();\n			}\n			*t_lex = curlex;\n			push(lexst, (void*)t_lex);\n			\n			curlex = get_lexem();\n			if(curlex == PLUS || curlex == MINUS) {\n				if (curlex == MINUS) {\n					tsign = -1;\n				}\n				curlex = get_lexem();\n			}\n			break;\n\n			case RBRACE:\n			t_lex = (enum lexem*)top(lexst);\n			while(t_lex != 0 && *t_lex != LBRACE) {\n				ex_op(*t_lex);\n				free(t_lex);\n				pop(lexst);\n				t_lex = (enum lexem*)top(lexst);\n			}\n			if (t_lex == 0) {\n				botva();\n			}\n			free(t_lex);\n			pop(lexst);\n			curlex = get_lexem();\n			break;\n			\n			case PLUS:\n			case MINUS:\n			t_lex = (enum lexem*)top(lexst);\n			while(t_lex != 0 && *t_lex != LBRACE) {\n				ex_op(*t_lex);\n				free(t_lex);\n				pop(lexst);\n				t_lex = (enum lexem*)top(lexst);\n			}\n			t_lex = malloc(sizeof(enum lexem));\n			if (t_lex == 0) {\n				printf(\"Memory allocation failed\\n\");\n				abort();\n			}\n			*t_lex = curlex;\n			push(lexst, (void*)t_lex);\n			\n			curlex = get_lexem();\n			if(curlex == PLUS || curlex == MINUS) {\n				if (curlex == MINUS) {\n					tsign = -1;\n				}\n				curlex = get_lexem();\n			}\n			break;\n\n			case MULTIPLY:\n			case DIVIDE:\n			t_lex = (enum lexem*)top(lexst);\n			while(t_lex != 0 && (*t_lex == MULTIPLY || *t_lex == DIVIDE)) {\n				ex_op(*t_lex);\n				free(t_lex);\n				pop(lexst);\n				t_lex = (enum lexem*)top(lexst);\n			}\n			t_lex = malloc(sizeof(enum lexem));\n			if (t_lex == 0) {\n				printf(\"Memory allocation failed\\n\");\n				abort();\n			}\n			*t_lex = curlex;\n			push(lexst, (void*)t_lex);\n			\n			curlex = get_lexem();\n			if(curlex == PLUS || curlex == MINUS) {\n				if (curlex == MINUS) {\n					tsign = -1;\n				}\n				curlex = get_lexem();\n			}\n			break;\n			\n			default:\n			botva();\n			break;\n		}\n	}\n	if (curlex == ERROR) {\n		botva();\n	}\n	while(!empty(lexst)) {\n		t_lex = (enum lexem*)top(lexst);\n		ex_op(*t_lex);\n		free(t_lex);\n		pop(lexst);\n	}\n	res = (struct long_int*)top(numst);\n	if (res == 0) {\n		botva();\n	}\n	pop(numst);\n	if (!empty(numst)) {\n		botva();\n	}\n	return res;\n}\n\nint main(void) {\n	struct long_int* res;\n	\n	curlex = get_lexem();\n	lexst = make_stack(*free);\n	numst = make_stack(*dest_long);\n	\n	while (curlex != EXIT) {\n		while (curlex == END) {\n			curlex = get_lexem();\n		}\n		if (curlex == VARNAME) {\n			char *t_str;\n			int i;\n			t_str = malloc(strl);\n			if (t_str == 0) {\n				printf(\"Memory allocation failed\\n\");\n				abort();\n			}\n			for(i = 0; str[i]; i++) {\n				t_str[i] = str[i];\n			}\n			t_str[i] = 0;\n			\n			curlex = get_lexem();\n			if (curlex == EQUAL) {\n				curlex = get_lexem();\n				res = solve_expr();\n				set_value(t_str, res);\n			} else {\n				res = get_value(str);\n				if (res == 0) {\n					botva();\n				}\n				push(numst, (void*)copy_long(res));\n				\n				res = solve_expr();\n				printl(res);\n				putchar(\'\\n\');\n				free_long(res);\n			}\n			free(t_str);\n		} else {\n			res = solve_expr();\n			printl(res);\n			putchar(\'\\n\');\n			free_long(res);\n		}\n		if (curlex != EXIT) {\n			curlex = get_lexem();\n		}\n	}\n	\n	cleanup();\n	kill_stack(lexst);\n	kill_stack(numst);\n	free(str);\n	return 0;\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (81,'#include \"stdlib.h\"\n\ntypedef void destructor(void* data);\n\nstruct item {\n	void* data;\n	struct item* next;\n};\n\nstruct stack {\n	struct item* head;\n	destructor* destr;\n	int size;\n};\n\nstatic void botva(void) {\n	printf(\"Memory allocation failed\\n\");\n	abort();\n}\n\nvoid push(struct stack* st, void* data) {\n	struct item* p;\n	p = malloc(sizeof(struct item));\n	if (p == 0) {\n		botva();\n	}\n	\n	p->data = data;\n	p->next = st->head;\n	st->head = p;\n	st->size++;\n}\n\nvoid *top(struct stack* st) {\n	if (st->head == 0) return 0;\n	return st->head->data;\n}\n\nvoid pop(struct stack* st) {\n	struct item* p;\n	p = st->head;\n	if (p == 0) return;\n	st->head = p->next;\n	free(p);\n	st->size--;\n}\n\nint empty(struct stack* st) {\n	if (st->size == 0) return 1;\n	return 0;\n}\n\nstruct stack* make_stack(destructor* destr) {\n	struct stack* p;\n	p = malloc(sizeof(struct stack));\n	if (p == 0) {\n		botva();\n	}\n	\n	p->head = 0;\n	p->size = 0;\n	p->destr = destr;\n	return p;\n}\n\nvoid kill_stack(struct stack* st) {\n	while (st->head != 0) {\n		st->destr(top(st));\n		pop(st);\n	}\n	free(st);\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (82,'#include \"long.h\"\n#include \"stdlib.h\"\n\n#define SIZE 10000\n\nstruct item {\n	char* name;\n	struct long_int* data;\n	struct item* next;\n};\n\nstatic struct item* table[SIZE];\n\nstatic void botva(void) {\n	printf(\"Memory allocation failed\\n\");\n	abort();\n}\n\nstatic int hash(char* s) {\n	int res = 0;\n	while(*s) {\n		res *= 37;\n		res += *s;\n		res %= SIZE;\n		s++;\n	}\n	return res;\n}\n\nstatic int strchk(char* s1,char* s2) {\n	while (*s1 && *s2) {\n		if (*s1 != *s2) {\n			return 0;\n		}\n		s1++;\n		s2++;\n	}\n	if (*s1 || *s2) {\n		return 0;\n	}\n	return 1;\n}\n\nstatic int length(char* s) {\n	int res = 1;\n	while (*s) {\n		res++;\n		s++;\n	}\n	return res;\n}\n\nstatic void copy(char *s1, char *s2) {\n	while (*s1) {\n		*s2 = *s1;\n		s2++;\n		s1++;\n	}\n	*s2 = 0;\n}\n\nvoid set_value(char* name, struct long_int* value) {\n	struct item* p;\n	int hn = hash(name);\n	p = table[hn];\n	\n	while (p && !strchk(name, p->name)) {\n		p = p->next;\n	}\n	if (p) {\n		free_long(p->data);\n		p->data = value;\n		return;\n	}\n	\n	p = malloc(sizeof(struct item));\n	if (p == 0) {\n		botva();\n	}\n	\n	p->data = value;\n	p->next = table[hn];\n	p->name = malloc(length(name));\n	if (p->name == 0) {\n		botva();\n	}\n	copy(name, p->name);\n	table[hn] = p;\n}\n\nstruct long_int* get_value(char* name) {\n	struct item* p;\n	int hn = hash(name);\n	p = table[hn];\n	\n	while (p && !strchk(name, p->name)) {\n		p = p->next;\n	}\n	if (p) {\n		return p->data;\n	}\n	\n	printf(\"Unknown variable %s.\\n\", name);\n	return 0;\n}\n\nvoid cleanup(void) {\n	int i;\n	struct item *p, *q;\n	for (i = 0; i < SIZE; i++) {\n		p = table[i];\n		while (p) {\n			q = p;\n			p = p->next;\n			\n			free(q->name);\n			free_long(q->data);\n			free(q);\n		}\n	}\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (83,'#define _CRT_SECURE_NO_WARNINGS\r\n//#include <crtdbg.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n#include \"stack.h\"\r\n#include \"vars.h\"\r\n\r\n#define N 100\r\nstruct varItem *vars[N];\r\n\r\nchar *toPol(char* str)\r\n{\r\n	char *s;\r\n	struct stack *operands;\r\n	unsigned int i = 0, ir = 0, sign = 0, state = 1;\r\n	char *res = calloc(ir+1, sizeof(char));\r\n	if(!res){perror(\"calloc of char\"); return 0; }\r\n	createStack(&operands, 0);\r\n	for(i=0; i<strlen(str); i++)\r\n	{\r\n		if(isdigit(str[i]))\r\n		{\r\n			if(sign%2 != 0)\r\n			{\r\n				sign = 0;\r\n				if(i == 1)\r\n				{\r\n					res = realloc(res, ir+2);\r\n					if(!res){perror(\"realloc of char\"); return 0; }\r\n					res[ir++] = \'-\';\r\n				}\r\n				else\r\n				{\r\n					res = realloc(res, ir+3);\r\n					if(!res){perror(\"realloc of char\"); return 0; }\r\n					res[ir++] = \' \';\r\n					res[ir++] = \'-\';\r\n				}\r\n			}\r\n			res = realloc(res, ir+2);\r\n			if(!res){perror(\"realloc of char\"); return 0; }\r\n			res[ir++] = str[i];\r\n			state = 0;\r\n		}\r\n		if(str[i] == \'(\')\r\n		{\r\n			push(&operands, &str[i]);\r\n			state = 1;\r\n		}\r\n		if(str[i] == \')\')\r\n		{\r\n			char *curr = top(operands);\r\n			while(curr[0] != \'(\')\r\n			{\r\n				res = realloc(res, ir+3);\r\n				if(!res){perror(\"realloc of char\"); return 0; }\r\n				res[ir++] = \' \';\r\n				res[ir++] = curr[0];\r\n				s = pop(&operands);\r\n				free(s);\r\n				curr = top(operands);\r\n			}\r\n			s = pop(&operands);\r\n			free(s);\r\n		}\r\n		if (str[i] == \'+\' || str[i] == \'-\')\r\n		{\r\n			if(!empty(operands))\r\n			{\r\n				char *curr = top(operands);\r\n				while(state == 0 && (curr[0] == \'+\' || curr[0] == \'-\' || curr[0] == \'*\' || curr[0] == \'/\'))\r\n				{\r\n					res = realloc(res, ir+3);\r\n					if(!res){perror(\"realloc of char\"); return 0; }\r\n					res[ir++] = \' \';\r\n					res[ir++] = curr[0];\r\n					s = pop(&operands);\r\n					free(s);\r\n					curr = top(operands);\r\n					if(!curr) break;\r\n				}\r\n			}\r\n			if(state == 1)\r\n			{\r\n				state = 0;\r\n				sign++;\r\n			}\r\n			else\r\n			{\r\n				res = realloc(res, ir+2);\r\n				res[ir++] = \' \';\r\n				push(&operands, &str[i]);\r\n			}\r\n		}\r\n		if (str[i] == \'*\' || str[i] == \'/\')\r\n		{\r\n			if(!empty(operands))\r\n			{\r\n				char *curr = top(operands);\r\n				while(curr[0] == \'*\' || curr[0] == \'/\')\r\n				{\r\n					res = realloc(res, ir+3);\r\n					if(!res){perror(\"realloc of char\"); return 0; }\r\n					res[ir++] = \' \';\r\n					res[ir++] = curr[0];\r\n					s = pop(&operands);\r\n					free(s);\r\n					curr = top(operands);\r\n					if(!curr) break;\r\n				}\r\n			}\r\n			res = realloc(res, ir+2);\r\n			if(!res){perror(\"realloc of char\"); return 0; }\r\n			res[ir++] = \' \';\r\n			push(&operands, &str[i]);\r\n		}\r\n	}\r\n	while(!empty(operands))\r\n	{\r\n		char *curr = top(operands);\r\n		res = realloc(res, ir+3);\r\n		if(!res){perror(\"realloc of char\"); return 0; }\r\n		res[ir++] = \' \';\r\n		res[ir++] = curr[0];\r\n		s = pop(&operands);\r\n		free(s);\r\n	}\r\n	res[ir] = 0;\r\n	free(str);\r\n	destroyStack(&operands);\r\n	return res;\r\n}\r\n\r\nint calcPol(char *in)\r\n{\r\n	unsigned int i, sign = 0, state = 1;\r\n	int resCurr = 0, curr = 0;\r\n	int *res;\r\n	struct stack *numbers;\r\n	createStack(&numbers, 1);\r\n	for(i=0; i<strlen(in); i++)\r\n	{\r\n\r\n		if( ( ((i<strlen(in)-1) && in[i+1]==\' \') || (i==strlen(in)-1) ) && (in[i] == \'+\' || in[i] == \'-\' || in[i] == \'*\' || in[i] == \'/\'))\r\n		{\r\n			int *b = pop(&numbers);\r\n			int *a = pop(&numbers);\r\n			if (in[i] == \'+\')	resCurr = (*a) + (*b);\r\n			if (in[i] == \'-\')	resCurr = (*a) - (*b);\r\n			if (in[i] == \'*\')	resCurr = (*a) * (*b);\r\n			if (in[i] == \'/\')\r\n			{\r\n				if((*b) == 0)\r\n				{\r\n					printf(\"Div by zero!\\n\");\r\n					return 0;\r\n				}\r\n				else\r\n					resCurr = (*a) / (*b);\r\n			}\r\n			push(&numbers, &resCurr);\r\n			if(a)	free(a);\r\n			if(b)	free(b);\r\n		}\r\n		if(in[i] != \' \')\r\n		{\r\n			if(isdigit(in[i]))\r\n				curr = curr*10 + in[i]-\'0\';\r\n			if(in[i] == \'-\' && state == 1)\r\n				sign = 1;\r\n			state = 0;\r\n		}\r\n		if(in[i] == \' \' || i == strlen(in)-1)\r\n		{\r\n			state = 1;\r\n			if(sign){ curr = -curr;	sign = 0; }\r\n			if((i!=0 && isdigit(in[i-1])) || isdigit(in[i]))\r\n				push(&numbers, &curr);\r\n			curr = 0;\r\n		}\r\n	}\r\n	res = pop(&numbers);\r\n	if(res) curr = (*res);\r\n	free(res); \r\n	destroyStack(&numbers);\r\n	return curr;\r\n}\r\n\r\nchar *reverse(char *s)\r\n{\r\n	unsigned int i;\r\n	char c;\r\n	for(i=0; i<strlen(s)/2; i++)\r\n	{\r\n		c = s[i];\r\n		s[i] = s[strlen(s)-1-i];\r\n		s[strlen(s)-1-i] = c;\r\n	}\r\n	return s;\r\n}\r\n\r\nchar *intToStr(int x)\r\n{\r\n	int lr = 2;\r\n	int sign = x>=0 ? 0 : 1;\r\n	char *res = calloc(3, sizeof(char));\r\n	if(!res){ perror(\"calloc of char\"); return 0; }\r\n	*(res) = \')\'; *(res+1) = \'0\';\r\n	x = abs(x);\r\n	while(x)\r\n	{\r\n		res = realloc(res, ++lr);\r\n		if(!res){ perror(\"realloc of char\"); return 0; }\r\n		*(res+lr-2) = \'0\' + x%10;\r\n		*(res+lr-1) = 0;\r\n		x /= 10;\r\n	}\r\n	if(sign == 1)\r\n	{\r\n		res = realloc(res, ++lr);\r\n		if(!res){ perror(\"realloc of char\"); return 0; }\r\n		*(res+lr-2) = \'-\';\r\n		*(res+lr-1) = 0;\r\n	}\r\n	res = realloc(res, ++lr);\r\n	if(!res){ perror(\"realloc of char\"); return 0; }\r\n	*(res+lr-2) = \'(\';\r\n	*(res+lr-1) = 0;\r\n	return reverse(res); // _strrev\r\n}\r\n\r\nchar *changeVarsToValue(char *s)\r\n{\r\n	unsigned int i, j;\r\n	int lr = 1, lt = 1, varValue = 0; // length of res and tmp\r\n	char *res, *tmp;\r\n	res = calloc(lr, sizeof(char));\r\n	if(!res){perror(\"calloc of char\"); return 0; }\r\n	tmp = calloc(lt, sizeof(char));\r\n	if(!tmp){perror(\"calloc of char\"); return 0; }\r\n	for(i=0; i<strlen(s); i++)\r\n	{\r\n		if(s[i] == \' \') continue;\r\n		if(isdigit(s[i]) || s[i] == \'(\'|| s[i] == \')\' || s[i] == \'+\' || s[i] == \'-\' || s[i] == \'*\' || s[i] == \'/\')\r\n		{\r\n			if(tmp[0])\r\n			{\r\n				varValue = get_value(vars, tmp);\r\n				free(tmp);\r\n				tmp = intToStr(varValue);\r\n				for(j=0; j<strlen(tmp); j++)\r\n				{\r\n					res = realloc(res, ++lr);\r\n					if(!res){perror(\"realloc of char\"); return 0; }\r\n					*(res+lr-2) = tmp[j];\r\n					*(res+lr-1) = 0;\r\n				}\r\n				lt = 1;\r\n				free(tmp);\r\n				tmp = calloc(lt, sizeof(char));\r\n				if(!tmp){perror(\"calloc of char\"); return 0; }\r\n			}\r\n			res = realloc(res, ++lr);\r\n			if(!res){perror(\"realloc of char\"); return 0; }\r\n			*(res+lr-2) = s[i];\r\n			*(res+lr-1) = 0;\r\n		}\r\n		else\r\n		{\r\n			tmp = realloc(tmp, ++lt);\r\n			if(!tmp){perror(\"realloc of char\"); return 0; }\r\n			*(tmp+lt-2) = s[i];\r\n			*(tmp+lt-1) = 0;\r\n		}\r\n	}\r\n	if(tmp[0])\r\n	{\r\n		varValue = get_value(vars, tmp);\r\n		free(tmp);\r\n		tmp = intToStr(varValue);\r\n		for(j=0; j<strlen(tmp); j++)\r\n		{\r\n			res = realloc(res, ++lr);\r\n			if(!res){perror(\"realloc of char\"); return 0; }\r\n			*(res+lr-2) = tmp[j];\r\n			*(res+lr-1) = 0;\r\n		}\r\n		lt = 1;\r\n		free(tmp);\r\n		tmp = calloc(lt, sizeof(char));\r\n		if(!tmp){perror(\"calloc of char\"); return 0; }\r\n	}\r\n	free(tmp);\r\n	free(s);\r\n	return res;\r\n}\r\n\r\nvoid parser()\r\n{\r\n	int k = 0; // key for string\r\n	int ch = 0;\r\n	int ln = 1, lv = 1;\r\n	int res = 0;\r\n	char *name, *value;\r\n	name = calloc(ln, sizeof(char));\r\n	if(!name){perror(\"calloc of char\"); return; }\r\n	value = calloc(lv, sizeof(char));\r\n	if(!value){perror(\"calloc of char\"); return; }\r\n	while(1)\r\n	{\r\n		ch = getchar();\r\n		// end work of program5\r\n		if(ch == EOF)\r\n			break;\r\n		// end of string\r\n		if(ch == 10)\r\n		{\r\n			if(name[0] == 0)\r\n			{\r\n				printf(\"Empty expression\\n\");\r\n				continue;\r\n			}\r\n			// k == 0 : only expression, not var for save\r\n			if(k == 0)\r\n			{\r\n				if(strcmp(name, \"print\") == 0)\r\n				{\r\n					printVars(vars);\r\n				}\r\n				else\r\n				{\r\n					name = changeVarsToValue(name);\r\n					name = toPol(name);\r\n					res = calcPol(name);\r\n					printf(\"-  %d  -\\n\", res);\r\n				}\r\n			}\r\n			else\r\n			{\r\n				// k == 1 : var with expression\r\n				value = changeVarsToValue(value);\r\n				value = toPol(value);\r\n				res = calcPol(value);\r\n				set_value(vars, name, res);\r\n				printf(\"-  %d  -\\n\", res);\r\n			}\r\n			k = 0; ln = 1; lv = 1;\r\n			free(name);\r\n			name = calloc(ln, sizeof(char));\r\n			if(!name){perror(\"calloc of char\"); return; }\r\n			free(value);\r\n			value = calloc(lv, sizeof(char));\r\n			if(!value){perror(\"calloc of char\"); return; }\r\n		}\r\n		else\r\n		{\r\n			if(ch == \'=\')\r\n			{\r\n				k++;\r\n			}\r\n			else\r\n			{\r\n				if(k == 0)\r\n				{\r\n					name = realloc(name, ++ln);\r\n					if(!name){perror(\"realloc of char\"); return; }\r\n					*(name+ln-2) = ch;\r\n					*(name+ln-1) = 0;\r\n				}\r\n				if(k == 1) \r\n				{\r\n					value = realloc(value, ++lv);\r\n					if(!value){perror(\"realloc of char\"); return; }\r\n					*(value+lv-2) = ch;\r\n					*(value+lv-1) = 0;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	printf(\"%s\\n\", name);\r\n	free(name);\r\n	printf(\"%s\\n\", value);\r\n	free(value);\r\n}\r\n\r\nint main()\r\n{\r\n	parser();\r\n	cleanup(vars);\r\n//	_CrtDumpMemoryLeaks();\r\n	return 0;\r\n}\r\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (84,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"stack.h\"\r\n\r\nvoid push(struct stack **st, void *data)\r\n{\r\n	struct item *tmp;\r\n	tmp = malloc(sizeof(struct item));\r\n	if(!tmp){ perror(\"malloc of item\"); return; }\r\n	//\r\n	if ((*st)->mode == 1)\r\n	{\r\n		int *p = data;\r\n		int tp = *p;\r\n		p = malloc(sizeof(int));\r\n		if(!p){	perror(\"malloc of int\"); return; }\r\n		(*p) = tp;\r\n		tmp->data = p;\r\n	}\r\n	else\r\n	{\r\n		char *p = data;\r\n		char tp = *p;\r\n		p = calloc(2, sizeof(char));\r\n		if(!p){	perror(\"malloc of char\"); return; }\r\n		(*p) = tp;\r\n		*(p+1) = 0;\r\n		tmp->data = p;\r\n	}\r\n	if(empty((*st)))\r\n	{\r\n		tmp->next = NULL;\r\n		(*st)->curr = tmp;\r\n	}\r\n	else\r\n	{\r\n		tmp->next = (*st)->curr;\r\n		(*st)->curr = tmp;\r\n	}\r\n}\r\n\r\nvoid *pop(struct stack **st)\r\n{\r\n	struct item *tmp;\r\n	void *p = NULL;\r\n	if(!empty((*st)))\r\n	{\r\n		p = (*st)->curr->data;\r\n		tmp = (*st)->curr->next;\r\n		free((*st)->curr);\r\n		(*st)->curr = tmp;\r\n	}\r\n	return p;\r\n}\r\n\r\nvoid *top(struct stack *st)\r\n{\r\n	if(!empty(st))\r\n	{\r\n		if(st->mode == 1)\r\n		{\r\n			return st->curr->data;\r\n		}\r\n		else\r\n		{\r\n			char *res = st->curr->data;\r\n			res[1] = 0;\r\n			return res;\r\n		}\r\n	}\r\n	return NULL;\r\n}\r\n\r\nint empty(struct stack *st)\r\n{\r\n	if(st == NULL)\r\n		return 1;\r\n	if(st->curr == NULL)\r\n		return 1;\r\n	return 0;\r\n}\r\n\r\nvoid createStack(struct stack **st, int mode)\r\n{\r\n	(*st) = malloc(sizeof(struct stack));\r\n	if(!(*st)){	perror(\"malloc of stack\"); return; }\r\n	(*st)->mode = mode;\r\n	(*st)->curr = NULL;\r\n}\r\n\r\nstatic void desStack(struct stack **st)\r\n{\r\n	struct item *tmp;\r\n	while(!empty((*st)))\r\n	{\r\n		tmp = (*st)->curr->next;\r\n		free((*st)->curr->data);\r\n		free((*st)->curr);\r\n		(*st)->curr = tmp;\r\n	}\r\n}\r\n\r\nvoid destroyStack(struct stack **st)\r\n{\r\n	if(!empty((*st)))\r\n		desStack(st);\r\n	free((*st));\r\n	(*st) = NULL;\r\n}\r\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (85,'#define _CRT_SECURE_NO_WARNINGS\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include \"vars.h\"\r\n#define N 100\r\n\r\nstatic unsigned int hash(const char *s)\r\n{\r\n	unsigned int res = 0;\r\n	while (*s)\r\n	{\r\n		res = (res*37 + *s) % N;\r\n		s++;\r\n	}\r\n	return res;\r\n}\r\n\r\nvoid set_value(struct varItem **vars, char *name, int value)\r\n{\r\n	struct varItem *p, *q;\r\n	for(q=vars[hash(name)]; q; q=q->next)\r\n		if(strcmp(q->name, name) == 0)\r\n		{\r\n			q->value = value;\r\n			return;\r\n		}\r\n	p = malloc(sizeof(struct varItem));\r\n	if(!p){	perror(\"malloc of varItem\"); return; }\r\n	p->name = calloc(sizeof(name), sizeof(char));\r\n	strcpy((p->name), (name));\r\n	p->value = value;\r\n	p->next = vars[hash(name)];\r\n	vars[hash(name)] = p;\r\n}\r\n\r\nint get_value(struct varItem **vars, char *name)\r\n{\r\n	struct varItem *p;\r\n	for(p=vars[hash(name)]; p; p=p->next)\r\n		if(strcmp(p->name, name) == 0)\r\n			return p->value;\r\n	return 0;\r\n}\r\n\r\nvoid printVars(struct varItem **vars)\r\n{\r\n	int i;\r\n	struct varItem *p;\r\n	printf(\"---Vars---\\n\");\r\n	for(i=0; i<N; i++)\r\n		for(p=vars[i]; p; p=p->next)\r\n			printf(\"%s = %d\\n\", p->name, p->value);\r\n	printf(\"---End---\\n\");\r\n}\r\n\r\nvoid cleanup(struct varItem **vars)\r\n{\r\n	int i;\r\n	struct varItem *p, *q;\r\n	for(i=0; i<N; i++)\r\n		for(p=vars[i]; p; p=vars[i])\r\n		{\r\n			q = vars[i]->next;\r\n			free(p->name);\r\n			free(p);\r\n			vars[i] = q;\r\n		}\r\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (86,'#include \"string.h\"\n#include \"stack.h\"\n#include \"lowlevelcalc.h\"\n#include <stdio.h>\n\n#include \"calculator.h\"\n\n\nstatic void freedbcell(void *addr)\n{\n	freedigit(addr);\n}\n\ncalculator newcalculator()\n{\n	calculator result;\n	result.db = newdatabase(sizeof(digit), 128);\n	result.db.freevalue = &freedbcell;\n	return result;\n}\nvoid freecalculator(calculator *c)\n{\n	cleanupdatabase(&c->db);\n}\n\n\n//static \nstruct calculatestate\n{\n	int state;\n	int position;\n	calculateresult result;\n	string temp;\n	string set;\n	stack operationstack;\n	stack hookposition;\n	expression exp;\n	calculator *cal;\n};\ntypedef struct calculatestate calculatestate;\n\nstatic void docalc(calculatestate *state)\n{\n	state->result.result = getresult(state->exp);\n	state->result.errortext = newstring();\n\n	if(state->set.chars[0] == 0)\n		state->result.errorposition = -1;\n	else\n	{\n		state->result.errorposition = -2;\n		digit d = copydigit(state->result.result);\n		set_value(&state->cal->db, state->set.chars, &d);\n	}\n\n}\n\nstatic void nothing(calculatestate *state)\n{\n	state->result.result = unknowndigit();\n	state->result.errorposition = -3;\n	state->result.errortext = newstring();\n	state->state = -1;\n}\n\nstatic void error(calculatestate *state,int position, char *err)\n{\n	(*state).result.result = unknowndigit();\n	(*state).result.errorposition = position+state->position;\n	(*state).result.errortext = newstring();\n	copystringC(&(*state).result.errortext, err);\n	state->state = -1;\n}\n\nstatic int chartype(char c)\n{\n	if(c == \' \')\n		return 1;\n	if(((c>=\'a\')&&(c<=\'z\')) || ((c>=\'A\')&&(c<=\'Z\')))\n		return 2;\n	else if((c>=\'0\')&&(c<=\'9\'))\n		return 3;\n	else if((c == \'+\')||(c == \'-\'))\n		return 4;\n	else if((c == \'/\')||(c == \'*\'))\n		return 5;\n	else if(c == \'(\')\n		return 6;\n	else if(c == \')\')\n		return 7;\n	else if(c == \'=\')\n		return 8;\n	else if((c == 10)||(c == 0))\n		return 9;\n	else\n		return 0;\n}\n\nstatic void adddigit(calculatestate *state)\n{\n//	printf(\"add: %s\\n\", state->temp.chars);\n	digit operand = newdigit(state->temp.chars);\n	adddigittoexpression(&state->exp, operand);\n}\n\nstatic void addid(calculatestate *state)\n{\n//	printf(\"add: %s\\n\", state->temp.chars);\n\n	int neg = 0;\n	char *c = state->temp.chars;\n	if(c[0] == \'+\')\n		c++;\n	else if(c[0] == \'-\')\n	{\n		neg = 1;\n		c++;\n	}\n\n	if(value_exist(state->cal->db, c))\n	{\n		digit d = copydigit(*(digit*)get_value(state->cal->db, c));\n		if(neg)\n			adddigittoexpression(&state->exp, negative(d));\n		else\n			adddigittoexpression(&state->exp, d);\n	}\n	else\n		error(state, -state->temp.size, \"?????????????????????????? ???? ???Â©??????????????.\");\n	\n}\n\nstatic int operationpriority(char o)\n{\n	switch(o)\n	{\n	case  0 : return -1;\n	case \'(\': return 0;\n	case \'+\': case \'-\': return 1;\n	case \'/\': return 2;\n	case \'*\': return 3;\n	}\n	return -1;\n}\n\nstatic char topchar(calculatestate *state)\n{\n	if(empty(state->operationstack))\n		return 0;\n	return *(char*)top(state->operationstack);\n}\nstatic void addop(calculatestate *state, char q)\n{\n//	printf(\"add: %c\\n\", q);\n	switch(q)\n	{\n	case \'+\': case \'-\': case \'*\': case \'/\':\n		while(operationpriority(topchar(state)) >= operationpriority(q))\n		{\n			addoperationtoexpression(&state->exp, topchar(state));\n			pop(&state->operationstack);\n		}\n		push(&state->operationstack, &q);\n	break;\n	case \'(\': push(&state->operationstack, &q);\n		  push(&state->hookposition, &state->position);\n		  break;\n	case \')\': \n		  up:\n		  if(empty(state->operationstack))\n		  {\n			error(state, 0, \"?Â²???? ?????????????????????? ????????????.\");\n			break;\n		  }\n		  if(*(char*)top(state->operationstack) != \'(\')\n		  {\n			addoperationtoexpression(&state->exp, topchar(state));\n			pop(&state->operationstack);\n		  	goto up;\n		  }\n		  pop(&state->hookposition);\n		  pop(&state->operationstack);\n		  break;\n	}\n\n}\n\ncalculateresult calculate(calculator *c, char *line)\n{\n	calculatestate state;\n	state.state = 0;\n	state.position = 0;\n	state.temp = newstring();\n	state.set = newstring();\n	state.operationstack = newstack(sizeof(char));\n	state.hookposition = newstack(sizeof(int));\n	state.exp = newexpression();\n	state.cal = c;\n	for(; (isNotEndLine(line, state.position))&&(state.state != -1); state.position++)\n	{\n//		printf(\"[%d]\\n\", state.state);\n		char c = line[state.position];\n		switch(state.state)\n		{\n		case 0:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	break;\n			case 2:	state.state = 1;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 3:	state.state = 5;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 4:	state.state = 8;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 5:	error(&state, 0, \"?????????? ?????????????? ???????????? ?????? :(\");\n				break;\n			case 6:	state.state = 7;\n				addop(&state, c);\n				break;\n			case 7:	error(&state, 0, \"?Â²?????????????????? ???????? ???? ???????????? ?? ???????????? ?????????????????? ?????????????????????? ????????????.\");\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ??????.\");\n//				state.state = -1;\n				break;\n			case 9:	nothing(&state);\n				break;\n			}\n			break;\n		case 1:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	state.state = 2;\n				break;\n			case 2:	case 3:\n				addchar(&state.temp, c);\n				break;\n			case 4:	case 5:\n				state.state = 7;\n				addid(&state);\n				addop(&state, c);\n				break;\n			case 6:	state.state = 7;\n				addid(&state);\n				addop(&state, \'*\');\n				addop(&state, c);\n				break;\n			case 7:	state.state = 9;\n				addid(&state);\n				addop(&state, c);\n				break;\n			case 8:	state.state = 7;\n				copystring(&state.set, state.temp);				\n				break;\n			case 9:	addid(&state);\n			}\n			break;\n		case 2:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	break;\n			case 2:	addid(&state);\n				addop(&state, \'*\');\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				state.state = 3;\n				break;\n			case 3:	error(&state, -1, \"?????? ???? ???????? ??????????? ???????????????????\");\n				break;\n			case 4:	case 5:\n				state.state = 7;\n				addid(&state);\n				addop(&state, c);				\n				break;\n			case 6:	state.state = 7;\n				addid(&state);\n				addop(&state, \'*\');\n				addop(&state, c);				\n				break;\n			case 7:	state.state = 9;\n				addid(&state);\n				addop(&state, c);\n				break;\n			case 8:	state.state = 7;\n				copystring(&state.set, state.temp);\n				break;\n			case 9:	break;\n			}\n			break;\n		case 3:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	state.state = 4;\n				addid(&state);\n				break;\n			case 2:	case 3:\n				addchar(&state.temp, c);\n				break;\n			case 4:	case 5:\n				state.state = 7;\n				addid(&state);\n				addop(&state, c);\n				break;\n			case 6:	state.state = 7;\n				addid(&state);\n				addop(&state, \'*\');\n				addop(&state, c);\n				break;\n			case 7:	state.state = 9;\n				addid(&state);\n				addop(&state, c);\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	addid(&state);\n			}\n			break;\n		case 4:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	break;\n			case 2:	state.state = 3;\n				addop(&state, \'*\');\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 3:	error(&state, -1, \"?????? ???? ???????? ??????????? ???????????????????\");\n				break;\n			case 4:	case 5:\n				state.state = 7;\n				addop(&state, c);\n				break;\n			case 6:	state.state = 7;\n				addop(&state, \'*\');\n				addop(&state, c);\n				break;\n			case 7:	state.state = 9;\n				addop(&state, c);\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	break;\n			}\n			break;\n		case 5:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	state.state = 6;\n				adddigit(&state);\n				break;\n			case 2:	state.state = 1;\n				adddigit(&state);\n				addop(&state, \'*\');\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 3:	addchar(&state.temp, c);\n				break;\n			case 4:	case 5:\n				state.state = 7;\n				adddigit(&state);\n				addop(&state, c);\n				break;\n			case 6:	state.state = 7;\n				adddigit(&state);\n				addop(&state, \'*\');\n				addop(&state, c);\n				break;\n			case 7:	state.state = 9;\n				adddigit(&state);\n				addop(&state, c);				\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	adddigit(&state);\n				break;\n			}\n			break;\n		case 6:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	break;\n			case 2:	state.state = 3;\n				addop(&state, \'*\');\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 3:	error(&state, -1, \"?????? ???? ???????? ??????????? ???????????????????\");\n				break;\n			case 4:	case 5:\n				state.state = 7;\n				addop(&state, c);\n				break;\n			case 6:	state.state = 7;\n				addop(&state, \'*\');\n				addop(&state, c);\n				break;\n			case 7:	state.state = 9;\n				addop(&state, c);\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	break;\n			}\n			break;\n		case 7:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	break;\n			case 2:	state.state = 3;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 3:	state.state = 5;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 4:	state.state = 8;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				break;\n			case 5:	error(&state, 0, \"?????? ???????\");\n				break;\n			case 6: addop(&state, c);\n				break;\n			case 7:	error(&state, 0, \"???? ??????-???? ?Â©?????Â©??????????.\");\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	error(&state, 0, \"?Â²?? ???????? ?Â©?????????????????? ?Â©????????????????????, ???? ?????? ??????????????, ?????? ?????? ????????-???? ???? ??????????????.\");\n				break;\n			}\n			break;\n		case 8:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	error(&state, 0, \"?????? ?????? ???????????? ???????? ?Â©???????????\");\n				break;\n			case 2:	state.state = 3;\n				addchar(&state.temp, c);\n				break;\n			case 3:	state.state = 5;\n				addchar(&state.temp, c);				\n				break;\n			case 4:	error(&state, 0, \"?????? ????????????.\");\n				break;\n			case 5:	error(&state, 0, \"?????? ???????\");\n				break;\n			case 6: error(&state, 0, \"?? ??????????????????, ???? ?? ?Â©?????? ???? ???????? ?Â©???????????????? ?????????????? ???Â©???????????? ?? ???????????????????? ?? ??????????????. ?Â°???? ????????????.\");\n				break;\n			case 7:	error(&state, 0, \"???? ??????-???? ?Â©?????Â©??????????.\");\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	error(&state, 0, \"?Â²?? ???????? ?Â©?????????????????? ?Â©????????????????????, ???? ?????? ??????????????, ?????? ?????? ????????-???? ???? ??????????????.\");\n				break;\n			}\n			break;\n		case 9:	switch(chartype(c))\n			{\n			case 0: error(&state, 0, \"?????? ??????? ?? ???????????? ???? ????????.\");\n				break;\n			case 1:	break;\n			case 2:	state.state = 3;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				addop(&state, \'*\');\n				break;\n			case 3:	state.state = 5;\n				clearstring(&state.temp);\n				addchar(&state.temp, c);\n				addop(&state, \'*\');				\n				break;\n			case 4:	state.state = 7;\n				addop(&state, c);				\n				break;\n			case 5:	state.state = 7;\n				clearstring(&state.temp);\n				addop(&state, c);\n				break;\n			case 6:	state.state = 7;\n				addop(&state, \'*\');\n				addop(&state, c);\n				break;\n			case 7:	state.state = 9;\n				addop(&state, c);\n				break;\n			case 8:	error(&state, 0, \"?????????? ???????????? ???????? ???????????? ??????????????????????????.\");\n				break;\n			case 9:	state.state = 7;\n				addop(&state, c);				\n				break;\n			}\n		}\n	}\n		\n	if(state.state != -1)\n	{\n		if(!empty(state.hookposition))\n			error(&state, *(int*)top(state.hookposition)-state.position, \"?Â²???? ?????????????????????? ????????????\");\n		while(!empty(state.operationstack))\n		{\n			addoperationtoexpression(&state.exp, *(char*)top(state.operationstack));\n			pop(&state.operationstack);\n		}\n		docalc(&state);\n	}\n\n	freeexpression(&state.exp);\n	freestring(&state.temp);\n	freestring(&state.set);\n	freestack(&state.operationstack);//???????????\n	freestack(&state.hookposition);\n	return state.result;\n}\n\nvoid freecalculateresult(calculateresult *result)\n{\n	freestring(&(result->errortext));\n	freedigit(&result->result);\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (87,'#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#include \"digit.h\"\n#include \"string.h\"\n\ndigit newdigit(char* value)\n{\n	int Loop = 0;\n	int neg = 0;\n	digit result;\n\n	result._value = 0;\n	result.unknown = 0;\n	if(value[0] == \'-\')\n	{\n		neg = 1;\n		value++;\n	}\n	while(value[Loop])\n	{\n		result._value = result._value*10 + value[Loop] - \'0\';\n		Loop++;\n	}\n	if(neg)\n		result._value *= -1;\n\n	result.tomato = newstring();\n	copystringC(&result.tomato, \"?Â·??????????\");\n\n	return result;\n}\n\ndigit unknowndigit()\n{\n	digit result;\n	result._value = 0;\n	result.unknown = 1;\n	result.tomato = newstring();\n	copystringC(&result.tomato, \"?Â·??????????\");\n	return result;\n}\n\n\ndigit copydigit(digit d)\n{\n	string newtomato = newstring();\n	copystring(&newtomato, d.tomato);\n	d.tomato = newtomato;\n	return d;\n}\n\ndigit add(digit a, digit b)\n{\n	digit result;\n	result._value = a._value+b._value;\n	result.unknown = a.unknown||b.unknown;\n	result.tomato = newstring();\n	copystringC(&result.tomato, \"?Â·??????????\");\n	return result;\n}\n\ndigit substract(digit a, digit b)\n{\n	digit result;\n	result._value = a._value-b._value;\n	result.unknown = a.unknown||b.unknown;\n	result.tomato = newstring();\n	copystringC(&result.tomato, \"?Â·??????????\");\n	return result;\n}\n\ndigit multiple(digit a, digit b)\n{\n	digit result;\n	result._value = a._value*b._value;\n	result.unknown = a.unknown||b.unknown;\n	result.tomato = newstring();\n	copystringC(&result.tomato, \"?Â·??????????\");\n	return result;\n}\n\n\ndigit divide(digit a, digit b)\n{\n	digit result;\n	if(b._value != 0)\n		result._value = a._value/b._value;\n	result.unknown = a.unknown||b.unknown||(b._value == 0);\n	result.tomato = newstring();\n	copystringC(&result.tomato, \"?Â·??????????\");\n	return result;\n}\n\ndigit negative(digit a)\n{\n	a._value = -a._value;\n	return a;\n}\n\nstring digittostring(digit a)\n{\n	string result = newstring();\n	if(a.unknown)\n		copystringC(&result, \"NaN\");\n	else\n	{\n		char r[25];\n		int pos = 0;\n		long long int q = a._value;\n		long long int k;\n		if(q<0)\n		{\n			q *= -1;\n			r[pos++] = \'-\';\n		}else if(q == 0)\n		{\n			addchar(&result, \'0\');\n			return result;\n		}\n		k = q;\n		while(k>0)\n		{\n			pos++;\n			k /= 10;\n		}\n		r[pos--] = 0;\n		k = q;\n		while(k>0)\n		{\n			r[pos--] = k%10+\'0\';\n			k /= 10;\n		}\n		copystringC(&result, r);	\n	}\n	return result;\n}\n\nvoid freedigit(digit* d)\n{\n	freestring(&d->tomato);\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (88,'#include \"hash.h\"\nint hash(char* from, int hashsize)\n{\n        int i = 0;\n        int result = 0;\n        char c;\n        while((c = from[i++]) != 0)\n        {\n                result = (result*17 + c + 128) % hashsize;\n        }\n	return result % hashsize;\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (89,'#include \"stdlib.h\"\n#include \"stdio.h\"//????????????\n#include \"stack.h\"\n#include \"lowlevelcalc.h\"\n\nexpression newexpression()\n{\n	expression result;\n	result.size = 0;\n	result.cell = NULL;\n	return result;\n}\nvoid adddigittoexpression(expression *e, digit d)\n{\n//	printf(\"[%d]\", d._value);\n	e->size++;\n	e->cell = realloc(e->cell ,e->size*sizeof(expressioncell));\n	e->cell[e->size-1].type = -1;\n	e->cell[e->size-1].value = d;\n}\nvoid addoperationtoexpression(expression *e, char operation)\n{\n//	printf(\"[%c]\", operation);\n	e->size++;\n	e->cell = realloc(e->cell ,e->size*sizeof(expressioncell));\n	switch(operation)\n	{\n	case \'+\': e->cell[e->size-1].type = 0;\n		  break;\n	case \'-\': e->cell[e->size-1].type = 1;\n		  break;\n	case \'*\': e->cell[e->size-1].type = 2;\n		  break;\n	case \'/\': e->cell[e->size-1].type = 3;\n	}\n	e->cell[e->size-1].value = unknowndigit();\n}\nvoid freeexpression(expression *e)\n{\n	int Loop;\n	for(Loop = 0; Loop < e->size; Loop++)\n		freedigit(&(e->cell[Loop].value));\n	free(e->cell);\n}\n\ndigit getresult(expression e)\n{\n	digit result;\n	stack st = newstack(sizeof(digit));\n	int Loop = 0;\n	digit a, b, c;\n\n\n/*\n	for(Loop = 0; Loop < e.size; Loop++)\n		if(e.cell[Loop].type == -1)\n			printf(\"%d \", e.cell[Loop].value._value);\n		else\n			switch(e.cell[Loop].type)\n			{\n			case 0: printf(\"+ \"); break;\n			case 1: printf(\"- \"); break;\n			case 2: printf(\"* \"); break;\n			case 3: printf(\"/ \"); break;\n			}\n	printf(\"\\n\");\n*/\n\n	for(Loop = 0; Loop < e.size; Loop++)\n	{\n		if(e.cell[Loop].type == -1)\n		{\n			digit d = copydigit(e.cell[Loop].value);\n			push(&st, &d);\n		}\n		else\n		{\n			b = *(digit*)(top(st));pop(&st);\n			a = *(digit*)(top(st));pop(&st);\n			switch(e.cell[Loop].type)\n			{\n			case 0: c = add(a, b); break;\n			case 1: c = substract(a, b); break;\n			case 2: c = multiple(a, b); break;\n			case 3: c = divide(a, b); break;\n			}\n			freedigit(&a);\n			freedigit(&b);\n			push(&st, &c);\n		}\n	}\n	result = *(digit*)(top(st));pop(&st);\n//	printf(\"epmty(st) == %d\\n\", empty(st));\n	freestack(&st);\n	return result;\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (90,'#include <stdio.h>\n#include <stdlib.h>\n\n#include \"string.h\"\n\n#include \"calculator.h\"\n\nvoid calc(calculator *c, char line[])\n{\n	calculateresult result = calculate(c, line);\n	if(result.errorposition == -1)\n	{\n		string resultstring = digittostring(result.result);\n		printf(\"%s\\n\", resultstring.chars);\n		freestring(&resultstring);\n	}\n	else if(result.errorposition >= 0)\n		showerror(result.errortext.chars, line, result.errorposition);\n	freecalculateresult(&result);\n}\n\nint main(int argc, char *argv[])\n{\n	calculator clc = newcalculator();\n	if(argc == 1)\n	{\n		int done = 0;\n		string line = newstring();\n		if(!readline(&line))\n		{\n			printf(\"???? ???????? ???? ???????????? ???????????? ?Â©?????????????????\\n\");			\n			done = 1;\n		}\n		while(!done)\n		{\n			calc(&clc, line.chars);\n			if(!readline(&line))\n				done = 1;\n		}\n		freestring(&line);\n	}\n	else\n	{\n		int Loop;\n		for(Loop = 1; Loop < argc; Loop++)\n			calc(&clc, argv[Loop]);\n	}\n	freecalculator(&clc);\n	return 0;\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (91,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"stack.h\"\n\nstack newstack(int size)\n{\n	stack result;\n	result.head = NULL;\n	result.size = size;\n	return result;\n}\n\nvoid push(stack *st, void* data)\n{\n	stackelement* element = malloc(sizeof(stackelement));\n	element->data = malloc(st->size);\n	memcpy(element->data, data, st->size);\n	element->next = st->head;\n	st->head = element;\n}\n\nvoid *top(stack st)\n{\n	if(st.head == NULL)\n	{\n		fprintf(stderr, \"top:?Â²?? ???????? ????????????.\\n\");\n		return NULL;\n	}\n	else\n		return st.head->data;\n}\n\nvoid pop(stack *st)\n{\n	if(st->head == NULL)\n		fprintf(stderr, \"pop:?Â²?? ???????? ????????????.\\n\");\n	else\n	{\n		stackelement* elem = st->head;\n		st->head = elem->next;\n		free(elem->data);\n		free(elem);\n	}\n}\nint empty(stack st)\n{\n	return st.head == NULL;\n}\nvoid freestack(stack *st)\n{\n	stackelement* elem;\n	while(st->head != NULL)\n	{\n		free(st->head->data);\n		elem = st->head;\n		st->head = st->head->next;\n		free(elem);\n	}\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (92,'#include <stdio.h>\r\n#include <stdlib.h>\r\n//#include <string.h>\r\n#include \"string.h\"\r\n\r\nint readline(string* line)\r\n{\r\n	int c;\r\n	clearstring(line);\r\n	printf(\"> \");\r\n	while(1)\r\n	{\r\n		c = getchar();\r\n		if((c == 0)||(c == 10)||(c == 13))\r\n		break;\r\n#ifdef	_WIN32\r\n		if(c == 4)\r\n#else\r\n		if(c == EOF)\r\n#endif\r\n		{\r\n			printf(\"\\n\");\r\n			return 0;\r\n		}\r\n		addchar(line, c);\r\n	}\r\n	return 1;\r\n}\r\n\r\nvoid showerror(char *errortext, char *list, int listposition)\r\n{\r\n	int Loop;\r\n	if(list[0])\r\n	{\r\n		fprintf(stderr, \"%s\\n\", list);\r\n		if(listposition >= 0)\r\n		{\r\n			for(Loop = 0; Loop<listposition; Loop++)\r\n				fprintf(stderr, \" \");\r\n			fprintf(stderr, \"^\\n\");\r\n		}\r\n	}\r\n	if(errortext[0])\r\n		fprintf(stderr, \"%s\\n\", errortext);\r\n}\r\n\r\nvoid clearstring(string *s)\r\n{\r\n	s->size = 0;\r\n	s->chars[0] = 0;\r\n}\r\n\r\nvoid addchar(string* s, char c)\r\n{\r\n	if(s->memory <= s->size+1)\r\n	{\r\n		s->memory += 5;\r\n		s->chars = realloc(s->chars ,s->memory);\r\n		if(s->chars == NULL)\r\n		{\r\n			showerror(\"?Â ???Â©?? ?Â©??????????, ??????????!11\", \"\", -1);\r\n			abort();\r\n		}\r\n	}\r\n	s->chars[s->size++] = c;\r\n	s->chars[s->size] = 0;\r\n}\r\n\r\nstring newstring(){\r\n	string result;\r\n	result.size = 0;\r\n	result.memory = 5;	\r\n	result.chars = malloc(result.memory);	\r\n	result.chars[0] = 0;\r\n	return result;\r\n}\r\n\r\nstatic void strcpy2(char *to, char* from)\r\n{\r\n	while(*to++ = *from++);\r\n}\r\n\r\nvoid copystring(string *a, string b)\r\n{\r\n	if(a->memory < b.size+1)\r\n	{\r\n		a->memory = b.size+1;\r\n		a->chars = realloc(a->chars, a->memory);\r\n		if(a->chars == NULL)\r\n		{\r\n			showerror(\"?Â ???Â©?? ?Â©??????????, ??????????!11\", \"\", -1);\r\n			abort();\r\n		}\r\n	}\r\n	a->size = b.size;\r\n	strcpy2(a->chars, b.chars);\r\n}\r\n\r\nvoid copystringC(string *a, char* b)\r\n{\r\n	int len = 0;\r\n	while(b[len++]);\r\n	if(a->memory < len)\r\n	{\r\n		a->memory = len;\r\n		a->chars = realloc(a->chars, a->memory);\r\n		if(a->chars == NULL)\r\n		{\r\n			showerror(\"?Â ???Â©?? ?Â©??????????, ??????????!11\", \"\", -1);\r\n			abort();\r\n		}\r\n	}\r\n	a->size = len-1;\r\n	strcpy2(a->chars, b);\r\n}\r\n\r\nvoid freestring(string *s)\r\n{\r\n	s->memory = 0;\r\n	s->size = -1;\r\n	free(s->chars);\r\n}\r\n\r\nint isNotEndLine(char *Line, int position)\r\n{\r\n	if(position == 0)\r\n		return 1;\r\n	return Line[position-1];\r\n}\r\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (93,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"vars.h\"\n#include \"hash.h\"\n//#include \"digit.h\"\n\nstatic void checkerr(void *a)\n{\n	if(a == NULL)\n	{\n		fprintf(stderr, \"???????? ???????? ?? ????????????\\n\");\n		abort();\n	}\n}\n\ndatabase newdatabase(int size, int hashsize)\n{\n	int Loop;\n\n	database db;\n	db.cellsize = malloc(sizeof(int)*hashsize);\n	checkerr(db.cellsize);\n	db.names = malloc(sizeof(char*)*hashsize);\n	checkerr(db.names);\n	db.values = malloc(sizeof(void*)*hashsize);\n	checkerr(db.values);\n\n	db.hashsize = hashsize;\n	db.size = size;\n\n	//TODO: ?????????????? ?????? ?????????????????????? ????????????????\n	for(Loop = 0; Loop < hashsize; Loop++)\n	{\n		db.cellsize[Loop] = 0;\n		db.names[Loop] = NULL;\n		db.values[Loop] = NULL;\n	}\n	return db;\n}\n\n\n\nvoid set_value(database* db, char *name, void* value)\n{\n	int Hash = hash(name, db->hashsize);\n	int Loop;\n	for(Loop = 0; Loop < db->cellsize[Hash]; Loop++)\n	{\n		if(strcmp(db->names[Hash][Loop], name) == 0)\n		{\n			db->freevalue((void*)((long int)db->values[Hash]+(long int)Loop*db->size));\n			memcpy((void*)((long int)db->values[Hash]+(long int)Loop*db->size), value, db->size);\n			return;\n		}\n	}\n	db->cellsize[Hash]++;\n\n	db->names[Hash] = realloc(db->names[Hash], sizeof(char*)*db->cellsize[Hash]);\n//	checkerr(db->names[Hash]);\n\n	db->names[Hash][db->cellsize[Hash]-1] = malloc((strlen(name)+1)*sizeof(char));\n//	checkerr(db->names[Hash][db->cellsize[Hash]-1]);\n	memcpy(db->names[Hash][db->cellsize[Hash]-1], name, (strlen(name)+1)*sizeof(char));\n\n	db->values[Hash] = realloc(db->values[Hash], db->size*db->cellsize[Hash]);\n//	checkerr((void*)((long int)db->values[Hash]+(long int)(db->cellsize[Hash]-1)*db->size));\n	\n	memcpy((void*)((long int)db->values[Hash]+(long int)(db->cellsize[Hash]-1)*db->size), value, db->size);\n}\n\nvoid *get_value(database db, char *name)\n{\n	int Hash = hash(name, db.hashsize);\n	int Loop;\n		for(Loop = 0; Loop < db.cellsize[Hash]; Loop++)\n			if(strcmp(db.names[Hash][Loop], name) == 0)\n						return (void*)((long int)db.values[Hash]+(long int)Loop*db.size);\n	return NULL;\n}\n\nint value_exist(database db, char *name)\n{\n	int Hash = hash(name, db.hashsize);\n	int Loop;\n        for(Loop = 0; Loop < db.cellsize[Hash]; Loop++)\n                if(strcmp(db.names[Hash][Loop], name) == 0)\n                        return 1;\n	return 0;\n}\n\nvoid cleanupdatabase(database *db)\n{\n	int Loop1, Loop2;\n	for(Loop1 = 0; Loop1 < db->hashsize; Loop1++)\n	{\n		for(Loop2 = 0; Loop2 < db->cellsize[Loop1]; Loop2++)\n		{\n			free(db->names[Loop1][Loop2]);\n			db->freevalue((void*)((long int)db->values[Loop1]+(long int)(Loop2)*db->size));\n		}\n		free(db->names[Loop1]);\n		free(db->values[Loop1]);\n	}\n	free(db->names);\n	free(db->values);\n	free(db->cellsize);\n}\n\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (94,'#include<stdio.h>\n#include<math.h>\nint main()\n{\n#define N 5 \n	int a, l, r, n, i;\n	int A[N]={1, 3, 5, 7, 9};\n	l=0;\n	r=(N-1);\n	n=(l+r)/2;\n	printf(\"??????? ?\\n\");\n	scanf(\"%d\", &a);\n	if((a>A[r])||(a<A[l]))\n	{\n		printf(\"??????? ?? ??????????? ???????\\n\");\n		return 0;\n	}\n	for(i=0;i<N;i++)\n		{\n			if(a==A[n])\n			{\n				printf(\"??????? ??????????? ???????\\n\");\n				return 0;\n			}\n			else\n			{\n				if(a<A[n])\n				{\n					r=n-1;\n					n=(r+l)/2;\n				}\n				else\n				{\n					l=n+1;\n					n=(r+l)/2;\n				}\n				if(l>r)\n				{\n					printf(\"??????? ?? ??????????? ???????\\n\");\n					return 0;\n				}\n			}	\n		}\n	\n	\n}	\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (95,'#include <stdio.h>\n#include <string.h>\n#define k 100\nint main()\n{\n	char s[k];\n	fgets(s, k, stdin);\n	s[strlen(s)-1] = 0;\n	int m = strlen(s)-1, l=0, n=m;\n	while((l<=m)||(n>=0))\n		{\n			if((s[l]==\' \')||(s[l]==\',\')||(s[l]==\'.\'))\n				do\n					l++;\n				while((s[l]==\' \')||(s[l]==\',\')||(s[l]==\'.\'));\n			if((s[n]==\' \')||(s[n]==\',\')||(s[n]==\'.\'))\n				do\n					n--;\n				while((s[n]==\' \')||(s[n]==\'.\')||(s[n]==\',\'));\n			if(s[l]==s[n])\n				{\n				n--;\n				l++;\n				}\n			else\n				{\n					printf(\"?????? ?? ?????????\\n\");\n	 				return (0);\n				}\n		}\n	printf(\"?????? - ?????????\\n\");\n	return(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (96,'#include<stdio.h>\n\nint main ()\n{\n    for ( ; ; ) \n    {\n	char s[10];\n	int T;\n	int T0;\n\n	printf(\"?????: \");\n	scanf(\"%s\", s);\n	printf(\"???????: \");\n	scanf(\"%d\", &T);\n	T0 = T;\n\n	int i, Otv;\n	for(i=0;s[i]!=0;i++)\n	{\n		;\n	}\n	int N=i;\n	for (i=0;s[i]!=0;i++)\n	{\n		if (s[i]>=\'A\')\n		{\n			s[i]=s[i]-(\'A\'-\'9\')+1;\n		}\n	}\n	Otv=(s[N-1])-\'0\';\n	for (i=N-2;i>=0;i--)\n	{\n		Otv = Otv + (s[i]-\'0\')*T;\n		T=T*T0;\n	}\n	printf (\"%d\\n\", N);\n	printf (\"ravno  %d\\n\", Otv);\n   }\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (97,'#include <math.h>\n#include <stdio.h>\nfloat f(float q)\n{\n	return(sin(q));\n}\nint main()\n{\n	float a,b,e,s,x,c,d;\n	a=0;\n	b=3.14;\n	e=0.001;\n	s=0;\n	for (x=a;x<b;x=x+e)\n	{\n			c=f(x);\n			d=f(x+e);\n			s=s+((c+d)/2)*e;\n	}\n	printf(\"%f\\n\",s);\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (98,'#include <stdio.h>\n#define N 255\n\nint main ()\n{\n	int i,b,c,a=0;\n	char st[N];\n	printf(\"????????? ??????? ?????????: \");\n	scanf(\"%d\",&b);\n	printf(\"?????: \");\n	scanf(\"%s\",&st);\n	for (i=0;st[i];i++)\n		;\n	c=b;\n	b=1;\n	for (;i;i--)\n	{\n		if (((c<=10)&&((st[i-1]-\'0\')>c))||((c>=11)&&((st[i-1]-\'A\')>c)))\n		{\n			printf(\"?????\\n\");\n			return 0;\n		}\n		if ((st[i-1]>=\'0\')&&(st[i-1]<=\'9\'))\n			a+=((st[i-1]-\'0\')*b);\n		if((st[i-1]>=\'A\')&&(st[i-1]<=\'Z\'))\n			a+=((10+st[i-1]-\'A\')*b);\n		b=b*c;\n\n	}\n	printf (\"????? ? dec: %d\\n\",a);\n	return 0;\n}\n	\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (99,'#include <stdio.h>\n#define N 3\nint main()\n{\n	int A[N][N]={0};\n	int B[N][N]={0};\n	int C[N][N]={0};\n	int i=0;\n	int j=0;\n	int k=0;\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++)\n			scanf(\"%d\",&A[i][j]);\n	\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++)\n			scanf(\"%d\",&B[i][j]);\n		\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++)\n			for (k=0;k<N;k++)\n				C[i][j]+=A[i][k]*B[k][j];\n 	printf(\"\\n\");\n	\n	for (i=0;i<N;i++)\n	{\n		for (j=0;j<N;j++)\n			printf(\"%d \",C[i][j]);\n		printf(\"\\n\");\n	} \n}\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (100,'#include <stdio.h>\nint main()\n{\nint A[5]={0};\nint c;\nint S=2;\nint a=0;\nint b=4;\nint i=0;\n\n     	for (i=0;i<5;i++)\n	scanf(\"%d\",&A[i]);\n 	scanf(\"%d\",&c);\n	\n	do\n	 {\n	S=(b+a)/2;\n	\n	if (A[S]>=c)\n	{b=S;}\n	else {a=S;}\n}\n	while((b-a)!=1);\n	\n	if ((A[b]!=c)&&(A[a]!=c))\n	{printf(\"???\\n\");} \n	else printf(\"????\\n\");\n}\n\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (101,'#include <stdio.h>\n\n#define N 3\n\nint A[N][N], B[N][N], C[N][N];\n\nint main()\n{\n	int i, j, k, t, f = 0;\n	for (i = 0; i < 3; i++)\n	{\n		for (j = 0; j < 3; j++)\n		{\n		scanf(\"%d\", &A[i][j]);\n		}\n	}\n	for (i = 0; i < 3; i++)\n	{\n		for (j = 0; j < 3; j++)\n		{\n		scanf(\"%d\", &B[i][j]);\n		}\n	}\n	for (i = 0; i < 3; i++)\n	{ \n		for (j = 0; j < 3; j++)\n		{ \n			for (k = 0; k < 3; k++)\n			{\n				t = A[i][k]*B[k][j];\n				f+=t;\n			}\n			C[i][j] = f;\n			f = 0;\n		}\n	}\n	for (i = 0; i < 3; i++)\n	{\n		for (j = 0; j < 3; j++)\n		{\n		printf(\"%d \" ,C[i][j]);\n		}\n	printf(\"\\n\");\n	}\n}\n	\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (102,'#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n#include \"mystring.h\"\n#include \"vars.h\"\n\nint strtoint(_string *s) {\n	int val = 0, i, j = 1;\n\n	for (i = s->sz - 1; i >= 0; i--) {\n		val += (s->q[i] - \'0\') * j;\n		j *= 10;\n	}\n	return val;\n}\n\nint priority(char symbol) {\n	if (symbol == \'(\' || symbol == 0) return 0;\n	else if (symbol == \'+\' || symbol == \'-\') return 1;\n	return 2;\n}\n\nint push_char(stack *st, char val) {\n	char *symbol = calloc(1, sizeof(char));\n	if (symbol == NULL)\n		return 1;\n	*symbol = val;\n	if (push(st, symbol) == 1)\n		return 1;\n	return 0;\n}\n\nint push_int(stack *st, int val) {\n	int *number = calloc(1, sizeof(int));\n	if (number == NULL)\n		return 1;\n	*number = val;\n	if (push(st, number) == 1)\n		return 1;\n	return 0;\n}\n\n// 0	all good\n// 1	division by zero\n// 2	fffuuuuuuu\nint pop_n_calc(stack *st, stack *du) {\n	char operation = 0;\n	int a = 0, b = 0;\n\n	operation = *(char *)top(st);\n	pop(st);\n\n	a = *(int *)top(du);\n	pop(du);\n	b = *(int *)top(du);\n	pop(du);\n\n	switch (operation) {\n		case \'+\':\n			if (push_int(du, a + b) == 1)\n				return 2;\n			break;\n		case \'-\':\n			if (push_int(du, b - a) == 1)\n				return 2;\n			break;\n		case \'*\':\n			if (push_int(du, a * b) == 1)\n				return 2;\n			break;\n		case \'/\':\n			if (a == 0) return 1;\n			else if (push_int(du, b / a) == 1)\n				return 2;\n	}\n\n	return 0;\n}\n\nint false_brackets_order(_string *str) {\n	int i = 0, j, q = 0;\n\n	for (j = 0; j < str->sz && i >= 0; j++)\n		if (str->q[j] == \'(\') {\n			q++;\n			i++;\n		}\n		else if (str->q[j] == \'=\')\n			if (q > 0) return q;\n			else\n				;\n		else if (str->q[j] == \')\')\n			i--;\n\n	return i;\n}\n\nvoid parse(_string *parse_string, omg hash) {\n	stack st = NULL, du = NULL;\n	int state = 0, i = 0, put_in_var = 0, sgn = 0;\n	_string id = {0, 0, 255, NULL}, var = {0, 0, 255, NULL};\n	char *str = parse_string->q;\n\n	if (str == NULL || false_brackets_order(parse_string)) {\n		return;\n	}\n\n	while (i <= parse_string->sz) {\n		switch (state) {\n			case 0:\n				if ((str[i] >= \'0\' && str[i] <= \'9\') || str[i] == \'+\' || str[i] == \'-\' || (str[i] >= \'a\' && str[i] <= \'z\')) {\n					if (str[i] == \'-\') sgn = -1;\n					else {\n						sgn = 1;\n						if (str[i] != \'+\')\n							if (add_symbol(&var, str[i]) == 1) {\n								destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n								return;\n							}\n					}\n					state = 1;\n				}\n				else\n					if (str[i] == \'(\' && push_char(&st, str[i]) == 0)\n						;\n					else {\n						destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n						return;\n					}\n\n					break;\n			case 1:\n				if ((str[i] >= \'0\' && str[i] <= \'9\') || (str[i] >= \'a\' && str[i] <= \'z\'))\n					if (add_symbol(&var, str[i]) == 1) {\n						destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n						return;\n					}\n					else\n						;\n				else {\n					if (var.q != NULL) {\n						int number = 0;\n						if (var.q[0] >= \'0\' && var.q[0] <= \'9\') number = sgn * strtoint(&var);\n						else number = sgn * get_value(hash, &var);\n						if (push_int(&du, number) == 1) {\n							destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n							return;\n						}\n					}\n\n					if ((str[i] == \'+\' || str[i] == \'-\' || str[i] == \'*\' || str[i] == \'/\' || str[i] == 0) && (str[i - 1] != \'-\' && str[i - 1] != \'+\')) {\n						int prior = priority(str[i]);\n\n						while (!empty(&st) && priority(*(int *)top(&st)) >= prior)\n							if (pop_n_calc(&st, &du) != 0) {\n								destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n								return;\n							}\n						clrstr(&var);\n						if (push_char(&st, str[i]) == 1) {\n							destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n							return;\n						}\n						state = 0;\n					}\n					else if (str[i] == \')\') {\n						while (!empty(&st) && *(char *)top(&st) != \'(\')\n							if (pop_n_calc(&st, &du) != 0) {\n								destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n								return;\n							}\n						clrstr(&var);\n						pop(&st);\n					}\n					else if (str[i] == \'=\') {\n						put_in_var = 1;\n						_strcpy(&var, &id);\n						clrstr(&var);\n						state = 0;\n					}\n					else {\n						destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n						return;\n					}\n				}\n		}\n		i++;\n	}\n\n	printf(\"%d\\n\", *(int *)top(&du));\n	if (put_in_var) set_value(hash, &id, *(int *)top(&du));\n	destroy(&st); destroy(&du); clrstr(&var); clrstr(&id);\n}\n\nint main() {\n	_string foo = {0, 0, 255, NULL};\n	omg hash = {0};\n\n	while (1) {\n		char sym = getchar();\n		if (sym == EOF) {\n			cleanup(hash);\n			return 0;\n		}\n		else if (sym == \'\\n\') {\n			parse(&foo, hash);\n			clrstr(&foo);\n			printf(\"\\n\");\n		}\n		else if (add_symbol(&foo, sym) == 1) {\n			cleanup(hash);\n			clrstr(&foo);\n			return 42;\n		}\n	}\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (103,'#include <stdlib.h>\n#include <stdio.h>\n\nstruct str {\n	int sz, memsz, dl;\n	char *q;\n};\n\ntypedef struct str _string;\n\n// 0	all good\n// 1	failed to reallocate memory\nint _realloc(_string *old) {\n	char *new = realloc(old->q, (old->memsz += old->dl));\n\n	if (new == NULL) return 1;\n	old->q = new;\n	return 0;\n}\n\n// for the great justice strings ends by 0\nint add_symbol(_string *s, char symbol) {\n	if (s->memsz < s->sz + 1)\n		if (_realloc(s) == 1) return 1;\n\n	s->sz++;\n	s->q[s->sz - 1] = symbol;\n	s->q[s->sz] = 0;\n	return 0;\n}\n\nvoid clrstr(_string *str) {\n	if (str->q != NULL)\n		free(str->q);\n	str->q = NULL;\n	str->sz = str->memsz = 0;\n}\n\n// 0	strings are equal\n// 1	first greater\n// -1	second is greater\n// 42	one or both arguments is not set\nint _strcmp(_string *a, _string *b) {\n	char *r = NULL, *p = NULL;\n\n	if (!a || !b)\n		return 42;\n	else {\n		r = a->q;\n		p = b->q;\n\n		while (*r && *p && *r == *p) {\n			r++;\n			p++;\n		}\n	}\n	return (*r - *p) % 2;\n}\n\nvoid _strcpy(_string *a, _string *b) {\n	int i;\n	if (a != NULL && b != NULL)\n		for (i = 0; i <= a->sz; i++)\n			if (add_symbol(b, a->q[i]) == 1) return;\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (104,'#include <stdlib.h>\n\nstruct item {\n	void *data;\n	struct item *next;\n};\n\ntypedef struct item *stack;\n\nint push(stack *st, void *data) {\n	stack q = malloc(sizeof(struct item));\n	if (q == NULL)\n		return 1;\n\n	q->data = data;\n	q->next = *st;\n	*st = q;\n	return 0;\n}\n\nint empty(stack *st) {\n	return *st == NULL;\n}\n\nvoid pop(stack *st) {\n	if (!empty(st)) {\n		stack q = (*st)->next;\n		free((*st)->data);\n		free(*st);\n		*st = q;\n	}\n}\n\nvoid *top(stack *st) {\n	if (!empty(st)) return (*st)->data;\n	return NULL;\n}\n\nvoid destroy(stack *st) {\n	while (!empty(st)) pop(st);\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (105,'#include <stdlib.h>\n#include <stdio.h>\n#include \"mystring.h\"\n\nstruct simple_item {\n	_string name;\n	int value;\n	struct simple_item *next;\n};\n\ntypedef struct simple_item *omg[113];\n\nint mhf(_string *name) {\n	return 0;\n}\n\nint set_value(omg hash, _string *name, int value) {\n	int key = mhf(name);\n	struct simple_item *r = hash[key];\n\n	while (r != NULL) {\n		if (_strcmp(&(r->name), name) == 0) break;\n		r = r->next;\n	} \n	if (r != NULL) r->value = value;\n	else {\n		struct simple_item *new = malloc(sizeof(struct simple_item));\n		if (new == NULL)\n			return 1;\n		new->value = value;\n		new->name.q = NULL; new->name.sz = new->name.memsz = 0; new->name.dl = 255;\n		_strcpy(name, &(new->name));\n		new->next = hash[key];\n		hash[key] = new;\n	}\n	return 0;\n}\n\nint get_value(omg hash, _string *name) {\n	int key = mhf(name);\n	struct simple_item *r = hash[key];\n\n	while (r != NULL) {\n		if (_strcmp(&(r->name), name) == 0) break;\n		r = r->next;\n	}\n	if (r != NULL) return r->value;\n	else return 0;\n}\n\nvoid cleanup(omg hash) {\n	int i;\n	for (i = 0; i < 113; i++) {\n		struct simple_item *r = hash[i];\n		while (r != NULL) {\n			struct simple_item *p = r;\n			r = r->next;\n			clrstr(&(p->name));\n			free(p);\n		}\n	}\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (106,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n//#include<crtdbg.h>\n\n#include\"vars.h\"\n#include\"stack.h\"\n#include\"main.h\"\n\nint main()\n{\n	int state = 0;\n	int a = 0;\n	char c;\n	while ((c = getchar()) != EOF)\n	{\n		state = state_function(c);\n		int_stack = creat();\n		char_stack = creat();\n		if (state == cipher || state == bracket || state == sign)\n		{\n			a = connective_c(c,0);\n/*#ifdef WIN32\n			if (a != -858993460)\n				printf(\"%d\\n\",a);\n#else\n			if (a != -1073742600)\n				printf(\"%d\\n\",a);\n#endif*/\n			if (state_zero != d_b_z)\n				printf(\"%d\\n\",a);\n			else \n				state_zero = 0;\n			makenull(int_stack);\n			makenull(char_stack);\n/*			int_stack = creat();\n			char_stack = creat();*/\n			continue;\n		}\n		if (state == letter)\n		{\n			check_enter(c);\n			makenull(int_stack);\n			makenull(char_stack);\n			continue;\n		}\n	}\n//	printf(\"1111\\n\");\n	cleanup();\n//	printf(\"444\\n\");\n/*	makenull(int_stack);\n	printf(\"2222\\n\");\n	makenull(char_stack);*/\n//	printf(\"3333\\n\");\n//	_CrtDumpMemoryLeaks();\n	return 0;\n}\n\nint state_function(char c)\n{\n	if (\'0\' <= c && c <= \'9\')\n		return cipher;\n	if (\'a\' <= c && c <= \'z\')\n		return letter;\n	if (c == \'(\')\n		return bracket;\n	if (c == \'+\' || c == \'-\')\n		return sign;\n}\n\nint connective_c(char c, int state_1)\n{\n	int state_cipher = 0;\n	int a = 0, b = 0, i = 0;\n	char s[10000] = {0};\n	do\n	{\n		if (c == \' \')\n			continue;\n		if (\'0\' <= c && c <= \'9\') \n		{\n			state_1 = 1;\n			if (state_cipher == 0)\n			{\n				state_cipher++;\n				a = c - \'0\';\n				push(int_stack, &a);\n				continue;\n			}\n			if (state_cipher > 0)\n			{\n				if (*(int*)top(int_stack) >= 0)\n					a = *(int*)top(int_stack) * 10 + (c - \'0\');\n				else\n					a = *(int*)top(int_stack) * 10 - (c - \'0\');\n				pop(int_stack);\n				push(int_stack, &a);\n				continue;\n			}\n		}\n		state_cipher = 0;\n		if (\'a\' <= c && c <= \'z\')\n		{\n			state_1 = 1;\n			i = 0;\n			while((\'a\' <=c && c <= \'z\') || c == \'_\' || (\'0\' <= c && c <= \'9\'))\n			{\n				s[i] = c;\n				i++;\n				c = getchar();\n			}\n			s[i] = \'\\0\';\n			a = get_value(s);\n			push(int_stack, &a);\n		}\n		if (c == \'(\')\n		{\n			state_1 = 0;\n			push(char_stack, &c);\n		}\n		if (state_1 == 0 && (c == \'+\' || c == \'-\'))\n		{\n			state_1 = 1;\n			c = getchar();\n			if (\'0\' <= c && c <= \'9\' )\n			{\n				a = c - \'0\';\n				a = 0 - a;\n				state_cipher++;\n				push(int_stack, &a);\n				continue;\n			}\n			else \n			{\n				i = 0;\n				while ((\'a\' <=c && c <= \'z\') || c == \'_\' || (\'0\' <= c && c <= \'9\'))\n				{\n					s[i] = c;\n					i++;\n					c = getchar();\n				}\n				s[i] = \'\\0\';\n				a = 0 - get_value(s);\n				push(int_stack, &a);\n			}\n		}\n		if (c == \')\')\n		{\n			char t;\n			state_1 = 1;\n			do\n			{\n				t = *(char*)top(char_stack);\n				pop(char_stack);\n				if (t != \'(\')\n					oper(t);\n			}\n			while (t != \'(\' && !empty(char_stack));\n		}\n		if (c == \'+\' || c == \'-\')\n		{\n			char t;\n			state_1 = 0;\n			do \n			{\n				if (!empty(char_stack))\n				{\n					t = *(char*) top(char_stack);\n					if (t != \'(\')\n					{\n						oper(t);\n						pop(char_stack);\n					}\n				}\n				else \n					t = \'(\';\n			}\n			while (t != \'(\' && !empty(char_stack));\n			push(char_stack, &c);\n		}\n		if (c == \'*\' || c == \'/\')\n		{\n			char t = 0;\n			state_1 = 0;\n			do \n			{\n				if (!empty(char_stack))\n				{\n					t = *(char*) top(char_stack);\n					if (t == \'*\' || t == \'/\')\n					{\n						oper(t);\n						pop(char_stack);\n					}\n				}\n				/*else \n					push(char_stack, &c);*/\n				\n			}\n			while ((t == \'*\' || t == \'-\') && !empty(char_stack));\n			push(char_stack, &c);\n		}\n		if (c == \'\\n\')\n			break;\n	}\n	while ((c = getchar()) != \'\\n\');\n	while(!empty(char_stack))\n	{\n		char t;\n		t = *(char*) top(char_stack);\n		pop(char_stack);\n		oper(t);\n	}\n	return *(int*)top(int_stack);\n}\n\nvoid oper(char t)\n{\n	int x = 0, y = 0, z;\n	if (!empty(int_stack))\n	{\n		x =*(int*) top(int_stack);\n		pop(int_stack);\n	}\n	if (!empty(int_stack))\n	{\n		y = *(int*) top(int_stack);\n		pop(int_stack);\n	}\n	if (t == \'+\')\n		z = x + y;\n	if (t == \'-\')\n		z = y - x;\n	if (t == \'*\')\n		z = x * y;\n	if (t == \'/\')\n	{\n		if (x == 0)\n		{\n			printf(\"divide by zero\\n\");\n			state_zero = d_b_z;\n		}\n		else\n			z = y / x;\n	}\n	push(int_stack, &z);\n}\n\nvoid check_enter(char c)\n{\n	int i = 0, a = 0;\n	char s[10000] = {0};\n	do\n	{\n		if (c == \' \')\n		{\n			c = getchar();\n			continue;\n		}\n		s[i] = c;\n		i++;\n		c = getchar();\n	}\n	while((\'a\' <= c && c <= \'z\') || (\'0\' <= c && c <= \'9\') || c == \'_\' || c ==\' \');\n	s[i] = \'\\0\';\n	if (c == \'\\n\')\n	{\n		printf(\"%d\\n\",get_value(s));\n		return;\n	}\n	if (c == \'=\')\n		set_value(s, connective_c(c = getchar(),0));\n	else \n	{\n		int value = get_value(s);\n		push(int_stack, &value);\n		a = connective_c(c,1);\n/*#ifdef WIN32\n                        if (a != -858993460)\n                                printf(\"%d\\n\",a);\n#else\n					if (a != -1073742600)\n                                printf(\"%d\\n\",a);\n#endif*/\n		if (state_zero != d_b_z)\n			printf(\"%d\\n\",a);\n		else \n			state_zero = 0;\n	}\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (107,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#include\"stack.h\"\r\n\r\nvoid push(stack *S, void *data)\r\n{\r\n	struct item *p;\r\n	void *q;\r\n	q = (int*)(malloc(sizeof(int)));\r\n	if (check_mem(q))\r\n		*(int*)q = *(int*)data;\r\n	else return;\r\n	p = (struct item*) (malloc (sizeof (struct item)));\r\n	p -> data = q;\r\n	p -> next = S -> top;\r\n	S -> top = p;	\r\n}\r\n\r\nvoid *pop(stack *S)\r\n{\r\n	void *q;\r\n	struct item *p;\r\n	p = S -> top;\r\n	S -> top = p -> next;\r\n	free(p->data);\r\n	free(p);\r\n}\r\n\r\nvoid *top(stack *S)\r\n{\r\n	if (S -> top)\r\n		return (S -> top -> data);\r\n	else return 0;\r\n}\r\n\r\nint empty(stack *S)\r\n{\r\n	return (S -> top == NULL);\r\n}\r\n\r\nvoid makenull(stack *S)\r\n{\r\n	struct item *p;\r\n	while (S -> top)\r\n	{\r\n		p = S -> top;\r\n		S -> top = p -> next;\r\n		free(p->data);\r\n		free(p);\r\n	}\r\n	free(S);\r\n}\r\n\r\nstack* creat()\r\n{\r\n	stack *S;\r\n	S =  malloc (sizeof (stack));\r\n	if (!check_mem(S))\r\n		return;\r\n	S -> top = NULL;\r\n	return S;\r\n}\r\n\r\nstatic int check_mem(void *q)\r\n{\r\n	if (q == 0)\r\n	{\r\n		perror(\"malloc\");\r\n		return 0;\r\n	}\r\n	else return 1;\r\n}\r\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (108,'#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#include\"vars.h\"\r\n\r\nstatic unsigned int hash (char *s)\r\n{\r\n	unsigned int res = 0;\r\n//	return 1;\r\n	while (*s)\r\n	{\r\n		res = (res * 37 + *s) % max_n;\r\n		s++;\r\n	}\r\n	return res;\r\n}\r\n\r\nvoid set_value (char* name, int value)\r\n{\r\n	static struct hash *p;\r\n	static struct hash *q;\r\n	int index;\r\n	index = hash(name);\r\n	q = h[index];\r\n	for (p = h[index]; p; p = p -> next)\r\n		q = p;\r\n	p = (struct hash *) malloc(sizeof (struct hash));\r\n	if (!check_mem(p))\r\n		return;\r\n	p -> count = value;\r\n	p -> name = (char*) malloc(sizeof (char) * (strlen(name) + 1));\r\n	if (!check_mem(p))\r\n		return;\r\n	strcpy(p -> name, name);\r\n	\r\n	if (!q || (strcmp(h[index] -> name, name) == 0))\r\n	{\r\n		if (!q)\r\n			h[index] = p;\r\n		else\r\n		{\r\n			q = h[index];\r\n			free(q -> name);\r\n			free(q);\r\n			h[index] = p;			\r\n		}\r\n\r\n	}\r\n	else \r\n		q -> next = p;\r\n	p -> next = 0;\r\n}\r\n\r\nint get_value (char* name)\r\n{\r\n	struct hash *p,*q;\r\n	int index;\r\n	index = hash(name);\r\n	//p = h[index];\r\n	for (p = h[index]; p; p=q)\r\n	{\r\n		if (strcmp(p -> name, name)==0)\r\n			return p -> count;\r\n		q = p -> next;\r\n	}\r\n	return 0;\r\n}\r\n\r\nvoid cleanup (void)\r\n{\r\n	int i;\r\n	struct hash *p, *q;\r\n 	for (i = 0; i < max_n; i++)\r\n	{\r\n		if (h[i])\r\n		{\r\n			p = h[i];\r\n			if (p -> next)\r\n				free(p -> next);\r\n			free(p -> name);\r\n			//free(p -> count);\r\n			free(p);\r\n		}\r\n	}\r\n}\r\n\r\nstatic int check_mem(void *q)\r\n{\r\n	if (q == 0)\r\n	{\r\n		perror(\"malloc\");\r\n		return 0;\r\n	}\r\n	else return 1;\r\n}\r\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (109,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	FILE *f;\n	int i,j,l,k;\n	char st[20],s[255];\n	printf (\"login: \");\n	scanf (\"%s\",st);\n	l=strlen(st);\n	f=fopen(\"/etc/passwd\",\"r\");\n	for (;fgets(s,255,f);)\n	{\n		j=1;\n		for (i=0;i<l;i++)\n			if (s[i]!=st[i]) j=0;\n		if (s[l]!=\':\') j=0;\n		if (j==1)\n		{\n			fclose(f);\n			i=0;\n			for (k=0;k!=4;)\n			{\n				if (s[i]==\':\') k++;\n				i++;\n			}\n			printf (\"name: \");\n			for (;(s[i]!=\':\')&&(s[i]!=\',\');i++)\n				printf (\"%c\",s[i]);\n			printf(\"\\n\");\n			return 0;\n		}\n        }\n	printf (\"???????????? ?? ??????????\");\n	printf(\"\\n\");\n	fclose(f);\n	return 0;\n}\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (110,'#include <stdio.h>\n#include <math.h>\nfloat a=6;\nfloat b=7;\nfloat c=0;\n\nfloat f(float x)\n{\n	return sin(x);\n}\n\nint main()\n{\n\n//	???? ?? ?????? ????????? ?????????? ????? -- \n//		??????? ???\n\n	if (f(a)*f(b) > 0)\n	{\n		printf(\"??????? ???\\n\");\n		return 0;\n	}\n\n	do {\n		if ((b-a)<0.001) { printf(\"%f\\n\", a); return 0; }\n		else {\n			if(f(a)*f(b)<0) c=(a+b)/2;\n			if(f(c)==0) { printf(\"%f\\n\", c); return 0; }\n			if((f(a)*f(c)<0)) b=c;\n			else a=c;\n		}\n	} while ( b-a > 0.001 );\n\n	printf(\"%f\\n\", c); return 0; \n//do (f(a)*f(b)<0) if abs(a+b)<10^(-3) return(a);\n//c=(a+b)/2; if(f(c)==0) return(c);\n//if (f(a)*f(c)<0) b=c;\n//a=c;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (111,'#include<stdio.h>\n#define N 5\nint f(int B[N],int x,int e)\n{\n	int z,s,k;\n	k=0;\n	s=0;\n	if(x==B[k]) return(1);\n	if(x==B[e]) return 1;\n	if ((x>=B[s])&&(x<=B[e]))\n	{\n		printf(\".\\n\");\n		while (s<e)\n		{\n			k=(s+e)/2;\n			printf(\"%d %d %d\\n\",B[s],B[e],B[k]);\n			if(x==B[k])\n			return(1);\n				if(x>B[k])\n					if (k==s)\n					{	s=s+e;\n						return(0);\n					}\n					else\n						s=k;\n					else \n						if (k==s)\n						{	s=s+e;\n							return(0);\n						}\n						else\n							e=k;\n			\n		}\n	}\n	printf(\", k: %d\\n\", k);\n	return (0);\n}\nint main()\n{\n	int A[N]={1,3,5,7,9};\n	int m,l;\n	int s[11];\n	for(l=0;l!=11;l++)\n	{\n		scanf(\"%d\",&s[l]);\n		m=f(A,s[l],N-1);\n		printf(\"m: %d\\n\", m);\n		if (m)\n		printf(\"????? %d ??????????? ? ???????\\n\",s[l]);\n		else printf(\"????? %d ?? ??????????? ? ???????\\n\",s[l]);\n	}\n	return 0;\n}\n\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (112,'#include <stdio.h>\n#include <string.h>\n#define n 100\nint main()\n{\n	char s[n];\n	int m, i,j, k, l=0,d=10, sum=0;\n	fgets(s,n,stdin);\n	scanf(\"%d\",&m);	\n	k=strlen(s)-1;\n	s[k]=0;\n	for(i=0;i<k;i++)\n		{\n			if((((s[i]-\'0\')>(m-1))&&(s[i]<\'A\'))||((s[i]-\'A\'+10)>(m-1))||(s[i]<\'0\')||((s[i]>\'9\')&&(s[i]<\'A\')||(s[i]>\'Z\')))\n				{\n					printf(\"???????? ??????? ??????????\");\n					return(0);\n				}\n			if((s[i]<=\'9\')&&(s[i]>=\'0\'))\n				{\n					l=s[i]-\'0\';\n					for(j=1;j<=k-i-1;j++)\n						l=l*m;\n				}\n			if((s[i]>=\'A\')&&(s[i]<=\'Z\'))\n				{\n					l=s[i]-\'A\'+10;\n					for(j=1;j<=k-i-1;j++)\n						l=l*m;\n				}\n			sum=sum+l;\n		}\n	printf(\"%d\\n\",sum);\n	return (0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (113,'#include <stdio.h>\n#include <math.h>\n//float a=6;\n//float b=7;\n//float c=0;\n\nfloat f(float x)\n{\n	return x;\n}\n\n//int main()\n//{\n\n//	???? ?? ?????? ????????? ?????????? ????? -- \n//		??????? ???\n//\n//	if (f(a)*f(b) > 0)\n//	{\n//		printf(\"??????? ???\\n\");\n//		return 0;\n//	}\n//\n//	do {\n//		if ((b-a)<0.001) { printf(\"%f\\n\", a); return 0; }\n//		else {\n//			if(f(a)*f(b)<0) c=(a+b)/2;\n//			if(f(c)==0) { printf(\"%f\\n\", c); return 0; }\n//			if((f(a)*f(c)<0)) b=c;\n//			else a=c;\n//		}\n//	} while ( b-a > 0.001 );\n//\n//	printf(\"%f\\n\", c); return 0; \nint main() {\nfloat a=0,b=1,c=0,I=0;\nfloat a1=a;float b1=b;\nwhile (fabs(b1-a1)>0.001){c=(a1+b1)/2;b1=a1;a1=c;}\nc = fabs(b1 - a1);\nprintf(\"c ?????????? ?????? %f\\n\", c);\n\ndo{I=I+ c*f(a); a = a + c; }\nwhile(a+c<=b);\nprintf(\"%f\\n\",I);\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (114,'#include <stdio.h>\n\n# define N 3\nint main()\n{\n int A[N], B[N], i, t, l, r, f;\n\nprintf(\"??? ??????: \");\n for (t = 0; t < N; t++)\n 	{\n	 scanf (\"%d\", &A[t]);\n	}\nprintf(\"??? ??????: \");\n for (t = 0; t < N; t++)\n 	{\n	 scanf (\"%d\", &B[t]);\n	}\n for (i = 0; i < N; i++)\n 	{ // ???? A[i] ? ??????? b\n	 int l = 0, r = N-1;\n	 while (l <= r)\n	 {\n	  f = (r + l)/2;\n	  if (B[f] == A[i])\n	  {\n	  	printf(\"????? %d ?? ??????? %d\\n\", A[i], f);\n		break;\n	  }\n	  if (B[f] > A[i])\n	     r = f-1;\n	  else l = f+1;\n	 }\n	}\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (115,'#include <stdio.h>\n\nint main()\n{\n	FILE *f;\n	int i,a,n,k;\n	int m[100];\n	f=fopen(\"input.txt\",\"r\");\n	if (!f)\n	{\n		printf(\"?? ??????? ????? ????!\\n\");\n		return(0);\n	}\n	fscanf(f,\"%d\",&n);\n	for (i=0;i<n;i++)\n		fscanf(f,\"%d\",&m[i]);\n	printf(\"??????? ????? \");\n	scanf(\"%d\",&a);\n	i=0;\n	n--;\n	if (a==m[n])\n	{\n		printf(\"???? ????? ?????!\\n\");\n		return(0);\n	}\n	k++;\n	while (n)\n	{\n		n=n/2;\n		if (a==m[i+n])\n		{\n			printf(\"???? ????? ?????!\\n\");\n			return(0);\n		}\n		if (a>m[i+n])\n			i+=n;\n		if ((!n)&(k))\n		{\n			n+=2;\n			k=0;\n		}\n	}\n	printf(\"??? ?????? ?????!\\n\");\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (116,'#include<stdio.h>\nint main()\n{\n        #define N 7\n	int A[N]={1,3,5,7,9,11,13};\n	int i, c, mid;\n	int N1=N-1; // ????? \n	int s=0; //  ??????\n	\n	printf (\"Vvidite chislo:\\n\");\n	scanf (\"%d\", &c);\n\n	for (i=0;i<N;i++)\n	{\n		if (s>N1)\n		{\n			printf (\"Net takogo\\n\\n\");\n                        return 0;\n                }\n		mid=(N1+s)/2;\n		if (A[mid]== c || A[s]==c ||  A[N1]==c)\n		{\n			printf (\"prinadlezhit\\n\\n\");\n			return 0;\n		}\n		if(A[mid+s]<c)\n		{\n	 		s=1+mid;\n		}\n		else\n		{\n			N1=mid-1;\n		}\n	}\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (117,'#include <stdio.h>\n\nint func(char *s, int n, int left, int right)\n{\n	if (left > right)\n		return (1);\n	if (s[left] == \' \')\n		return func(s, n, left + 1, right);\n	if (s[right] == \' \')\n		return func(s, n, left, right - 1);\n	if (func(s,n,left + 1, right - 1))\n	{\n		if (s[left]!=s[right])\n	        	return(0);\n		return (1);\n	}\n	else return (0);\n}\n\nint main()\n{\n	FILE *f;\n	char s[100];\n	int i,j,n;\n	f=fopen(\"input.txt\",\"r\");\n	fgets(s,100,f);\n	for (i=0;s[i]!=\'\\n\';i++);\n	s[i]=0;\n	n=i;\n	for (i=0;i<n;i++)\n		if (((s[i]<\'a\')||(s[i]>\'z\'))&&(s[i]!=\' \'))\n		{\n			n--;\n			for (j=i;j<n;j++)\n				s[j]=s[j+1];\n			s[n]=0;\n			i--;\n		}\n	if (func(s,n,0, n-1))\n		printf(\"??? ?????????!\");\n	else \n		printf(\"??? ?? ?????????!\");\n	printf(\"\\n\");\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (118,'#include<stdio.h>\n#include<string.h>\nint main()\n{\n	#define N 1000\n	int b, l, i, k, a, c, t;\n	char s[10];\n	printf(\"???????:  \");\n	scanf(\"%d\", &b);\n	printf(\"??????? ?????:  \");\n	scanf(\"%s\", s);\n	l=strlen(s);\n	t=b;\n	b=1;\n	c=0;\n	for(i=l-1;i>=0;i--)\n	{\n		if(s[i]>=\'A\')\n		{\n			s[i]=s[i]-(\'A\'-9)+1;\n			c=c+s[i]*b;\n		}\n		else\n			c=c+(s[i]-\'0\')*b;\n		b=b*t;\n	}\n	printf(\"?????????:  %d\\n\", c);\n}	\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (119,'# include <stdio.h>\n#include <math.h>\n# include <string.h>\n int degree(int x,int y)\n     {int i;\n      int d = 1;\n      for (i = 1;i<=y;i++) d = x*d;\n      printf(\"%d^%d = %d\\n\", x, y, d);\n      return d;\n      }\n int main()\n {char s[100];\n  int g,i,z;\n  int u = 0;\n  int p = 0;\n  scanf(\"%s%d\",s,&g);\n  printf(\"????? ?????? %s ? ????? %d\\n\", s, g);\n  z = strlen(s);\n  for (i = 0;i<=z;i++) {if((s[i]>=\'A\') && (s[i]<=\'Z\')) s[i] = s[i] - \'A\' + 10;\n    			if((s[i]>=\'0\') && (s[i]<=\'9\')) s[i] = s[i] - \'0\';\n                        if (s[i]>g){printf(\"????????! ???????? ???????!:????????? ??????? ????????? ?????? ???????!\\n\");\n			            u = u+1;\n				    break;};};\n  if (u == 0)for (i = 0; i < z; i++) p = p + s[i]*degree(g,z-i-1);\n  printf(\"%d\\n\",p);\n  return 0;\n  }\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (120,'# include <stdio.h>\n#include <string.h>\n# define N 100\n\nmain ()\n{\n char s[N];\n int d;\n int i, n;\n FILE *p = fopen(\"stroka.txt\", \"r\");\n \n 	if (!p)\n 	{	\n 	 perror(\"fopen\");\n	 }\n fgets (s, N, p);\n s[strlen(s) - 1] = 0;\n d = strlen(s);\n\n n = d-1;\n\n int aaa = 0;\n \n 	for (i = 0; i < d; i++)\n		{\n		if  (s[i] != \' \')\n		 	{\n				\n			 while (s[n] == \' \')\n			 	n--;\n\n			 printf(\"?????????? %c ? %c\\n\", s[i], s[n]);\n\n			 if (s[i] != s[n])\n			 	aaa = 1;\n						 \n			 n--;	\n			}\n		}\n\n if (aaa == 0)\n	 printf (\"?????? ???????? ???????????\\n\");\nelse\n	 printf (\"?????? ?? ???????? ???????????\\n\");\n}\n\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (121,'#include <stdio.h>\n#include <string.h>\nint main()\n{\n char S[100];\n int sch=0;\n int ch=0;\n int symb=0;\n int M=1;\n int i=0;\n printf(\"Vvedite sistemu\\n\");\n scanf(\"%d\",&sch);\n printf(\"Vvedite chislo\\n\");\n scanf(\"%s\",S);\n 	for (i=strlen(S)-1;i>=0;i--) \n	 {\n		 if ((*(S+i)>=\'0\')&&(*(S+i)<=\'9\'))\n {\n		 symb=(int)(*(S+i)) - (int)\'0\';\n		 }\n		else {symb=(int)(*(S+i)) - (int)\'A\' + 10;}\n		ch+=symb*M;\n		M*=sch;\n		 }   \n		 printf(\"Eto chislo ravno %d\\n\",ch);\n		 }\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (122,'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define N 5\nint main()\n{\n	int a[N] = { 1, 3, 5, 7, 9 };\n	int b,i,l,r;\n	while(1)\n	{\n	scanf(\"%d\",&b);\n	l=0;\n	r=N-1;\n		while (l<=r)\n		{\n		i=(l+r)/2;\n		if (b==a[i])\n		{\n			printf (\"Yes\");\n			break;\n		}\n		else\n			{\n			if (b<a[i])\n				r=i-1;\n			else\n				l=i+1;\n				}\n		}\n		printf(\".\\n\");\n	}\n	return 0;\n}\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (123,'#include <stdio.h>\n#define N 5 \n\nvoid f( int *A, int c)\n{\n	int a,b;\n	a=0; b=N-1;\n		do\n		{int mid=(b+a)/2;\n			if (A[mid]==c)\n			{	printf(\"? ?????? ??????? ???? ???? ??????? ? ??? ????? %d\\n\", mid);\n				return;\n			}\n			if (A[mid]>c)\n				b=mid-1;\n			else \n				a=mid+1;\n		}\n		while (b>=a);\n			printf(\"? ?????? ??????? ??? ???????? ???????? \\n\");\n		return;\n}\n\nint main() \n{int i;\n	scanf(\"%d\",&i);\n		int B[N]={1,3,5,7,9};\n			if ((i>B[N-1]) || (i<B[0]))\n				printf (\"? ?????? ??????? ??? ???????? ???????? \\n\");\n			else\n				f(B,i);\nreturn;\n}\n\n\n\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (124,'#include <stdio.h>\n#include <string.h>\n#define n 10000\n#define k 100\n\nint main()\n{\n	char s[n];\n	char d[k];\n	char h[k];\n	int i, j;\n	int l=0,m=0;\n	FILE* f=fopen(\"/etc/passwd\",\"r\");\n	fgets(d,k,stdin);	\n	d[strlen(d)-1]=0;\n	while(fgets(s,n,f)!=NULL)\n	{\n		s[strlen(s)-1]=0;\n		for(i=0;i<(strlen(d));i++)\n			h[i]=s[i];\n		h[i]=0;\n		if(strcmp(d,h)==0)\n			{\n				for(j=0;m<4;j++)\n					if(s[j]==\':\')\n						m++;\n				for(l=j;(s[l]!=\',\')&(s[l]!=\':\');l++)\n					printf(\"%c\",s[l]);\n				printf(\"\\n\");\n				return(0);\n			}\n	}\n	printf(\"???????????? ???\");\n	fclose(f);\n	return(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (125,'#include<stdio.h>\n\nint main()\n{\n	FILE *f;\n	char s[100],n;\n	int h,k,i,a,b;\n	f=fopen(\"input.txt\",\"r\");\n	fscanf(f,\"%d\\n\",&b);\n	fgets(s,100,f);\n	i=100;\n	while (s[i]!=\'\\n\')\n		i--;\n	i--;\n	h=0;\n	k=1;\n	while (i>=0)\n	{\n		if ((s[i]>=\'A\')&&(s[i]<=\'Z\'))\n			a=s[i]-\'A\'+10;\n		if ((s[i]>=\'0\')&&(s[i]<=\'9\'))\n			a=s[i]-\'0\';\n		if (a>=b)\n		{\n			printf(\"???????????? ?????? ?????\\n\");\n			return(0);\n		}\n		else\n		{\n			h+=a*k;\n			k*=b;\n			i--;\n		}\n	}\n	printf(\"%d\\n\",h);\n	return(0);\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (126,'#include \"stdlib.h\"\n#include \"stdio.h\"\n\nint writebuff = 0, writebl = 0;\nint readbuff = 0, readbl = -1;\n\nchar* char_to_bin(char c) {\n	char* res;\n	int l;\n	\n	res = malloc(9 * sizeof(char));\n	if (res == 0) {\n		abort();\n	}\n	\n	l = 0;\n	while (l < 8) {\n		res[7-l] = \'0\' + (c & 1);\n		c = c >> 1;\n		l++;\n	}\n	res[8] = 0;\n\n	return res;\n}\n\nchar bin_to_char(char *s) {\n	char c;\n	int l;\n\n	c = 0;\n	for (l = 0; s[l]; l++) {\n		c *= 2;\n		c += s[l] - \'0\';\n	}\n\n	return c;\n}\n\nchar* int_to_bin(int c) {\n	char* res;\n	int l;\n	\n	res = malloc(33 * sizeof(char));\n	if (res == 0) {\n		abort();\n	}\n	\n	l = 0;\n	while (l < 32) {\n		res[31-l] = \'0\' + (c & 1);\n		c = c >> 1;\n		l++;\n	}\n	res[32] = 0;\n\n	return res;\n}\n\nint bin_to_int(char *s) {\n	int c, l;\n\n	c = 0;\n	for (l = 0; s[l]; l++) {\n		c *= 2;\n		c += s[l] - \'0\';\n	}\n\n	return c;\n}\n\nvoid printb(char *s) {\n	while (*s) {\n		writebuff *= 2;\n		writebuff += *s - \'0\';\n		writebl++;\n		if (writebl >= 8) {\n			putchar(writebuff);\n			writebuff = 0;\n			writebl = 0;\n		}\n		s++;\n	}\n}\n\nvoid finish_print() {\n	if (writebl == 0) return;\n	while (writebl < 8) {\n		writebuff *= 2;\n		writebl++;\n	}\n	putchar(writebuff);\n}\n\nint getb() {\n	int c;\n	if (readbl < 0) {\n		c = getchar();\n		if (c == EOF) return EOF;\n		readbl = 7;\n		readbuff = c;\n	}\n	c = ((readbuff >> readbl) & 1) + \'0\';\n	readbl--;\n	return c;\n}\n\nchar* scanb(int n) {\n	int l, c;\n	char* s;\n\n	s = malloc((n + 1) * sizeof(char));\n	l = 0;\n	while (l < n) {\n		c = getb();\n		if (c != EOF) {\n			s[l] = c;\n			l++;\n		} else {\n			break;\n		}\n	}\n	s[l] = 0;\n	s = realloc(s, (l + 1) * sizeof(char));\n	return s;\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (127,'#include \"stdlib.h\"\n\ntypedef int chk_func(void* a, void* b);\n\nstruct heap {\n	void** head;\n	chk_func* check;\n	int num;\n	int order;\n	int total;\n};\n\nstruct heap *make_heap(chk_func* check, int order) {\n	struct heap *r;\n	\n	r = malloc(sizeof(struct heap));\n	if (r == 0) {\n		abort();\n	}\n	r->num = 0;\n	r->total = 20;\n	r->check = check;\n	r->order = order;\n	r->head = malloc(r->total * sizeof(void*));\n	if (r->head == 0) {\n		abort();\n	}\n	return r;\n}\n\nvoid push(struct heap* h, void* a) {\n	int x, y;\n	void *t;\n	\n	x = h->num;\n	if (x >= h->total) {\n		h->total += 20;\n		h->head = realloc(h->head, h->total * sizeof(void*));\n		if (h == 0) {\n			abort();\n		}\n	}\n	h->head[x] = a;\n	\n	y = (x - 1) / 2;\n	while(x > 0 && h->check(h->head[x], h->head[y]) * h->order > 0) {\n		t = h->head[x];\n		h->head[x] = h->head[y];\n		h->head[y] = t;\n		x = y;\n		y = (x - 1) / 2;\n	}\n	h->num++;\n}\n\nvoid* pop(struct heap* h) {\n	int x, y;\n	void *t;\n	\n	if (h->num == 0) {\n		return 0;\n	}\n	\n	h->num--;\n	t = h->head[0];\n	h->head[0] = h->head[h->num];\n	h->head[h->num] = t;\n	\n	x = 0;\n	y = x * 2 + 2;\n	while (y < h->num && (h->check(h->head[y], h->head[x]) * h->order > 0 || h->check(h->head[y-1], h->head[x]) * h->order > 0)) {\n		if (h->check(h->head[y-1], h->head[y]) * h->order > 0) {\n			y--;\n		}\n		t = h->head[x];\n		h->head[x] = h->head[y];\n		h->head[y] = t;\n		x = y;\n		y = x * 2 + 2;\n	}\n	if (y == h->num && h->check(h->head[y-1], h->head[x]) * h->order > 0) {\n		t = h->head[x];\n		h->head[x] = h->head[y-1];\n		h->head[y-1] = t;\n	}\n	\n	return h->head[h->num];\n}\n\nvoid free_heap(struct heap* h) {\n	free(h->head);\n	free(h);\n}\n\nint empty(struct heap* h) {\n	return (h->num == 0);\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (128,'#include \"stdlib.h\"\n#include \"stdio.h\"\n#include \"heap.h\"\n#include \"tree.h\"\n#include \"binio.h\"\n\nvoid decompress(char* in, char* out) {\n	int i, l, c;\n	struct node* tn, *root; \n	char *s;\n\n	freopen(in, \"r\", stdin);\n	freopen(out, \"w\", stdout);\n\n	s = scanb(32);\n	l = bin_to_int(s);\n	free(s);\n\n	tn = root = build_tree();\n	\n	i = 0;\n	while (i < l) {\n		if (tn->l == 0) {\n			putchar(tn->name);\n			tn = root;\n			i++;\n			if (i >= l) break;\n		}\n		c = getb();\n		if (c == EOF) {\n			abort();\n		}\n		if (c == \'0\') {\n			tn = tn->l;\n		} else {\n			tn = tn->r;\n		}\n	}\n\n	free_tree(root);\n}\n\nvoid compress(char* in, char* out) {\n	int c, i, l;\n	int weight[256];\n	struct node* tn1, *tn2, *tn3;\n	struct heap* ch;\n	char *s;\n	char **table;\n	\n	freopen(in, \"r\", stdin);\n	freopen(out, \"w\", stdout);\n	for (i = 0; i < 256; i++) {\n		weight[i] = 0;\n	}\n	l = 0;\n	while ((c = getchar()) != EOF) {\n		weight[c]++;\n		l++;\n	}\n\n	ch = make_heap(tree_check, -1);\n	for (i = 0; i < 256; i++) {\n		if (weight[i] == 0 && i > 1) {\n			continue;\n		}\n		tn1 = make_node(i, weight[i], 0, 0);\n		push(ch, (void*)tn1);\n	}\n	while (!empty(ch)) {\n		tn1 = (struct node*)pop(ch);\n		tn2 = (struct node*)pop(ch);\n		if (tn2 == 0) break;\n		tn3 = make_node(0, tn1->weight + tn2->weight, tn1, tn2);\n		push(ch, (void*)tn3);\n	}\n	free_heap(ch);\n\n	s = int_to_bin(l);\n	printb(s);\n	free(s);\n\n	s = tree_get_string(tn1);\n	printb(s);\n	free(s);\n\n	s = tree_get_leaves(tn1);\n	printb(s);\n	free(s);\n\n	table = get_symb_table(tn1);\n	rewind(stdin);\n	while ((c = getchar()) != EOF) {\n		printb(table[c]);\n	}\n	finish_print();\n	\n	free_tree(tn1);\n	free_symb_table(table);\n}\n\nint main(int argc, char *argv[]) {\n	switch(argc) {\n		case 3:\n			compress(argv[2], argv[1]);\n		break;\n\n		case 4:\n			decompress(argv[2], argv[3]);\n		break;\n\n		default:\n			printf(\"./main [archive name] [file name] to compress\\n\");\n			printf(\"./main -d [archive name] [file name] to decompress\\n\");	\n	}\n	return 0;\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (129,'#include \"stdlib.h\"\n#include \"binio.h\"\n#include \"string.h\"\n\nstruct node {\n	int name;\n	int weight;\n	struct node *l, *r;\n};\n\nstruct node* make_node(int n, int w, struct node* l, struct node* r);\n\nstatic int tree_depth(struct node* t) {\n	int a, b;\n	if (t->l == 0 && t->r == 0) {\n		return 1;\n	}\n	a = tree_depth(t->l);\n	b = tree_depth(t->r);\n	return (a > b ? a : b) + 1;\n}\n\nstatic void set_names(struct node* t) {\n	char* s;\n	\n	if (t->l == 0 && t->r == 0) {\n		s = scanb(8);\n		t->name = bin_to_char(s);\n		free(s);\n		\n		return;\n	}\n\n	set_names(t->l);\n	set_names(t->r);\n}\n\nstatic struct node* build_tree_r() {\n	int c;\n	struct node* a, *b, *r;\n	\n	c = getb();\n	if (c == \'0\') {\n		a = make_node(0, 0, 0, 0);\n	} else {\n		a = build_tree_r();\n	}\n	c = getb();\n	if (c == \'0\') {\n		b = make_node(0, 0, 0, 0);\n	} else {\n		b = build_tree_r();\n	}\n	r = make_node(0, 0, a, b);\n\n	return r;\n}\n\nstruct node* build_tree() {\n	struct node* r;\n\n	r = build_tree_r();\n	set_names(r);\n	return r;\n}\n\nstatic char** make_symb_table(struct node* t, char* s, int l) {\n	char **a, **b;\n	int i;\n\n	if (t->l == 0 && t->r == 0) {\n		a = malloc(256 * sizeof(char*));\n		if (a == 0) {\n			abort();\n		}\n		for(i = 0; i < 256; i++) {\n			a[i] = 0;\n		}\n		\n		s[l] = 0;\n		a[t->name] = strdup(s);\n		return a;\n	}\n	\n	s[l] = \'0\';\n	a = make_symb_table(t->l, s, l + 1);\n	s[l] = \'1\';\n	b = make_symb_table(t->r, s, l + 1);\n	for(i = 0; i < 256; i++) {\n		if (b[i] != 0) {\n			if (a[i] != 0) {\n				printf(\"Error at creating symbol table: symbol #%d belongs to two nodes\\n\", i);\n				abort();\n			}\n			a[i] = b[i];\n		}\n	}\n	free(b);\n	return a;\n}\n\nvoid free_symb_table(char **s) {\n	int i;\n	\n	for(i = 0; i < 256; i++) {\n		if (s[i]) {\n			free(s[i]);\n		}\n	}\n	free(s);\n}\n\nint tree_check(void* aa, void* bb) {\n	struct node* a, *b;\n	a = (struct node*)aa;\n	b = (struct node*)bb;\n	return a->weight - b->weight;\n}\n\nstruct node* make_node(int n, int w, struct node* l, struct node* r) {\n	struct node* res;\n	res = malloc(sizeof(struct node));\n	if (res == 0) {\n		abort();\n	}\n	res->name = n;\n	res->weight = w;\n	res->l = l;\n	res->r = r;\n	return res;\n}\n\nchar** get_symb_table(struct node* t) {\n	char* s;\n	char** res;\n	\n	s = malloc(tree_depth(t) * sizeof(char));\n	if (s == 0) {\n		abort();\n	}\n\n	res = make_symb_table(t, s, 0);\n	free(s);\n	return res;\n}\n\nchar* tree_get_string(struct node* t) {\n	char *res, *s1, *s2;\n	int l1, l2;\n	\n	if (t->l == 0 && t->r == 0) {\n		res = malloc(2 * sizeof(char));\n		if (res == 0) {\n			abort();\n		}\n		res[0] = \'0\';\n		res[1] = 0;\n		return res;\n	}\n			\n	s1 = tree_get_string(t->l);\n	s2 = tree_get_string(t->r);\n	l1 = l2 = 0;\n	while (s1[l1]) l1++;\n	while (s2[l2]) l2++;\n	if (l1 > 1)  l1++;\n	if (l2 > 1) l2++;\n	\n	res = malloc((l1 + l2 + 1) * sizeof(char));\n	if (res == 0) {\n		abort();\n	}\n	\n	if (l1 > 1) {\n		res[0] = \'1\';\n		l1 = 0;\n		while (s1[l1]) {\n			res[l1 + 1] = s1[l1];\n			l1++;\n		}\n	} else {\n		res[0] = \'0\';\n		l1 = 0;\n	}\n	if (l2 > 1) {\n		res[l1 + 1] = \'1\';\n		l2 = 0;\n		while (s2[l2]) {\n			res[l1 + l2 + 2] = s2[l2];\n			l2++;\n		}\n	} else {\n		res[l1 + 1] = \'0\';\n		l2 = 0;\n	}\n	res[l1 + l2 + 2] = 0;\n	free(s1);\n	free(s2);\n	return res;\n}\n\nchar* tree_get_leaves(struct node* t) {\n	char *res, *s1, *s2;\n	int l1, l2;\n	\n	if (t->l == 0 && t->r == 0) {\n		res = char_to_bin(t->name);\n		return res;\n	}\n			\n	s1 = tree_get_leaves(t->l);\n	s2 = tree_get_leaves(t->r);\n	l1 = l2 = 0;\n	while (s1[l1]) l1++;\n	while (s2[l2]) l2++;\n	\n	res = malloc((l1 + l2 + 1) * sizeof(char));\n	if (res == 0) {\n		abort();\n	}\n	\n	l1 = 0;\n	while (s1[l1]) {\n		res[l1] = s1[l1];\n		l1++;\n	}\n	l2 = 0;\n	while (s2[l2]) {\n		res[l1 + l2] = s2[l2];\n		l2++;\n	}\n	res[l1 + l2] = 0;\n	free(s1);\n	free(s2);\n\n	return res;\n}\n\nvoid free_tree(struct node* t) {\n	if (t->l) free_tree(t->l);\n	if (t->r) free_tree(t->r);\n	free(t);\n}\n','Ð˜Ð²Ð°Ð½','Ivan','m');
INSERT INTO `bias` VALUES (130,'#include<stdlib.h>\n#include\"main.h\"\nint cmp(struct variable *var1,struct variable *var2)\n{\n	int i = 0;\n	struct variable *v1 = var1,*v2 = var2;\n	while((v1->name[i] != 0)&&(v2->name[i] != 0)&&(v1->name[i] == v2->name[i]))\n		if (i == 255)\n		{\n			v1 = v1->next;\n			v2 = v2->next;\n			i = 0;\n		}\n		else\n			i++;\n	return (v1->name[i] - v2->name[i]);\n}\nunsigned int hash (struct variable *var)\n{\n	unsigned int res = 0;\n	int i = 0;\n	struct variable *v = var;\n	while (v->name[i])\n	{\n		res = (res*991 + v->name[i]) % N;\n		if (i == 255)\n		{\n			v = v->next;\n			i = 0;\n		}\n		else\n			i++;\n	}\n	return res;\n}\nvoid set_value(struct variable *var,int value)\n{\n	struct hashtable *p;\n	unsigned int a;\n	p = malloc(sizeof(struct hashtable));\n	if (!p)\n		perror(\"malloc\");\n	else\n	{\n		a = hash(var);\n		p->next = H[a];\n		p->name = var;\n		p->val = value;\n		H[a] = p;\n	}\n}\nint get_value(struct variable *var)\n{\n	struct hashtable *p;\n	p = H[hash(var)];\n	while (p)\n	{\n		if (cmp(var,p->name) == 0)\n			return (p->val);\n		p = p->next;\n	}\n	perror(\"unknown variable\");\n}\nvoid cleanup(void)\n{\n	struct hashtable *p,*q;\n	struct variable *r,*u;\n	int i;\n	for(i = 0;i < N;i++)\n	{\n		if (!H[i])\n			continue;\n		p = H[i];\n		q = p->next;\n		while(p)\n		{\n			//printf(\"9\\n\");\n			r = p->name;\n			u = r->next; \n			while(r)\n			{\n//				printf(\"9\\n\");\n				free(r);\n				r = u;\n				if (r)\n					u = r->next;\n			}\n			free(p);\n			p = q;\n			if (p)\n				q = p->next;\n		}\n	}\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (131,'#include<stdio.h>\n#include<stdlib.h>\nstruct stack\n{\n	void *data;\n	struct stack *next;\n};\nstruct stack *head1,*head2;\nstruct hashtable\n{\n	struct variable *name;\n	int val;\n	struct hashtable *next;\n};\nstruct variable\n{\n	char name[256];\n	struct variable *next;\n};\nvoid freevar(struct variable *v)\n{\n	struct variable *r,*u;\n	r = v;\n	u = r->next;\n	while(r)\n	{\n		free(r);\n		r = u;\n		if (r)\n			u = r->next;\n	}\n}\n#include\"stack.h\"\n#include\"hash.h\"\n#define N 10000\nstruct hashtable *H[N];\nstruct variable *var1head,*var2head;\nint main()\n{\n	int i,stt = 0,s = 0,*b,*b1,*b2;\n	struct variable *v,*r;\n	char c,*d,e;\n	c = getchar();\n	while (c != EOF)\n	{\n		\n		if (c == \'\\n\')\n		{\n			c = getchar();\n			continue;\n		}\n		else if ((c >= \'a\')&&(c <= \'z\'))\n		{\n			\n			v = malloc(sizeof(struct variable));\n			if (!v)\n				perror(\"malloc\");\n			v->name[0] = c;\n			v->next = NULL;\n			var1head = v;\n			c = getchar();\n			i = 1;\n			while ((c >= \'a\')&&(c <= \'z\')||(c == \'_\'))\n			{\n				v->name[i] = c;\n				i++;\n				if (i == 255)\n				{\n					r = malloc(sizeof(struct variable));\n					if (!r)\n						perror(\"malloc\");\n					r->next = NULL;\n					v->next = r;\n					v = v->next;\n					i = 0;\n				}\n				c = getchar();\n			}\n			v->name[i] = 0;\n			if (c == \'=\')\n			{	\n				stt = 1;\n				c = getchar();\n				if ((c == \'+\')||(c == \'-\'))\n				{\n					e = c;\n					c = getchar();\n					while ((c >= \'0\')&&(c <=\'9\'))\n					{\n						s = s*10 + c - \'0\';\n						c = getchar();\n					}\n					b = malloc(sizeof(int));\n					if (!b)\n						perror(\"malloc\");\n					if (e == \'+\')\n						*b = s;\n					if (e == \'-\')\n						*b = s*(-1);\n					push(&head2,b);\n					s = 0;\n				}\n			}\n			else\n			{\n				stt = 0;\n				b = malloc(sizeof(int));\n				if (!b)\n					perror(\"malloc\");\n				*b = get_value(var1head);\n				push(&head2,b);\n				freevar(var1head);\n				var1head = NULL;\n			}\n		}\n		else\n		{\n			stt = 0;\n			if ((c == \'+\')||(c == \'-\'))\n			{\n				e = c;\n				c = getchar();\n				while ((c >= \'0\')&&(c <= \'9\'))\n				{\n					s = s*10 + c - \'0\';\n					c = getchar();\n				}\n				b = malloc(sizeof(int));\n				if (!b)\n					perror(\"malloc\");\n				if (e == \'+\')\n					*b = s;\n				if (e == \'-\')\n					*b = s*(-1);\n				push(&head2,b);\n				s = 0;\n			}\n		}\n		while ((c != EOF)&&(c != \'\\n\'))\n		{\n			{\n				if (c == \'=\')\n				{\n					while ((c = getchar())&&(c != EOF)&&(c != \'\\n\'));\n					pop(&head2);\n					printf(\"parse error\\n\");\n				}\n				if ((c >= \'0\')&&(c <= \'9\'))\n				{\n					while ((c >= \'0\')&&(c <= \'9\'))\n					{\n						s = s*10 + c - \'0\';\n						c = getchar();\n					}\n					b = malloc(sizeof(int));\n					if (!b)\n						perror(\"malloc\");\n					*b = s;\n					push(&head2,b);\n					s = 0;\n				}\n				if ((c >= \'a\')&&(c <= \'z\'))\n				{\n					v = malloc(sizeof(struct variable));\n					if (!v)\n						perror(\"malloc\");\n					v->name[0] = c;\n					v->next = NULL;\n					var2head = v;\n					c = getchar();\n					i = 1;\n					while (((c >= \'a\')&&(c <= \'z\'))||(c == \'_\'))\n					{\n						v->name[i] = c;\n						i++;\n						if (i == 255)\n						{\n							r = malloc(sizeof(struct variable));\n							if (!r)\n								perror(\"malloc\");\n							r->next = NULL;\n							v->next = r;\n							v = v->next;\n							i = 0;\n						}\n						c = getchar();\n					}\n					v->name[i] = 0;\n					b = malloc(sizeof(int));\n					if (!b)\n						perror(\"malloc\");\n					*b = get_value(var2head);\n					push(&head2,b);\n					freevar(var2head);\n					var2head = NULL;\n				}\n				if (c == \'(\')\n				{\n					d = malloc(sizeof(char));\n					if (!d)\n						perror(\"malloc\");\n					*d = c;\n					push(&head1,d);\n					c = getchar();\n					if ((c == \'+\')||(c == \'-\'))\n					{\n						e = c;\n						c = getchar();\n						while((c >= \'0\')&&(c <= \'9\'))\n						{\n							s = s*10 + c - \'0\';\n							c = getchar();\n						}\n						b = malloc(sizeof(int));\n						\n						if (!b)\n							perror(\"malloc\");\n						if (e == \'+\')\n							*b = s;\n						if (e == \'-\')\n							*b = s*(-1);\n						push(&head2,b);\n						s = 0;\n					}			\n				}\n				if (c == \')\')\n				{\n					d = (char *)top(head1);\n					while (*d != \'(\')\n					{\n						b1 = (int *)top(head2);\n						pop(&head2);\n						b2 = (int *)top(head2);\n						pop(&head2);\n						if (*d == \'+\')\n							s = *b2 + *b1;\n						if (*d == \'-\')\n							s = *b2 - *b1;\n						if (*d == \'*\')\n							s = *b2 * *b1;\n						if (*d == \'/\')\n							if (*b1 == 0)\n							{\n								printf(\"division by zero\\n\");\n								return 0;\n							}\n							else\n								s = *b2 / *b1;\n						free(b1);\n						free(b2);\n						free(d);\n						b = malloc(sizeof(int));\n						if (!b)\n							perror(\"malloc\");\n						*b = s;\n						s = 0;\n						push(&head2,b);\n						pop(&head1);\n						d = (char *)top(head1);\n					}\n					pop(&head1);\n					c = getchar();\n				}\n				if ((c == \'+\')||(c == \'-\'))\n				{\n					if (!empty(head1))\n					{\n						d = (char *)top(head1);\n						while ((!empty(head1))&&(*d != \'(\'))\n						{\n							b1 = (int *)top(head2);\n							pop(&head2);\n							b2 = (int *)top(head2);\n							pop(&head2);\n							if (*d == \'+\')\n								s = *b2 + *b1;\n							if (*d == \'-\')\n								s = *b2 - *b1;\n							if (*d == \'*\')\n								s = *b2 * *b1;\n							if (*d == \'/\')\n								if (*b1 == 0)\n								{\n									printf(\"division by zero\\n\");\n									return 0;\n								}\n								else\n									s = *b2 / *b1;\n							free(b1);\n							free(b2);\n							free(d);\n							b = malloc(sizeof(int));\n							if (!b)\n								perror(\"malloc\");\n							*b = s;\n							s = 0;\n							push(&head2,b);\n							pop(&head1);\n							if (!empty(head1))\n								d = (char *)top(head1);\n						}\n					}\n					d = malloc(sizeof(char));\n					if (!d)\n						perror(\"malloc\");\n					*d = c;\n					push(&head1,d);\n					c = getchar();\n					if ((c == \'+\')||(c == \'-\'))\n					{\n						e = c;\n						c = getchar();\n						while ((c >= \'0\')&&(c <= \'9\'))\n						{\n							s = s*10 + c - \'0\';\n							c = getchar();\n						}\n						b = malloc(sizeof(int));\n						if (!b)\n							perror(\"malloc\");\n						if (e == \'+\')\n							*b = s;\n						if (e == \'-\')\n							*b = s*(-1);\n						push(&head2,b);\n						s = 0;\n					}\n				}\n				if ((c == \'*\')||(c == \'/\'))\n				{\n					if (!empty(head1))\n					{\n						d = (char *)top(head1);\n						while ((*d != \'(\')&&(*d != \'+\')&&(*d != \'-\')&&(!empty(head1)))\n						{\n							b1 = (int *)top(head2);\n							pop(&head2);\n							b2 = (int *)top(head2);\n							pop(&head2);\n							if (*d == \'+\')\n								s = *b2 + *b1;\n							if (*d == \'-\')\n								s = *b2 - *b1;\n							if (*d == \'*\')\n								s = *b2 * *b1;\n							if (*d == \'/\')\n								if (*b1 == 0)\n								{\n									printf(\"division by zero\\n\");\n									return 0;\n								}\n								else\n									s = *b2 / *b1;\n							free(b1);\n							free(b2);\n							free(d);\n							b = malloc(sizeof(int));\n							if (!b)\n								perror(\"malloc\");\n							*b = s;\n							s = 0;\n							push(&head2,b);\n							pop(&head1);\n							if (!empty(head1))\n								d = (char *)top(head1);\n						}	\n					}\n					d = malloc(sizeof(char));\n					if (!d)\n						perror(\"malloc\");\n					*d = c;\n					push(&head1,d);\n					c = getchar();\n					if ((c == \'+\')||(c == \'-\'))\n					{\n						e = c;\n						c = getchar();\n						while ((c >= \'0\')&&(c <= \'9\'))\n						{\n							s = s*10 + c - \'0\';\n							c = getchar();\n						}\n						b = malloc(sizeof(int));\n						if (!b)\n							perror(\"malloc\");\n						if (e == \'+\')\n							*b = s;\n						if (e == \'-\')\n							*b = s*(-1);\n						push(&head2,b);\n						s = 0;\n					}\n				}\n			}\n		}\n		if (!empty(head1))\n			d = (char *)top(head1);\n		while(!empty(head1))\n		{\n			b1 = (int *)top(head2);\n			pop(&head2);\n			b2 = (int *)top(head2);\n			pop(&head2);\n			if (*d == \'+\')\n				s = *b2 + *b1;\n			if (*d == \'-\')\n				s = *b2 - *b1;\n			if (*d == \'*\')\n				s = *b2 * *b1;\n			if (*d == \'/\')\n				if (*b1 == 0)\n				{\n					printf(\"division by zero\\n\");\n					return 0;\n				}\n				else\n					s = *b2 / *b1;\n			free(b1);\n			free(b2);\n			free(d);\n			b = malloc(sizeof(int));\n			if (!b)\n				perror(\"malloc\");\n			*b = s;\n			push(&head2,b);\n			s = 0;\n			pop(&head1);\n			if (!empty(head1))\n				d = (char *)top(head1);\n		}\n		if (stt == 0)\n		{\n			if (!empty(head2))\n			{\n				b = (int *)top(head2);\n				printf(\"%d\\n\",*b);\n				free(b);\n			}\n		}\n		if (stt == 1)\n		{\n			if (!empty(head2))\n			{\n				b = (int *)top(head2);\n				set_value(var1head,*b);\n				var1head = NULL;\n				free(b);\n			}\n		}\n		if (!empty(head2))\n			pop(&head2);\n		c = getchar();\n	}\n	cleanup();\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (132,'#include\"main.h\"\nvoid push (struct stack **st, void *data)\n{\n	struct stack *p;\n	p = (struct stack *) malloc(sizeof(struct stack));\n	if (!p)\n		perror(\"malloc\");\n	else\n	{\n		p->data = data;\n		p->next = (*st);\n		(*st) = p;\n	}\n}\nvoid pop (struct stack **st)\n{\n	struct stack *p;\n	p = (*st);\n	(*st) = (*st)->next;\n	free(p);\n}\nvoid *top(struct stack *st)\n{\n	return(st->data);\n}\nint empty(struct stack *st)\n{\n	if (!st)\n		return 1;\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (133,'#include \"long.h\"\r\n#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n#include \"string.h\"\r\n\r\nlongint *li_construct(longint *a)\r\n{\r\n	int i;\r\n	longint *l = (longint*)malloc(sizeof(longint));\r\n	if (!l)\r\n	{\r\n		perror(\"malloc: \");\r\n		return NULL;\r\n	}\r\n	if (!a)\r\n	{\r\n		l->length = 0;\r\n		l->sign = 1;\r\n		l->digits = NULL;\r\n	}\r\n	else\r\n	{\r\n		l->length = a->length;\r\n		l->sign = a->sign;\r\n		l->digits = (int*)malloc(sizeof(int)*l->length);\r\n		if (!l->digits)\r\n		{\r\n			perror(\"malloc: \");\r\n			free(l);\r\n			return NULL;\r\n		}\r\n		for (i = 0; i < l->length; i++) l->digits[i] = a->digits[i];\r\n	}\r\n	return l;\r\n	\r\n}\r\n\r\nlongint *li_construct_str(char *s)\r\n{\r\n	int i = 0;\r\n	longint *a = li_construct(NULL);\r\n	if (!a) return NULL;\r\n	if (!s) return NULL;\r\n	\r\n	if (*s == \'-\')\r\n	{\r\n		a->sign = -1;\r\n		s++;\r\n	}\r\n	else\r\n	{\r\n		if (*s == \'+\') s++;\r\n		a->sign = 1;\r\n	}\r\n\r\n	a->length = strlen(s);\r\n	a->digits = (int*)malloc(sizeof(int)*a->length);\r\n	if (!a->digits)\r\n	{\r\n		perror(\"malloc: \");\r\n		return NULL;\r\n	}\r\n	\r\n	i = a->length-1;\r\n	while (*s)\r\n	{\r\n		a->digits[i--] = *s-\'0\';\r\n		s++;\r\n	}\r\n\r\n	for (i = a->length - 1; a->digits[i] == 0; i--); i++;\r\n	\r\n	if (i < a->length)\r\n	{\r\n		a->digits = (int*)realloc(a->digits, sizeof(int)*i);\r\n		a->length = i;\r\n	}\r\n\r\n	return a;\r\n}\r\n\r\nvoid li_destruct(longint *a)\r\n{\r\n	if (a->length >= 0)\r\n	{\r\n		free(a->digits);\r\n	}\r\n	free(a);\r\n}\r\n\r\nvoid li_print(longint *a)\r\n{\r\n	int i;\r\n	if (a->length<=0)\r\n	{\r\n		putchar(\'0\');\r\n		return;\r\n	}\r\n	if (a->sign == -1) putchar(\'-\');\r\n	for (i = a->length-1; i >= 0; i--)\r\n	{\r\n		putchar(a->digits[i]+\'0\');\r\n	}\r\n}\r\n\r\n\r\nlongint *li_add(longint *a, longint *b)\r\n{\r\n	int i;\r\n	int *p;\r\n	longint *c;\r\n\r\n	if (a->sign != b->sign)\r\n	{\r\n		b->sign = -b->sign;\r\n		c = li_sub(a,b);\r\n		b->sign = -b->sign;\r\n		return c;\r\n	}\r\n\r\n	c = li_construct(a);\r\n\r\n	if (c->length < b->length)\r\n	{\r\n		p = (int*)realloc(c->digits,sizeof(int)*b->length);\r\n		if (!p)\r\n		{\r\n			perror(\"realloc\");\r\n			return c;\r\n		}\r\n		c->digits = p;\r\n		for (i = c->length; i < b->length; i++) c->digits[i] = 0;\r\n		c->length = b->length;\r\n	}\r\n\r\n	for (i = 0; i < c->length; i++)\r\n	{\r\n		if (i < b->length)\r\n			c->digits[i] += b->digits[i];\r\n\r\n		if (c->digits[i] >= 10)\r\n		{\r\n			if (i + 1 == c->length)\r\n			{\r\n				p = (int*)realloc(c->digits,sizeof(int)*(c->length +1) );\r\n				if (!p)\r\n				{\r\n					perror(\"realloc\");\r\n					return c;\r\n				}\r\n				c->digits = p;\r\n				c->digits[c->length] = 0;\r\n\r\n				c->length++;\r\n			}\r\n\r\n			c->digits[i+1]+= c->digits[i]/10;\r\n			c->digits[i] = c->digits[i] % 10;\r\n		}\r\n	}\r\n\r\n	return c;\r\n}\r\n\r\nlongint *li_sub(longint *a, longint *b)\r\n{\r\n	int i;\r\n	longint *c,*s;\r\n\r\n	if (a->sign != b->sign) return li_add(a,b);\r\n\r\n	if (li_cmp(a,b) < 0)\r\n	{\r\n		c = li_construct(b);\r\n		c->sign = -c->sign;\r\n		s = a;\r\n	}\r\n	else\r\n	{\r\n		c = li_construct(a);\r\n		s = b;\r\n	}\r\n\r\n	for (i = 0; i < c->length; i++)\r\n	{\r\n		if (i < s->length)\r\n			c->digits[i] -= s->digits[i];\r\n\r\n		if (c->digits[i] < 0)\r\n		{\r\n			c->digits[i] += 10;\r\n			c->digits[i+1]--;\r\n		}\r\n	}\r\n\r\n	for (i = c->length - 1; i > 0 && c->digits[i] == 0; i--);\r\n	i++;\r\n	if (i < c->length)\r\n	{\r\n		c->length = i;\r\n		c->digits = (int*)realloc(c->digits,sizeof(int)*c->length);\r\n	}\r\n	return c;\r\n}\r\n\r\nlongint *li_mul(longint *a, longint *b)\r\n{\r\n	int i,j;\r\n	longint *c = li_construct(NULL);\r\n\r\n	c->length = a->length + b->length;\r\n\r\n	c->digits = (int*)calloc(c->length, sizeof(int));\r\n	if (!c->digits)\r\n	{\r\n		perror(\"calloc\");\r\n		return a;\r\n	}\r\n\r\n	for (i = 0; i < b->length; i++)\r\n	{\r\n		for (j = 0; j < a->length; j++)\r\n		{\r\n			c->digits[i+j] += b->digits[i] * a->digits[j];\r\n		}\r\n	}\r\n\r\n	for (i = 0; i < c->length; i++)\r\n	{\r\n		if (c->digits[i] >= 10)\r\n		{\r\n			c->digits[i+1] += c->digits[i] / 10;\r\n			c->digits[i] = c->digits[i] % 10;\r\n		}\r\n	}\r\n\r\n	for (i = c->length - 1; i > 0 && c->digits[i] == 0; i--);\r\n	i++;\r\n	if (i < c->length)\r\n	{\r\n		c->length = i;\r\n		c->digits = (int*)realloc(c->digits,sizeof(int)*c->length);\r\n	}\r\n\r\n	if (a->sign != b->sign) c->sign = -1; else c->sign = 1;\r\n\r\n	return c;\r\n}\r\n\r\nlongint *li_div(longint *a, longint *b)\r\n{\r\n	int i,t;\r\n	int *p;\r\n	longint *d,*c = li_construct(a);\r\n\r\n	if (b->length ==0 ||(b->length == 1 && b->digits[0] == 0) )\r\n	{\r\n		li_destruct(c);\r\n		printf(\"ERROR: Zero divizion!\\n\");\r\n		return a;\r\n	}\r\n\r\n	p = c->digits;\r\n	c->digits += c->length - 1;\r\n	c->length = 1;\r\n\r\n	d = li_construct(NULL);\r\n	d->digits = (int*)calloc(a->length, sizeof(int));\r\n	if (!d)\r\n	{\r\n		perror(\"calloc\");\r\n		li_destruct(c);\r\n		return a;\r\n	}\r\n	d->length = 0;\r\n	\r\n	for (t = 0; c->digits >= p; t++,c->digits--,c->length++)\r\n	{\r\n		d->length = t+1;\r\n		while (c->length > 1 && c->digits[c->length - 1] == 0) c->length--;\r\n\r\n		while (li_cmp(c, b) >= 0)\r\n		{\r\n			d->digits[t]++;\r\n			//sub\r\n			for (i = 0; i < c->length; i++)\r\n			{\r\n				if (i < b->length)\r\n					c->digits[i] -= b->digits[i];\r\n\r\n				if (c->digits[i] < 0)\r\n				{\r\n					c->digits[i] += 10;\r\n					c->digits[i+1]--;\r\n				}\r\n			}\r\n\r\n			for (i = 0; i < c->length; i++)\r\n			{\r\n				if (c->digits[i] >= 10)\r\n				{\r\n					c->digits[i+1] += c->digits[i] / 10;\r\n					c->digits[i] = c->digits[i] % 10;\r\n				}\r\n			}\r\n\r\n			while (c->length > 1 && c->digits[c->length - 1] == 0) c->length--;\r\n			//end sub\r\n\r\n\r\n		}\r\n	}\r\n\r\n	c->digits++;\r\n\r\n	for (i = 0; i < d->length / 2; i++)\r\n	{\r\n		t = d->digits[i];\r\n		d->digits[i] = d->digits[d->length - i - 1];\r\n		d->digits[d->length - i - 1] = t;\r\n	}\r\n\r\n	for (i = d->length - 1; i > 0 && d->digits[i] == 0; i--);\r\n	i++;\r\n	if (i < d->length)\r\n	{\r\n		d->length = i;\r\n		d->digits = (int*)realloc(d->digits,sizeof(int)*d->length);\r\n	}\r\n\r\n	li_destruct(c);\r\n\r\n	if (a->sign != b->sign) d->sign = -1; else d->sign = 1;\r\n\r\n	return d;\r\n}\r\n\r\nint li_cmp(longint *a, longint *b)\r\n{\r\n	int i;\r\n	if (a->length < b->length)\r\n		return -1;\r\n	if (a->length > b->length)\r\n		return 1;\r\n\r\n	for (i = a->length - 1; i >=0 && a->digits[i] == b->digits[i]; i--);\r\n	\r\n	if (i == -1) return 0;\r\n	return a->digits[i] - b->digits[i];\r\n}\r\n/*\r\nint main()\r\n{\r\n	longint *b;\r\n	longint *a;\r\n	longint *c;\r\n	char s[255];\r\n	scanf(\"%s\",s);\r\n	a = li_construct_str(s);\r\n	li_print(a);\r\n	putchar(\'\\n\');\r\n\r\n	scanf(\"%s\",s);\r\n	b = li_construct_str(s);\r\n	li_print(b);\r\n	putchar(\'\\n\');\r\n\r\n	c = li_div(a,b);\r\n	li_print(c);\r\n	putchar(\'\\n\');\r\n\r\n	li_destruct(b);\r\n	li_destruct(a);\r\n	li_destruct(c);\r\n	return 0;\r\n}\r\n*/','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (134,'#ifndef __GNUC__\r\n#include <crtdbg.h>\r\n//#define _CRT_SECURE_NO_WARNINGS\r\n//#define _CRT_SECURE_NO_DEPRECATE\r\n#endif\r\n#include \"stack.h\"\r\n#include \"vars.h\"\r\n#include \"long.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <ctype.h>\r\n\r\nstruct equation\r\n{\r\n	char op;\r\n	longint *val;\r\n};\r\n\r\nstruct equation *equation_construct(struct equation *a)\r\n{\r\n	struct equation *eq;\r\n	if (!a)\r\n	{\r\n		eq = (struct equation*)malloc(sizeof(struct equation));\r\n		eq->op = 0;\r\n		eq->val = li_construct(NULL);\r\n		return eq;\r\n	}\r\n	else\r\n	{\r\n		eq = (struct equation*)malloc(sizeof(struct equation));\r\n		eq->op = a->op;\r\n		eq->val = li_construct(a->val);\r\n		return eq;\r\n	}\r\n}\r\n\r\nvoid equation_destruct(struct equation *eq)\r\n{\r\n	li_destruct(eq->val);\r\n	free(eq);\r\n}\r\n\r\nint prior(char c)\r\n{\r\n	switch (c)\r\n	{\r\n		case \'(\': return 0;\r\n		case \'-\': return 1;\r\n		case \'+\': return 1;\r\n		case \'*\': return 2;\r\n		case \'/\': return 2;\r\n		default: return -1;\r\n	}\r\n}\r\n\r\nint oppush(stack st, char c)\r\n{\r\n	struct equation *eq,*eq2;\r\n	longint *li = NULL;\r\n\r\n	eq = equation_construct( (struct equation*)top(st) );\r\n	pop(st);\r\n	eq2 = equation_construct( (struct equation*)top(st) );\r\n	pop(st);\r\n	\r\n	switch (c)\r\n	{\r\n	case \'+\': li = li_add(eq2->val, eq->val); break;\r\n	case \'-\': li = li_sub(eq2->val, eq->val); break;\r\n	case \'*\': li = li_mul(eq2->val, eq->val); break;\r\n	case \'/\': li = li_div(eq2->val, eq->val); break;\r\n	}\r\n\r\n	li_destruct(eq2->val);\r\n	eq2->val = li;\r\n	push(st, eq2);\r\n	\r\n	equation_destruct(eq);\r\n	equation_destruct(eq2);\r\n	return 0;\r\n}\r\n\r\nvoid eval()\r\n{\r\n	stack st1,st2;\r\n	int mode = -1;\r\n	int i = 0;\r\n	char c,pc = \'\\n\';\r\n	char ctmp;\r\n	\r\n	char eqname[256];\r\n	int eqmode = 0;\r\n	char name[256];\r\n	int namelen = 0;\r\n	char *val,*tval;\r\n	int valcap = 4096;\r\n	int vallen = 0;\r\n	\r\n	struct equation eq;\r\n	struct equation *peq = NULL;\r\n	eq.val = NULL;\r\n	\r\n	val = (char*)malloc(valcap);\r\n	//init variables table\r\n	set_operators((construct_func)(&equation_construct), (destruct_func)(&equation_destruct));\r\n		\r\n	//init stacks\r\n	st1 = createStack(sizeof(char));\r\n	st2 = createStack(sizeof(struct equation));\r\n	st2->constructor = (construct_func)(&equation_construct);\r\n	st2->destructor = (destruct_func)(&equation_destruct);\r\n	\r\n	\r\n	while ( (i = getchar()) != EOF)\r\n	{\r\n		c = (char)i;\r\n\r\n		if (c == \' \') continue;\r\n\r\n		\r\n		if (mode == 0) //number mode\r\n		{\r\n			if (isdigit(c))\r\n			{\r\n				val[vallen++] = c;\r\n				if (vallen == valcap)\r\n				{\r\n					valcap *= 2;\r\n					tval = realloc((void*)val, valcap);\r\n					if (!tval)\r\n					{\r\n						perror(\"realloc\");\r\n						free(val);\r\n						return;\r\n					}\r\n					val = tval;\r\n				}\r\n			}\r\n			else\r\n			{\r\n				if (eq.val) li_destruct(eq.val);\r\n				\r\n				val[vallen] = 0;\r\n				eq.val = li_construct_str(val);\r\n				push(st2, &eq);\r\n				/*li_print(eq.val);\r\n				putchar(\' \');*/\r\n				\r\n				mode = -1;\r\n			}\r\n		}\r\n\r\n		else if (mode == 1) //variable mode\r\n		{\r\n			if (isalpha(c) || c == \'_\' || isdigit(c))\r\n			{\r\n				name[namelen++] = c;\r\n			}\r\n			else\r\n			{\r\n				name[namelen] = 0;\r\n				if (c == \'=\')\r\n				{\r\n					if (!empty(st1) || !empty(st2))\r\n					{\r\n						printf(\"Parse error\\n\");\r\n						free(val);\r\n						return;\r\n					}\r\n					strcpy(eqname, name);\r\n					eqmode = 1;\r\n				}\r\n				else\r\n				{\r\n					\r\n					peq = (struct equation*)get_value(name);\r\n					push(st2,peq);\r\n				}\r\n				mode = -1;\r\n			}\r\n			\r\n		}\r\n\r\n\r\n		\r\n		if (mode == -1) //free mode\r\n		{\r\n			if (isdigit(c) || (prior(pc) >= 0 && (c == \'-\' || c ==\'+\')) )\r\n			{\r\n				val[0] = c;\r\n				vallen = 1;\r\n				mode = 0;\r\n			}\r\n			\r\n			if (isalpha(c))\r\n			{\r\n				name[0] = c;\r\n				namelen = 1;\r\n				mode = 1;\r\n			}\r\n\r\n			if (c == \'(\')\r\n			{\r\n				push(st1,&c);\r\n			}\r\n			\r\n			if (prior(c) > 0)\r\n			{\r\n				if (!empty(st1))\r\n				{\r\n					ctmp = *(char*)top(st1);\r\n					while (!empty(st1) && prior(ctmp) >= prior(c))\r\n					{\r\n						oppush(st2,ctmp);\r\n						pop(st1);\r\n						if (!empty(st1))\r\n						ctmp = *(char*)top(st1);\r\n					}\r\n				}\r\n				push(st1,&c);\r\n			}\r\n\r\n			if (c == \')\')\r\n			{\r\n				while (!empty(st1) && (ctmp = *(char*)top(st1)) != \'(\')\r\n				{\r\n					oppush(st2,ctmp);\r\n					pop(st1);\r\n				}\r\n				if (!empty(st1)) pop(st1);\r\n			}\r\n			\r\n		}\r\n\r\n		if (c == \'\\n\')\r\n		{\r\n			while (!empty(st1))\r\n			{\r\n				ctmp = *(char*)top(st1);\r\n				oppush(st2,ctmp);\r\n				pop(st1);\r\n			}\r\n			if (eqmode == 0)\r\n			{\r\n				while (!empty(st2))\r\n				{\r\n					peq = (struct equation*)top(st2);\r\n					li_print(peq->val);\r\n					putchar(\' \');\r\n					pop(st2);\r\n				}\r\n				putchar(\'\\n\');\r\n			}\r\n			else\r\n			{\r\n				set_value(eqname, top(st2));\r\n				while (!empty(st2)) pop(st2);\r\n			}\r\n			eqmode = 0;\r\n		}\r\n		\r\n		pc = c;\r\n	} // while\r\n	\r\n	if (eq.val)\r\n		li_destruct(eq.val);\r\n\r\n	free(val);\r\n}\r\n\r\nint main()\r\n{\r\n	\r\n	eval();\r\n	\r\n	printf(\"\\n\");\r\n	cleanup();\r\n	free_all_stacks();\r\n\r\n#ifndef __GNUC__\r\n	_CrtDumpMemoryLeaks(); \r\n#endif\r\n\r\n	return 0;\r\n}\r\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (135,'#include \"stack.h\"\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\nstatic void rep_error(int n)\r\n{\r\n	switch (n)\r\n	{\r\n		case 1: printf(\"stack: Malloc error\\n\"); return;\r\n		case 2: printf(\"stack: Stack is NULL\\n\"); return;\r\n		case 3: printf(\"stack: Uninitialized stack\\n\"); return;\r\n	}\r\n	printf(\"FUUUUUUUUUUUUUUUUUCK!\\n\");\r\n}\r\n\r\nstack stacks[255];\r\nint stack_count = 0;\r\n\r\nstack createStack(unsigned char size)\r\n{\r\n	stack st;\r\n	if (size == 0)\r\n	{\r\n		rep_error(4);\r\n		return NULL;\r\n	}\r\n	st = (stack)malloc(sizeof(struct stackStr));\r\n	if (!st)\r\n	{\r\n//		rep_error(1);\r\n		perror(\"malloc\");\r\n		return NULL;\r\n	}\r\n	\r\n	st->top = NULL;\r\n	st->size = size;\r\n	st->constructor = NULL;\r\n	st->destructor = NULL;\r\n	stacks[stack_count++] = st;\r\n	return st;\r\n}\r\n\r\nint empty(stack st)\r\n{\r\n	if (!st)\r\n	{\r\n		rep_error(2);\r\n		return 1;\r\n	}\r\n	if (st->size == 0)\r\n	{\r\n		rep_error(3);\r\n		return 1;\r\n	}\r\n	return  (st->top == NULL);\r\n}\r\n\r\nvoid push(stack st, void *data)\r\n{\r\n	struct item *i;\r\n	if (!st)\r\n	{\r\n		rep_error(2);\r\n		return;\r\n	}\r\n	if (st->size == 0)\r\n	{\r\n		rep_error(3);\r\n		return;\r\n	}\r\n	\r\n	i = (struct item*)malloc(sizeof(struct item));\r\n	if (!i)\r\n	{\r\n		rep_error(1);\r\n		return;\r\n	}\r\n	\r\n	i->next = st->top;\r\n	st->top = i;\r\n\r\n	if (st->constructor)\r\n	{\r\n		i->data = st->constructor(data);\r\n		return;\r\n	}\r\n	\r\n	i->data = (void*)malloc(st->size);\r\n	if (!i->data)\r\n	{\r\n		rep_error(1);\r\n		return;\r\n	}\r\n	\r\n	memcpy(i->data,data,st->size);\r\n}\r\n\r\nvoid *top(stack st)\r\n{\r\n	if (!st)\r\n	{\r\n		rep_error(2);\r\n		return NULL;\r\n	}\r\n	if (st->size == 0)\r\n	{\r\n		rep_error(3);\r\n		return NULL;\r\n	}\r\n	\r\n	if (!st->top) return NULL;\r\n	return st->top->data;\r\n}\r\n\r\nvoid pop(stack st)\r\n{\r\n	struct item *i;\r\n	\r\n	if (!st)\r\n	{\r\n		rep_error(2);\r\n		return;\r\n	}\r\n	if (st->size == 0)\r\n	{\r\n		rep_error(3);\r\n		return;\r\n	}\r\n	\r\n	\r\n	if (!st->top) return;\r\n	\r\n	i = st->top;\r\n	st->top = i->next;\r\n\r\n	if (st->destructor) st->destructor(i->data);\r\n	else free(i->data);\r\n	free(i);\r\n}\r\n\r\nvoid freeStack(stack st)\r\n{\r\n	int i = 0;\r\n	while (!empty(st))\r\n	{\r\n		pop(st);\r\n	}\r\n\r\n	for (;i < stack_count; i++)\r\n	{\r\n		if (stacks[i] == st)\r\n		{\r\n			stacks[i] = NULL;\r\n			break;\r\n		}\r\n	}\r\n	\r\n	free(st);\r\n}\r\n\r\nvoid free_all_stacks()\r\n{\r\n	int i = 0;\r\n	for (; i < stack_count; i++)\r\n	{\r\n		if (stacks[i])\r\n		{\r\n			freeStack(stacks[i]);\r\n		}\r\n	}\r\n}\r\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (136,'/*#include <stdio.h>\n#include \"stack.h\"\n\nint main()\n{\n	int i,k;\n	stack st;\n\n	st = createStack(sizeof(int));\n	\n	printf(\"%d\\n\",k=st->size);\n	for (i = 0; i<10; i++)\n	{\n		push(st,&i);\n\n		k = *( (int*)top(st) );\n\n		printf(\"%d \",k);\n	}\n\n	for (i = 0;i<8;i++)\n	{\n		k = *(int*)top(st);\n\n		printf(\"%d \",k);\n		pop(st);\n	}\n\n	for ( i = 5 ;i< 15; i++)\n	{\n		push(st,&i);\n	}\n\n	while (!empty(st))\n	{\n		k = *(int*)top(st);\n\n		printf(\"%d \",k);\n	\n		pop(st);\n	}\n\n	freeStack(st);\n}\n*/','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (137,'/*#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	for ( ; ; )\n	{\n		void *p = calloc(100000000, 1);\n		if (!p)\n		{\n			perror(\"calloc\");\n			return 0;\n		}\n	}\n	\n\n	return 0;\n}\n*/','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (138,'#include \"vars.h\"\r\n#include \"stack.h\"\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n\r\n#define HASH_SIZE 23\r\n\r\nstruct itemI\r\n{\r\n	char *name;\r\n	void* value;\r\n	struct itemI *next;\r\n};\r\n\r\nstruct itemI *table[HASH_SIZE];\r\nconstruct_func constr = NULL;\r\ndestruct_func destr = NULL;\r\n\r\nvoid set_operators(construct_func constructor,destruct_func destructor)\r\n{\r\n	constr = constructor;\r\n	destr = destructor;\r\n}\r\n\r\nint hash(char *name)\r\n{\r\n	int c = 0;\r\n	while (*name)\r\n	{\r\n		c = (c*3+*name) % HASH_SIZE;\r\n		name++;\r\n	}\r\n\r\n	return c;\r\n}\r\n\r\nstatic struct itemI *find(char *name)\r\n{\r\n	struct itemI *i;\r\n	int h = hash(name);\r\n	\r\n	i = table[h];\r\n\r\n	while (i)\r\n	{\r\n		if (!strcmp(name,i->name)) return i;\r\n		i = i->next;\r\n	}\r\n\r\n	return NULL;\r\n}\r\n\r\nvoid set_value(char *name, void *value)\r\n{\r\n	int h;\r\n	struct itemI *it = find(name);\r\n	\r\n	if (!constr || !destr)\r\n	{\r\n		printf(\"ERROR: undefined constructor or destrcutor\\n\");\r\n		return;\r\n	}\r\n	\r\n	if (!it)\r\n	{\r\n		h = hash(name);\r\n		it = (struct itemI*)malloc(sizeof(struct itemI));\r\n		if (!it) return;\r\n		it->name = (char*)malloc(sizeof(char)*(strlen(name)+1));\r\n		if (!it->name) return;\r\n		strcpy(it->name,name);\r\n		\r\n		it->value = constr(value);\r\n		\r\n		it->next = table[h];\r\n		table[h] = it;\r\n	}\r\n	else\r\n	{\r\n		destr(it->value);\r\n		it->value = constr(value);\r\n	}\r\n}\r\n\r\nvoid *get_value(char *name)\r\n{\r\n	struct itemI *it = find(name);\r\n	if (it)\r\n	{\r\n		return it->value;\r\n	}\r\n	else\r\n	{\r\n		return NULL;\r\n	}\r\n}\r\n\r\nvoid cleanup()\r\n{\r\n	int i;\r\n	struct itemI *it;\r\n	if (!destr)\r\n	{\r\n		printf(\"ERROR: Undefined destructor\\n\");\r\n		return;\r\n	}\r\n	for (i = 0; i<HASH_SIZE ; i++)\r\n	{\r\n		while (table[i])\r\n		{\r\n			it = table[i];\r\n			table[i] = table[i]->next;\r\n			if (it && it->name) \r\n				free(it->name);\r\n			destr(it->value);\r\n			free(it);\r\n		}\r\n	}\r\n}\r\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (139,'# include <stdio.h>\n#include <math.h>\n# include <string.h>\n int degree(int x,int y)\n     {int i;\n      int d = 1;\n      for (i = 1;i<=y;i++) d = x*d;\n      printf(\"%d^%d = %d\\n\", x, y, d);\n      return d;\n      }\n int main()\n {char s[100];\n  int g,i,z;\n  int u = 0;\n  int p = 0;\n  scanf(\"%s%d\",s,&g);\n  printf(\"????? ?????? %s ? ????? %d\\n\", s, g);\n  z = strlen(s);\n  for (i = 0;i<=z;i++) {if((s[i]>=\'A\') && (s[i]<=\'Z\')) s[i] = s[i] - \'A\' + 10;\n    			if((s[i]>=\'0\') && (s[i]<=\'9\')) s[i] = s[i] - \'0\';\n                        if (s[i]>g){printf(\"????????! ???????? ???????!:????????? ??????? ????????? ?????? ???????!\\n\");\n			            u = u+1;\n				    break;};};\n  if (u == 0)for (i = 0; i < z; i++) p = p + s[i]*degree(g,z-i-1);\n  printf(\"%d\\n\",p);\n  return 0;\n  }\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (140,'#include <stdio.h>\n#include <string.h>\n#define NMAX 100000\n\nvoid swap (int *A,int i,int j)\n{\n	int c;\n	c=A[i];\n	A[i]=A[j];\n	A[j]=c;\n}\n\nint quicksort (int *A,int l,int r)\n{\n	printf(\"%d %d\\n\", l, r);\n	int x,i=l,j=r;\n	if (l>=r)\n		return 0;\n	else\n	{\n		x=(A[l]+A[r])/2;\n		for (;i<j;)\n		{\n			for (;A[i]<x;)\n				i++;\n			for (;A[j]>x;)\n				j--;\n			if (i<=j)\n			{\n				swap(A,i,j);\n				i++;\n				j--;\n			}\n		}\n		if (l<j) quicksort (A,l,j);\n		if (i<r) quicksort (A,i,r);\n		return 0;\n	}\n}\n\nint main ()\n{\n	int A[NMAX],i;\n	int N;\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	scanf(\"%d\", &N);\n	for (i=0;i<N;i++)\n	{\n//		printf(\"A[%d]=\",i);\n		scanf(\"%d\",&A[i]);\n	}\n	quicksort (A,0,N-1);\n	for (i=0;i<N-1;i++)\n		printf(\"%d \",A[i]);\n	printf(\"%d\\n\",A[i]);\n	return 0;\n}\n\n\n\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (141,'#include<stdio.h>\n#include<string.h>\nint main()\n{\n#	define N 1000\n	int i, k, j, d, m;\n	char s[N];\n	FILE *f=fopen(\"input.txt\", \"r\");\n	if(!f)\n	{\n		printf(\"ai ai\");\n	}\n	fgets(s,N,f);\n	m=strlen(s);\n	for(k=0;k<m;k++)\n	{\n		printf(\"%c\", s[k]);\n	}\n	printf(\"\\n\");\n	i=0;\n	j=m-1;\n	printf(\"?????: %d\\n\", m);\n	for(d=0;d<m/2;d++)\n	{\n		\n		while(s[i]<\'0\')\n		{\n			i++;\n			if(i==j)\n			{	\n				printf(\"?????????\\n\");\n				return 0;\n			}\n		}\n		while(s[j]<\'0\')\n		{\n			j--;\n			if(j==i)\n			{	\n				printf(\"?????????\\n\");\n				return 0;\n			}\n			\n		}	\n		printf(\"?????????? ???????? %d ? %d\\n\", i, j);\n		if(s[i]!=s[j])\n		{\n			printf(\"?????? ?? ?????????\\n\");\n			return 0;\n		}\n		i++;\n		j--;\n	}\n	printf(\"?????? ?????????\\n\");	\n	fclose(f);\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (142,'#include <stdio.h>\n#include <string.h>\n#define NMAX 100000\n\nvoid swap (int *A,int i,int j)\n{\n	int c;\n	c=A[i];\n	A[i]=A[j];\n	A[j]=c;\n}\n\nint sift (int *A,int N,int k)\n{\n	if ((2*k+1<N))\n	if (A[2*k+1]>A[2*k+2])\n	{	\n		if ((A[2*k+1]>A[k])&&(2*k+1<N))\n		{		\n			swap (A,k,2*k+1);\n			sift (A,N,2*k+1);\n		}\n	}	\n	else\n	{\n		if ((A[2*k+2]>A[k])&&(2*k+2<N))\n		{\n			swap (A,k,2*k+2);\n			sift (A,N,2*k+2);\n		}\n	}\n	return 0;\n}\n\nint main ()\n{\n	int A[NMAX],i;\n	int N, M;\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	scanf(\"%d\", &N);\n	M=N;\n	for (i=0;i<N;i++)\n	{\n//		printf(\"A[%d]=\",i);\n		scanf(\"%d\",&A[i]);\n	}\n	for (;N>1;)\n	{\n		if (N==M) \n			for (i = N/2-1; i >= 0; i--)\n				sift (A,N,i);\n		swap (A,0,--N);\n		sift (A,N,0);\n	}\n	for (i=0;i<M-1;i++)\n		printf(\"%d \",A[i]);\n	printf(\"%d\\n\",A[M-1]);\n	return 0;\n}\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (143,'#include <stdio.h>\nint isprime (int a)\n{\n	int i, b, c;\n	c=1;\n	for (i=2; i<a; i++)\n	{\n		b=a%i;\n		if (b==0)\n			c=0;\n	}\n	printf(\"f(%d) = %d\\n\", a, c);\n	return (c);\n}\nint main()\n{\n	int i;int j=0;\n	int n=5;\n	scanf (\"%d\",&n);\n	int A[100]={0};\n	for (i=0;i<n;i++)\n		scanf (\"%d\",&A[i]);\n	for (i=0;i<n;i++)\n	{	A[i]=isprime (A[i]);\n		j=j+A[i];\n	}\n	if (j == n)\n	printf(\"??? ???????\\n\");\n	else if (j == 0)\n	printf(\"??? ?????????\\n\");\n	else\n	printf(\"???? ? ??, ? ??\\n\");\n	\n		\n}\n\n\n\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (144,'#include<stdio.h>\n#define N 100\nint g(char *B,int s,int e)\n{\n	if (s<e)\n	{\n		while (s <= e && ((B[e]<\'0\')||(B[e]>\'z\')))\n		e--;\n		while (s <= e && ((B[s]<\'0\')||(B[s]>\'z\')))\n		s++;\n		if (s<e)\n		{\n			if (B[s]==B[e])\n				return(g(B,s+1,e-1));\n			if (B[s]!=B[e])\n				return(0);\n		}\n		else\n		return (1);\n	\n	}\n	else\n	return (1);\n}\nint main()\n{\n	FILE *f;\n	f=fopen(\"lk8.txt\", \"r\");\n	char A[N]={0};\n	int l,r,x;\n	l=0;\n	fgets(A,N-1,f);\n	if (A[0]!=0)\n		for(r=0;(&A[r]!=0)&&(r<N);r++)\n		printf(\"%d \",A[r]);\n		x=g(A,l,r-1);\n	if (x==1)\n		printf(\"??? ?????????\\n\");\n	else\n		printf(\"??? ?? ?????????\\n\");\n	fclose(f);\n	printf(\"%d %d \\n\",l,r);\n\n	return(0);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (145,'#include <stdio.h>\nint main()\n{\n	int N,i,j,k;\n	int A[100][100]={0};\n	int B[100][100]={0};\n	int C[100][100]={0};\n	scanf (\"%d\", &N);\n	for (i=0;i<N;i++)\n	{\n		for (j=0;j<N;j++)\n		{\n			scanf (\"%d\", &A[i][j]);\n		};\n	};\n	for (i=0;i<N;i++)\n	{\n		for (j=0;j<N;j++)\n		{\n			scanf (\"%d\", &B[i][j]);\n		};\n	};\n	for (i=0;i<N;i++)\n	{\n		for (j=0;j<N;j++)\n		{\n			for (k=0;k<N;k++)\n				C[i][j]=C[i][j]+A[i][k]*B[k][j];\n		};\n	};\n	for (i=0;i<N;i++)\n	{\n		for (j=0;j<N;j++)\n		{\n			printf(\"%d  \", C[i][j]);\n		};\n		printf(\"\\n\");\n	};\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (146,'#include<stdio.h>\n#include<string.h>\nvoid quicksort(int *A, int l, int r)\n{	\n	int x,i,j,c;\n	i=l;\n	j=r;\n	x=(A[l]+A[r])/2;\n	while(i<j)\n	{\n		while(A[i]<x)\n		{\n			i++;\n		}\n		while(A[j]>x)\n		{\n			j--;\n		}\n		if(i<=j)\n		{\n			c=A[i];\n			A[i]=A[j];\n			A[j]=c;\n			i++;\n			j--;\n		}\n	}\n	if(i<r)\n	{\n		quicksort(A, i, r);\n	}\n	if(l<j)\n	{\n		quicksort(A, l, j);\n	}\n\n}\nint main()\n#define Nmax 100000\n{	\n	int k,l,r,N;\n	FILE *f;\n	FILE *g;\n	f=fopen(\"input11.txt\", \"r\");\n	g=fopen(\"output11.txt\", \"w\");\n	fscanf(f, \"%d\", &N);\n	int B[Nmax];\n	for(k=0;k<N;k++)\n	{\n		fscanf(f, \"%d\", &B[k]);\n	}\n	l=0;\n	r=N-1;\n	quicksort( B, l, r);\n	for(k=0;k<N;k++)\n	{\n		fprintf(g, \"%d \", B[k]);\n	}\n	fprintf(g, \"\\n\");\n	fclose(f);\n	fclose(g);\n\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (147,'#include<stdio.h>\n#include<string.h>\n#include<math.h>\nvoid sift(int *A, int N, int k)\n{\n	int a,b,c;\n	if(2*k+2<N)\n	{\n		if(A[2*k+1]<=A[2*k+2])\n		{\n			if(A[2*k+2]>A[k])\n			{\n				c=A[k];\n				A[k]=A[2*k+2];\n				A[2*k+2]=c;\n				sift(A,N,2*k+2);\n			}\n		}\n		else\n		{\n			 if(A[2*k+1]>A[k])\n			 {\n				 c=A[k];\n				 A[k]=A[2*k+1];\n				 A[2*k+1]=c;\n				 sift(A,N,2*k+1);\n			 }\n		}\n	}\n	if(2*k+1<N)\n	{	\n		if(A[2*k+1]>A[k])\n		{\n			 c=A[k];\n			 A[k]=A[2*k+1];\n			 A[2*k+1]=c;\n			 sift(A,N,2*k+1);\n		}\n\n	}\n}\nint main()\n{\n	#define Nmax 100000\n	int k,N,i,j=0,q,P,d=0;\n	FILE *f;\n	FILE *g;\n	g=fopen(\"output12.txt\", \"w\");\n	f=fopen(\"input12.txt\", \"r\");\n	fscanf(f, \"%d\", &N);\n	int B[Nmax];\n	for(k=0;k<N;k++)\n	{\n		fscanf(f, \"%d\", &B[k]);\n	}\n	for(i=N/2-1;i>=0;i--)\n	{	\n		sift(B,N,i);\n	}\n	P=N-1;\n	for(j=0;P!=0;j++)\n	{\n		q=B[0];\n		B[0]=B[P];\n		B[P]=q;\n		P--;\n		sift(B,P+1,0);	\n	}\n	for(k=0;k<N;k++)\n	{\n		fprintf(g, \"%d \", B[k]);\n	}\n	fprintf(g, \"\\n\");\n	fclose(f);\n	fclose(g);\n}	\n\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (148,'#include <stdio.h>\n#define N 5\n	\nint A[N];int i,k,j;\nint B[N];\n\nvoid number(void)\n{\ni=2;\nfor(k=0;k<N;k++)\n {\n A[k]=i++;\n }\n}\n\nvoid isprime(void)\n{\n	for(i=0;i<N;i++)\n	{\n		for(j=i+1;j<N;j++)\n		{\n			if (A[i]!=A[j])\n			{\n				if (A[i]!=0 && A[j]%A[i]==0) A[j]=0;\n			}\n		}\n	}\n}\n\nint main ()\n{\n	for (i = 0; i < N; i++)\n		scanf(\"%d\", &B[i]);\n\n	number();\n	isprime();\n\n	for (i = 0; i < N; i++)\n		printf(\"%d\\n\", A[i]);\n	printf(\"\\n\");\n\n	for (i=0;i<N;i++)\n	{\n		for(j=0;j<N;j++)\n		{\n		if (B[i]==A[j]) \n			printf(\"%d ???????\\n\", B[i]);\n		}\n	}\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (149,'#include<stdio.h>\n#include <stdlib.h>\nvoid quicksort(int *X, int l, int r)\n{\n	int x1=l, x2=r;\n	int s, mst;\n	if (r>l)\n	{\n		s=(X[l]+X[r])/2;\n		while (x1<=x2)\n		{\n			while ((x1<r) && (X[x1]<s))\n			{\n				x1++;\n			}\n			while ((x2>l) && (X[x2]>s))\n			{\n				x2--;\n			}\n			if (x1<=x2)\n			{\n				mst=X[x1];\n				X[x1]=X[x2];\n				X[x2]=mst;\n				x1++;\n				x2--;\n			}\n		}\n		if (l<x2) \n		{\n			quicksort (X, l, x2);\n		}\n		if (x1<r)\n		{\n			quicksort (X, x1, r);\n		}\n	}\n}\nint main ()\n{\n	int m, i;          \n	int *X;\n	FILE *f1, *f2;\n	f1=fopen (\"input.txt\",\"r\");\n	f2=fopen (\"output.txt\",\"w\");\n	fscanf (f1, \"%d\", &m); \n	X = malloc(m * sizeof(int));\n	for (i=0;i<m;i++)\n	{\n		fscanf (f1, \"%d\", &X[i] );\n	}\n	quicksort (X, 0,  m-1);\n	for (i=0;i<m;i++)\n	{\n		fprintf (f2 , \"%d \", X[i]);\n	}\n	fclose(f1);\n	fclose(f2);\n	free(X);\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (150,'#include<stdio.h>\n#define N 2\nint main()\n{\n	int A[N][N]; int B[N][N]; int C[N][N]={{0}}; int i,j,k;\n		for(i=0;i<N;i++)\n			for(j=0;j<N;j++)\n				scanf(\"%d\",&A[i][j]);\n		for(i=0;i<N;i++)\n			for(j=0;j<N;j++)\n				scanf(\"%d\",&B[i][j]);\n		for(i=0;i<N;i++)\n		{\n			for(j=0;j<N;j++)\n					{\n					for (k=0;k<N;k++)\n						C[i][j]=A[i][k]*B[k][j]+C[i][j];\n					printf(\"%d \",C[i][j]);\n					}\n			printf(\"\\n\");\n		}\n					\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (151,'#include<stdio.h>\n#define N 5\nint main()\n{\n	int A[N] = { 1, 3, 5, 7, 9 }; int i,j,k,c;\n	scanf(\"%d\", &c);\n	i=0;j=N-1;\n	do \n	{\n	k=(i+j)/2;\n	 if (c==A[k]) { printf(\"%d\\n\",c); return 0; }\n	 else \n	 	if (c<A[k]) j=k-1;\n		else i=k+1;\n	}\n	while(i<=j);\n	printf(\"????? ???\\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (152,'#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"long.h\"\n\nvoid free_int(struct long_int t)\n{\n	if(t.digits && t.digits != NULL)\n	{\n		free(t.digits);\n		t.digits = NULL;\n	}\n}\n\nstruct long_int create()\n{\n	struct long_int res;\n	res.sign = 1;\n	res.length = 0;\n	res.digits = NULL;\n	return res;\n}\n\nstruct long_int copy(struct long_int A)\n{\n	struct long_int res = create();\n	res.length = A.length;\n	if(res.length != 0) \n	{\n		res.sign = A.sign;\n		res.digits = calloc(res.length, sizeof(long long));\n		if(!res.digits){perror(\"calloc of varItem\"); return res; }\n		memcpy(res.digits, A.digits, sizeof(long long) * res.length);\n	}\n	return res;\n}\n\nvoid printInt(struct long_int t)\n{\n	int i;\n	int printnow = 0;\n	if(!t.length)\n	{\n		printf(\"0\\n\");\n		return;\n	}\n	if(t.sign == -1)\n		printf(\"-\");\n	for (i = t.length-1; i>=0; i--) {\n		if (printnow)\n			printf(\"%09lld\", t.digits[i]);\n		else if (t.digits[i] > 0) {\n			printf(\"%lld\", t.digits[i]);\n			printnow = 1;\n		}\n	}\n	if (!printnow) printf(\"0\");\n	printf(\"\\n\");\n}\n\nstruct long_int stringToInt(char *s)\n{\n	struct long_int res = create();\n	int i, tmp = 0, stepTen = 1, q = 0;\n	\n	if(s[0] == \'-\')\n	{\n		q = 1;\n		res.sign = -1;\n	}\n	else\n	{\n		res.sign = 1;\n		q = 0;\n	}\n	for(i = strlen(s)-1; i >= q; i--)\n	{\n		tmp += (s[i] - \'0\') * stepTen;\n		stepTen *= 10;\n		if(stepTen == BASE || (q == i && tmp>0) || strlen(s) == 1)\n		{\n			res.digits = realloc(res.digits, sizeof(long long) * (res.length + INT_SIZE));\n			if(!res.digits){ perror(\"realloc of int*\"); break; }\n			res.digits[res.length] = tmp;\n			res.length++;\n			tmp = 0;\n			stepTen = 1;\n		}\n	}\n	return res;\n}\n\nchar* intToString(struct long_int A)\n{\n	int j, l;\n	long long a;\n	char b[INT_SIZE+2];\n	char *res;\n	if(A.sign == -1)\n	{\n		res = calloc(A.length*(INT_SIZE+2)+3, sizeof(char));\n		if(!res){perror(\"calloc of varItem\"); return res; }\n		res[0] = \'(\';\n		res[1] = \'-\';\n		res[2] = 0;\n	}\n	else\n	{\n		res = calloc(A.length*(INT_SIZE+2)+2, sizeof(char));\n		if(!res){perror(\"calloc of varItem\"); return res; }\n		res[0] = \'(\';\n		res[1] = 0;\n	}\n\n	for(j=A.length-1; j>=0; j--)\n	{\n		a = A.digits[j];\n		if(j!=A.length-1 && a == 0)\n		{\n			strcat(res, \"000000000\");\n		}\n		else\n		{\n			if(j==A.length && a == 0)\n			{\n			}\n			else\n			{\n				sprintf(b, \"%09lld\", a);\n				b[INT_SIZE] = 0;\n				strcat(res, b);\n			}\n		}\n	}\n	l = strlen(res);\n	res[l] = \')\';\n	res[l+1] = 0;\n	return res;\n}\n\nint cmp(struct long_int A, struct long_int B)\n{\n	int i;\n\n	if(A.sign > B.sign)\n		return 1;\n	if(B.sign > A.sign)\n		return -1;\n\n	if(A.length > B.length)\n		return 1;\n	if(B.length > A.length)\n		return -1;\n\n	for(i = A.length-1; i >= 0; i--)\n		if(A.digits[i] > B.digits[i])\n			return 1;\n		else if(B.digits[i] > A.digits[i])\n			return -1;\n\n	return 0;\n}\n\nstruct long_int sum(struct long_int A, struct long_int B)\n{\n	int i;\n	struct long_int res = create();\n	if(A.sign != B.sign)\n	{\n		B.sign *= -1;\n		res = sub(A, B);\n		B.sign *= -1;\n	}\n	else\n	{\n		res.sign = A.sign;\n		res.length = A.length > B.length ? A.length+1 : B.length+1;\n		res.digits = calloc(res.length+1, sizeof(long long));\n		if(!res.digits){perror(\"calloc of varItem\"); return res; }\n		for(i = 0; i < res.length; i++)\n		{\n			if(i < A.length)\n				res.digits[i] += A.digits[i];\n			if(i < B.length)\n				res.digits[i] += B.digits[i];\n\n			res.digits[i+1] = res.digits[i] / BASE;\n			res.digits[i] %= BASE;\n		}\n	}\n	while(res.length && res.digits[res.length-1] == 0) res.length--;\n	return res;\n}\n\nstruct long_int sub(struct long_int A, struct long_int B)\n{\n	int i;\n	struct long_int res;\n	if(A.sign == 1 && B.sign == 1)\n	{\n		if(cmp(A, B) == -1)\n		{\n			res = sub(B, A);\n			res.sign = -1;\n		}\n		else\n		{\n			res = copy(A);\n			for(i = 0; i < res.length; i++)\n			{\n				if(i < B.length)\n					res.digits[i] -= B.digits[i];\n				if(res.digits[i] < 0)\n				{\n					res.digits[i] += BASE;\n					res.digits[i+1]--;\n				}\n				if(res.digits[i] == 0) res.length--;\n			}\n		}\n		return res;\n	}\n	else if(A.sign == 1 && B.sign == -1)\n	{\n		B.sign = 1;\n		res = sum(A, B);\n		return res;\n	}\n	else if(A.sign == -1 && B.sign == 1)\n	{\n		A.sign = 1;\n		res = sum(A, B);\n		res.sign = -1;\n		return res;\n	}\n	else\n	{\n		A.sign = 1;\n		B.sign = 1;\n		res = sub(A, B);\n		res.sign = -res.sign;\n		return res;\n	}\n}\n\nstruct long_int mul(struct long_int A, struct long_int B)\n{\n	int i, j;\n	struct long_int res = create();\n	res.sign = A.sign * B.sign;\n	res.length = A.length + B.length + 1;\n	res.digits = calloc(res.length, sizeof(long long));\n	if(!res.digits){perror(\"calloc of varItem\"); return res; }\n	for(i = 0; i < A.length; i++)\n		for(j = 0; j < B.length; j++)\n		{\n			res.digits[i+j] += A.digits[i] * B.digits[j];\n			if(res.digits[i+j] >= BASE)\n			{\n				res.digits[i+j+1] += res.digits[i+j] / BASE;\n				res.digits[i+j] %= BASE;\n			}\n		}\n	while(res.length && res.digits[res.length-1] == 0) res.length--;\n	return res;\n}\n\nstruct long_int mulShort(struct long_int A, long long B, int shift)\n{\n	int i;\n	struct long_int res = create();\n\n	res.length = A.length + shift + 1;\n	res.digits = calloc(res.length, sizeof(long long));\n	if(!res.digits){perror(\"calloc of varItem\"); return res; }\n	for(i=0; i<A.length; i++)\n	{\n		res.digits[shift+i] += B * A.digits[i];\n		res.digits[shift+i+1] = res.digits[shift+i] / BASE;\n		res.digits[shift+i] %= BASE;\n	}\n	while(res.length && res.digits[res.length-1] == 0) res.length--;\n	return res;\n}\n\nstatic void Subtract(struct long_int *A, struct long_int B)\n{\n	int i;\n	for(i=0; i<(*A).length; i++)\n	{\n		if(i < B.length)\n			(*A).digits[i] -= B.digits[i];\n		\n		if((*A).digits[i] < 0)\n		{	\n			(*A).digits[i] += BASE;\n			(*A).digits[i+1]--;\n		}\n	}\n	if((*A).length && (*A).digits[(*A).length-1] == 0)\n	       (*A).length--;	\n}\n\nstruct long_int divv(struct long_int A, struct long_int B)\n{\n	int i;\n	struct long_int res = create();\n	if(cmp(A, B) == -1)\n	{\n		res.sign = 1;\n		res.length = 1;\n		res.digits = calloc(res.length, sizeof(long long));\n		return res;\n	}\n	res.length = A.length - B.length + 1;\n	res.sign = A.sign * B.sign;\n	A.sign = 1; B.sign = 1;\n	res.digits = calloc(res.length, sizeof(long long));\n	if(!res.digits) {perror(\"calloc of varItem\"); return res; }\n	for(i=res.length-1; i>=0; i--)\n	{\n		struct long_int tmp = create();\n		\n		long long min = 0, max = BASE, mid;\n		do\n		{\n			int cmpRes;\n			mid = (min+max)/2;\n			tmp = mulShort(B, mid, i);\n			cmpRes = cmp(A, tmp);\n			if(cmpRes == 1)\n			{\n				free_int(tmp);\n				min = mid + 1;\n			}\n			if(cmpRes == -1)\n			{\n				free_int(tmp);\n				max = mid - 1;\n			}\n			if(cmpRes == 0)\n			{\n				res.digits[i] = mid;\n				Subtract(&A, tmp);\n				free_int(tmp);\n				return res;\n			}\n		}\n		while(min <= max);\n		res.digits[i] = mid = (min+max)/2;\n		tmp = mulShort(B, mid, i);\n		Subtract(&A, tmp);\n		free_int(tmp);\n	}\n	while(res.length && res.digits[res.length-1] == 0) res.length--;\n	return res;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (153,'#define _CRT_SECURE_NO_WARNINGS\n\n#include <crtdbg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include \"stack.h\"\n#include \"vars.h\"\n\n#define N 100\nstruct varItem *vars[N];\n\nchar *toPol(char* str)\n{\n	char *s;\n	struct stack *operands;\n	unsigned int i = 0, ir = 0, sign = 0, state = 1;\n	char *res = calloc(ir+1, sizeof(char));\n	if(!res){perror(\"calloc of char\"); return 0; }\n	createStack(&operands, 0);\n	for(i=0; i<strlen(str); i++)\n	{\n		if(isdigit(str[i]))\n		{\n			if(sign%2 != 0)\n			{\n				sign = 0;\n				if(i == 1)\n				{\n					res = realloc(res, ir+2);\n					if(!res){perror(\"realloc of char\"); return 0; }\n					res[ir++] = \'-\';\n				}\n				else\n				{\n					res = realloc(res, ir+3);\n					if(!res){perror(\"realloc of char\"); return 0; }\n					res[ir++] = \' \';\n					res[ir++] = \'-\';\n				}\n			}\n			res = realloc(res, ir+2);\n			if(!res){perror(\"realloc of char\"); return 0; }\n			res[ir++] = str[i];\n			state = 0;\n		}\n		if(str[i] == \'(\')\n		{\n			push(&operands, &str[i]);\n			state = 1;\n		}\n		if(str[i] == \')\')\n		{\n			char *curr = top(operands);\n			while(curr[0] != \'(\')\n			{\n				res = realloc(res, ir+3);\n				if(!res){perror(\"realloc of char\"); return 0; }\n				res[ir++] = \' \';\n				res[ir++] = curr[0];\n				s = pop(&operands);\n				free(s);\n				curr = top(operands);\n			}\n			s = pop(&operands);\n			free(s);\n		}\n		if (str[i] == \'+\' || str[i] == \'-\')\n		{\n			if(!empty(operands))\n			{\n				char *curr = top(operands);\n				while(state == 0 && (curr[0] == \'+\' || curr[0] == \'-\' || curr[0] == \'*\' || curr[0] == \'/\'))\n				{\n					res = realloc(res, ir+3);\n					if(!res){perror(\"realloc of char\"); return 0; }\n					res[ir++] = \' \';\n					res[ir++] = curr[0];\n					s = pop(&operands);\n					free(s);\n					curr = top(operands);\n					if(!curr) break;\n				}\n			}\n			if(state == 1)\n			{\n				state = 0;\n				sign++;\n			}\n			else\n			{\n				res = realloc(res, ir+2);\n				res[ir++] = \' \';\n				push(&operands, &str[i]);\n			}\n		}\n		if (str[i] == \'*\' || str[i] == \'/\')\n		{\n			if(!empty(operands))\n			{\n				char *curr = top(operands);\n				while(curr[0] == \'*\' || curr[0] == \'/\')\n				{\n					res = realloc(res, ir+3);\n					if(!res){perror(\"realloc of char\"); return 0; }\n					res[ir++] = \' \';\n					res[ir++] = curr[0];\n					s = pop(&operands);\n					free(s);\n					curr = top(operands);\n					if(!curr) break;\n				}\n			}\n			res = realloc(res, ir+2);\n			if(!res){perror(\"realloc of char\"); return 0; }\n			res[ir++] = \' \';\n			push(&operands, &str[i]);\n		}\n	}\n	while(!empty(operands))\n	{\n		char *s;\n		char *curr = top(operands);\n		res = realloc(res, ir+3);\n		if(!res){perror(\"realloc of char\"); return 0; }\n		res[ir++] = \' \';\n		res[ir++] = curr[0];\n		s = pop(&operands);\n		free(s);\n	}\n	res[ir] = 0;\n	free(str);\n	destroyStack(&operands);\n	return res;\n}\n\nstruct long_int calcPol(char *in)\n{\n	unsigned int i, sign = 0, state = 1, l = 1;\n	struct long_int resCurr, curr = create();\n	struct long_int *res;\n	char *s = calloc(strlen(in)+1, sizeof(char));\n	struct stack *numbers;\n	s[0] = 0;\n	createStack(&numbers, 1);\n	for(i=0; i<strlen(in); i++)\n	{\n		if( ( ((i<strlen(in)-1) && in[i+1]==\' \') || (i==strlen(in)-1) ) && (in[i] == \'+\' || in[i] == \'-\' || in[i] == \'*\' || in[i] == \'/\'))\n		{\n			struct long_int *b = pop(&numbers);\n			struct long_int *a = pop(&numbers);\n			if (in[i] == \'+\')	resCurr = sum((*a), (*b));\n			if (in[i] == \'-\')	resCurr = sub((*a), (*b));\n			if (in[i] == \'*\')	resCurr = mul((*a), (*b));\n			if (in[i] == \'/\')\n			{\n				if((*b).length == 0 || ((*b).length == 1 && (*b).digits[0] == 0))\n				{\n					printf(\"Div by zero!\\n\");\n					resCurr = create();\n				}\n				else\n					resCurr = divv((*a), (*b));\n			}\n			if(resCurr.length == 0)\n			{\n				free_int(resCurr);\n				resCurr.sign = 1;\n				resCurr.length = 1;\n				resCurr.digits = calloc(1, sizeof(long long));\n			}\n			push(&numbers, &resCurr);\n			free_int((*a));		free(a);\n			free_int((*b));		free(b);\n			free_int(resCurr);\n		}\n		if(in[i] != \' \')\n		{\n			if(isdigit(in[i]))\n			{\n				s[l-1] = in[i];\n				s[l] = 0;\n				l++;\n			}\n			if(in[i] == \'-\' && state == 1)\n				sign = 1;\n			state = 0;\n		}\n		if(in[i] == \' \' || i == strlen(in)-1)\n		{\n			l = 1;\n			state = 1;\n			curr  = stringToInt(s);\n			if(sign){ curr.sign = -curr.sign;	sign = 0; }\n			if((i!=0 && isdigit(in[i-1])) || isdigit(in[i]))\n				push(&numbers, &curr);\n			free_int(curr);\n		}\n	}\n	res = pop(&numbers);\n	if(res)\n	{\n		/*int i;\n		curr.sign = (*res).sign;\n		curr.length = (*res).length;\n		for(i=0; i<curr.length; i++)\n			curr.digits[i] = (*res).digits[i];*/\n		curr = copy((*res));\n		free_int((*res));\n		free(res);\n	}\n	free(s);\n	destroyStack(&numbers);\n	return curr;\n}\n\nchar *changeVarsToValue(char *s)\n{\n	unsigned int i, j;\n	int lr = 1, lt = 1; // length of res and tmp\n	struct long_int varValue = create();\n	char *res = \"\", *tmp;\n	res = calloc(lr, sizeof(char));\n	if(!res){perror(\"calloc of char\"); return 0; }\n	tmp = calloc(lt, sizeof(char));\n	if(!tmp){perror(\"calloc of char\"); return 0; }\n	for(i=0; i<strlen(s); i++)\n	{\n		if(isdigit(s[i]) || s[i] == \'(\'|| s[i] == \')\' || s[i] == \'+\' || s[i] == \'-\' || s[i] == \'*\' || s[i] == \'/\')\n		{\n			if(tmp[0])\n			{\n				varValue = get_value(vars, tmp);\n				free(tmp);\n				tmp = intToString(varValue);\n				for(j=0; j<strlen(tmp); j++)\n				{\n					res = realloc(res, ++lr);\n					if(!res){perror(\"realloc of char\"); return 0; }\n					*(res+lr-2) = tmp[j];\n					*(res+lr-1) = 0;\n				}\n				lt = 1;\n				free(tmp);\n				tmp = calloc(lt, sizeof(char));\n				if(!tmp){perror(\"calloc of char\"); return 0; }\n			}\n			res = realloc(res, ++lr);\n			if(!res){perror(\"realloc of char\"); return 0; }\n			*(res+lr-2) = s[i];\n			*(res+lr-1) = 0;\n		}\n		else\n		{\n			tmp = realloc(tmp, ++lt);\n			if(!tmp){perror(\"realloc of char\"); return 0; }\n			*(tmp+lt-2) = s[i];\n			*(tmp+lt-1) = 0;\n		}\n	}\n	if(tmp[0])\n	{\n		varValue = get_value(vars, tmp);\n		free(tmp);\n		tmp = intToString(varValue);\n		for(j=0; j<strlen(tmp); j++)\n		{\n			res = realloc(res, ++lr);\n			if(!res){perror(\"realloc of char\"); return 0; }\n			*(res+lr-2) = tmp[j];\n			*(res+lr-1) = 0;\n		}\n		lt = 1;\n		if(strcmp(tmp, \"()\") != 0)\n			free(tmp);\n		tmp = calloc(lt, sizeof(char));\n		if(!tmp){perror(\"calloc of char\"); return 0; }\n	}\n	free(tmp);\n	free(s);\n	return res;\n}\n\nvoid parser()\n{\n	int k = 0; // key for string\n	int ch = 0;\n	int ln = 1, lv = 1;\n	struct long_int res;\n	char *name, *value;\n	name = calloc(ln, sizeof(char));\n	if(!name){perror(\"calloc of char\"); return; }\n	value = calloc(lv, sizeof(char));\n	if(!value){perror(\"calloc of char\"); return; }\n	while(1)\n	{\n		ch = getchar();\n		// end work of program5\n		if(ch == EOF)\n			break;\n		// end of string\n		if(ch == 10)\n		{\n			if(name[0] == 0)\n			{\n				printf(\"Empty expression\\n\");\n				continue;\n			}\n			// k == 0 : only expression, not var for save\n			if(k == 0)\n			{\n				if(strcmp(name, \"print\") == 0)\n				{\n					printVars(vars);\n				}\n				else\n				{\n					name = changeVarsToValue(name);\n					name = toPol(name);\n					res = calcPol(name);\n					printInt(res);\n					free_int(res);\n				}\n			}\n			else \n			{\n				// k == 1 : var with expression\n				value = changeVarsToValue(value);\n				value = toPol(value);\n				res = calcPol(value);\n				set_value(vars, name, res);\n				printInt(res);\n				free_int(res);\n			}\n			k = 0; ln = 1; lv = 1;\n			free(name);\n			name = calloc(ln, sizeof(char));\n			if(!name){perror(\"calloc of char\"); return; }\n			free(value);\n			value = calloc(lv, sizeof(char));\n			if(!value){perror(\"calloc of char\"); return; }\n		}\n		else\n		{\n			if(ch == \'=\')\n			{\n				k++;\n			}\n			else\n			{\n				if(k == 0)\n				{\n					name = realloc(name, ++ln);\n					if(!name){perror(\"realloc of char\"); return; }\n					*(name+ln-2) = ch;\n					*(name+ln-1) = 0;\n				}\n				if(k == 1)\n				{\n					value = realloc(value, ++lv);\n					if(!value){perror(\"realloc of char\"); return; }\n					*(value+lv-2) = ch;\n					*(value+lv-1) = 0;\n				}\n			}\n		}\n	}\n	printf(\"%s\\n\", name);\n	free(name);\n	printf(\"%s\\n\", value);\n	free(value);\n}\n\nint main()\n{\n	parser();\n	cleanup(vars);\n	_CrtDumpMemoryLeaks();\n	return 0;\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (154,'#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n#include \"long.h\"\n\nvoid push(struct stack **st, void *data)\n{\n	struct item *tmp;\n	tmp = malloc(sizeof(struct item));\n	if(!tmp){ perror(\"malloc of item\"); return; }\n\n	if ((*st)->mode == 1)\n	{\n		struct long_int *z = data;\n		struct long_int *p;\n		p = malloc(sizeof(struct long_int));\n		if(!p){	perror(\"malloc of int\"); return; }\n		p->digits = calloc(z->length, sizeof(long long));\n		if(!p->digits){	perror(\"malloc of int\"); return; }\n		{\n			int i;\n			(*p).sign = (*z).sign;\n			(*p).length = (*z).length;\n			for(i=0; i<(*p).length; i++)\n				(*p).digits[i] = (*z).digits[i];\n		}\n		tmp->data = p;\n	}\n	else\n	{\n		char *p = data;\n		char tp = *p;\n		p = calloc(2, sizeof(char));\n		if(!p){	perror(\"malloc of char\"); return; }\n		(*p) = tp;\n		*(p+1) = 0;\n		tmp->data = p;\n	}\n	if(empty((*st)))\n	{\n		tmp->next = NULL;\n		(*st)->curr = tmp;\n	}\n	else\n	{\n		tmp->next = (*st)->curr;\n		(*st)->curr = tmp;\n	}\n}\n\nvoid *pop(struct stack **st)\n{\n	struct item *tmp;\n	struct long_int *p = NULL;\n	char *res = NULL;\n	if(!empty((*st)))\n	{\n		if((*st)->mode == 1)\n			p = (*st)->curr->data;\n		else\n			res = (*st)->curr->data;\n		tmp = (*st)->curr->next;\n		free((*st)->curr);\n		(*st)->curr = tmp;\n		if((*st)->mode == 1)\n			return p;\n		else\n			return res;\n	}\n	else\n		return res;\n}\n\nvoid *top(struct stack *st)\n{\n	if(!empty(st))\n	{\n		if(st->mode == 1)\n		{\n			return st->curr->data;\n		}\n		else\n		{\n			char *res = st->curr->data;\n			res[1] = 0;\n			return res;\n		}\n	}\n	return NULL;\n}\n\nint empty(struct stack *st)\n{\n	if(st == NULL)\n		return 1;\n	if(st->curr == NULL)\n		return 1;\n	return 0;\n}\n\nvoid createStack(struct stack **st, int mode)\n{\n	(*st) = malloc(sizeof(struct stack));\n	if(!(*st)){	perror(\"malloc of stack\"); return; }\n	(*st)->mode = mode;\n	(*st)->curr = NULL;\n}\n\nstatic void desStack(struct stack **st)\n{\n	struct item *tmp;\n	while(!empty((*st)))\n	{\n		tmp = (*st)->curr->next;\n		if((*st)->mode == 1)\n		{\n			struct long_int *tmp = (*st)->curr->data;\n			free_int((*tmp));\n		}\n		free((*st)->curr->data);\n		free((*st)->curr);\n		(*st)->curr = tmp;\n	}\n}\n\nvoid destroyStack(struct stack **st)\n{\n	if(!empty((*st)))\n		desStack(st);\n	free((*st));\n	(*st) = NULL;\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (155,'#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"vars.h\"\n\n#define N 100\n\nstatic unsigned int hash(const char *s)\n{\n	unsigned int res = 0;\n	while (*s)\n	{\n		res = (res*37 + *s) % N;\n		s++;\n	}\n	return res;\n}\n\nvoid set_value(struct varItem **vars, char *name, struct long_int value)\n{\n	struct varItem *p, *q;\n	for(q=vars[hash(name)]; q; q=q->next)\n		if(strcmp(q->name, name) == 0)\n		{\n			{\n				int i;\n				free_int(q->value);\n				q->value.sign = value.sign;\n				q->value.length = value.length;\n				q->value.digits = calloc(q->value.length, sizeof(long long));\n				if(!q->value.digits){perror(\"calloc of varItem\"); return; }\n				for(i=0; i<q->value.length; i++)\n					q->value.digits[i] = value.digits[i];\n			}\n			return;\n		}\n	p = malloc(sizeof(struct varItem));\n	if(!p){	perror(\"malloc of varItem\"); return; }\n	p->name = calloc(strlen(name)+1, sizeof(char));\n	strcpy(p->name, name);\n	{\n		int i;\n		p->value.sign = value.sign;\n		p->value.length = value.length;\n		p->value.digits = calloc(value.length, sizeof(long long));\n		if(!p->value.digits){perror(\"calloc of varItem\"); return; }\n		for(i=0; i<p->value.length; i++)\n			p->value.digits[i] = value.digits[i];\n	}\n	p->next = vars[hash(name)];\n	vars[hash(name)] = p;\n	return;\n}\n\nstruct long_int get_value(struct varItem **vars, char *name)\n{\n	struct varItem *p;\n	struct long_int res;\n	for(p=vars[hash(name)]; p; p=p->next)\n		if(strcmp(p->name, name) == 0)\n			return p->value;\n	res.sign = 1;\n	res.length = 1;\n	res.digits = calloc(1, sizeof(long long));\n	if(!res.digits){perror(\"calloc of varItem\"); return res; }\n	set_value(vars, name, res);\n	free_int(res);\n	return get_value(vars, name);\n}\n\nvoid printVars(struct varItem **vars)\n{\n	int i;\n	struct varItem *p;\n	printf(\"-  Vars  -\\n\");\n	for(i=0; i<N; i++)\n		for(p=vars[i]; p; p=p->next)\n		{\n			printf(\"%s = \", p->name);\n			printInt(p->value);\n		}\n	printf(\"-  End  -\\n\");\n}\n\nvoid cleanup(struct varItem **vars)\n{\n	int i;\n	struct varItem *p, *q;\n	for(i=0; i<N; i++)\n		for(p=vars[i]; p; p=vars[i])\n		{\n			q = vars[i]->next;\n			if(p->name)\n				free(p->name);\n			free_int(p->value);\n			free(p);\n			vars[i] = q;\n		}\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (156,'#include \"long.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n//#define DD\n#define START_INT_LEN 50\n#define BASE 10000\n\nstatic void reallocate_li(long_int*,int);\nstatic void destroy_zeroes(long_int*);\nstatic void shift(long_int*,int);\nstatic int max (int,int);\nstatic int min (int,int);\n\nvoid print_li(long_int* a){\n	int len;\n	len = a->length;\n	if (a->sign == -1&&(a->length!=1 && a->digits[0]!=0)){\n		printf(\"-\");\n	}\n	while(len!=0){\n		printf((len==a->length)?\"%d\":\"%04d\",a->digits[len-1]);\n#ifdef DD\n		printf(\" \");\n#endif\n		len--;\n	}\n}\nvoid free_li (long_int* a){\n	free(a->digits);\n}\n\nvoid init_long (long_int* a,int size,char* str){\n	int i,len,cnt=0,j=0;\n	a->digits = (int*)calloc(size,sizeof(int));\n	if (!a->digits){\n		perror(\"calloc\");\n	}\n	if (str){\n		len = strlen(str);\n		for (i=len-1;i>=0;i--){\n			if (cnt==4){cnt=0;j++;}\n			if (cnt==0){\n				a->digits[j]+=str[i]-\'0\';\n				cnt++;\n			} else if (cnt == 1) {\n				a->digits[j]+=10*(str[i]-\'0\');\n				cnt++;\n			} else if (cnt == 2) {\n				a->digits[j]+=100*(str[i]-\'0\');\n				cnt++;\n			} else if (cnt == 3) {\n				a->digits[j]+=1000*(str[i]-\'0\');\n				cnt++;\n			}\n		}\n	}\n	a->length = size;\n	a->sign = 1;	\n}\n\nlong_int add (long_int a, long_int b){\n	long_int c;\n	int i,shift=0,booly=-1;\n	int maxlen,minlen;\n	if (a.sign == b.sign){\n	if (a.length >= b.length){\n			maxlen = a.length;\n			minlen = b.length;\n			booly = 1010;\n		} else {\n			maxlen = b.length;\n			minlen = a.length;\n			booly = 1011;\n		}\n		\n		init_long(&c,maxlen+1,NULL);\n		for (i=0;i<minlen;i++){\n			int sum = a.digits[i]+b.digits[i]+shift;\n			if (sum >= BASE) \n				c.digits[i] = sum - BASE;\n			else\n				c.digits[i] = sum;\n			shift = sum/BASE;\n		}\n		for (;i<maxlen;i++){\n			int sum = (booly == 1010)?a.digits[i]+shift:b.digits[i]+shift;\n			if (sum >= BASE)\n				c.digits[i] = sum - BASE;\n			else \n				c.digits[i] = sum;\n			shift = sum/BASE;\n		}\n		c.digits[i]+=shift;\n		c.sign = a.sign;\n		if (c.digits[i]==0)\n			reallocate_li(&c,c.length-1);\n	} else if(a.sign == 1){\n		c = sub(a,b);\n	} else {\n		c = sub(b,a);\n		c.sign = -1;\n	}\n	return c;\n}\n\nlong_int sub (long_int a, long_int b){\n	long_int c;\n	int buf = 0,booly = -1,i,sgn=0;\n	int maxlen,t=0;\n	if (a.sign == b.sign){\n		t = compare_li(a,b);\n		if (t>0 && a.sign == 1){\n			booly = 1010;\n			sgn = 1;\n			maxlen = a.length;\n		} else if (t<0 && a.sign == 1){\n			booly = 1011;\n			sgn = -1;\n			maxlen = b.length;\n		} else if (t == 0){\n			init_long(&c,1,NULL);\n			return c;\n		} else if (t>0 && a.sign == -1){\n			booly = 1011;\n			sgn = 1;\n			maxlen = b.length;\n		} else if (t<0 && a.sign == -1){\n			booly = 1010;\n			sgn = -1;\n			maxlen = a.length;\n		}		\n		\n		init_long(&c,maxlen,NULL);\n		for (i=0;i<maxlen;i++){\n			int op1 = (i<a.length)?a.digits[i]:0;\n			int op2 = (i<b.length)?b.digits[i]:0;\n		\n			c.digits[i] = (booly == 1010)?(op1 - op2 + buf):(op2 - op1 +buf);	\n			if (c.digits[i] < 0){\n				c.digits[i] += BASE;\n				buf = -1;\n			}\n			else \n				buf = 0;\n		}\n		c.sign = sgn;\n		destroy_zeroes(&c);\n	} else {\n		c = add(a,b);\n		c.sign = a.sign;\n	}\n	return c;\n}\n\nint  compare_li (long_int a, long_int b){\n	int i;\n	if (a.sign > b.sign)return 1;\n	if (b.sign > a.sign)return -1;\n\n	if (a.length > b.length){\n		return 1;\n	} else if (b.length > a.length){\n		return -1;\n	} else {\n		for (i = a.length-1;i>=0;i--){\n			if (a.digits[i] == b.digits[i]) continue;\n			if (a.sign > 0)\n				return (a.digits[i]<b.digits[i])?-1:1;\n			else \n				return (a.digits[i]<b.digits[i])?1:-1;\n		}\n	}\n	return 0;\n}\n\nlong_int mul (long_int a,long_int b){\n	static int TIMES = 9;\n	int i,j,len,t1,t2;\n	long_int c;\n\n	t2 = 0;\n	\n	len = a.length + b.length;\n	init_long(&c,len,NULL);\n	for (i=0;i<len;i++){\n		int cnt = 0;\n		t1 = t2;\n		t2 = 0;\n		for (j = max(0, i-b.length+1); j <= min(i,a.length-1); j++){\n			t1 += a.digits[j] * b.digits[i-j];\n			if ((++cnt) == TIMES){\n				t2 += t1/BASE;\n				t1 %= BASE;\n				cnt = 0;\n			}\n		}\n		t2 += t1/BASE;\n		c.digits[i] = t1 % BASE;\n	}\n	c.sign = a.sign * b.sign;\n	destroy_zeroes(&c);\n	return c;\n}\nlong_int mul_short (long_int a, int b){\n	long_int c;\n	int buf=0,i,sgn;\n	if (b>=0)sgn = 1;\n	else { sgn = -1; b*=-1;}\n	init_long(&c,a.length + 9,NULL);\n	for (i = 0;i<a.length;i++){\n		c.digits[i] = a.digits[i] * b;\n		c.digits[i] += buf;\n\n		buf = c.digits[i]/BASE;\n		c.digits[i] %= BASE;\n	}\n	c.digits[i]+=buf;\n	c.sign = a.sign * sgn;\n	destroy_zeroes(&c);\n	return c;\n}\n\nlong_int divide (long_int a,long_int b){\n	long_int c,reminder;\n	int i;\n	if (a.length < b.length){\n		init_long(&c,1,NULL);\n		return c;\n	}\n	init_long (&c,a.length - b.length +1,NULL);	\n	make_copy(&reminder,a);\n	for (i = c.length - 1; i>=0 ;i--){\n		int dig;\n		long_int prod,clone;\n		int left = 0,right = BASE;\n		int middle;\n		while (right - left > 1){\n			middle = (left+right)/2;\n			prod = mul_short(b,middle);\n			shift(&prod,i);\n			if (compare_li(reminder,prod) >= 0) left = middle;\n			else right = middle;\n			free_li(&prod);\n		}\n		dig = left;\n		prod = mul_short(b,dig);\n		shift(&prod,i);\n		c.digits[i] = dig;\n		make_copy(&clone,reminder);\n		free_li(&reminder);\n		reminder = sub (clone,prod);\n		free_li(&prod);\n		free_li(&clone);\n	}\n	destroy_zeroes(&c);\n	c.sign = a.sign * b.sign;\n	free_li(&reminder);\n	return c;\n}\nstatic void destroy_zeroes (long_int* a){\n	int prl = a->length;\n	while (a->length > 1 && a->digits[a->length-1] == 0) a->length--;\n	if (a->length != prl)\n		reallocate_li(a,a->length);\n}\nstatic void shift (long_int* a,int size){\n	int i;\n	reallocate_li(a,a->length + size);\n	for (i = a->length-1;i>=size;i--){\n		a->digits[i] = a->digits[i-size];\n	}\n	for ( ;i>=0;i--){\n		a->digits[i] = 0;\n	}\n}\nstatic int max (int a,int b){\n	return (a>=b)?a:b;\n}\nstatic int min (int a,int b){\n	return (a>=b)?b:a;\n}\nstatic void reallocate_li(long_int *a,int newsize){\n	int* q = (int*)realloc(a->digits,newsize*sizeof(int));\n	if (!q)\n		perror(\"realloc\");\n	a->digits = q;\n	a->length = newsize;\n}\n\nvoid make_copy (long_int* a,long_int b){\n	int i;\n	init_long(a,b.length,NULL);\n	a->sign = b.sign;\n	for (i=0;i<b.length;i++){\n		a->digits[i] = b.digits[i];\n	}\n}\n		\n	\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (157,'#ifdef WIN32\n#define _CRT_SECURE_NO_WARNINGS\n#define _CRTDBG_MAP_ALLOC\n#include <crtdbg.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#include \"long.h\"\n#include \"stack.h\"\n#include \"vars.h\"\n\n#define MAX_INT_LEN 15\n#define MAX_VAR_LEN 25\n\n\n#define _RELEASE\n\nstatic long_int calculate ( long_int op1 , long_int op2 , char oper );\nint main()\n{\n	stack *charStack=NULL, *intStack=NULL;\n	char *str=NULL;\n	char *towrite = NULL;\n	char *varstr = NULL;\n	int c=0;\n	int curr_INT_LEN = MAX_INT_LEN;\n	int curr_VAR_LEN = MAX_VAR_LEN;\n\n	int sign = 1;\n	long_int end_result;\n	int prevchar=0;\n	// 0 : ??? ???? ????????\n	// 1 : ???? ?????\n	// 2 : ???? ????? ...\n	// 4 : ???? )\n	int waseq = 0;	\n	//??????? ?????? ? ????????\n	str = (char*)malloc(MAX_INT_LEN*sizeof(char));//Str for int\n	varstr = (char*)malloc(MAX_VAR_LEN*sizeof(char));//Str for var name\n	if (!str || !varstr){\n		perror(\"malloc\");\n		return 1;\n	}\n	str[0]=\'\\0\';\n	varstr[0]=\'\\0\';\n	charStack = createStack(__c);\n	intStack = createStack(__l);\n	while(1){\n#ifdef WIN32\n		if (c==4) break;\n#else\n		if (c==-1) break;\n#endif\n		while(1){\n			c = getchar();\n#ifdef WIN32\n			if (c==4) break;\n#else\n			if (c==EOF) break;\n#endif\n			if (c == \'\\t\' || c == \' \') continue;\n			if (c == \'=\'){\n				towrite =(char*)malloc(curr_VAR_LEN*(sizeof(char)));\n				if (!towrite){\n					perror(\"malloc\");\n					exit(0);\n				}\n				towrite[0]=\'\\0\';\n				if (varstr[0] == \'\\0\'){\n					printf(\"Syntax Error: Check before \'=\'.\\n\");\n				}\n				strcpy(towrite,varstr);\n				varstr[0]=\'\\0\';\n				waseq = 1;\n				prevchar = 0;\n				continue;\n			}\n			if (isalpha(c)||c==\'_\'){\n					if (prevchar != 2){//???? ?? ????? ?? ???? ????\n						char tempstr[2];\n						tempstr[0]=c;\n						tempstr[1]=\'\\0\';\n							\n						strcpy(varstr,tempstr);\n						prevchar = 2;\n					} else {\n						char tempstr[2];\n						tempstr[0]=c;\n						tempstr[1]=\'\\0\';\n						if (strlen(varstr)==curr_VAR_LEN-2){\n							char *temp;\n							temp = (char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!temp){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(temp,varstr);\n							free(varstr);\n							curr_VAR_LEN+=50;\n							varstr=(char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!varstr){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(varstr,temp);\n							free(temp);\n						}\n						strcat(varstr,tempstr);\n					}				\n				continue;\n			}\n			if (isdigit(c)){\n				if (prevchar == 0){ /*|| prevchar == 4){*///???? ?? ????? ??? ???? ????????\n					char tempstr[2];\n					tempstr[0]=c;\n					tempstr[1]=\'\\0\';\n					strcpy(str,tempstr);\n					prevchar = 1;\n				} else if (prevchar == 2){ \n						char tempstr[2];\n						tempstr[0]=c;\n						tempstr[1]=\'\\0\';\n						if (strlen(varstr)==curr_VAR_LEN-2){\n							char *temp;\n							temp = (char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!temp){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(temp,varstr);\n							free(varstr);\n							curr_VAR_LEN+=50;\n							varstr=(char*)malloc(curr_VAR_LEN*(sizeof(char)));\n							if (!varstr){\n								perror(\"malloc\");\n								exit(0);\n							}\n							strcpy(varstr,temp);\n							free(temp);\n						}\n						strcat(varstr,tempstr);\n				} else if (prevchar == 1){// ???? ?? ????? ??? ?????\n					char tempstr[2];\n					tempstr[0]=c;\n					tempstr[1]=\'\\0\';\n					if (strlen(str)==curr_INT_LEN-2){\n						char *temp;\n						temp = (char*)malloc(curr_INT_LEN*(sizeof(char)));\n						if (!temp){\n							perror(\"malloc\");\n							exit(0);\n						}\n						strcpy(temp,str);\n						free(str);\n						curr_INT_LEN+=50;\n						str=(char*)malloc(curr_INT_LEN*(sizeof(char)));\n						if (!str){\n							perror(\"malloc\");\n							exit(0);\n						}\n						strcpy(str,temp);\n						free(temp);\n					}\n					strcat(str,tempstr);\n				} else if (prevchar == 4){\n					printf(\"Syntax error: Check after \')\'.\");\n				}	\n				continue;		\n			}\n			else if (prevchar == 1){\n				long_int a;\n				int len;\n				//a = sign*atoi(str);\n				len = strlen(str);\n				init_long(&a,(len/4*4==len)?len/4:len/4+1,str);\n				a.sign = sign;\n				sign = 1;\n				push(intStack,&a);\n#ifndef _RELEASE\n				//printf(\"%d \",a);\n				print_li(&a);\n				putchar(\'\\n\');\n#endif\n				free_li(&a);\n			}\n			if (c == \'(\'){\n				push(charStack,&c);\n				prevchar = 0;\n			}\n			else if (c == \')\'){\n				char t;\n				if (prevchar == 2){\n					long_int val;\n					//val = get_value(varstr);\n					make_copy(&val,get_value(varstr));\n#ifndef _RELEASE\n					//printf(\"%d \",val);\n					print_li(&val);\n					putchar(\'\\n\');\n#endif\n					varstr[0] = \'\\0\';\n					push(intStack,&val);\n					free_li(&val);\n				}\n				prevchar = 4;\n				if (!empty(charStack)){\n					t =*(char*)top(charStack);\n					while (t != \'(\'){\n						long_int result;\n						long_int op1,op2;\n\n						//op1 = *(int*)top(intStack);\n						make_copy(&op1,*(long_int*)top(intStack));\n						pop(intStack);\n						//op2 = *(int*)top(intStack);\n						make_copy(&op2,*(long_int*)top(intStack));\n						pop(intStack);\n						result = calculate(op1,op2,t);\n						push(intStack,&result);\n#ifndef _RELEASE\n						printf(\" %c \",t);\n#endif\n						pop(charStack);\n						if (!empty(charStack)){\n							t = *(char*)top(charStack);\n						}\n						else t = 0;\n						free_li(&result);\n						free_li(&op1);\n						free_li(&op2);\n					}\n					pop(charStack);\n				}\n			}\n			else if (c == \'*\' || c == \'/\'){\n				char t;\n				if (prevchar == 2){\n					long_int val;\n					val = get_value(varstr);\n					//make_copy(&val,get_value(varstr));\n#ifndef _RELEASE\n					//printf(\"%d \",val);\n					print_li(&val);\n#endif\n					varstr[0] = \'\\0\';\n					push(intStack,&val);\n					free_li(&val);\n				}\n				prevchar = 0;\n				if (!empty(charStack)){\n					t = *(char*)top(charStack);\n					while (t== \'*\' || t == \'/\'){\n						long_int result;\n						long_int op1,op2;\n\n						//op1 = *(int*)top(intStack);\n						make_copy(&op1,*(long_int*)top(intStack));\n						pop(intStack);\n						//op2 = *(int*)top(intStack);\n						make_copy(&op2,*(long_int*)top(intStack));\n						pop(intStack);\n						result = calculate(op1,op2,t);\n						push(intStack,&result);\n#ifndef _RELEASE		\n						printf(\" %c \",t);\n#endif\n						pop(charStack);\n						if (!empty(charStack)){\n							t = *(char*)top(charStack);\n						}\n						else t = 0;\n						free_li(&result);\n						free_li(&op1);\n						free_li(&op2);\n					}\n				}\n				push(charStack,&c);\n			}\n			else if (c == \'+\' || c == \'-\'){\n				if (prevchar!=0){\n					char t;\n					if (prevchar == 2){\n						long_int val;\n						val = get_value(varstr);\n						//make_copy(&val,get_value(varstr));\n#ifndef _RELEASE\n						//printf(\"%d \",val);\n						print_li(&val);\n#endif\n						varstr[0] = \'\\0\';\n						push(intStack,&val);\n						free_li(&val);\n					}   \n					prevchar = 0;\n					if (!empty(charStack)){\n						t = *(char*)top(charStack);\n						while (t ==\'*\' || t ==\'/\' || t== \'+\' || t==\'-\'){\n							long_int result;\n							long_int op1,op2;\n\n							//op1 = *(int*)top(intStack);\n							make_copy(&op1,*(long_int*)top(intStack));\n							pop(intStack);\n							//op2 = *(int*)top(intStack);\n							make_copy(&op2,*(long_int*)top(intStack));\n							pop(intStack);\n							result = calculate(op1,op2,t);\n							push(intStack,&result);\n#ifndef _RELEASE						\n							printf(\" %c \",t);\n#endif\n							pop(charStack);\n							if (!empty(charStack)){\n								t = *(char*)top(charStack);\n							}\n							else\n								t = 0;\n							free_li(&result);\n							free_li(&op1);\n							free_li(&op2);\n						}\n					}\n					push(charStack,&c);\n				} else\n					sign = (c==\'+\')?sign*1:sign*(-1);\n			}\n			else if (c == \'\\n\'){\n				if (prevchar == 2){\n					long_int val;\n					\n					val = get_value(varstr);\n					//make_copy(&val,get_value(varstr));\n#ifndef _RELEASE\n					//printf(\"%d \",val);\n					print_li(&val);\n					//putchar(\'\\n\');\n#endif\n					varstr[0] = \'\\0\';\n					push(intStack,&val);\n					free_li(&val);\n				}\n				while (!empty(charStack)){\n					char t;\n					long_int result;\n					long_int op1,op2;\n\n					t = *(char*)top(charStack);\n#ifndef _RELEASE				\n					printf(\" %c \",*(char*)top(charStack));\n#endif\n					//op1 = *(int*)top(intStack);\n					make_copy(&op1,*(long_int*)top(intStack));\n					pop(intStack);\n					//op2 = *(int*)top(intStack);\n					make_copy(&op2,*(long_int*)top(intStack));\n					pop(intStack);\n					result = calculate(op1,op2,t);\n					push(intStack,&result);\n					pop(charStack);\n					free_li(&result);\n					free_li(&op1);\n					free_li(&op2);\n				}\n				if (!empty(intStack)){\n					//end_result = *(int*)top(intStack);\n					make_copy(&end_result,*(long_int*)top(intStack));\n					if (waseq == 1){\n						if (towrite[0]!=\'\\0\')\n							set_value(towrite,&end_result);\n						waseq = 0;\n					} else {\n						print_li(&end_result);\n						putchar(\'\\n\');\n					}\n					//end_result = 0;\n					free_li(&end_result);\n					prevchar=0;\n					pop(intStack);\n				}\n				break;\n			}\n		}\n		if (towrite){\n			free(towrite);\n			towrite=NULL;\n		}\n	}\n	destroyStack(charStack);	\n	destroyStack(intStack);\n	cleanup();\n	free(str);\n	free(varstr);\n#ifdef WIN32\n	_CrtDumpMemoryLeaks();\n#endif\n	return 0;\n}\nstatic long_int calculate ( long_int op1 , long_int op2 , char oper ){\n	long_int result;\n	switch (oper) {\n		case \'+\' : result = add(op2, op1); \n			   break;\n		case \'*\' : result = mul(op2, op1);\n			   break;\n		case \'-\' : result = sub(op2, op1);\n			   break;\n		case \'/\' : result = divide(op2, op1);\n			   break;\n		default : perror(\"Unknown operator\");\n			  init_long(&result,1,NULL);\n	}\n	return result;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (158,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"stack.h\"\r\n#include \"long.h\"\r\n\r\n\r\nstatic void destrStruct_I (struct item* a);\r\nstatic int checkMalloc(void*);\r\n\r\nvoid push (stack *st,void* data){\r\n	void* t;\r\n	struct item *p;\r\n\r\n	if (st->stackType == i){\r\n		t = (int*)malloc(sizeof(int));\r\n		if(!checkMalloc(t)){\r\n			return;\r\n		}\r\n		*(int*)t = *(int*)data;\r\n	} else if (st->stackType == c) {\r\n		t = (char*)malloc(sizeof(char));\r\n		if(!checkMalloc(t)){\r\n			return;\r\n		}\r\n		*(char*)t = *(char*)data;\r\n	} else {\r\n		t = (long_int*)malloc(sizeof(long_int));\r\n		if (!checkMalloc(t)){\r\n			return;\r\n		}\r\n		make_copy((long_int*)t,*(long_int*)data);\r\n	}\r\n\r\n	p = (struct item*)malloc(sizeof(struct item));\r\n	if(!checkMalloc(p)){\r\n		free(t);\r\n		return;\r\n	}\r\n	p -> data = t;\r\n	p -> next = st -> head;\r\n	st -> head = p;\r\n}\r\n\r\nvoid* top (stack *st){\r\n	if (!empty(st)){\r\n		return (void*)(st->head->data);\r\n	}\r\n	return NULL;\r\n}\r\n\r\nvoid pop(stack* st){\r\n	struct item* q;\r\n	q = st -> head;\r\n	st -> head = q->next;\r\n	if (st->stackType == __l){\r\n		free_li((long_int*)q->data);\r\n		free(q->data);\r\n	} else \r\n		free(q->data);\r\n	free(q);\r\n}\r\nint empty(stack* st){\r\n	return (st->head==NULL||st==NULL);\r\n}\r\n\r\nstack* createStack (type stackType){\r\n	stack* st;\r\n	st = malloc(sizeof(stack));\r\n	st->head = NULL;\r\n	st->stackType = stackType;\r\n	return st;\r\n}\r\nvoid destroyStack (stack* st) {\r\n	if(st->head != NULL)\r\n		destrStruct_I(st->head);\r\n	free(st);\r\n}\r\nvoid destrStruct_I (struct item* a){ // str item\r\n	if (a->next)\r\n		destrStruct_I (a->next);\r\n	free_li(a->data);\r\n	free(a);		\r\n}\r\nvoid* top_pop (stack *st){\r\n	if(!empty(st)){\r\n		void* temp;\r\n		temp = top (st);\r\n		pop(st);\r\n		return temp;\r\n	}\r\n	else\r\n		return NULL;\r\n}\r\n\r\nvoid printStack (stack* st)\r\n{\r\n	if (empty(st))\r\n		printf(\"Stack is empty\\n\");\r\n	else {\r\n		struct item* p;\r\n		printf(\"-> \");\r\n		switch (st->stackType){\r\n			case i:	\r\n				for (p = st->head; p ; p = p->next){\r\n					printf(\"%d->\",*(int*)p->data); \r\n				}\r\n				break;\r\n			case c:\r\n				for (p = st->head; p ; p = p->next){\r\n					printf(\"%c->\",*(char*)p->data); \r\n				}\r\n				break;\r\n			case l:\r\n				for (p = st->head; p ; p = p->next){\r\n					print_li((long_int*)p->data);\r\n					printf(\"->\");\r\n				}\r\n			default:break;\r\n		}\r\n		printf(\"X\\n\");\r\n	}\r\n}\r\nstatic int checkMalloc(void* p){\r\n	if (p==NULL){\r\n		perror(\"malloc\");\r\n		return 0;\r\n	}\r\n	return 1;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (159,'#include \"long.h\"\r\n#include \"vars.h\"\r\n\r\n#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nstatic unsigned int hashf(char*);\r\nstatic void destrStruct_H (hash* a);\r\nstatic int checkMalloc(void*);\r\n\r\nvoid set_value(char* name, void* data){\r\n	void* p;\r\n	var* someVar;\r\n	char* str;\r\n	int hval;\r\n	hash* a;\r\n	\r\n	p = (long_int*)malloc(sizeof(long_int));\r\n	if(!checkMalloc(p))return;\r\n	//*(int*)p = *(int*)data;\r\n	make_copy((long_int*)p,*(long_int*)data);\r\n\r\n	hval = hashf(name);\r\n	for (a=HashTable[hval]; a; a=a->next)	{\r\n		if(strcmp(a->varVal->name,name)==0) {\r\n			free_li(a->varVal->value);\r\n			free(a->varVal->value);\r\n			a->varVal->value = p;\r\n			return;\r\n		}\r\n	}\r\n	str = (char*)malloc(sizeof(char)*(1+strlen(name)));\r\n	if(!checkMalloc(str)){\r\n		free(p);\r\n		return;\r\n	}\r\n	strcpy(str,name);\r\n\r\n	someVar =(var*) malloc(sizeof(var));\r\n	if(!checkMalloc(someVar)){\r\n		free(p);\r\n		free(str);\r\n		return;\r\n	}\r\n	someVar->name = str;\r\n	someVar->value = p;\r\n	\r\n	a = (hash*)malloc(sizeof(hash));\r\n	if(!checkMalloc(a)){\r\n		free(p);\r\n		free(str);\r\n		free(someVar);\r\n		return;\r\n	}\r\n	a->varVal=someVar;\r\n	if (HashTable[hval])\r\n		p = (void*)HashTable[hval]->next;\r\n	else \r\n		p = NULL;\r\n	HashTable[hval]=a;\r\n	a->next = (hash*)p;\r\n}\r\nlong_int get_value(char* name){\r\n	int hval = hashf(name);\r\n	hash* a;\r\n	long_int value;\r\n	for(a = HashTable[hval]; a ; a=a->next){\r\n		if(strcmp(a->varVal->name,name)==0){\r\n			//value = *(int*)a->varVal->value;\r\n			make_copy(&value,*(long_int*)a->varVal->value);\r\n			return value;\r\n		}\r\n	}\r\n	init_long(&value,1,NULL);\r\n	return value;\r\n}\r\nvoid cleanup(void){\r\n	int i;\r\n	for(i=0; i<maxHash ; i++){\r\n		if (HashTable[i]!=NULL){\r\n			destrStruct_H(HashTable[i]);\r\n		}\r\n	}\r\n}\r\n\r\n\r\nstatic unsigned int hashf (char* str){ \r\n	unsigned int len = strlen(str);\r\n	unsigned int sum=1;\r\n	unsigned int i;\r\n\r\n	for (i=0; i<len; i++){\r\n		sum = (sum+(unsigned int)str[i])%maxHash;\r\n	}\r\n	return (sum*7)%maxHash;\r\n}\r\nstatic void destrStruct_H (hash* a){ // str item\r\n	if (a->next)\r\n		destrStruct_H (a->next);\r\n	free(a->varVal->name);\r\n	free_li(a->varVal->value);\r\n	free(a->varVal->value);\r\n	free(a->varVal);\r\n	free(a);		\r\n}\r\nstatic int checkMalloc(void* p){\r\n	if(p==NULL){\r\n		perror(\"malloc\");\r\n		return 0;\r\n	}\r\n	return 1;\r\n}\r\n	\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (160,'#include \"stdio.h\"\r\n#include \"stdlib.h\"\r\n//#include \"crtdbg.h\"\r\n#include \"long.h\"\r\n#include \"stack.h\"\r\n#include \"vars.h\"\r\n#define CHUNK_SIZE 100\r\n\r\nstruct item *stack1 = 0, // numbers\r\n			*stack2 = 0; // operations\r\n\r\nint prior(char x)\r\n{\r\n	if (x == \'(\')\r\n		return 0;\r\n	if ((x == \'+\') || (x == \'-\'))\r\n		return 1;\r\n	return 2;\r\n}\r\n\r\nstruct long_int* read_long(char *source, int str_len, int sign)\r\n{\r\n	struct long_int* l_int;\r\n	int i, k = str_len / 4 + ((str_len % 4) != 0), cnt = 0;\r\n	l_int = malloc(sizeof(struct long_int));\r\n	if (!l_int)\r\n	{\r\n		perror(\"malloc\");\r\n		exit(1);\r\n	}\r\n	l_int->length = k;\r\n	l_int->digits = malloc(k * sizeof(int));\r\n	if (!l_int->digits)\r\n	{\r\n		perror(\"malloc\");\r\n		exit(1);\r\n	}\r\n	l_int->sign = sign;\r\n	k--;\r\n	for (i = str_len - 4; i >= 0; i -= 4)\r\n	{\r\n		l_int->digits[cnt] = ((source[i] - \'0\')*1000) + ((source[i+1] - \'0\')*100) + ((source[i+2] - \'0\')*10) + ((source[i+3] - \'0\')*1);\r\n		cnt++;\r\n		k--;\r\n	}\r\n	if ((i < 0) && (i != -4))\r\n	{\r\n		int t = 1;\r\n		l_int->digits[cnt] = 0;\r\n		i += 3;\r\n		while (i >= 0)\r\n		{\r\n			l_int->digits[cnt] += (source[i] - \'0\')*t;\r\n			t *= 10;\r\n			i--;\r\n		}\r\n	}\r\n	return l_int;\r\n}\r\n\r\nint main()\r\n{\r\n	char c;\r\n	//freopen(\"calc_in.txt\", \"r\", stdin);\r\n	//freopen(\"calc_out.txt\", \"w\", stdout);\r\n	printf(\"\\nPress exit or quit to stop the program.\\n\");\r\n	while (1)\r\n	{\r\n		char *st_char, *p = NULL, *s, temp_char;\r\n		int i = 0, base = 10, r, pos_eq = 0, var_eval = 0, sign = 1, *pop1, *pop2; //, foo;\r\n		struct long_int temp_long1, temp_long2, *st_long, long_res, long_to_pop;\r\n\r\n		size_t allocated = 0, used = 0;\r\n		while ((c = getchar()) != \'\\n\')\r\n		{\r\n			if (c == EOF)\r\n			{\r\n				p = malloc(5);\r\n				strcpy(p, \"exit\");\r\n				used = 4;\r\n				break;\r\n			}\r\n			if (c == \'=\')\r\n				pos_eq = used;\r\n			if (allocated == used) {\r\n				char *q = realloc(p, allocated + CHUNK_SIZE);\r\n				if (!q)\r\n				{\r\n					perror(\"malloc\");\r\n					return 0;\r\n				}\r\n				allocated += CHUNK_SIZE;\r\n				p = q;\r\n			}\r\n			p[used++] = (char)c;\r\n		}\r\n		if (used == 4)			//exit (or quit)\r\n		{\r\n			if (\r\n				((p[0] == \'e\') && (p[1] == \'x\') && (p[2] == \'i\') && (p[3] == \'t\'))\r\n				||\r\n				((p[0] == \'q\') && (p[1] == \'u\') && (p[2] == \'i\') && (p[3] == \'t\'))\r\n				)\r\n			{\r\n				while (!empty(stack1))\r\n				{\r\n					long_to_pop = *(struct long_int *)(top(stack1));\r\n					free(long_to_pop.digits);\r\n					pop(&stack1);\r\n				}\r\n				while (!empty(stack2))\r\n					pop(&stack2);\r\n				free(p);\r\n				cleanup();\r\n				//_CrtDumpMemoryLeaks();\r\n				return 0;\r\n			}\r\n		}\r\n		if (!p)			//if only enter has pressed\r\n			continue;\r\n\r\n		if (1)			//some more bytes\r\n		{\r\n			char *q = realloc(p, allocated + 5);\r\n			if (!q)\r\n			{\r\n				perror(\"malloc\");\r\n				return 0;\r\n			}\r\n			allocated += 5;\r\n			p = q;\r\n		}\r\n\r\n		p[used++] = 0;		//last symbol of string is \'\\0\'\r\n		if (pos_eq)			//need to evaluate variable?\r\n		{\r\n			var_eval = 1;\r\n			s = p + pos_eq + 1;\r\n		}\r\n		else\r\n		{\r\n			var_eval = 0;\r\n			s = p;\r\n		}\r\n\r\n		if (s[0] == \'-\')		//first symbol is \'-\'\r\n		{\r\n			sign = -1;\r\n			i++;\r\n		}\r\n\r\n		//--\r\n		/*\r\n		used--;\r\n		if (p[0] == \'-\')\r\n		{\r\n			p++;\r\n			used --;\r\n			sign = -1;\r\n		}\r\n		if (m == 0)\r\n			a = read_long(p, used, sign);\r\n		if (m == 1)\r\n			b = read_long(p, used, sign);\r\n		m++;\r\n		if (m == 2)\r\n		{\r\n			printf(\"%d\\n\", long_int_cmp(*a, *b));\r\n			m = 0;\r\n		}\r\n		continue;\r\n		*/\r\n		//--\r\n\r\n		while (s[i])					// expression parsing starts here\r\n		{\r\n			if ((\'0\' <= s[i]) && (s[i] <= \'9\'))\r\n			{\r\n				//int ds;\r\n				//printf(\"\\nfind number\\n\");\r\n				r = i;\r\n				while ((\'0\' <= s[i]) && (s[i] <= \'9\'))\r\n					i++;\r\n				//readlong\r\n				st_long = read_long(s + r, i - r, sign);\r\n				//for (ds = 0; ds < st_long->length; ds++)\r\n				//	printf(\" %d \", st_long->digits[ds]);\r\n				// end readlong\r\n				push(&stack1, st_long);\r\n				sign = 1;\r\n				continue;\r\n			}\r\n			if ((\'a\' <= s[i]) && (s[i] <= \'z\'))			//variable here\r\n			{\r\n				char* var_name = s + i, swap_char;\r\n				struct long_int var_value;\r\n				int var_i;\r\n				while ( ((\'a\' <= s[i]) && (s[i] <= \'z\')) || ((\'0\' <= s[i]) && (s[i] <= \'9\')) || (s[i] == \'_\'))\r\n					i++;\r\n				swap_char = s[i];\r\n				s[i] = 0;\r\n				var_value = get_value(var_name);\r\n				//printf(\"\\n\");\r\n				s[i] = swap_char;\r\n\r\n				st_long = malloc(sizeof(struct long_int));\r\n				if (!st_long)\r\n				{\r\n					perror(\"malloc\");\r\n					return 0;\r\n				}\r\n				st_long->digits = malloc(( var_value.length )*sizeof(int));\r\n				if (!(st_long->digits))\r\n				{\r\n					perror(\"malloc\");\r\n					return 0;\r\n				}\r\n				for (var_i = 0; var_i < var_value.length; var_i++)\r\n					st_long->digits[var_i] = var_value.digits[var_i];\r\n				st_long->length = var_value.length;\r\n				st_long->sign = var_value.sign;\r\n\r\n				push(&stack1, st_long);\r\n				continue;\r\n			}\r\n			if (s[i] == \' \')\r\n			{\r\n				//printf(\"\\nfind \' \'\\n\");\r\n				i++;\r\n				continue;\r\n			}\r\n			if (s[i] == \'(\')\r\n			{\r\n				//printf(\"\\nfind \'(\'\\n\");\r\n				st_char = malloc(1);\r\n				if (!st_char)\r\n				{\r\n					perror(\"malloc\");\r\n					return 0;\r\n				}\r\n				*st_char = \'(\';\r\n				push(&stack2, st_char);\r\n\r\n				if (s[i+1] == \'-\')			//\'-\' after \'(\', negative number is reading\r\n				{\r\n					sign = -1;\r\n					i++;\r\n				}\r\n\r\n				i++;\r\n				continue;\r\n			}\r\n			if (s[i] == \')\')\r\n			{\r\n				int sk_i;\r\n				//printf(\"\\nfind \')\'\\n\");\r\n				while ( (temp_char = (*(char *)(top(stack2)))) != \'(\' )\r\n				{\r\n					pop(&stack2);\r\n					temp_long2 = *(struct long_int *)(top(stack1));\r\n					pop2 = temp_long2.digits;\r\n					pop(&stack1);\r\n					temp_long1 = *(struct long_int *)(top(stack1));\r\n					pop1 = temp_long1.digits;\r\n					pop(&stack1);\r\n\r\n					if (temp_char == \'+\')\r\n						long_res = add(temp_long1, temp_long2);\r\n					if (temp_char == \'-\')\r\n						long_res = sub(temp_long1, temp_long2);\r\n					if (temp_char == \'*\')\r\n						long_res = mul(temp_long1, temp_long2);\r\n					if (temp_char == \'/\')\r\n						long_res = del(temp_long1, temp_long2);\r\n					free(pop1);\r\n					free(pop2);\r\n					st_long = malloc(sizeof(struct long_int));\r\n					if (!st_long)\r\n					{\r\n						perror(\"malloc\");\r\n						return 0;\r\n					}\r\n\r\n					st_long->digits = malloc(( long_res.length )*sizeof(int));\r\n					if (!(st_long->digits))\r\n					{\r\n						perror(\"malloc\");\r\n						return 0;\r\n					}\r\n					for (sk_i = 0; sk_i < long_res.length; sk_i++)\r\n						st_long->digits[sk_i] = long_res.digits[sk_i];\r\n					st_long->length = long_res.length;\r\n					st_long->sign = long_res.sign;\r\n\r\n					push(&stack1, st_long);\r\n				}\r\n				pop(&stack2);\r\n				i++;\r\n				continue;\r\n			}\r\n			//printf(\"\\nthis is operation \\n\");\r\n			if (empty(stack2))\r\n			{\r\n				st_char = malloc(1);\r\n				if (!st_char)\r\n				{\r\n					perror(\"malloc\");\r\n					return 0;\r\n				}\r\n				*st_char = s[i];\r\n				push(&stack2, st_char);\r\n				i++;\r\n			}\r\n			else\r\n			{\r\n				\r\n				while (prior( temp_char = (*(char *)(top(stack2))) ) >= prior(s[i]))\r\n				{\r\n					pop(&stack2);\r\n					temp_long2 = *(struct long_int *)(top(stack1));\r\n					pop2 = temp_long2.digits;\r\n					pop(&stack1);\r\n					temp_long1 = *(struct long_int *)(top(stack1));\r\n					pop1 = temp_long1.digits;\r\n					pop(&stack1);\r\n\r\n					if (temp_char == \'+\')\r\n						long_res = add(temp_long1, temp_long2);\r\n					if (temp_char == \'-\')\r\n						long_res = sub(temp_long1, temp_long2);\r\n					if (temp_char == \'*\')\r\n						long_res = mul(temp_long1, temp_long2);\r\n					if (temp_char == \'/\')\r\n						long_res = del(temp_long1, temp_long2);\r\n					st_long = malloc(sizeof(struct long_int));\r\n					free(pop1);\r\n					free(pop2);\r\n					if (!st_long)\r\n					{\r\n						perror(\"malloc\");\r\n						return 0;\r\n					}\r\n\r\n					//st_long->digits = malloc(( long_res.length )*sizeof(int));\r\n					st_long->digits = long_res.digits;\r\n					//perror\r\n					//for (foo = 0; foo < long_res.length; foo++)\r\n					//	st_long->digits[foo] = long_res.digits[foo];\r\n					st_long->length = long_res.length;\r\n					st_long->sign = long_res.sign;\r\n\r\n					push(&stack1, st_long);\r\n					if (empty(stack2))\r\n						break;\r\n				}\r\n				st_char = malloc(1);\r\n				if (!st_char)\r\n				{\r\n					perror(\"malloc\");\r\n					exit(1);\r\n				}\r\n				*st_char = s[i];\r\n				push(&stack2, st_char);\r\n				i++;\r\n			}\r\n		}									//parsing finished\r\n\r\n		while (!empty(stack2))\r\n		{\r\n			temp_char = (*(char *)(top(stack2)));\r\n			pop(&stack2);\r\n			temp_long2 = *(struct long_int *)(top(stack1));\r\n			pop2 = temp_long2.digits;\r\n			pop(&stack1);\r\n			temp_long1 = *(struct long_int *)(top(stack1));\r\n			pop1 = temp_long1.digits;\r\n			pop(&stack1);\r\n\r\n			if (temp_char == \'+\')\r\n				long_res = add(temp_long1, temp_long2);\r\n			if (temp_char == \'-\')\r\n				long_res = sub(temp_long1, temp_long2);\r\n			if (temp_char == \'*\')\r\n				long_res = mul(temp_long1, temp_long2);\r\n			if (temp_char == \'/\')\r\n				long_res = del(temp_long1, temp_long2);\r\n			st_long = malloc(sizeof(struct long_int));\r\n			free(pop1);\r\n			free(pop2);\r\n			if (!st_long)\r\n			{\r\n				perror(\"malloc\");\r\n				return 0;\r\n			}\r\n\r\n			//st_long->digits = malloc(( long_res.length )*sizeof(int));\r\n			st_long->digits = long_res.digits;\r\n			//perror\r\n			//for (foo = 0; foo < long_res.length; foo++)\r\n			//	st_long->digits[foo] = long_res.digits[foo];\r\n			st_long->length = long_res.length;\r\n			st_long->sign = long_res.sign;\r\n\r\n			push(&stack1, st_long);\r\n		}\r\n\r\n		st_long = (struct long_int *)(top(stack1));\r\n		if (var_eval)\r\n		{\r\n			if (p[pos_eq - 1] == \' \')\r\n				p[pos_eq - 1] = 0;\r\n			p[pos_eq] = 0;\r\n			set_value(p, *st_long, pos_eq);\r\n			if (p[pos_eq - 1] == 0)\r\n				p[pos_eq - 1] = \' \';\r\n			p[pos_eq] = \'=\';\r\n		}\r\n		else\r\n		{\r\n			print(*st_long);\r\n		}\r\n		while (!empty(stack1))\r\n				{\r\n					long_to_pop = *(struct long_int *)(top(stack1));\r\n					free(long_to_pop.digits);\r\n					pop(&stack1);\r\n				}\r\n		while (!empty(stack2))\r\n			pop(&stack2);\r\n		free(p);\r\n	}\r\n	//a = _CrtDumpMemoryLeaks();\r\n	return 0;\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (161,'#include \"stdlib.h\"\r\n#include \"stdio.h\"\r\nstruct long_int\r\n{\r\n	int *digits;\r\n	int length;\r\n	int sign;\r\n};\r\n\r\nstatic int long_int_cmp(struct long_int a, struct long_int b)\r\n{\r\n	int i;\r\n	if ((a.length == 1) && (b.length == 1) && (a.digits[0] == 0) && (b.digits[0] == 0))\r\n		return 0;\r\n	if ((a.sign == 1) && (b.sign == -1))\r\n		return 1;\r\n	if ((a.sign == -1) && (b.sign == 1))\r\n		return -1;\r\n	if (a.sign == 1)\r\n	{\r\n		if (a.length > b.length)\r\n			return 1;\r\n		if (a.length < b.length)\r\n			return -1;\r\n		for (i = a.length - 1; i >= 0; i--)\r\n		{\r\n			if (a.digits[i] > b.digits[i])\r\n				return 1;\r\n			if (a.digits[i] < b.digits[i])\r\n				return -1;\r\n		}\r\n		return 0;\r\n	}\r\n	if (a.length < b.length)\r\n		return 1;\r\n	if (a.length > b.length)\r\n		return -1;\r\n	for (i = a.length - 1; i >= 0; i--)\r\n	{\r\n		if (a.digits[i] < b.digits[i])\r\n			return 1;\r\n		if (a.digits[i] > b.digits[i])\r\n			return -1;\r\n	}\r\n	return 0;\r\n}\r\n\r\nvoid print(struct long_int a)\r\n{\r\n	int i;\r\n	if (a.sign == -1)\r\n		printf(\"-\");\r\n	printf(\"%d\", a.digits[a.length - 1]);\r\n	for (i = a.length - 2; i >= 0; i--)\r\n		printf(\" %04d\", a.digits[i]);\r\n	printf(\"\\n\");\r\n}\r\n\r\nstruct long_int add(struct long_int a, struct long_int b)\r\n{\r\n	struct long_int long_res;\r\n	int buffer = 0, i;\r\n	if (a.sign == b.sign)\r\n	{\r\n		int\r\n			len_max = (a.length > b.length?a.length:b.length), \r\n			len_min = (a.length < b.length?a.length:b.length), \r\n			*x = (a.length > b.length?a.digits:b.digits), \r\n			*y = (a.length > b.length?b.digits:a.digits);\r\n		long_res.digits = malloc(len_max * sizeof(int));\r\n		if (!(long_res.digits))\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		for (i = 0; i < len_min; i++)\r\n		{\r\n			long_res.digits[i] = x[i] + y[i] + buffer;\r\n			buffer = long_res.digits[i] / 10000;\r\n			long_res.digits[i] = long_res.digits[i] % 10000;\r\n		}\r\n		for (i = len_min; i < len_max; i++)\r\n		{\r\n			long_res.digits[i] = x[i] + buffer;\r\n			buffer = long_res.digits[i] / 10000;\r\n			long_res.digits[i] = long_res.digits[i] % 10000;\r\n		}\r\n		long_res.length = len_max;\r\n		long_res.sign = a.sign;\r\n		if (buffer)\r\n		{\r\n			int *new_digits = realloc(long_res.digits, (long_res.length + 1)*(sizeof(int)));\r\n			if (!new_digits)\r\n			{\r\n				perror(\"malloc\");\r\n				exit(1);\r\n			}\r\n			long_res.digits = new_digits;\r\n			long_res.digits[long_res.length] = 1;\r\n			long_res.length++;\r\n		}\r\n	}\r\n	else\r\n	{\r\n		struct long_int t_a = a, t_b = b, t_c;\r\n		int cmp_res, *tmp;\r\n		t_a.sign = t_b.sign = 1;\r\n		cmp_res = long_int_cmp(t_a, t_b);\r\n		if (cmp_res == 0)\r\n		{\r\n			long_res.digits = malloc(sizeof(int));\r\n			if (!(long_res.digits))\r\n			{\r\n				perror(\"malloc\");\r\n				exit(1);\r\n			}\r\n			long_res.digits[0] = 0;\r\n			long_res.length = 1;\r\n			long_res.sign = 1;\r\n			return long_res;\r\n		}\r\n		if (cmp_res == 1)\r\n		{\r\n			long_res.sign = a.sign;\r\n		}\r\n		if (cmp_res == -1)\r\n		{\r\n			long_res.sign = b.sign;\r\n			t_c = a;\r\n			a = b;\r\n			b = t_c;\r\n		}\r\n		long_res.length = a.length;\r\n		long_res.digits = malloc(long_res.length*sizeof(int));\r\n		if (!(long_res.digits))\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		for (i = 0; i < b.length; i++)\r\n		{\r\n			long_res.digits[i] = a.digits[i] - b.digits[i] + buffer;\r\n			if (long_res.digits[i] < 0)\r\n			{\r\n				long_res.digits[i] += 10000;\r\n				buffer = -1;\r\n			}\r\n			else\r\n			{\r\n				buffer = 0;\r\n			}\r\n		}\r\n		for (i = b.length; i < long_res.length; i++)\r\n		{\r\n			long_res.digits[i] = a.digits[i] + buffer;\r\n			if (long_res.digits[i] < 0)\r\n			{\r\n				long_res.digits[i] += 10000;\r\n				buffer = -1;\r\n			}\r\n			else\r\n			{\r\n				//buffer = 0;\r\n				break;\r\n			}\r\n		}\r\n		//some nulls in the big end of result?\r\n		//if???\r\n		for (i = long_res.length - 1; long_res.digits[i] == 0; i--)\r\n			;\r\n		if (i + 1 != long_res.length)\r\n		{\r\n			tmp = realloc(long_res.digits, (i + 1) * sizeof(int));\r\n			if (!tmp)\r\n			{\r\n				perror(\"malloc\");\r\n				exit(1);\r\n			}\r\n			long_res.digits = tmp;\r\n		}\r\n		long_res.length = i + 1;\r\n	}\r\n	return long_res;\r\n}\r\nstruct long_int sub(struct long_int a, struct long_int b)\r\n{\r\n	b.sign *= -1;\r\n	return (add(a, b));\r\n}\r\nstruct long_int mul(struct long_int a, struct long_int b)\r\n{\r\n	struct long_int long_res, t_a;\r\n	int i, j, buffer = 0, *tmp;\r\n	if (long_int_cmp(a, b) < 0)\r\n	{\r\n		t_a = a;\r\n		a = b;\r\n		b = t_a;\r\n	}\r\n	long_res.sign = a.sign * b.sign;\r\n	long_res.length = a.length + b.length + 1;\r\n	long_res.digits = calloc(long_res.length, sizeof(int));\r\n	if (!(long_res.digits))\r\n	{\r\n		perror(\"malloc\");\r\n		exit(1);\r\n	}\r\n	for (i = 0; i < b.length; i++)\r\n	{\r\n		buffer = 0;\r\n		for (j = 0; j < a.length; j++)\r\n		{\r\n			long_res.digits[i + j] += a.digits[j] * b.digits[i] + buffer;\r\n			buffer = long_res.digits[i + j] / 10000;\r\n			long_res.digits[i + j] = long_res.digits[i + j] % 10000;\r\n		}\r\n		if (buffer)\r\n		{\r\n			int k;\r\n			for (k = a.length + i; k < long_res.length; k++)\r\n			{\r\n				long_res.digits[k] += buffer;\r\n				buffer = long_res.digits[k] / 10000;\r\n				long_res.digits[k] %= 10000;\r\n				if (!buffer)\r\n					break;\r\n			}\r\n		}\r\n	}\r\n	for (i = long_res.length - 1; long_res.digits[i] == 0; i--)\r\n		;\r\n	if (i + 1 != long_res.length)\r\n	{\r\n		tmp = realloc(long_res.digits, (i + 1) * sizeof(int));\r\n		if (!tmp)\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		long_res.digits = tmp;\r\n	}\r\n	long_res.length = i + 1;\r\n	return long_res;\r\n}\r\nstruct long_int del(struct long_int a, struct long_int b)\r\n{\r\n	struct long_int long_res;\r\n	int i, d, k, *tmp, buf, len, len0, out;\r\n	if ((a.length < b.length) || ((a.length == 1) && (a.length == b.length) && (a.digits[0] < b.digits[0]) ))\r\n	{\r\n		long_res.digits = malloc(sizeof(int));\r\n		if (!(long_res.digits))\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		long_res.digits[0] = 0;\r\n		long_res.length = 1;\r\n		long_res.sign = 1;\r\n		return long_res;\r\n	}\r\n	long_res.sign = a.sign * b.sign;\r\n	long_res.length = a.length - b.length + 1;\r\n	long_res.digits = malloc(long_res.length * sizeof(int));\r\n	if (!(long_res.digits))\r\n	{\r\n		perror(\"malloc\");\r\n		exit(1);\r\n	}\r\n	tmp = malloc((b.length + 1) * sizeof(int));\r\n	if (!(tmp))\r\n	{\r\n		perror(\"malloc\");\r\n		exit(1);\r\n	}\r\n	len0 = a.length;\r\n	for (i = long_res.length - 1; i >= 0; i--)\r\n	{\r\n		int flag = 0; // -1, 0, 1\r\n		int left = 0, right = 9999;\r\n		for (k = len0 - 1; a.digits[k] == 0; k--);\r\n		len0 = k + 1;\r\n		\r\n		while (left <= right)\r\n		{\r\n			d = (left + right) / 2;\r\n			buf = 0;\r\n			for (k = 0; k < b.length; k++)\r\n			{\r\n				tmp[k] = b.digits[k] * d + buf;\r\n				buf = tmp[k] / 10000;\r\n				tmp[k] %= 10000;\r\n			}\r\n			tmp[b.length] = buf;\r\n			for (k = b.length; tmp[k] == 0; k--);\r\n			len = k + 1;\r\n			if (len + i > len0)\r\n			{\r\n				right = d - 1;\r\n				continue;\r\n			}\r\n			if (len + i < len0)\r\n			{\r\n				left = d + 1;\r\n				continue;\r\n			}\r\n			out = 0;\r\n			for (k = len - 1; k >= 0; k--)\r\n			{\r\n				if (a.digits[k + i] < tmp[k])\r\n				{\r\n					out = 1;\r\n					break;\r\n				}\r\n				if (a.digits[k + i] > tmp[k])\r\n				{\r\n					out = 2;\r\n					break;\r\n				}\r\n			}\r\n			if (out == 1)\r\n			{\r\n				right = d - 1;\r\n				continue;\r\n			}\r\n			left = d + 1;\r\n		}\r\n\r\n		d = right;\r\n		//\r\n		long_res.digits[i] = d;\r\n\r\n		buf = 0;\r\n		for (k = 0; k < b.length; k++)\r\n		{\r\n			tmp[k] = b.digits[k] * d + buf;\r\n			buf = tmp[k] / 10000;\r\n			tmp[k] %= 10000;\r\n		}\r\n		tmp[b.length] = buf;\r\n\r\n		for (k = b.length; tmp[k] == 0; k--);\r\n		len = k + 1;\r\n\r\n		buf = 0;\r\n		for (k = 0; k < len; k++)\r\n		{\r\n			a.digits[k+i] = a.digits[k+i] - tmp[k] + buf;\r\n			if (a.digits[k+i] < 0)\r\n			{\r\n				a.digits[k+i] += 10000;\r\n				buf = -1;\r\n			}\r\n			else\r\n			{\r\n				buf = 0;\r\n			}\r\n		}\r\n		for (k = len + i; k < len0; k++)\r\n		{\r\n			a.digits[k] = a.digits[k] + buf;\r\n			if (a.digits[k] < 0)\r\n			{\r\n				a.digits[i] += 10000;\r\n				buf = -1;\r\n			}\r\n			else\r\n			{\r\n				//buffer = 0;\r\n				break;\r\n			}\r\n		}\r\n		//printf(\"Found %d , substr. fin\\n\", d);\r\n		//print(a);\r\n		//printf(\"\\n\");\r\n		//}\r\n\r\n		//prev = d;\r\n		//cnt++;\r\n	}\r\n	free(tmp);\r\n	for (k = long_res.length - 1; long_res.digits[k] == 0; k--);\r\n	len = k + 1;\r\n	long_res.length = len;\r\n	return long_res;\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (162,'#include \"stdlib.h\"\r\nstruct item {\r\n	void *data;\r\n	struct item *next;\r\n};\r\n\r\nvoid push(struct item **stack, void* data)\r\n{\r\n	struct item *p = malloc(sizeof(struct item));\r\n	if (!p) {\r\n		perror(\"malloc\");\r\n		exit(1);\r\n	}\r\n	p->data = data;\r\n	p->next = *stack;\r\n	*stack = p;\r\n}\r\n\r\nvoid *top(struct item *stack)\r\n{\r\n	return (stack->data);\r\n}\r\n\r\nvoid pop(struct item **stack)\r\n{\r\n	struct item *p = *stack;\r\n	free((*stack)->data);\r\n	*stack = (*stack)->next;\r\n	free(p);\r\n}\r\n\r\nint empty(struct item *stack)\r\n{\r\n	return (stack == NULL);\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (163,'#include \"stdlib.h\"\r\n#include \"long.h\"\r\n#define hesh_num 15\r\n\r\nstruct var_list {\r\n	char *name;\r\n	struct long_int value;\r\n	struct var_list *next;\r\n}* vars[hesh_num];\r\n\r\nint hesh(char *s)\r\n{\r\n	int res = 0;\r\n	while (*s)\r\n	{\r\n		res = (res * 37 + *s) % hesh_num;\r\n		s++;\r\n	}\r\n	return res;\r\n}\r\n\r\nvoid set_value(char *name, struct long_int value, int name_length)\r\n{\r\n	int h = hesh(name);\r\n	struct var_list *p = vars[h];\r\n	for (; p; p = p->next)\r\n	{\r\n		int i = 0, same = 1;\r\n		while (p->name[i])\r\n		{\r\n			if (p->name[i] != name[i])\r\n			{\r\n				same = 0;\r\n				break;\r\n			}\r\n			i++;\r\n		}\r\n		if (same)\r\n			if (!name[i])\r\n				break;\r\n	}\r\n	if (p)\r\n	{\r\n		int i;\r\n		free((p->value).digits);\r\n		(p->value).digits = malloc(( value.length )*sizeof(int));\r\n		if (!((p->value).digits))\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		for (i = 0; i < value.length; i++)\r\n			(p->value).digits[i] = value.digits[i];\r\n		(p->value).length = value.length;\r\n		(p->value).sign = value.sign;\r\n	}\r\n	else\r\n	{\r\n		char *new_name;\r\n		int i;\r\n		new_name = malloc(name_length + 1);\r\n		if (!new_name)\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		p = malloc(sizeof(struct var_list));\r\n		if (!p) {\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		for (i = 0; i < name_length; i++)\r\n		{\r\n			new_name[i] = name[i];\r\n		}\r\n		new_name[name_length] = 0;\r\n		p->name = new_name;\r\n\r\n		(p->value).digits = malloc(( value.length )*sizeof(int));\r\n		if (!((p->value).digits))\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		for (i = 0; i < value.length; i++)\r\n			(p->value).digits[i] = value.digits[i];\r\n		(p->value).length = value.length;\r\n		(p->value).sign = value.sign;\r\n\r\n		p->next = vars[h];\r\n		vars[h] = p;\r\n	}\r\n}\r\n\r\nstruct long_int get_value(char *name)\r\n{\r\n	int h = hesh(name);\r\n	struct var_list *p = vars[h];\r\n	for (; p; p = p->next)\r\n	{\r\n		int i = 0, same = 1;\r\n		while (p->name[i])\r\n		{\r\n			if (p->name[i] != name[i])\r\n			{\r\n				same = 0;\r\n				break;\r\n			}\r\n			i++;\r\n		}\r\n		if (same)\r\n			if (!name[i])\r\n				break;\r\n	}\r\n	if (p)\r\n	{\r\n		return (p->value);\r\n	}\r\n	else\r\n	{\r\n\r\n		char *new_name;\r\n		int i, name_length;\r\n		for (i = 0; name[i]; i++)\r\n			;\r\n		name_length = i;\r\n		new_name = malloc(name_length + 1);\r\n		if (!new_name)\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		p = malloc(sizeof(struct var_list));\r\n		if (!p) {\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		for (i = 0; i < name_length; i++)\r\n		{\r\n			new_name[i] = name[i];\r\n		}\r\n		new_name[name_length] = 0;\r\n		p->name = new_name;\r\n\r\n		(p->value).digits = malloc(sizeof(int));\r\n		if (!((p->value).digits))\r\n		{\r\n			perror(\"malloc\");\r\n			exit(1);\r\n		}\r\n		(p->value).digits[0] = 0;\r\n		(p->value).length = 1;\r\n		(p->value).sign = 1;\r\n\r\n		p->next = vars[h];\r\n		vars[h] = p;\r\n		return (p->value);\r\n	}\r\n}\r\nvoid cleanlist(struct var_list *q)\r\n{\r\n	if (q->next)\r\n		cleanlist(q->next);\r\n	free(q->name);\r\n	free((q->value).digits);\r\n	free(q);\r\n}\r\nvoid cleanup(void)\r\n{\r\n	int i;\r\n	for (i = 0; i < hesh_num; i++)\r\n		if (vars[i])\r\n			cleanlist(vars[i]);\r\n}\r\n','Ð¢ÐµÐ¹Ð¼ÑƒÑ€','Teimur','m');
INSERT INTO `bias` VALUES (164,'#include \"bitstream.h\"\r\n\r\nFILE *stream_file;\r\nchar cbuf;\r\nint cbuf_i;\r\nchar buf[BUFFER_SIZE];\r\nint buf_i;\r\nint mode = -1;\r\nint buf_li;\r\nint internal_file = 0;\r\n\r\nstatic void parse_error(const char* text)\r\n{\r\n	printf(\"ERROR: %s\\n\",text);\r\n}\r\n\r\n\r\nvoid InitBitStream(FILE *f, int stream_mode)\r\n{\r\n	if (mode != -1)\r\n	{\r\n		parse_error(\"Bit stream is already open\");\r\n		return;\r\n	}\r\n/*\r\n	if (stream_mode == BITSTREAM_READ && f->_flag != 9)\r\n	{\r\n		parse_error(\"Invalid mode. Use \\\"rb\\\" mode\");\r\n		return;\r\n	}\r\n*/\r\n	stream_file = f;\r\n	cbuf = 0;\r\n\r\n	if (stream_mode == BITSTREAM_WRITE)\r\n	{\r\n		cbuf_i = 0;\r\n		buf_i = 0;\r\n	}\r\n	else\r\n	{\r\n		buf_i = BUFFER_SIZE;\r\n		cbuf_i = 8;\r\n		buf_li = BUFFER_SIZE;\r\n	}\r\n	internal_file = 0;\r\n	mode = stream_mode;\r\n}\r\n\r\nvoid OpenBitStream(const char* filename, int stream_mode)\r\n{\r\n	if (mode != -1)\r\n	{\r\n		parse_error(\"Bit stream is already open\");\r\n		return;\r\n	}\r\n\r\n	stream_file = fopen(filename, (stream_mode == BITSTREAM_READ) ? \"rb\" : \"wb\");\r\n	InitBitStream(stream_file, stream_mode);\r\n	internal_file = 1;\r\n}\r\n\r\n\r\nvoid PutBit(char c)\r\n{\r\n	if (mode != BITSTREAM_WRITE)\r\n	{\r\n		parse_error(\"Stream mode doesn\'t allow write\");\r\n		return;\r\n	}\r\n\r\n	if (c >= \'0\') c -= \'0\';\r\n//	putchar(c + \'0\');\r\n	cbuf += c << (cbuf_i++);\r\n	\r\n	if (cbuf_i == 8)\r\n	{\r\n		buf[buf_i++] = cbuf;\r\n		cbuf = 0;\r\n		cbuf_i = 0;\r\n		if (buf_i == BUFFER_SIZE)\r\n		{\r\n			buf_i = 0;\r\n			fwrite(buf, BUFFER_SIZE, 1, stream_file);\r\n		}\r\n	}\r\n\r\n}\r\n\r\nchar GetBit()\r\n{\r\n	if (mode != BITSTREAM_READ)\r\n	{\r\n		parse_error(\"Stream mode doesn\'t allow read\");\r\n		return -1;\r\n	}\r\n\r\n	if (buf_li == 0)\r\n	{\r\n		return -1;\r\n	}\r\n\r\n	if (cbuf_i == 8)\r\n	{\r\n		if (buf_i == buf_li)\r\n		{\r\n			buf_li = fread(buf, 1, BUFFER_SIZE, stream_file);\r\n			if (buf_li == 0)\r\n			{\r\n				return -1;\r\n			}\r\n			buf_i = 0;\r\n		}\r\n\r\n		cbuf = buf[buf_i++];\r\n		cbuf_i = 0;\r\n	}\r\n\r\n	return (cbuf >> (cbuf_i++)) & 1;\r\n}\r\n\r\nvoid CloseBitStream()\r\n{\r\n	if (mode == -1)\r\n	{\r\n		parse_error(\"No stream file opened\");\r\n		return;\r\n	}\r\n	if (mode == BITSTREAM_WRITE)\r\n	{\r\n		if (cbuf_i)\r\n		{\r\n			buf[buf_i++] = cbuf;\r\n		}\r\n		if (buf_i)\r\n		{\r\n			fwrite(buf, 1, buf_i, stream_file);\r\n		}\r\n	}\r\n\r\n	mode = -1;\r\n	if (internal_file) fclose(stream_file);\r\n}\r\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (165,'#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#ifndef __GNUC__\r\n#include <crtdbg.h>\r\n#define SERP_CHAR \'\\\\\'\r\n#else\r\n#define SERP_CHAR \'/\'\r\n#endif\r\n#include \"bitstream.h\"\r\n#include \"hufftree.h\"\r\n\r\nunsigned int counts[256];\r\nchar buffer[BUFFER_SIZE];\r\nint buffsize;\r\n\r\nchar *ExtractFileName(char* name)\r\n{\r\n	char *s = name;\r\n	while (*s) s++;\r\n	while (s != name && *s != SERP_CHAR) s--;\r\n	if (*s == SERP_CHAR) s++;\r\n	return s;\r\n}\r\n\r\nvoid Compress(const char *filename, char **files, int filecount)\r\n{\r\n	int i,j;\r\n	FILE *f,*archive;\r\n	Tree tree;\r\n	char *s;\r\n	int *filesizes;\r\n	int fcount = filecount;\r\n\r\n	filesizes = (int*)malloc(sizeof(int)*filecount);\r\n	if (!filesizes)\r\n	{\r\n		perror(\"malloc: \");\r\n		return;\r\n	}\r\n	else\r\n	{\r\n		memset(filesizes, 0, sizeof(int) * filecount);\r\n	}\r\n\r\n	//Counting number of characters\r\n	for (i = 0; i < filecount; i++)\r\n	{\r\n		f = fopen(files[i], \"rb\");\r\n		if (!f)\r\n		{\r\n			printf(\"Cannot open file \\\"%s\\\"\\n\", files[i]);\r\n			filesizes[i] = -1;\r\n			fcount--;\r\n			continue;\r\n		}\r\n		\r\n		do\r\n		{\r\n			buffsize = fread(buffer, 1, BUFFER_SIZE, f);\r\n			for (j = 0; j < buffsize; j++)\r\n			{\r\n				counts[(unsigned char)buffer[j]]++;\r\n				filesizes[i]++;\r\n			}\r\n		}	while (!feof(f));\r\n\r\n		fclose(f);\r\n	}\r\n\r\n	tree = BuildTree(counts);\r\n	BuildCodes(tree);\r\n\r\n	//Creating an archive\r\n	archive = fopen(filename, \"wb\");\r\n\r\n	fprintf(archive, \"TIAR\");\r\n\r\n	fwrite(&fcount, sizeof(int), 1, archive);\r\n	for (i = 0; i < filecount; i++)\r\n	{\r\n		if (filesizes[i] == -1) continue;\r\n		s = ExtractFileName(files[i]);\r\n		fwrite(s, strlen(s) + 1, 1, archive);\r\n		fwrite(&filesizes[i], sizeof(int), 1, archive);\r\n	}\r\n\r\n	InitBitStream(archive, BITSTREAM_WRITE);\r\n	\r\n	WriteTree(tree);\r\n\r\n	for (i = 0; i < filecount; i++)\r\n	{\r\n		if (filesizes[i] == -1) continue;\r\n		f = fopen(files[i], \"rb\");\r\n		if (!f)\r\n		{\r\n			perror(\"fopen: \");\r\n			fclose(archive);\r\n			return;\r\n		}\r\n		\r\n		do\r\n		{\r\n			buffsize = fread(buffer, 1, BUFFER_SIZE, f);\r\n			for (j = 0; j < buffsize; j++)\r\n			{\r\n				for (s = GetCode(buffer[j]); *s; s++)\r\n				{\r\n					PutBit(*s);\r\n				}\r\n				\r\n			}\r\n		}	while (!feof(f));\r\n\r\n		fclose(f);\r\n	}\r\n\r\n	CloseBitStream();\r\n	fclose(archive);\r\n	CleanCodes();\r\n	CleanTree(tree);\r\n	free(filesizes);\r\n}\r\n\r\n\r\nvoid Decompress(const char *filename)\r\n{\r\n	FILE *archive,*f;\r\n	int filecount;\r\n	char **files;\r\n	int *filesizes;\r\n	char header[4];\r\n	int i,j;\r\n	char c;\r\n	int totalsize = 0;\r\n	Tree tree = NULL,t;\r\n\r\n	archive = fopen(filename, \"rb\");\r\n	if (!archive)\r\n	{\r\n		printf(\"Cannot open file \\\"%s\\\"\\n\", filename);\r\n		return;\r\n	}\r\n\r\n	fread(header, 1, 4, archive);\r\n	if (memcmp(\"TIAR\", header, 4))\r\n	{\r\n		printf(\"\\\"%s\\\" is not an archive!\\n\", filename);\r\n		fclose(archive);\r\n		return;\r\n	}\r\n\r\n	fread(&filecount, sizeof(int), 1, archive);\r\n\r\n	files = (char**)malloc(sizeof(char*) * filecount);\r\n	filesizes = (int*)malloc(sizeof(int) * filecount);\r\n	if (!files || !filesizes)\r\n	{\r\n		perror(\"malloc: \");\r\n		fclose(archive);\r\n		return;\r\n	}\r\n\r\n	for (i = 0; i < filecount; i++)\r\n	{\r\n		j = 0;\r\n		do\r\n		{\r\n			c = (char)fgetc(archive);\r\n			buffer[j++] = c;\r\n		} while (c != 0);\r\n\r\n		files[i] = (char*)malloc(strlen(buffer) + 1);\r\n		if (!files[i])\r\n		{\r\n			perror(\"malloc: \");\r\n			fclose(archive);\r\n			return;\r\n		}\r\n		strcpy(files[i], buffer);\r\n\r\n		fread(&filesizes[i], sizeof(int), 1, archive);\r\n		totalsize += filesizes[i];\r\n	}\r\n\r\n	InitBitStream(archive, BITSTREAM_READ);\r\n	if (totalsize)\r\n	{\r\n		tree = ReadTree();\r\n		t = tree;\r\n	}\r\n\r\n	for (i = 0; i < filecount; i++)\r\n	{\r\n		j = 0;\r\n		buffsize = 0;\r\n		f = fopen(files[i], \"wb\");\r\n		if (!f)\r\n		{\r\n			perror(\"fopen: \");\r\n			fclose(archive);\r\n			return;\r\n		}\r\n		\r\n		while (j < filesizes[i])\r\n		{\r\n			if (t->c != -1)\r\n			{\r\n				j++;\r\n				buffer[buffsize++] = (char)t->c;\r\n				t = tree;\r\n				\r\n				if (buffsize == BUFFER_SIZE)\r\n				{\r\n					fwrite(buffer, buffsize, 1, f);\r\n					buffsize = 0;\r\n				}\r\n			}\r\n			else\r\n			{\r\n				c = GetBit();\r\n				if (c)\r\n					t = t->r;\r\n				else\r\n					t = t->l;\r\n			}\r\n\r\n		}\r\n		if (buffsize) fwrite(buffer, buffsize, 1, f);\r\n		fclose(f);\r\n	}\r\n\r\n\r\n	CloseBitStream();\r\n	fclose(archive);\r\n	CleanTree(tree);\r\n}\r\n\r\nint main(int argc, char **argv)\r\n{\r\n	if (argc < 2)\r\n	{\r\n		printf(\"Invalid parameters\\n\");\r\n		return 0;\r\n	}\r\n\r\n	if (argc == 2)\r\n	{\r\n		printf(\"File list is empty!\\n\");\r\n		return 0;\r\n	}\r\n\r\n	if (strcmp(argv[1],\"-d\"))\r\n	{\r\n		Compress(argv[1], &argv[2], argc - 2);\r\n	}\r\n	else\r\n	{\r\n		Decompress(argv[2]);\r\n	}\r\n\r\n	return 0;\r\n}\r\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (166,'#include \"hufftree.h\"\r\n#include \"bitstream.h\"\r\n#include <string.h>\r\n\r\nint codes_builded = 0;\r\nchar *codes[256];\r\nchar temp_code[255];\r\n\r\nstatic int pred(const void* p1, const void* p2)\r\n{\r\n	return (*(struct item**)p2)->count - (*(struct item**)p1)->count;\r\n}\r\n\r\nTree BuildTree(unsigned int counts[256])\r\n{\r\n	Tree *tree = NULL;\r\n	Tree t;\r\n	int i,j,count = 0;\r\n\r\n	for (i = 0; i < 256; i++)\r\n	{\r\n		if (counts[i]) count++;\r\n	}\r\n\r\n	if (count == 0) return NULL;\r\n	\r\n	tree = (Tree*)malloc(sizeof(Tree) * count);\r\n	if (!tree)\r\n	{\r\n		perror(\"malloc: \");\r\n		return NULL;\r\n	}\r\n\r\n	for (i = 0, j = 0; i < count; i++, j++)\r\n	{\r\n		while (counts[j] == 0) j++;\r\n\r\n		tree[i] = (Tree)malloc(sizeof(struct item));\r\n		if (!tree[i])\r\n		{\r\n			perror(\"malloc: \");\r\n			return NULL;\r\n		}\r\n\r\n		tree[i]->c = (unsigned char)j;\r\n		tree[i]->count = counts[j];\r\n		tree[i]->l = tree[i]->r = NULL;\r\n	}\r\n\r\n	\r\n	while (count > 1)\r\n	{\r\n		qsort(tree, count, sizeof(struct item*), &pred);\r\n\r\n		t = (struct item*)malloc(sizeof(struct item));\r\n		t->l = tree[count-1];\r\n		t->r = tree[count-2];\r\n		t->c = -1;\r\n		t->count = t->l->count + t->r->count;\r\n		tree[count - 2] = t;\r\n		count--;\r\n	}\r\n\r\n	t = tree[0];\r\n	free(tree);\r\n\r\n	return t;\r\n\r\n}\r\n\r\nstatic void buildcode(Tree node, int si)\r\n{\r\n	if (!node) return;\r\n	if (node->l)\r\n	{\r\n		temp_code[si] = \'0\';\r\n		buildcode(node->l, si+1);\r\n	}\r\n	if (node->r)\r\n	{\r\n		temp_code[si] = \'1\';\r\n		buildcode(node->r, si+1);\r\n	}\r\n	if (node->c != -1)\r\n	{\r\n		/*if (si == 0)\r\n		{\r\n			temp_code[si++] = \'0\';\r\n		}*/\r\n		temp_code[si] = 0;\r\n\r\n		codes[node->c] = (char*)malloc(strlen(temp_code) + 1);\r\n		if (!codes[node->c])\r\n		{\r\n			perror(\"malloc: \");\r\n			return;\r\n		}\r\n\r\n		strcpy(codes[node->c], temp_code);\r\n		//printf(\"\\\"%c\\\" = %s\\n\", node->c, codes[node->c]);\r\n	}\r\n}\r\n\r\nvoid CleanTree(Tree tree)\r\n{\r\n	if (!tree) return;\r\n	if (tree->l)\r\n		CleanTree(tree->l);\r\n	if (tree->r)\r\n		CleanTree(tree->r);\r\n	free(tree);\r\n}\r\n\r\nvoid BuildCodes(Tree tree)\r\n{\r\n	if (codes_builded) CleanCodes();\r\n	buildcode(tree, 0);\r\n	codes_builded = 1;\r\n}\r\n\r\nvoid CleanCodes()\r\n{\r\n	int i;\r\n	for (i = 0; i < 256; i++)\r\n	{\r\n		if (codes[i])\r\n		{\r\n			free(codes[i]);\r\n			codes[i] = NULL;\r\n		}\r\n	}\r\n	codes_builded = 0;\r\n}\r\n\r\nchar* GetCode(char c)\r\n{\r\n	if (!codes_builded)\r\n	{\r\n		printf(\"%s\\n\", \"ERROR: Codes haven\'t been builded!\");\r\n		return NULL;\r\n	}\r\n	return codes[(unsigned char)c];\r\n}\r\n\r\nvoid WriteTree(Tree tree)\r\n{\r\n	unsigned char c = 0;\r\n	int i;\r\n	if (!tree) return;\r\n	if (tree->l || tree->r) PutBit(1);\r\n	else \r\n	{\r\n		PutBit(0);\r\n		c = (char)tree->c;\r\n		for (i = 0; i < 8 ; i++)\r\n		{\r\n			PutBit((c >> i) %2);\r\n		}\r\n	}\r\n	if (tree->l) WriteTree(tree->l);\r\n	if (tree->r) WriteTree(tree->r);\r\n}\r\n\r\nTree ReadTree()\r\n{\r\n	char c1;\r\n	int i;\r\n	Tree t;\r\n	t = (Tree)malloc(sizeof(struct item));\r\n	if (!t)\r\n	{\r\n		perror(\"malloc: \");\r\n		return NULL;\r\n	}\r\n	t->c = -1;\r\n	t->l = NULL;\r\n	t->r = NULL;\r\n	t->count = 0;\r\n	c1 = GetBit();\r\n	if (c1) \r\n	{\r\n		t->l = ReadTree(); \r\n		t->r = ReadTree();\r\n	}\r\n	else\r\n	{\r\n		t->c = 0;\r\n		for (i = 0; i < 8; i++)\r\n		{\r\n			t->c += GetBit() << i;\r\n		}\r\n	}\r\n	return t;\r\n}\r\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (167,'#include <stdio.h>\n#include <string.h>\n#define N 10000\n\nint palin(char *A)\n{	\n	int a=0, b=strlen(A)-2;\n	while (b-a>=1)\n	{\n		printf(\"a: %d, b: %d\\n\", a, b);\n		while(A[a]==\' \')\n			a++;\n		\n		while(A[b]==\' \')\n			b--;	\n		\n		if (A[a]!=A[b])\n			\n			return 0;\n\n		a++;\n		b--;\n	}\n	return 1;\n}\n\n\nint main()\n{	\n	char B[N];\n	FILE *f=fopen(\"input.txt\", \"r\");\n	fgets (B, N, f);\n	printf (\"%d \\n\",palin(B));\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (168,'#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nint main ()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n	int i,k=0;\n	char c,z[11];\n	struct item *head,*p,*A,*q;\n	while (c!=EOF)\n	{\n		c=fgetc(f);\n		while (!(((c>=\'a\')&&(c<=\'z\'))||((c>=\'A\')&&(c<=\'Z\')))&&(c!=EOF))\n			c=fgetc(f);\n		if (c==EOF)\n			break;\n		i=0;\n		z[i]=c;\n		i++;\n		while ((((c>=\'a\')&&(c<=\'z\'))||((c>=\'A\')&&(c<=\'Z\')))&&(c!=EOF))\n		{\n			c=fgetc(f);\n			z[i++]=c;\n		}\n		z[i-1]=0;\n		if (k==0)\n		{\n			A=malloc(sizeof(struct item));\n			head=A;\n			A->count=1;\n			A->next=0;\n			strcpy(A->word,z);\n			k++;	\n		}\n		else\n		{\n			q=head;\n			for (p=head;(p)&&(strcmp(z,p->word));p=p->next)\n				q=p;\n			if (p==0)\n			{\n				A=malloc(sizeof(struct item));\n				A->count=1;\n				A->next=0;\n				strcpy(A->word,z);\n				q->next=A;\n			}\n			else\n			{\n				p->count++;\n			}	\n		}\n	}\n	f=fopen(\"output.txt\",\"w\");\n	for (p=head;p;p=p->next)\n		fprintf(f,\"%s %d\\n\",p->word,p->count);\n	fclose(f);\n\n	while (head)\n	{\n		p=head;\n		head=head->next;\n		free(p);\n	}\n\n	return 0;\n}\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (169,'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <string.h>\nint main()\n{ \nint i,j,a,k,sum1,sum2;\nchar S[100];\nfgets(S, 100, stdin);\nscanf(\"%d\",&a);\nsum1=0;\n	for (i=0;S[i];i++)\n	{\n		if ((S[i]==\'\\n\'||S[i]==\' \')||(S[i]==\'.\'))\n		{\n			k=i;\n			break;\n		}\n	}\n	for (i=0;i<k;i++)\n	{\n		if (S[i] >= \'0\' && S[i] <= \'9\')\n		{\n			S[i] = S[i] - \'0\';\n			printf(\"????? ?????????????? S[%d] = %d\\n\", i, S[i]);\n		}\n		else\n		if (S[i] >= \'A\' && S[i] <= \'F\')\n		{\n			S[i] = S[i]-\'A\'+10;\n			printf(\"????? ?????????????? S[%d] = %d\\n\", i, S[i]);\n		}\n	}\n	for (i=0;i<k;i++)\n	{\n//		S[i+1]=S[i]*a+S[i+1];\n		sum1 = sum1 * a + S[i];\n	\n	}\n	printf(\"? ?????????? ??????? ??? %d\\n\",sum1);\nreturn 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (170,'#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\nint main()\n{\nint a,b,c,i,n;\na=0;\nb=1;\ni=2;\nscanf(\"%d\",&n);\nwhile(i<n+19)\n	{\n	a=a+b;\n	i++;\n	if(i==n)\n		{\n		printf(\"%d\",a);\n		break;\n		}\n	else\n	{\n	b=a+b;\n	i++;\n		if(i==n)\n		{\n		printf(\"%d\",b);\n		break;\n		}\n		}\n}\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (171,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\nint main()\n{\nchar S[100];\nchar login[100];\nchar * p;\nint i=0;\nint j=0;\nint r=0;\nchar Symbol;\nFILE *f=fopen(\"/etc/passwd\",\"rt\");\n	if (!f) {printf(\"Can\'t open file\\n\"); \n	return 0;}\n printf(\"Vvedite login:\\n\");\n scanf(\"%s\",login);\n do {\n	 p=fgets(S,100,f);\n	if (p) {\n		r=0;\n		for (i=0; login[i] != 0; i++)\n		{\n			if (login[i]!=S[i]) r=1;\n		}\n		if ((S[i])!=\':\') r=1;\n			if (r==0) {\n				i=0;\n				j=0;\n				do {\n					Symbol=S[i++];\n					if (Symbol==\':\') j++;\n				} while (j<4);\n				printf(\"Your name is \");\n				do {\n					Symbol=S[i++];\n					if (Symbol!=\',\') printf(\"%c\",Symbol);\n				} while(Symbol!=\',\');\n			}\n		}\n	}\nwhile ((p)&&(r)); // ?????, ????? p == 0 ???    r == 0\n                  //              ????? ?????   ????????? ??????????? ?????? ???????? ?????? ?????\nprintf(\"\\n\");\n\nif ( r == 1 )\n{\n	printf(\"?????? ?????? ? ????? ???\\n\");\n}\n\nfclose(f);\n}\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (172,'#define _CRT_SECURE_NO_WARNINGS\r\n\r\n//#include <crtdbg.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include <limits.h>\r\n#include \"three.h\"\r\n#include \"hufflib.h\"\r\n\r\n#define LENGTH_ALPHABET 256\r\n\r\nint len = LENGTH_ALPHABET, count_cymbol = 0, lenArr = 0;\r\nint out[8], len_out = 0;\r\nchar cym; int f = 0;\r\nchar countCymbol[33];\r\n\r\nstruct three *root, *tmpRoot;\r\nstruct three *Arr[LENGTH_ALPHABET];\r\nstruct alphabet A[LENGTH_ALPHABET], a[LENGTH_ALPHABET];\r\n\r\nvoid printBit(int bit)\r\n{\r\n	out[len_out] = bit;\r\n	len_out++;\r\n	if(len_out == 8)\r\n	{\r\n		int i, ch;\r\n		ch = toDec(out);\r\n		printf(\"%c\", ch);\r\n		// clear\r\n		for(i=0; i<8; i++)\r\n			out[len_out] = 0;\r\n		len_out = 0;\r\n	}\r\n}\r\n\r\nvoid insertSort1(int len)\r\n{\r\n	int i, j;\r\n	struct three *current = calloc(1, sizeof(struct three));\r\n	for(i=1; i<len; i++)\r\n	{\r\n		cpy(current, Arr[i]);\r\n		for(j=i-1; (j>=0) && (current->freq > Arr[j]->freq); j--)\r\n		{\r\n			cpy(Arr[j+1], Arr[j]);\r\n		}\r\n		cpy(Arr[j+1], current);\r\n	}\r\n	free(current);\r\n}\r\n\r\nvoid buildThree(struct three **T, int len)\r\n{\r\n	int i = len;\r\n	int k = len+1;\r\n	struct three *left, *right;\r\n	if(i == 0)\r\n	{	\r\n		// TREE\r\n		(*T) = calloc(1, sizeof(struct three));\r\n		cpy((*T), Arr[0]); free(Arr[0]);\r\n		(*T)->s[0] = 0;\r\n	}\r\n	while(i != 0)\r\n	{\r\n		// left\r\n		left = calloc(1, sizeof(struct three));\r\n		cpy(left, Arr[i]); free(Arr[i]);\r\n		left->s[0] = 0;\r\n		// right\r\n		right = calloc(1, sizeof(struct three));\r\n		cpy(right, Arr[i-1]);\r\n		right->s[0] = 0;\r\n		// root\r\n		Arr[i-1]->cymbol = \'?\';	Arr[i-1]->s[0] = 0;\r\n		Arr[i-1]->freq = left->freq + right->freq;\r\n		Arr[i-1]->left = left;	Arr[i-1]->right = right;\r\n		// TREE\r\n		if(i == 1)\r\n		{\r\n			(*T) = Arr[i-1];\r\n			break;\r\n		}\r\n		insertSort1(i);\r\n		i = i - 1;\r\n	}\r\n}\r\n\r\nvoid code(char *nameIn, char *nameOut)\r\n{\r\n	int i, c = 0;\r\n	for(i=0; i<8; i++)\r\n			out[len_out] = 0;\r\n	for(i=0; i<LENGTH_ALPHABET; i++)\r\n	{\r\n		a[i].cymbol = i;\r\n		a[i].freq = 0;\r\n		A[i].cymbol = i;\r\n	}\r\n	freopen(nameIn, \"rb\", stdin);\r\n	while( (c = getchar()) != EOF )\r\n	{\r\n		a[c].freq++;\r\n		count_cymbol++;\r\n	}\r\n	insertSort(a);\r\n	for(i=0; i<LENGTH_ALPHABET; i++)\r\n		if(a[i].freq == 0)\r\n		{\r\n			len = i;\r\n			break;\r\n		}\r\n\r\n	for(i=0; i<len; i++)\r\n	{\r\n		Arr[i] = calloc(1, sizeof(struct three));\r\n		Arr[i]->cymbol = a[i].cymbol;\r\n		Arr[i]->freq = a[i].freq;\r\n		Arr[i]->posInAlphabet = i;\r\n		Arr[i]->left = NULL;\r\n		Arr[i]->right = NULL;\r\n	}\r\n\r\n	freopen(nameIn, \"rb\", stdin);\r\n	freopen(nameOut, \"wb\", stdout);\r\n\r\n	if(len > 1)\r\n	{\r\n		toTwo(count_cymbol, countCymbol); \r\n		printf(\"%d \", count_cymbol);\r\n		buildThree(&root, len-1);\r\n		prefix(root, a);\r\n\r\n		for(i=0; i<len; i++)\r\n			A[a[i].cymbol] = a[i];\r\n		print(root); // printThree\r\n		while( (c = getchar()) != EOF )\r\n		{\r\n			unsigned int j;\r\n			for(j=0; j<strlen(A[c].s); j++)\r\n				printBit(A[c].s[j]-\'0\');\r\n		}\r\n		if(len_out != 0)\r\n		{\r\n			len_out = 7;\r\n			printBit(0);\r\n		}\r\n	}\r\n	else if(len == 1)\r\n	{\r\n		printf(\"%d \", count_cymbol);\r\n		buildThree(&root, len-1);\r\n		prefix(root, a);\r\n		printf(\"%c\", (*root).cymbol);\r\n	}\r\n}\r\nvoid readThree(struct three *root)\r\n{\r\n	int c;\r\n	c = getchar();\r\n	if(c == 0 + \'0\')\r\n	{\r\n		root->left = calloc(1, sizeof(struct three));\r\n		root->left->posInAlphabet = -1;\r\n		root->right = calloc(1, sizeof(struct three));\r\n		root->right->posInAlphabet = -1;\r\n		readThree(root->left);\r\n		readThree(root->right);\r\n	}\r\n	else if(c == 1 + \'0\')\r\n	{\r\n		int ch;\r\n		ch = getchar();\r\n		root->cymbol = ch;\r\n		root->posInAlphabet = 0;\r\n	}\r\n	else\r\n	{\r\n		f = 1;\r\n		cym = c;\r\n	}\r\n}\r\n\r\nint getBit()\r\n{\r\n	int c;\r\n	if(len_out == 0)\r\n	{\r\n		c = getchar();\r\n		if(c == EOF)\r\n			return -1;\r\n		toTwoD(c, out);\r\n		len_out = 8;\r\n	}\r\n	len_out--;\r\n	return out[len_out];\r\n}\r\n\r\nvoid decode(char *nameIn, char *nameOut)\r\n{\r\n	int i, c, bit;\r\n	for(i=0; i<8; i++)\r\n		out[len_out] = 0;\r\n	freopen(nameIn, \"rb\", stdin);\r\n	freopen(nameOut, \"wb\", stdout);\r\n	scanf(\"%d\", &count_cymbol);\r\n	c = getchar();\r\n	root = calloc(1, sizeof(struct three));\r\n	readThree(root);\r\n	if(f == 1)\r\n	{\r\n		for(i=0; i<count_cymbol; i++)\r\n			printf(\"%c\", cym);\r\n	}\r\n	else if(root)\r\n	{\r\n		tmpRoot = root;\r\n		while( ((bit = getBit()) != -1) && count_cymbol>0)\r\n		{\r\n			if(bit == 0)\r\n				tmpRoot = tmpRoot->left;\r\n			if(bit == 1)\r\n				tmpRoot = tmpRoot->right;\r\n			if(tmpRoot->posInAlphabet == 0)\r\n			{\r\n				printf(\"%c\", tmpRoot->cymbol);\r\n				tmpRoot = root;\r\n				count_cymbol--;\r\n			}\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char* argv[])\r\n{\r\n	if(argc == 4)\r\n		decode(argv[2], argv[3]);\r\n	else if(argc == 3)\r\n		code(argv[1], argv[2]);\r\n	cleanThree(root);\r\n//	_CrtDumpMemoryLeaks();\r\n	return 0;\r\n}\r\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (173,'#include <stdio.h>\r\n#include <string.h>\r\n\r\nint step(int a, int n)\r\n{\r\n	int i, res = 1;\r\n	for (i=0; i<n; i++)\r\n		res = res * a;\r\n	return res;\r\n}\r\n\r\nint toDec(unsigned s[])\r\n{\r\n	int i, res = 0;\r\n	for(i=0; i<8; i++)\r\n		res += (s[i])*step(2, 8-1-i);\r\n	return res;\r\n}\r\n\r\nvoid downTo(char *s)\r\n{\r\n	unsigned int i = 0;\r\n	char ch = \'q\';\r\n	for(i=0; i<strlen(s)/2; i++)\r\n	{\r\n		ch = s[i];\r\n		s[i] = s[strlen(s)-i-1];\r\n		s[strlen(s)-i-1] = ch;\r\n	}\r\n}\r\n\r\nvoid revv(int a[])\r\n{\r\n	unsigned int i = 0;\r\n	int ch;\r\n	for(i=0; i<8/2; i++)\r\n	{\r\n		ch = a[i];\r\n		a[i] = a[8-i-1];\r\n		a[8-i-1] = ch;\r\n	}\r\n}\r\n\r\nvoid toTwo(int a, char countCymbol[])\r\n{\r\n	int j, i = -1;\r\n	while (a > 0)\r\n	{\r\n		i++;\r\n		countCymbol[i] = \'0\' + a%2;\r\n		a /= 2;\r\n	}\r\n	for(j=i+1; j<32; j++)\r\n		countCymbol[j] = \'0\';\r\n	countCymbol[33] = 0;\r\n	downTo(countCymbol);\r\n}\r\n\r\nvoid toTwoD(int a, int out[])\r\n{\r\n	int i = -1;\r\n	for(i=0; i<8; i++)\r\n		out[i] = 0;\r\n	i = -1;\r\n	while (a > 0)\r\n	{\r\n		i++;\r\n		out[i] = a%2;\r\n		a /= 2;\r\n	}\r\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (174,'#define _CRT_SECURE_NO_WARNINGS\r\n#include \"three.h\"\r\n\r\nvoid prefix(struct three *root, struct alphabet a[])\r\n{\r\n	if(!root->left)\r\n	{\r\n		if(root->s[0] == 0) { root->s[0] = \'0\'; root->s[1] = 0; }\r\n		strcpy(a[root->posInAlphabet].s, root->s);\r\n		return;\r\n	}\r\n	strcpy(root->left->s, root->s);\r\n	strcat(root->left->s, \"0\");\r\n	prefix(root->left, a);\r\n	\r\n	strcpy(root->right->s, root->s);\r\n	strcat(root->right->s, \"1\");\r\n	prefix(root->right, a);\r\n}\r\n\r\nvoid cleanThree(struct three *root)\r\n{\r\n	if(!root)	return;\r\n	cleanThree(root->left);\r\n	cleanThree(root->right);\r\n	free(root);\r\n	root = NULL;\r\n}\r\n\r\nvoid printThree(struct three *root, int mode)\r\n{\r\n	if(!root)return;\r\n	if(!(root->left) || mode)\r\n		printf(\"%c%s \", root->cymbol, root->s);\r\n	printThree(root->left, mode);\r\n	printThree(root->right, mode);\r\n}\r\n\r\nint search(struct three *root, char *s)\r\n{\r\n	int res = -1;\r\n	if(!root) return res;\r\n	if(strcmp(root->s, s) == 0)\r\n		return root->cymbol;\r\n	res = search(root->left, s);\r\n	if(res >= 0) return res;\r\n	res = search(root->right, s);\r\n	if(res >= 0) return res;\r\n	return res;\r\n}\r\n/*\r\nvoid buildThree(struct three **T, struct alphabet a[], int len)\r\n{\r\n	int i = len-1;\r\n	struct three *left, *right, *root;\r\n	// left\r\n	left = calloc(1, sizeof(struct three));\r\n	left->cymbol = a[i].cymbol;\r\n	left->freq = a[i].freq;\r\n	left->posInAlphabet = i;\r\n	left->s[0] = 0;\r\n	left->left = NULL; left->right = NULL;\r\n	// right\r\n	right = calloc(1, sizeof(struct three));\r\n	right->cymbol = a[i-1].cymbol;\r\n	right->freq = a[i-1].freq;\r\n	right->posInAlphabet = i-1;\r\n	right->s[0] = 0;\r\n	right->left = NULL; right->right = NULL;\r\n	// root\r\n	root = calloc(1, sizeof(struct three));\r\n	root->cymbol = 0;	root->s[0] = 0;\r\n	root->freq = left->freq + right->freq;\r\n	root->left = left;	root->right = right;\r\n	// TREE\r\n	(*T) = root;\r\n	for(i=len-3; i>=0; i--)\r\n	{\r\n		// left\r\n		left = calloc(1, sizeof(struct three));\r\n		left->cymbol = a[i].cymbol;\r\n		left->freq = a[i].freq; left->s[0] = 0;\r\n		left->posInAlphabet = i;\r\n		left->left = NULL; left->right = NULL;\r\n		// root\r\n		root = calloc(1, sizeof(struct three));\r\n		root->cymbol = 0; root->s[0] = 0;\r\n		root->freq = left->freq + (*T)->freq;\r\n		root->left = left;	root->right = (*T);\r\n		(*T) = root;\r\n	}	\r\n}*/\r\n\r\nvoid insertSort(struct alphabet a[])\r\n{\r\n	int i, j;\r\n	struct alphabet current;\r\n	for(i=1; i<256; i++)\r\n	{\r\n		current.cymbol = a[i].cymbol;\r\n		current.freq = a[i].freq;\r\n		for(j=i-1; (j>=0) && (current.freq>a[j].freq); j--)\r\n		{\r\n			a[j+1].cymbol = a[j].cymbol;\r\n			a[j+1].freq = a[j].freq;\r\n		}\r\n		a[j+1].cymbol = current.cymbol;\r\n		a[j+1].freq = current.freq;\r\n	}\r\n}\r\n\r\nvoid cpy(struct three *a, struct three *b)\r\n{\r\n	a->cymbol = b->cymbol;\r\n	a->freq = b->freq;\r\n	a->left = b->left; a->right = b->right;\r\n	a->posInAlphabet = b->posInAlphabet;\r\n	strcmp(a->s, b->s);\r\n}\r\n\r\nvoid print(struct three *root)\r\n{\r\n	if(!root->left && !root->right)\r\n	{\r\n		printf(\"%c\", \'1\');\r\n		printf(\"%c\", root->cymbol);\r\n	}\r\n	else\r\n	{\r\n		printf(\"%c\", \'0\');\r\n		print(root->left);\r\n		print(root->right);\r\n	}\r\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (175,'#include<stdio.h>\n#include<string.h>\nint main ()\n{\n	int i, m=0, n, k;\n	FILE *f;\n	f=fopen (\"pal.txt\",\"r\");\n\n	#define N 1000\n	char s[N];\n	fgets (s, N, f);\n	m=strlen(s);\n\n	for (i=0;i<m;i++)\n	{\n		printf (\"%c\", s[i]);\n	}\n	printf (\"\\n\");\n	\n	n=0;\n	k=m-1;\n	for (i=0;i<m/2; i++)\n	{\n		while (s[n]<\'0\') \n		{\n			n++;\n			i++;\n		}	\n		while (s[k]<\'0\') \n		{\n			k--;\n			i++;\n		}\n		if (s[n]!=s[k])\n		{\n			printf (\"NeT\\n\");\n			return 0;\n		}\n		n++;\n		k--;\n	}\n	printf (\"DA\\n\");\n	\n	fclose (f);\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (176,'#include<stdio.h>\n#include<stdlib.h>\n\nint bsort(int *A,int N,int k)\n{\n	int buf;\n	if ((2*k+1<N))\n	if (A[2*k+1]>A[2*k+2])\n	{\n		if ((A[2*k+1]>A[k])&&(2*k+1<N))\n		{\n			buf=A[k];\n			A[k]=A[2*k+1];\n			A[2*k+1]=buf;\n			bsort(A,N,2*k+1);\n		}\n	}\n	else\n	{\n		if ((A[2*k+2]>A[k])&&(2*k+2<N))\n		{\n			buf=A[k];\n			A[k]=A[2*k+2];\n			A[2*k+2]=buf;\n			bsort(A,N,2*k+2);\n		}	\n	}\n}\n\nint main ()\n{\n	int m, i, buf, n;\n	FILE *f, *g;\n	f=fopen (\"input1.txt\",\"r\");\n	\n	freopen(\"output.txt\", \"w\", stdout);\n\n	fscanf (f, \"%d\", &m);\n	int * X;\n	X = malloc (m * sizeof (int));\n	\n	for (i=0; i<m ;i++)\n	{\n		fscanf (f, \"%d\", &X[i]);\n	}\n\n	for(i=m/2-1;i>=0;i--)\n	{\n		bsort ( X, m , i);\n	}\n\n	n=m-1;\n	while( n)\n	{\n		buf=X[0];\n		X[0]=X[n];\n		X[n]=buf;\n		n--;\n		bsort(X, n+1, 0);\n	}\n\n	for (i=0; i<m ;i++)\n        {\n//		fprintf (g, \"%d\", X[i]);\n		printf (\"%d \", X[i]);\n		\n	}\n	printf (\"\\n\");\n\n	fclose (f);\n//	fclose (g);\n	free(X);\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (177,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main()\n{\n	int i=0,k,j,l,m,d=0,count=0;\n	#define N 100000\n	FILE *f;\n	f=fopen(\"input14.txt\", \"r\");\n	char c;\n	char A[N];\n	char C[11];\n	fgets(A,N,f);\n	l=strlen(A);\n	struct item{\n		char word[11];\n		int count;\n		struct item *next;\n	};\n	struct item *head, *p, *q, *v;\n	head=NULL;\n	for(i=0;i<l;i++)\n	{\n		printf(\"%c\",A[i]);\n	}	\n	printf(\"l: %d\\n\", l);\n	for(i=0;i<l-1;)\n	{\n		while(i < l && A[i]<\'A\' || A[i]>\'z\')\n		{\n			i++;\n		}\n		j=0;\n		d=0;\n		while(i < l && A[i]>=\'A\' && A[i]<=\'z\')\n		{\n			C[j]=A[i];\n			j++;\n			i++;\n\n		}\n		C[j]=0;\n		struct item *p=malloc(sizeof(struct item));\n		p=head;\n		while(p && strcmp(p->word,C)!=0)\n		{\n			q=p;\n			p=p->next;\n		}\n		if(p==NULL)\n		{\n			if (C[0] != 0)\n			{\n				struct item *v=malloc(sizeof(struct item));\n				printf(\"????????? ????? %s\\n\", C);\n				strcpy(v->word,C);\n				v->next=head;\n				v->count=1;\n				head=v;\n			}\n		}\n		if(p!=NULL)\n		{\n			p->count++;\n		}\n	}\n	for(p=head ; p ; p=p->next)\n	{\n		printf(\"%s  %d\\n\", p->word , p->count);\n		printf(\"\\n\");\n	}\n	fclose(f);\n\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (178,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint main()\n{\n	int i=0,k,j,l,m,d=0,count=0;\n	#define N 100000\n	FILE *f;\n	f=fopen(\"input14.txt\", \"r\");\n	char c;\n	char A[N];\n	char C[11];\n	fgets(A,N,f);\n	l=strlen(A);\n	struct item{\n		char word[11];\n		int count;\n		struct item *next;\n	};\n	struct item *head, *p, *q, *v;\n	head=NULL;\n	for(i=0;i<l;i++)\n	{\n		printf(\"%c\",A[i]);\n	}	\n	printf(\"l: %d\\n\", l);\n	for(i=0;i<l-1;)\n	{\n		while(i < l && A[i]<\'A\' || A[i]>\'z\')\n		{\n			i++;\n		}\n		j=0;\n		d=0;\n		while(i < l && A[i]>=\'A\' && A[i]<=\'z\')\n		{\n			C[j]=A[i];\n			j++;\n			i++;\n\n		}\n		C[j]=0;\n		struct item *p=malloc(sizeof(struct item));\n		p=head;\n		while(p && strcmp(p->word,C)!=0)\n		{\n			q=p;\n			p=p->next;\n		}\n		if(p==NULL)\n		{\n			if (C[0] != 0)\n			{\n				struct item *v=malloc(sizeof(struct item));\n				printf(\"????????? ????? %s\\n\", C);\n				strcpy(v->word,C);\n				v->next=head;\n				v->count=1;\n				head=v;\n			}\n		}\n		if(p!=NULL)\n		{\n			p->count++;\n		}\n	}\n	for(p=head ; p ; p=p->next)\n	{\n		printf(\"%s  %d\\n\", p->word , p->count);\n		printf(\"\\n\");\n	}\n	fclose(f);\n\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (179,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint main()\n{\n	int i,j=0,N;\n	FILE *f;\n	f=fopen(\"input13.txt\", \"r\");\n	fscanf(f,\"%d\", &N);\n	int A[N];\n	struct item {\n		int data;\n		struct item *next;\n	};\n	struct item *head = 0;\n	for(i=0;i<N;i++)\n	{	\n		fscanf(f, \"%d\",  &A[i]);\n		printf(\"%d  \", A[i]);\n	}\n	printf(\"\\n\");\n	struct item *k=malloc(sizeof(struct item));\n	struct item *p, *q;\n	k->data=A[j];\n	k->next=head;\n	head=k;\n	for(j=1;j<N;j++)\n	{\n	//	struct item *p=malloc(sizeof(struct item));\n	//	struct item *q=malloc(sizeof(struct item));\n		p=head;\n		q=NULL;\n		while(p!=0 && p->data<=A[j])\n		{\n			q=p;\n			p=p->next;\n		}\n		if(q==NULL)\n		{\n			struct item *z=malloc(sizeof(struct item));\n			z->data=A[j];\n			head=z;\n			z->next=p;\n		}\n		if(p==NULL)\n		{\n			struct item *z=malloc(sizeof(struct item));\n			z->data=A[j];\n			q->next=z;\n			z->next=NULL;\n		}\n		if(p!=NULL && q!=NULL)\n		{\n			struct item *z=malloc(sizeof(struct item));\n			z->data=A[j];\n			q->next=z;\n			z->next=p;\n		}\n	}\n	for(k=head;k;k=k->next)\n	{\n		printf(\"%d  \", k->data);\n	}\n	printf(\"\\n\");\n	fclose(f);\n	while(head!=NULL)\n	{\n		p=head;\n		head=head->next;\n		free(p);\n	}\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (180,'#include <stdio.h>\n#include <string.h>\n#define N 100000\n\n	void quicksort (int *A, int l, int r)\n	{\n	\n	int x;     //??????? ???????\n	int i, j, t;\n\n	i = l;\n	j = r;\n	x = (A[l] + A[r])/2;\n\n	\n	while (i <= j)\n	{\n	 while(A [i] < x)\n		i++;\n	 while (A[j] > x)\n	 	j--;\n	\n	 if (i <=j)\n	 {\n	  t = A[i];\n	  A[i] = A[j];\n	  A[j] = t;\n	  i++;\n	  j--;\n	 }\n	}\n	\n\n	if (i < r) \n	    quicksort(A, i, r);\n	if (l < j)\n	    quicksort(A, l, j);\n	}\n\n\nint main()\n{\n int A[N];\n int n, i, x;\n \n \n FILE *f = fopen (\"input.txt\", \"r\");\n if (!f)\n {\n  perror (\"fopen\");\n }\n\n \n fscanf (f, \"%d\", &n);\n\n for (i = 0; i < n ; i++)\n {\n  fscanf (f, \"%d\", &x);\n  A[i] = x;\n }\n\n  quicksort(A, 0, n-1);\n \n \n FILE *p = fopen (\"output.txt\", \"w\");\n if (!p)\n {\n  perror (\"fopen\");\n }\n \n\n for (i = 0; i < n; i++)\n fprintf(p, \"%d \", A[i]);\n\n fprintf(p, \"\\n\");\n fclose(p);\nreturn 0;\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (181,'#include <stdio.h>\n#include <string.h>\n\nint main()\n\n{\nint i,j;\nint p=0;\nchar M[1000];\nFILE *f=fopen(\"input.txt\", \"rt\");\n	if (f==NULL) \n	printf(\"%s\",\"takogo  faila  net\\n\");\n	else\n	{\n\n	fgets(M,1000,f);\n	i=0; j=strlen(M)-2;\n	printf(\"??????: %s, j: %d\\n\", M, j);\n	do{ if (M[i]==\'.\' || M[i]==\',\' || M[i]==\' \') i++;\n	else\n	if (M[j]==\'.\' || M[j]==\',\' || M[j]==\' \') j--;\n	else\n	if (M[i]!=M[j]) \n	{ printf(\"???????? %c ? %c\\n\", M[i], M[j]);\n	  printf(\"%s\",\"Ne palindrom\\n\"); p=1; \n	break;}\n	else {i++; j--;}\n}\n\n	while(i<j);\n	if (p!=1) printf(\"%s\",\"Palindrom\\n\");\n\n	fclose(f);\n}}\n\n\n\n	\n\n	 \n	\n\n\n \n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (182,'#include <stdio.h>\n#include <string.h>\n\n#include \"arch.h\"\n#include \"tree.h\"\n\n//#define DEBUG\nstatic void makeCodesFromTree(code*,tnode*,int,exli);\nstatic void initialize(tnode*,int);\nstatic void makeZero(code*,int);\nstatic void countSymbolsInFile(char*,tnode*,int*);\nvoid archivate (char* str1, char* str2){//here were are archivating\n	int cnt=0,putChar=0;\n#ifdef DEBUG\n	int i;\n#endif\n	unsigned int c;\n	tnode* rootOfHT;\n	code codes[256];\n	tnode symbs[256];\n	int all=0;\n	FILE* fta;\n	FILE* archive;\n	/*initializing*/\n	initialize (symbs,256);\n	makeZero(codes,256);\n	/*counting*/\n	countSymbolsInFile(str2,symbs,&all);\n	/*making Huffman tree*/\n	rootOfHT = makeHuffmanTree(symbs,256);\n	//writing 2)tree to file and 1)number of chars\n	archive = fopen(str1,\"w\");\n	fprintf(archive,\"%d\",all);\n	if (rootOfHT){\n		int t = (!rootOfHT->left && !rootOfHT->right);\n		printTreeToFile(archive,rootOfHT);\n		//travel along the tree to make code-table\n		makeCodesFromTree(codes,rootOfHT,t,0LL);\n#ifdef DEBUG\n		for (i=0;i<256;i++){\n			if (codes[i].length)\n				printf(\"%c - %lld - %d\\n\",i,codes[i].word,codes[i].length);\n		}\n#endif\n		/*We have a table with HuffCodes\n		  Reading file => changing symbols with codes\n		*/\n		fta = fopen(str2,\"rb\");\n		while ((c = fgetc(fta)) != EOF){\n			int putBit;\n			exli temp;\n			int len;\n			temp = codes[c].word;\n			len = codes[c].length;\n			while (len){\n				exli dummy = temp;\n				dummy >>= len-1;\n				putBit = (dummy & 1LL);\n				len--;\n				cnt++;\n				putChar <<= 1;\n				putChar |= putBit;\n				if (cnt % 8 == 0){\n					fputc(putChar,archive);\n				cnt -= 8;\n				}\n			}\n		}\n		/*if we have some unprinted chars*/\n		if (cnt % 8 !=0){\n			putChar <<= (8-cnt);\n			fputc(putChar,archive);\n		}\n		//archive is ready\n		fclose(fta);\n		freeTree(rootOfHT);\n	}\n	fclose(archive);\n}\nvoid makeCodesFromTree(code* codes,tnode* root,int curlen,exli curcode){\n	if (root->left == NULL && root->right == NULL){\n		codes[root->c].length = curlen;\n		codes[root->c].word = curcode;\n		return;\n	}\n	if (root->left){\n		curlen++;\n		curcode <<= 1;\n		makeCodesFromTree(codes,root->left,curlen,curcode);\n		curcode >>= 1;\n		curlen--;\n	}\n	if (root->right){\n		curlen++;\n		curcode <<= 1;\n		curcode += 1;\n		makeCodesFromTree(codes,root->right,curlen,curcode);\n		curcode >>= 1;\n		curlen --;\n	}\n}\nvoid dearchivate (char* str1,char* str2){\n	int cnt,c;\n	FILE* archive,*unpacked;\n	tnode* rootOfHT,*curPos;\n	archive = fopen(str1,\"rb\");\n	fscanf(archive,\"%d\",&cnt);\n	if (cnt){\n		rootOfHT = createTreeFromFile(archive);\n		curPos = rootOfHT;\n		unpacked = fopen(str2,\"w\");\n		while((c = fgetc(archive)) != EOF && cnt){\n			int temp;\n			int i;\n			for (i=0;i<8;i++){\n				temp = c & (1<<(7-i));\n				if (!curPos->left && !curPos->right){\n					fputc(curPos->c,unpacked);\n					curPos = rootOfHT;\n					cnt--;\n					if (cnt == 0) break;\n				}\n				if (curPos->left || curPos->right){\n					if (!temp){\n						curPos = curPos->left;\n					} else {\n						curPos = curPos->right;\n					}\n				}\n			}\n		}\n		if (!curPos->left && !curPos->right && cnt>0){\n			fputc(curPos->c,unpacked);\n			curPos = rootOfHT;\n			cnt--;\n		}\n		if (cnt != 0){\n			printf(\"Probably mistake has occured.\\n\");\n		}\n		fclose(unpacked);\n		freeTree(rootOfHT);\n	} else {\n		unpacked = fopen(str2,\"w\");\n		fclose(unpacked);\n	}\n	fclose(archive);\n}\nstatic void countSymbolsInFile(char* filename,tnode* symbs,int* all){\n	FILE* fta;\n	int c;\n	fta = fopen(filename,\"rb\");\n	while ((c = fgetc(fta)) != EOF){\n		symbs[c].cnt++;\n		(*all)++;\n	}\n	fclose(fta);\n}\n\nstatic void makeZero (code* codes,int n){\n	int i;\n	for (i=0;i<n;i++)\n		codes[i].length = codes[i].word = 0;\n}\nstatic void initialize(tnode* sym,int n){\n	int i;\n	for (i=0;i<n;i++){\n		sym[i].left = sym[i].right = NULL;\n		sym[i].c = i;\n		sym[i].cnt = 0;\n		sym[i].isDynamic = 0;\n	}\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (183,'#include <stdio.h>\n#include <string.h>\n\n#include \"arch.h\"\n\n//#define FLAG\n\nstatic void print_help(void);\n\nint main(int argc,char* argv[]){\n	FILE* f;\n	if (argc > 1){\n		if (strcmp(argv[1],\"-d\") == 0){\n			//dearchivating\n			f = fopen(argv[2],\"r\"); //test open\n			if (!f){\n				printf(\"Error:There isn\'t any file named \\\"%s\\\" to extract.\\n\",argv[2]);\n				return 0;\n			}\n			fclose(f);\n			printf(\"Extracting...\\n\");\n			dearchivate(argv[2],argv[3]);\n			printf(\"Done!\\n\");\n		}\n		else if (strcmp(argv[1],\"--help\") == 0 || strcmp(argv[1],\"-h\") == 0){\n			print_help();\n		} else {\n			f = fopen(argv[2],\"r\");//test open\n			if (!f){\n				printf(\"Error:there isn\'t any file named \\\"%s\\\" to archivate.\\n\",argv[2]);\n				return 0;\n			}\n			fclose(f);\n			printf(\"Archivating...\\n\");\n			archivate(argv[1],argv[2]);\n			printf(\"Done!\\n\");\n		}	\n	}\n	else {\n		print_help();\n	}	\n	return 0;\n}\n\nstatic void print_help(void){\n	printf(\"Usage:\\n\");\n	printf(\"\\tTo make an archive with your file:\\n\");\n	printf(\"\\t\\t./main archive_name file_name\\n\");\n	printf(\"\\tTo dearchivate:\\n\");\n	printf(\"\\t\\t./main -d archive_name file_name\\n\");\n	printf(\"\\tTo get this help page use -h or --help.\\n\");\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (184,'#include <stdio.h>\n#include <stdlib.h>\n#include \"tree.h\"\n\nstatic tnode* createRootNode (tnode*, tnode*);\nstatic void countNonZeroes(tnode*,int*,int*);\n//bonus, yet unused function\nvoid climb (tnode* node,void (*function)(tnode*)){\n	if (node->left) climb(node->left,function);\n	(*function)(node);\n	if (node->right) climb(node->right,function);\n}\n\ntnode* makeHuffmanTree(tnode* syms,int n){\n	tnode* root;\n	int cnt=0;\n	int end = n-1;\n	int prevnonzero = 0;\n	int place=0;//there will be the root \n	//counting non-zero values\n	countNonZeroes(syms,&cnt,&prevnonzero);\n	if (cnt == 0){\n		return NULL;\n	}\n	if (cnt == 1){\n		place = prevnonzero;\n	}\n	while (cnt>1){//while there won\'t be one root\n		tnode *t;\n		int i;\n		int imin,imin2;\n		int start = prevnonzero;\n		//searching for a couple of minimums\n		while (syms[start].cnt == 0){//searching for first non-zero number\n			if (start == end) return NULL;  \n			start++;\n		}\n		imin = start;\n		start++;\n		while (syms[start].cnt == 0){//second non-zero number\n			if (start == end) break;\n			start++;\n		}\n		imin2 = start;\n		start++;\n		if (syms[imin].cnt>syms[imin2].cnt){\n			tnode swap;\n			swap = syms[imin];\n			syms[imin]=syms[imin2];\n			syms[imin2]=swap;\n		}\n		for (i=start; i<=end; i++){\n			if (syms[i].cnt == 0) continue;\n			if (syms[i].cnt < syms[imin].cnt){\n				imin2 = imin;\n				imin = i;\n			} else if (syms[i].cnt < syms[imin2].cnt){\n				imin2 = i;\n			}\n		}\n		//found. creating root and inserting in the array\n		t = createRootNode(&syms[imin],&syms[imin2]);\n		if (t == NULL) return NULL;\n		syms[imin] = *t;\n		syms[imin].isDynamic = 0;\n		free(t);\n		syms[imin2] = syms[end];\n		cnt--;\n		end--;\n		place = imin;\n		//inserted\n	}\n	root = &syms[place];\n	return root;\n}\ntnode* createTreeFromFile(FILE* file){\n	int c;\n	tnode *root,*left,*right;\n	root = (tnode*)malloc(sizeof(tnode));\n	if (!root){\n		perror(\"malloc\");\n		return NULL;\n	}\n	root->left = root->right = NULL;\n	root->c = root->cnt = 0;\n	root->isDynamic = 1;\n	c = fgetc(file);//eating \'(\'\n	c = fgetc(file);//what is next?\n	if (c == \'(\'){\n		ungetc(c,file);\n		left = createTreeFromFile(file);\n		root->left = left;\n		right = createTreeFromFile(file);\n		root->right = right;\n	} else {\n		if (c == \'-\'){\n			int temp;\n			temp = fgetc(file);\n			if (temp == \'(\'){\n				root->c = temp;\n			} else {\n				ungetc(temp,file);\n				root->c = c;\n			}\n		} else {\n			root->c = c;\n		}\n	}		\n	c = fgetc(file);//eating \')\'\n	return root;\n}\nvoid printTreeToFile(FILE* file,tnode* root){\n	fputc(\'(\',file);\n	if (root->left)printTreeToFile(file,root->left);\n	if (!root->left && !root->right){\n		if (root->c == \'(\'){\n			fputc(\'-\',file);\n		}\n	   	fputc(root->c,file);\n	}\n	if (root->right)printTreeToFile(file,root->right);\n	fputc(\')\',file);\n}\nvoid freeTree(tnode* root){\n	if(!root) return;\n	if(root->left)freeTree(root->left);\n	if(root->right)freeTree(root->right);\n	if(root->isDynamic)\n		free(root);\n}\n\nstatic void countNonZeroes(tnode* syms,int* cnt,int* posoffirst){\n	int j;\n	for (j=0;j<256;j++){\n		if (syms[j].cnt != 0){\n			if ((*cnt) == 0)(*posoffirst) = j;\n			(*cnt)++;\n		}\n	}\n}\n\nstatic tnode* createRootNode (tnode* nodeL,tnode* nodeR){\n	int sum;\n	tnode* q,*left,*right;\n	sum = nodeL->cnt + nodeR->cnt;\n	q = (tnode*)malloc(sizeof(tnode));\n	left = (tnode*)malloc(sizeof(tnode));\n	right = (tnode*)malloc(sizeof(tnode));\n\n	if (!q || !left || !right){\n		perror(\"malloc\");\n		return NULL;\n	}\n	*left = *nodeL;\n	left->isDynamic = 1;\n	*right = *nodeR;\n	right->isDynamic = 1;\n	q->left = left;\n	q->right = right;\n	q->c = nodeR->c;\n	q->cnt = sum;\n	q->isDynamic = 1;\n	if (nodeL->isDynamic)free(nodeL);\n	if (nodeR->isDynamic)free(nodeR);\n	return q;\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (185,'#include \"compress.h\"\n\nvoid packFile(char *filename, char *archive)\n{\n	size_t count[0x100], i, j, k, read;\n	unsigned int sizeOfFile = 0;\n	uchar buf[_BUFFER_SIZE];\n	FILE *inputFile = fopen(filename, \"rb\");\n/*#ifdef DEBUG\n	FILE *outputFile = stdout;\n#else*/\n	FILE *outputFile = fopen(archive, \"wb\");\n//#endif\n\n	treeNode tree[512];\n	size_t top, bottom;\n	code codes[0x100];\n\n\n	if(inputFile == NULL)\n	{\n		perror(\"[11] fopen\");\n		abort();\n	}\n	if(outputFile == NULL)\n	{\n		perror(\"[12] fopen\");\n		abort();\n	}\n\n	//\n	// ****************************************************************** Read file\n	//\n	\n	fseek(inputFile, 0, SEEK_END);\n	sizeOfFile = ftell(inputFile);\n	fwrite(&sizeOfFile, 4, 1, outputFile);\n	fseek(inputFile, 0, SEEK_SET);\n\n	memset(count, 0, sizeof(size_t)*0x100);\n	for(i=0; i<sizeOfFile; i+=_BUFFER_SIZE)\n	{\n		fread(buf, _BUFFER_SIZE, 1, inputFile);\n		read = _BUFFER_SIZE < sizeOfFile-i ? _BUFFER_SIZE : sizeOfFile-i;\n#ifdef DEBUG\n		printf(\"read %lu bytes\\n\", read);\n#endif\n		for(j = 0; j < read; j++)\n			count[buf[j]]++;\n	}\n	fclose(inputFile);\n\n#ifdef DEBUG\n	for(j=0; j<32; j++)\n	{\n		for(i=0; i<8; i++)\n			printf(\"%3lu \'%c\' %lu\\t\", j*8+i, (int)(j*8+i), count[j*8+i]);\n		printf(\"\\n\");\n	}\n	printf(\"File size: %u\\n\", sizeOfFile);\n#endif\n\n	//\n	// ****************************************************************** Make tree\n	//\n	\n	top = bottom = 511;\n	for(i=0; i<0x100; i++)\n		if(count[i] != 0)\n			makeEdge(&tree[bottom--], i, count[i]);\n#ifdef DEBUG\n	printf(\"bottom=%lu top=%lu\\n\", bottom, top);\n#endif\n	while(top > bottom+1)\n	{\n		for(i = bottom+1; i < top; i++)\n			for(j = i+1; j <= top; j++)\n				if(tree[i].count < tree[j].count)\n				{\n					tree[0] = tree[i];\n					tree[i] = tree[j];\n					tree[j] = tree[0];\n				}\n		makeNode(&tree[bottom--], top-1, top, tree[top].count + tree[top-1].count);\n		top -= 2;\n	}\n	\n	__DEBUG( printNode(tree, bottom+1, stdout); );\n	dumpTree(outputFile, tree, bottom+1);\n\n	//\n	// ***************************************************************** Make codes\n	//\n\n	clearCodes(codes);\n	setCodes(codes, tree, bottom+1, 0, 0);\n#ifdef DEBUG\n	printf(\"\\n --- codes: ---\\n\");\n	for(i=0; i<0x100; i++)\n	{\n		if(codes[i].len == 0)\n			continue ;\n		printf(\"%c: \", (int)i);\n		printf(\"%d:%llu\", codes[i].len, codes[i].cod);\n		printf(\"\\n\");\n	}\n	printf(\" --- end ---\\n\");\n#endif\n\n	//\n	// ************************************************************** Compress file\n	//\n\n	size_t useCount = 0;\n	size_t useNumber = 0;\n	const int useMax = _BUFFER_SIZE*2;\n	uint64 blockWrite[useMax];\n	memset(blockWrite, 0, useMax*sizeof(uint64));\n	{\n		size_t readBytes;\n\n		if((inputFile = fopen(filename, \"rb\")) == NULL)\n		{\n			perror(\"[13] fopen\");\n			abort();\n		}\n\n#ifdef DEBUG\n		printf(\"\\n --- compress: ---\\n\");\n#endif\n		for(i=0; i<sizeOfFile; i+=_BUFFER_SIZE)\n		{\n			fread(buf, _BUFFER_SIZE, 1, inputFile);\n			readBytes = _BUFFER_SIZE < sizeOfFile-i ? _BUFFER_SIZE : sizeOfFile-i;\n#ifdef DEBUG\n			printf(\"read %lu bytes\\n\", readBytes);\n#endif\n			for(j=0; j<readBytes; j++)\n			{\n#ifdef DEBUG\n				printf(\"\'%c\': %llu   useNumber=%lu, useCount=%lu \\n\", buf[j], codes[buf[j]].cod, useNumber, useCount);\n#endif\n				if((64-useCount) >= codes[buf[j]].len)\n				{\n					blockWrite[useNumber] += codes[buf[j]].cod << (64 - useCount - codes[buf[j]].len);\n					useCount += codes[buf[j]].len;\n					if(useCount == 64)\n					{\n						useNumber++;\n						useCount = 0;\n					}\n				}\n				else\n				{\n					blockWrite[useNumber] += codes[buf[j]].cod >> (codes[buf[j]].len - (64 - useCount));\n					useNumber++;\n					blockWrite[useNumber] += codes[buf[j]].cod << ((64 - codes[buf[j]].len) + (64 - useCount));\n					useCount = useCount - 64 + codes[buf[j]].len;\n				}\n\n				if(useNumber == useMax-1)\n				{\n					uint64 tmp = blockWrite[useNumber];\n#ifdef DEBUG\n					printf(\"\\n --- result: ---\\n\");\n					for(k=0; k<useNumber; k++)\n					{\n						printf(\"%X %X\\n\", (uint)(blockWrite[k]>>32), (uint)(blockWrite[k]&0xffffffff));\n					}\n					printf(\"\\n --- end of result ---\\n\");\n#endif\n					fwrite(blockWrite, (useMax-1)*sizeof(uint64), 1, outputFile);\n					memset(blockWrite, 0, useMax*sizeof(uint64));\n					useNumber = 0;\n					blockWrite[0] = tmp;\n				}\n			}\n		}\n		fclose(inputFile);\n\n#ifdef DEBUG\n		printf(\"\\n --- result: ---\\n\");\n		for(i=0; i<=useNumber; i++)\n		{\n			printf(\"%X %X\\n\", (uint)(blockWrite[i]>>32), (uint)(blockWrite[i]&0xffffffff));\n		}\n		printf(\"\\n --- end of compress ---\\n\");\n#endif\n\n		if(useCount == 0)\n			useNumber--;\n		fwrite(blockWrite, (useNumber+1)*sizeof(uint64), 1, outputFile);\n	}\n	fclose(outputFile);\n\n\n}\n\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (186,'#include \"decompress.h\"\n\nvoid unpackFile(char *inputArchive, char *outputName)\n{\n	FILE *inputFile = fopen(inputArchive, \"rb\");\n	FILE *outputFile = fopen(outputName, \"wb\");\n	unsigned int sizeOfFile;\n	int i;\n	treeNode tree[512];\n	size_t lastNode, sizeOfSourceFile;\n\n	if(inputFile == NULL)\n	{\n		perror(\"[21] fopen\");\n		return ;\n	}\n	if(outputFile == NULL)\n	{\n		perror(\"[22] fopen\");\n		return ;\n	}\n\n	//\n	// *************************************************************** calc size\n	//\n	\n	fseek(inputFile, 0, SEEK_END);\n	sizeOfSourceFile = ftell(inputFile);\n	fseek(inputFile, 0, SEEK_SET);\n	__DEBUG( printf(\"sizeOfSourceFile=%lu\\n\", sizeOfSourceFile); );\n\n	//\n	// *************************************************************** read tree\n	//\n\n	fread(&sizeOfFile, 4, 1, inputFile);\n	lastNode = readTreeFromFile(tree, inputArchive) + 1;;;;;;;;;;;;;;;;;;;;;;;\n	__DEBUG( printNode(tree, 0, stdout); );\n\n	//\n	// ********************************************************* decompress file\n	//\n\n	__DEBUG( printf(\"\\n --- decompress: ---\\n\"); );\n	uint64 buf[_BUFFER_SIZE];\n	uchar writeBuf[_BUFFER_SIZE]; size_t currentWritePos = 0; \n	size_t currentBit = 0;\n	size_t currentNode = 0;\n	size_t readsCount = 0;\n	// skip tree\n	__DEBUG( printf(\"lastNode=%lu\\n\", lastNode); );\n	size_t bytesBeforeFile = (5*lastNode+4)/64 + ((5*lastNode+4)%64>0 ? 1 : 0);\n	bytesBeforeFile *= 8;\n	fread(buf, bytesBeforeFile, 1, inputFile);\n	__DEBUG( printf(\"skip %lu bytes\\n\", bytesBeforeFile); );\n\n	sizeOfSourceFile -= bytesBeforeFile + 4;\n	for(i = 0; i < sizeOfFile; currentBit++)\n	{\n		if(currentBit % (_BUFFER_SIZE*64) == 0)\n		{\n			int tmp;\n			currentBit = 0;\n			//tmp=fread(buf, _BUFFER_SIZE*64 > sizeOfFile - _BUFFER_SIZE*readsCount ? sizeOfFile - _BUFFER_SIZE*readsCount : _BUFFER_SIZE, 1, inputFile);\n			tmp = (_BUFFER_SIZE*8 > sizeOfSourceFile - _BUFFER_SIZE*8*readsCount) ? (sizeOfSourceFile - _BUFFER_SIZE*8*readsCount) : (_BUFFER_SIZE*8);\n			__DEBUG( printf(\"i must read %d bytes\\n\", tmp); );\n			tmp = fread(buf, tmp, 1, inputFile);\n			readsCount++;\n			__DEBUG( printf(\"i\'m read(tmp=%d) some bytes and now i\'m happy :)\\n\", tmp); );\n#ifdef DEBUG\n			printf(\"\\n--- read dump: ---\\n\");\n			for(tmp=0; tmp<_BUFFER_SIZE; tmp++)\n				printf(\"%3d: %llu\\n\", tmp, buf[tmp]);\n			printf(\"\\n--- end of dump ---\\n\");\n#endif\n		}\n\n		currentNode = (buf[currentBit/64] >> (63-currentBit%64)) & 1 ? tree[currentNode].right : tree[currentNode].left;\n		__DEBUG( printf(\"currentBit=%d   node=%lu\\n\", (int)((buf[currentBit/64] >> (63-currentBit%64)) & 1), currentNode); );\n\n		if(tree[currentNode].type == _TREE_VERTEX)\n		{\n			__DEBUG( printf(\"char %d: \'%c\'\\n\", i, tree[currentNode].value); );\n			writeBuf[currentWritePos++] = tree[currentNode].value;\n			if(currentWritePos == _BUFFER_SIZE)\n			{\n				fwrite(writeBuf, _BUFFER_SIZE, 1, outputFile);\n				currentWritePos = 0;\n			}\n			i++;\n			currentNode = 0;\n		}\n	}\n	fwrite(writeBuf, currentWritePos, 1, outputFile);\n	__DEBUG( printf(\"\\n --- end ---\\n\"); );\n\n\n\n	fclose(inputFile);\n}\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (187,'#include \"main.h\"\n\nvoid printHelp()\n{\n	printf(\"\\tSimple archiver on Huffman\'s algorithm\\n\\n\");\n	printf(\"\\tUsage:\\n\");\n	printf(\"\\t\\thuff <file 1> <file 2>    - compress <file 1> and save archive in <file 2>\\n\");\n	printf(\"\\t\\thuff -d <file 1> <file 2> - decompress <file 1> to <file 2>\\n\");\n	printf(\"\\t\\thuff -h                   - show this help message\\n\\n\");\n	printf(\"\\tGood bye! :)\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n	int action = _ACTION_NOACTION;\n\n	switch(argc)\n	{\n		case 3:\n			action = _ACTION_COMPRESS;\n			break;\n		case 4:\n			if(!strcmp(argv[1], \"-d\"))\n				action = _ACTION_DECOMPRESS;\n	}\n\n#ifndef DEBUG\n	if(action == _ACTION_NOACTION)\n	{\n		printHelp();\n		return 0;\n	}\n#else\n	if(action == _ACTION_NOACTION)\n		printf(\"\\n\");\n#endif\n	else if(action == _ACTION_COMPRESS)\n		packFile(argv[1], argv[2]);\n	else\n		unpackFile(argv[2], argv[3]);\n	\n	return 0;\n}\n\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (188,'#include \"tree.h\"\n\nvoid makeEdge(treeNode *node, char value, size_t count)\n{\n	node->type = _TREE_VERTEX;\n	node->value = value;\n	node->count = count;\n}\n\nvoid makeNode(treeNode *node, int left, int right, size_t count)\n{\n	node->type = _TREE_NODE;\n	node->left = left;\n	node->right = right;\n	node->count = count;\n}\n\nvoid printNode(treeNode tree[], int id, FILE *output)\n{\n	if(tree[id].type == _TREE_NODE)\n	{\n		fprintf(output, \"[\");\n		if(tree[id].left != 0)\n			printNode(tree, tree[id].left, output);\n		if(tree[id].right != 0)\n			printNode(tree, tree[id].right, output);\n		fprintf(output, \"]\");\n	}\n	else\n		fprintf(output, \"{%c}\", tree[id].value);\n}\n\nvoid clearCodes(code *result)\n{\n	memset(result, 0, sizeof(code)*0x100);\n}\n\nvoid setCodes(code *result, treeNode *tree, int id, uint64 path, uchar len)\n{\n	if(tree[id].type == _TREE_NODE)\n	{\n		len++;\n		path <<= 1;\n		setCodes(result, tree, tree[id].left, path, len);\n		path++;\n		setCodes(result, tree, tree[id].right, path, len);\n	}\n	else\n	{\n		result[tree[id].value].cod = path;\n		result[tree[id].value].len = len;\n	}\n}\n\nstatic size_t dumpTreedfs(treeNode *tree, size_t nodeNumber, uint64 *start, size_t currentBit)\n{\n	if(tree[nodeNumber].type == _TREE_NODE)\n	{\n#ifdef DEBUG\n		printf(\"currentBit=%lu   1(%lu)\\n\", currentBit, nodeNumber);\n		//printf(\"currentBit=%lu[%llu]   1(%lu)\\n\", currentBit, start[currentBit/64], nodeNumber);\n		{ int tmp = currentBit/64; int a = tmp==0? 0 : tmp-1; int b = a+1; printf(\"    %8X %8X   %8X %8X\\n\", (uint)(start[a]>>32), (uint)(start[a]&0xffffffff), (uint)(start[b]>>32), (uint)(start[b]&0xffffffff)); }\n#endif\n		//printf(\"    %llu\\n\", start[currentBit/64]);\n		start[currentBit/64] |= (1LL<<(63-currentBit%64));\n		//printf(\"    %llu\\n\", start[currentBit/64]);\n		currentBit++;\n		currentBit = dumpTreedfs(tree, tree[nodeNumber].left, start, currentBit);\n		currentBit = dumpTreedfs(tree, tree[nodeNumber].right, start, currentBit);\n	}\n	else\n	{\n		//start[currentBit/64] += 1<<(63-currentBit%64);\n#ifdef DEBUG\n		printf(\"currentBit=%lu   0(%lu) value=%2X\\n\", currentBit, nodeNumber, tree[nodeNumber].value);\n		{ int tmp = currentBit/64; int a = tmp==0? 0 : tmp-1; int b = a+1; printf(\"    %8X %8X   %8X %8X\\n\", (uint)(start[a]>>32), (uint)(start[a]&0xffffffff), (uint)(start[b]>>32), (uint)(start[b]&0xffffffff)); }\n#endif\n		currentBit++;\n		if(currentBit%64 > 64-8)\n		{\n			start[currentBit/64] |= ((uint64)tree[nodeNumber].value >> (8-(64-currentBit%64)));\n			start[currentBit/64+1] |= ((uint64)tree[nodeNumber].value << (60-(currentBit%64-60)));\n		}\n		else\n		{\n			start[currentBit/64] |= ((uint64)tree[nodeNumber].value << (64-currentBit%64-8));\n		}\n		currentBit += 8;\n	}\n	return currentBit;\n}\n\nvoid dumpTree(FILE *stream, treeNode *node, size_t startNode)\n{\n	uint64 writeBuf[64];\n	size_t usedBits;\n\n	memset(writeBuf, 0, sizeof(uint64)*64);\n#ifdef DEBUG\n	printf(\"\\n --- dump tree to file: ---\\n\");\n#endif\n	usedBits = dumpTreedfs(node, startNode, writeBuf, 0);\n#ifdef DEBUG\n	{ int tmp = usedBits/64; int a = tmp==0? 0 : tmp-1; int b = a+1; printf(\"    %8X %8X   %8X %8X\\n\", (uint)(writeBuf[a]>>32), (uint)(writeBuf[a]&0xffffffff), (uint)(writeBuf[b]>>32), (uint)(writeBuf[b]&0xffffffff)); }\n	printf(\"\\n --- end of tree\'s dump ---\\n\");\n#endif\n	fwrite(writeBuf, 8*(usedBits/64 + (usedBits%64>0)), 1, stream);\n}\n\nstatic size_t readTreedfs(treeNode *tree, size_t nodeNumber, uint64 *start, size_t *currentBit)\n{\n	int bit = (start[(*currentBit)/64] >> (63-(*currentBit)%64)) & 1;\n	size_t lastNode = nodeNumber;\n	(*currentBit)++;\n	if(bit == 1)\n	{\n#ifdef DEBUG\n		printf(\"node: number=%lu  currentBit=%lu\\n\", nodeNumber, *currentBit);\n#endif\n		tree[nodeNumber].type = _TREE_NODE;\n		tree[nodeNumber].left = lastNode+1;\n		lastNode = readTreedfs(tree, lastNode+1, start, currentBit);\n		tree[nodeNumber].right = lastNode+1;\n		lastNode = readTreedfs(tree, lastNode+1, start, currentBit);\n	}\n	else\n	{\n#ifdef DEBUG\n		printf(\"vert: number=%lu  currentBit=%lu\", nodeNumber, *currentBit);\n#endif\n		tree[nodeNumber].type = _TREE_VERTEX;\n		if((*currentBit)%64>64-8)\n		{\n			tree[nodeNumber].value = (start[(*currentBit)/64] & (0xffffffffffffffffLL >> ((*currentBit)%64))) << (8-(64-(*currentBit)%64));\n			tree[nodeNumber].value += start[(*currentBit)/64+1] >> (64-(8-(64-(*currentBit)%64)));\n		}\n		else\n		{\n#ifdef DEBUG\n			printf(\"(i\'m here)\");\n#endif\n			tree[nodeNumber].value = (start[(*currentBit)/64] >> (64 - (*currentBit) - 8)) & 0xff;\n		}\n		(*currentBit) += 8;\n#ifdef DEBUG\n		printf(\" value=%c\\n\", tree[nodeNumber].value);\n#endif\n	}\n	return lastNode;\n}\n\nsize_t readTreeFromFile(treeNode *tree, char *filename)\n{\n	FILE *inputFile = fopen(filename, \"rb\");\n	uint64 readBuf[64];\n	size_t tmp;\n	size_t fileSize;\n	size_t treeSize;\n\n#ifdef DEBUG\n	printf(\"\\n --- read tree: ---\\n\");\n#endif\n\n	if(inputFile == NULL)\n	{\n		perror(\"[31] fopen\");\n		fprintf(stderr, \"this fatal unknown error\\n\");\n		exit(1);\n	}\n\n\n	fseek(inputFile, 0, SEEK_END);\n	fileSize = ftell(inputFile);\n	fseek(inputFile, 0, SEEK_SET);\n\n	fread(&tmp, 4, 1, inputFile);\n	tmp = fread(readBuf, ((fileSize-4)/8 >= 64 ? 64 : (fileSize-4)/8)*sizeof(uint64), 1, inputFile);\n#ifdef DEBUG\n	printf(\"tmp=%lu\\nfileSize=%lu\\n\", tmp, fileSize);\n#endif\n\n	tmp = 0;\n	treeSize = readTreedfs(tree, 0, readBuf, &tmp);\n	fclose(inputFile);\n\n#ifdef DEBUG\n	printf(\"\\n --- end of tree ---\\n\");\n#endif\n\n	return treeSize;\n}\n\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (189,'#include<stdio.h>\n#include<string.h>\nint main()\n{\n	int i=0,j,l,k=0,d=0,e,N;\n	#define N 1000\n	char A[N],B[N],C[N],D[N];\n	FILE *f;\n	f=fopen(\"/etc/passwd\", \"r\");\n	printf(\"??????? ?????:  \");\n	scanf(\"%s\", A);\n	l=strlen(A);\n	while(fgets(B,N,f))\n	{\n		for(i=0;B[i]!=\':\';i++)\n		{\n			C[i]=B[i];\n		}\n		C[i] = 0;\n			k=strcmp(A,C);\n			if(k==0)\n			{\n				for(j=0;d!=4;j++)\n				{	\n					if(B[j]==\':\')\n					d++;	\n				}\n				e=j;\n				for(;B[j]!=\':\';j++)\n				{\n					D[j-e]=B[j];\n					printf(\"%c\", D[j-e]);\n				}\n				printf(\"\\n\");\n				fclose(f);\n				return 0;\n			}\n		\n	}\n	printf(\"???????????? ?? ??????????\\n\");\n	fclose(f);\n}\n\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (190,'#include <stdio.h>\n#include <string.h>\n#define NNAX 100000\n\nvoid sift (int *A, int N, int k)\n{\n	int x, t;\n\n	/*for ( ;(2*k + 2) < N; k++)\n	   {\n	    if (A[k] < A[2*k +1] || A[k] < A[2*k +2])\n	    {\n	     \n	    //x = indmax (A[2*k + 1], A[2*k + 2]);\n	     t = A[k];\n	     A[k] = x;\n	     x = t;\n	    }\n	   }*/\n	\n	// k -- ??????? ???????\n	//A[k]  A[2*k+1]  A[2*k+2]\n	t = k;\n	if (2*k+1<N && A[2*k+1]>A[t]) t = 2*k+1;\n	if (2*k+2<N && A[2*k+2]>A[t]) t = 2*k+2;\n	// t -- ?????? ????????????? ?? ????\n	if (t != k)\n	{\n		int z = A[k];\n		A[k] = A[t];\n		A[t] = z;\n		sift(A, N, t);\n	}\n}\n\n\nint main()\n{\n int A[NNAX];\n int n, i, l, x, k;\n \n \n FILE *f = fopen (\"input.txt\", \"r\");\n if (!f)\n {\n  perror (\"fopen\");\n }\n\n \n fscanf (f, \"%d\", &n);\n\n int original_n = n;\n\n for (i = 0; i < n ; i++)\n {\n  fscanf (f, \"%d\", &x);\n  A[i] = x;\n }\n    \n   for (k = n/2; k>=0; k--)\n  	 sift (A, n, k);\n\n   while (n >= 2)\n   {\n    n--;\n    l = A[0];\n    A[0] = A[n];\n    A[n] = l;\n    sift (A, n, 0);\n   }\n\n \n \n FILE *p = fopen (\"output.txt\", \"w\");\n if (!p)\n {\n  perror (\"fopen\");\n }\n \n\n for (i = 0; i < original_n; i++)\n     fprintf(p, \"%d \", A[i]);\n fprintf(p, \"\\n\");\n fclose(p);\n return 0;\n}\n	\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (191,'#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<string.h>\nint main()\n{\nint i,k,j;\nint c;\nchar S[100];\nfgets(S, 100, stdin);\nS[strlen(S)-1] = 0;\nprintf(\"??????: <<<%s>>>\\n\", S);\nfor(k=0;S[k];k++)\n	j=k;\nfor(i=0;i<j;)\n	{\n	\n		\n		while((S[i]==\' \')||(S[i]==\',\')||(S[i]==\'-\'))\n			i++;\n		while((S[j]==\' \')||(S[j]==\',\')||(S[j]==\'-\'))\n			j--;\n		if(S[i]!=S[j])\n		{\n			printf(\"?? ?????????\\n\");	\n			return 0;\n		}\n		else\n		{\n			i++;\n			j--;\n		}\n	}\nprintf(\"?????????\\n\");\n}\n	/*for(j=k;j!=;j--)\n		if(S[j]==\' \')||(S[j]==\',\')||(S[j]==\'-\')\n	j--;*/\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (192,'#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nint main()\n{\nint a,b,c,n;\nscanf(\"%i\",&a);\nscanf(\"%i\",&b);\nn=0;\nwhile(n==0)\n	{\n	if(a%b==0)\n		n=b;\n	else\n		{\n			c=a;\n			a=b;\n			b=c%b;\n		}\n	}\nprintf(\"?????????? ????? ???????? %i\",n);\n}\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (193,'#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nfloat f(float x)\n{\n	return(sin(x));\n}\nint main()\n{\nfloat a,b,c;\nscanf(\"%f\",&a);\nscanf(\"%f\",&b);\nfloat eps=0.001;\nc = a;\nwhile(fabs(f(c))>=eps)\n	{\n		c=(b+a)/2;\n		if(fabs(f(a))<fabs(f(b)))\n			b=c;\n		else\n			a=c;\n	}\nprintf(\"Solution %f\",c);\nreturn 0;\n}\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (194,'#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\nfloat f(float x)\n{\n	return (x*x);\n}\nint main()\n{\nfloat a,b,c,d,s;\nfloat ep=0.001;\ns=0;\n/*scanf(\"%f\",a);\nscanf(\"%f\",b);*/\na=0;\nb=1;\nc = a;\nwhile(c<b)\n	{\n	d=c+ep;\n	if (f(c)<f(d))\n		{\n		s=s+(ep*f(c));\n		c=c+ep;\n		}\n	else \n		{\n		s=s+(ep*f(d));\n		c=c+ep;\n		}\n	}\nprintf(\"???????? %f\",s);\nreturn 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (195,'#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define N 10\nint isprime(int a)\n{\nint j;\nfor(j=2;j*j<=a;j++)\n	{\n	if(a%j==0)\n		{\n		return 1;\n		break;\n		}\n	}\nreturn 0;\n}\nint main()\n{\nint i,k;\nk=0;\nint B[N]={12,13,35,567,87,98,90,67,31};\nfor(i=0;i<N;i++)\n	{\n	k=isprime(B[i]);\n	if (k==1)\n	{\n	printf(\"??????? ?????????\");\n	break;\n	}\n	}\nif(k==0)\nprintf(\"??? ??????\");\n}\n\n\n\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (196,'#include<stdlib.h>\n#include<stdio.h>\n#include<math.h>\n#define N 2\nint main()\n{\nint i,j,k,s;\ns=0;\nint A[N][N]={ { 1, 2}, { 3, 4 } };\nint B[N][N]={ { 2, 0}, { 0, 2 } };\nint C[N][N]={ 0 };\nfor(i=0;i<N;i++)\n	for(j=0;j<N;j++)\n	{\n		s = 0;\n		for(k=0;k<N;k++)\n			{\n				s=s+(A[i][k]*B[k][j]);	\n			}\n		C[i][j]=s;\n		printf(\"%i \",C[i][j]);\n		\n	}\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (197,'#include <stdio.h>\n#include <string.h>\n#define N 100\n\n\n\nvoid g (int A[N][N],int *V,int k,int m,int *t)\n{\n	int j;\n	int p=*t;\n	p++;\n	*t=p;\n	V[k]=1;\n	printf (\"%d \",k);\n	for (j=0;j<=m;j++)\n		if ((!V[j])&&(A[k][j]))\n			g(A,V,j,m,t);\n}\n\nvoid h (char *S,int *i, int *j)\n{\n	int c,k,t=1;\n	for (c=0;(c<=strlen(S))&&(S[c]!=\' \');c++)\n		;\n	for (k=c-1;k>=0;k--)\n	{\n		*i+=(S[k]-\'0\')*t;\n		t=t*10;\n	}\n	t=1;\n	for (k=strlen(S)-2;k>=c+1;k--)\n	{\n		*j+=(S[k]-\'0\')*t;\n		t=t*10;\n	}\n\n}\n\nint main ()\n{\n	FILE *f=fopen (\"input.c\",\"r\");\n	int i,j,A[N][N],V[N],m=0,t;\n	char S[10];\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++)\n			A[i][j]=0;\n	for (;fgets(S,10,f);)\n	{\n		i=0;\n		j=0;\n		h(S,&i,&j);\n		A[i][j]=1;\n		A[j][i]=1;\n		if (i>m) m=i;\n		if (j>m) m=j;\n	}\n	printf(\"m: %d\\n\", m);\n	for (i=0;i<m;i++)\n	{\n		for (j=0;j<N;j++)\n			V[j]=0;\n		t=0;\n		V[i]=1;\n		if (i) g(A,V,0,m,&t);\n		else g(A,V,1,m,&t);\n		printf (\"- %d %d %d\\n\",i,t,m);\n		if (t!=m)\n		{\n			fclose (f);\n			printf (\"?????????? ????? ????????? - %d\\n\",i);\n			return 0;\n		}\n	}\n	fclose (f);\n	printf (\"?? ?????????? ????? ?????????\\n\");\n	return 0;\n}		\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (198,'#include<stdio.h>\n#include<math.h>\n#define N 100\n\nint f(int x,int y)\n{\nif(y==0)\nreturn(1);\nreturn(x*f(x,y-1));\n}\nint main ()\n{\n	printf(\"_ \");\n	int b,c;\n	int i,t;\n	t=0;\n	i=0;\n	char A[N]={0};\n	scanf(\"%d\",&b);\n	printf(\"_ \");\n	scanf(\"%s\",A);\n	\n	c=0;\n	printf(\"_ \");\n	while(A[t+1]!=0)\n	t++;\n	while(i!=t+1)\n	{\n	printf(\"\\n %d \\n\",A[i]-\'0\');\n	i++;\n	};\n	for(i=t;i!=-1;i--)\n	{\n		if ((b<=10)&&(b>=2)&&(A[t-i]>=\'0\')&&(A[t-i]<b+\'0\'))\n			if ((A[t-i]>=\'0\')&&(A[t-i]<=\'9\'))\n				c=c+(A[i]-\'0\')*f(b,t-i);\n		if ((b>10)&&((A[t]>=\'0\')&&(A[i]<=\'9\')))\n			c=c+f(b,t-i)*(A[i]-\'0\');	\n		if ((b>10)&&((A[i]>=\'A\')&&(A[i]<b+\'A\')))\n			c=c+f(b,t-i)*(A[i]-\'A\'+10);\n	}\n	printf(\"%d\\n\",c);\n	return(0);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (199,'#include <math.h>\n#include <stdio.h>\nint main()\n{\n	int i,n,c;\n	int k=5;\n	int e=1;\n	int a=0;\n	int b=k-1;\n	int A[100]={0};\n	for (i=0;i<k;i++)\n		A[i]=2*i;\n	printf(\"? ???????: \");\n	for (i = 0; i < k; i++)\n	{\n		printf(\"%d \", A[i]);\n	}\n	printf(\"\\n\");\n	scanf(\"%d\",&n);\n	int B[100]={0};\n	for (i=0;i<n;i++)\n		scanf(\"%d\",&B[i]);\n	for (i=0;i<n;i++)\n	{	c=0;\n		a=0;\n		b=k-1;\n		while (!c)\n		{	\n			if((B[i]>=A[0])&&(B[i]<=A[k-1]))\n			{\n				if(B[i]==A[0])\n				{\n					printf(\"??????? %d ?????? ?? ????? 0\\n\", B[i]);\n					c=1;\n				}\n				if(B[i]==A[k-1])\n				{\n					printf(\"??????? %d ?????? ?? ????? %d\\n\",B[i],k-1);\n					c=1;\n				}\n				while((b-a>e)&&(c==0))\n				{\n					if(B[i]==A[(a+b)/2])\n					{\n						printf(\"??????? %d ?????? ?? ?????  %d\\n\",B[i], (a+b)/2);\n						c=1;\n					}\n					if(B[i]>A[(a+b)/2])\n					{\n						a=(a+b)/2;\n					} else \n					b=(a+b)/2;\n				}\n				if (!c) printf(\"??????? %d ?? ???????????\\n\",B[i]);\n				c=1;\n\n			}\n			else\n			{	\n				c=1;\n				printf(\"??????? %d ?? ???????????\\n\",B[i]);\n			}\n		}\n\n	}\n	\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (200,'#include <stdio.h>\n#include <string.h>\n#define LENGTH 1000\n\nint main()\n\n{\n	int l,r,f=0;\n	char arr[LENGTH];\n	FILE *s;\n\n\n	s=fopen(\"input.txt\", \"r\");\n	fgets(arr,LENGTH,s);\n	l=0; r=strlen(arr)-2;\n	while(l<=r && !f && r>0) { \n		if (arr[l]==\'.\' || arr[l]==\',\' || arr[l]==\' \') { \n			l++;\n		} else {\n			if (arr[r]==\'.\' || arr[r]==\',\' || arr[r]==\' \') { \n				r--;\n			} else {\n				if (arr[l]!=arr[r]) { \n					printf(\"?? ?????????\\n\"); f=1;\n				} else { \n					l++; r--;\n				};\n			};\n		};\n				\n	};\n	if (!f) printf(\"?????????\\n\");\n	return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (201,'#include <stdio.h>\n#include <string.h>\nint main ()\n{\n	char A[100]={\'0\'};\n	int b;\n	int a,c,i;\n	int s=0;\n	scanf (\"%d\",&b);\n	int n=0;\n	getchar();\n	while (n == 0 || A[n-1]!=\'\\n\')\n	{\n		A[n]=getchar();\n		n++;\n	}\n	for (i=0;i<n-1;i++)\n	{\n		if ((A[i]<=\'9\')&&(A[i]>=\'0\'))\n			a=A[i]-\'0\';\n		else a=A[i]-\'A\'+10;\n		printf(\"a: %d\\n\", a);\n		s=s*b+a;\n		printf(\"s: %d\\n\", s);\n	}\n	printf(\"%d\\n\",s);\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (202,'#include <stdio.h>\n#include <string.h>\n#define n 100000\n\nvoid h(int*s, int l, int o)\n{\nint q;\n//printf(\"%d, %d \",o,l);\n//printf(\"[ \");\n//for (q = o; q < l; q++)\n//{\n//	printf(\"%d \", s[q]);\n//}\n//printf(\"]\\n\");\nint i=o, j=l-1;\nint x,a;\nx=(s[o]+s[l-1])/2;\n//printf(\"???????: %d\\n\",x);\nwhile(i<=j)\n	{\n		while(s[i]<x) \n			i++;\n		while(s[j]>x)\n			j--;\n		if(i<=j)\n		{\n			a=s[i];\n			s[i]=s[j];\n			s[j]=a;		\n			i++;\n			j--;\n		}\n	}\nif(l-1>i)\n	h(s,l,i);\nif(j>o)\n	h(s,j+1,o);\nreturn;\n}\n\nint main()\n{\nint s[n];\nint i,j,m=0,t,x,k;\nFILE*f=fopen(\"input.txt\",\"r\");\nFILE*g=fopen(\"output.txt\",\"w\");\n\nfscanf(f, \"%d\", &m);\nfor (i = 0; i < m; i++)\n	fscanf(f, \"%d\", &s[i]);\n\nh(s,m,0);\n\nfor (i = 0; i < m; i++)\n	fprintf(g, \"%d \", s[i]);\nfprintf(g, \"\\n\");\n\nfclose(g);\nfclose(f);\nreturn(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (203,'#include <stdio.h>\n\nstruct node {\n    struct node *root, *left, *right;\n    int symbol, useflag, number;\n};\ntypedef struct node Ttree[0x200];\n\nstatic int buffer;\nstatic char length;\n\nstatic void setbit(char bit) {\n    buffer <<= 1;\n    buffer |= bit;\n    length++;\n\n    if (length == 8) {\n        putchar(buffer);\n        length = 0;\n        buffer = 0;\n    }\n}\n\nstatic void setchar(char field) {\n    char i;\n    for (i = 7; i >= 0; i--) setbit((field >> i) & 1);\n}\n\nstatic void setint(int field) {\n    int i;\n    for (i = 0x1f; i >= 0; i--) setbit((field >> i) & 1);\n}\n\nstatic char getbit(void) {\n    char val;\n\n    if (length == 0) {\n        buffer = getchar();\n        length = 8;\n    }\n\n    val = (buffer >> (length - 1)) & 1;\n    length--;\n\n    return val;\n}\n\nstatic int getint(int size) {\n    int i, value;\n\n    value = 0;\n    for (i = 0; i < size; i++) {\n        int bit = getbit();\n\n        value <<= 1;\n        value |= bit;\n    }\n\n    return value;\n}\n\nstatic int  min(Ttree tree, int n) {\n    int i, min;\n\n    for (min = 0; tree[min].useflag && min < n; min++)\n        ;\n    for (i = 0; i < n; i++)\n        if (tree[i].useflag == 0 && tree[i].number < tree[min].number)\n            min = i;\n\n    return min;\n}\n\nstatic void create_tree(Ttree tree, int *k) {\n    int border, i;\n\n    border = *k - 1;\n    for (i = 0; i < border; i++) {\n        int m1, m2;\n\n        m1 = min(tree, *k);\n        tree[m1].useflag = 1;\n\n        m2 = min(tree, *k);\n        tree[m2].useflag = 1;\n\n        tree[*k].number = tree[m1].number + tree[m2].number;\n        tree[*k].symbol = 0x200;\n        tree[*k].left = &tree[m1];\n        tree[*k].right = &tree[m2];\n\n        tree[m1].root = tree[m2].root = &tree[*k];\n\n        (*k)++;\n    }\n}\n\nstatic void restore_tree(Ttree tree, int *k, struct node *curr) {\n    int bit;\n\n    bit = getbit();\n    if (buffer == EOF) return;\n\n    if (bit == 1) {\n        curr->symbol = 0x200;\n        curr->number = 1;\n\n        curr->left = &tree[++(*k)];\n        tree[*k].root = curr;\n        restore_tree(tree, k, curr->left);\n\n        curr->right = &tree[++(*k)];\n        tree[*k].root = curr;\n        restore_tree(tree, k, curr->right);\n    }\n    else {\n        int symbol = getint(8);\n        curr->symbol = symbol;\n        curr->number = 1;\n    }\n}\n\nvoid prep2decomp(Ttree tree, int *n) {\n    restore_tree(tree, n, &tree[*n]);\n}\n\nvoid prep2comp(Ttree tree, struct node *pointers[], int *n) {\n    int i, a[0x100] = {0}, j;\n\n    while ((i = getchar()) != EOF) a[i]++;\n    \n    j = 0;\n    for (i = 0; i < 0x100; i++)\n        if (a[i]) {\n            tree[j].number = a[i];\n            tree[j].symbol = i;\n            pointers[i] = &tree[j++];\n            (*n)++;\n        }\n\n    create_tree(tree, n);\n}\n\nstatic void print_tree(Ttree tree, struct node *root, unsigned *size) {\n    static int counter;\n    counter++;\n\n    if (root == NULL) return;\n    if (root->symbol != 0x200) {\n        setbit(0);\n        setchar(root->symbol);\n        *size += root->number * (counter - 1);\n    }\n    else {\n        setbit(1);\n        print_tree(tree, root->left, size);\n        print_tree(tree, root->right, size);\n    }\n    counter--;\n}\n\nvoid compress(Ttree tree, struct node *pointers[], struct node *root) {\n    int symbol;\n    unsigned size = 0;\n\n    print_tree(tree, root, &size);\n    if (size == 0) {\n        setint(root->number);\n        return;\n    }\n    setint(size);\n\n    while ((symbol = getchar()) != EOF) {\n        struct node *t = pointers[symbol];\n        char code[0x100] = {0};\n        int i = 0;\n\n        while (t != root) {\n            if (t->root->left == t) code[i++] = 0;\n            else code[i++] = 1;\n            t = t->root;\n        }\n        for (i--; i >= 0; i--) setbit(code[i]);\n    }\n    while (length != 0) setbit(0);\n}\n\nvoid decompress(Ttree tree, int k) {\n    unsigned size;\n    struct node *curr;\n\n    size = getint(0x20);\n    if (k == 0) {\n        int i;\n        for (i = 0; i < size - 1; i++) putchar(tree[0].symbol);\n    }\n\n    curr = &tree[0];\n    while (buffer != EOF && size) {\n        int bit;\n\n        size--;\n        bit = getbit();\n        if (buffer == EOF) break;\n\n        if (bit == 0) curr = curr->left;\n        else curr = curr->right;\n\n        if (curr->symbol != 0x200) {\n            putchar(curr->symbol);\n            curr = &tree[0];\n        }\n    }\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (204,'#include <stdio.h>\n#include \"compressor.h\"\n\nint parse(int argc, char *argv[], Ttree tree, struct node *pointers[],\n  int *n) {\n    if (argc < 4) {\n        printf(\"mmwoo..\\nusage: \\\"foo [option] [file1] [file2]\\\"\\n\"\n               \"\\toptions:\\n\\tc\\tcompress \\\"file1\\\" to \\\"file2\\\"\\n\\t\"\n               \"d\\tdecompress \\\"file1\\\" to \\\"file2\\\"\\n\");\n        return 1;\n    }\n    else {\n        if (!freopen(argv[2], \"r\", stdin)) \n        {\n            perror(\"freopen\");\n            return 1;\n        }\n\n        if(*argv[1] == \'c\') {\n            prep2comp(tree, pointers, n);\n            if (!freopen(argv[3], \"w\", stdout)) {\n                perror(\"freopen\");\n                return 1;\n            }\n            if (!freopen(argv[2], \"r\", stdin)) {\n                perror(\"freopen\");\n                return 1;\n            }\n            if (*n == 0) return 0;\n            compress(tree, pointers, &tree[*n - 1]);\n        }\n        else if (*argv[1] == \'d\') {\n            prep2decomp(tree, n);\n            if (!freopen(argv[3], \"w\", stdout)) {\n                perror(\"freopen\");\n                return 1;\n            }\n            if (tree[*n].number == 0) return 0;\n            decompress(tree, *n);\n        }\n        else {\n            printf(\"unavailable option\\n\");\n            return 1;\n        }\n    }\n\n    return 0;\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (205,'#include <stdio.h>\n#include \"compressor.h\"\n#include \"parser.h\"\n\nint main(int argc, char *argv[]) {\n    Ttree tree = {{NULL, NULL, NULL, 0, 0, 0}, };\n    struct node *pointers[0x100] = {NULL, };\n    int n = 0;\n    int err;\n    \n    err = parse(argc, argv, tree, pointers, &n);\n    if (err) return 1;\n\n    return 0;\n}\n','Ð¢Ð°Ñ€Ð°Ñ','Taras','m');
INSERT INTO `bias` VALUES (206,'#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n//#define _CRTDBG_MAP_ALLOC\r\n//#include<crtdbg.h>\r\n\r\n#include\"long.h\"\r\n\r\nstruct long_int add(struct long_int a1, struct long_int b1)\r\n{\r\n	int place = 0;\r\n	int i = 0;\r\n	struct long_int a;\r\n	struct long_int b;\r\n\r\n	size_t allocated = 0;\r\n	struct long_int res;\r\n\r\n	res.digits = NULL;\r\n	res.length = 0;\r\n	res.sign = 0;\r\n	\r\n	a = copy(a1);\r\n	b = copy(b1);\r\n\r\n	if (a.sign == 1 && b.sign == 1)\r\n	{\r\n		res.sign = 1;\r\n		a.sign = 0;\r\n		b.sign = 0;\r\n	}\r\n	if (a.sign == 1)\r\n	{\r\n		a.sign = 0;\r\n		res = sub(b,a);\r\n		free(a.digits);\r\n		free(b.digits);\r\n		return res;\r\n	}\r\n	if (b.sign == 1)\r\n	{\r\n		b.sign = 0;\r\n		res = sub(a,b);\r\n		free(a.digits);\r\n		free(b.digits);\r\n		return res;\r\n	}\r\n	length(&a,&b);\r\n	allocated = a.length + 1;\r\n	res.digits = (int*) calloc(allocated, sizeof(int));\r\n	if (!check_mem_long(res.digits))\r\n		return;\r\n	for (i = 0; i <= MAX(a.length, b.length); i++)\r\n	{\r\n		res.digits[i] = a.digits[i] + b.digits[i] + place;\r\n		place = 0;\r\n		if (res.digits[i] > N - 1)\r\n		{\r\n			res.digits[i] %= N;\r\n			place = 1;\r\n		}\r\n	}\r\n	if (place == 1)\r\n	{\r\n		res.digits[i] = 1;\r\n		i++;\r\n	}\r\n	res.length = i-1;\r\n	free(a.digits);\r\n	free(b.digits);\r\n	return res;\r\n}\r\n\r\nstruct long_int sub(struct long_int a1, struct long_int b1)\r\n{\r\n	int place = 0;\r\n	int i = 0;\r\n	struct long_int a;\r\n	struct long_int b;\r\n	size_t allocated = 0;\r\n	struct long_int res;\r\n\r\n	a = copy(a1);\r\n	b = copy(b1);\r\n	//a1.digits = a.digits;\r\n	res.digits = 0;\r\n	res.length = 0;\r\n	res.sign = 0;\r\n\r\n	if (a.sign == 0 && b.sign == 1)\r\n	{\r\n		b.sign = 0;\r\n		res = add(a,b);\r\n		free(a.digits);\r\n		free(b.digits);\r\n		return res;\r\n	}\r\n	if (a.sign == 1 && b.sign == 0)\r\n	{\r\n		b.sign = 1;\r\n		res = add(a,b);\r\n		free(a.digits);\r\n		free(b.digits);\r\n		return res;\r\n	}\r\n	if (a.sign == 1 && b.sign == 1)\r\n	{\r\n		b.sign = 0;\r\n		a.sign = 0;\r\n		res = sub(b,a);\r\n		free(a.digits);\r\n		free(b.digits);\r\n		return res;\r\n	}\r\n	if (a.length < b.length)\r\n	{\r\n		res = sub(b,a);\r\n		res.sign = 1;\r\n		free(b.digits);\r\n		free(a.digits);\r\n		return res;\r\n	}\r\n	if (a.length == b.length)\r\n	{\r\n		if (A_MIN(a,b))\r\n		{\r\n			res = sub(b,a);\r\n			res.sign = 1;\r\n			free(a.digits);\r\n			free(b.digits);\r\n			return res;\r\n		}\r\n	}\r\n	length(&a,&b);\r\n	allocated = a.length + 1;\r\n	res.digits = (int*) calloc(allocated, sizeof(int));\r\n	if (!check_mem_long(res.digits))\r\n		return;\r\n	for (i = 0; i <= MAX(a.length, b.length); i++)\r\n	{\r\n		if (a.digits[i] < b.digits[i])\r\n		{\r\n			if (0 <= a.digits[i+1] && a.digits[i+1] <= N - 1)\r\n			{\r\n				a.digits[i+1]--;\r\n				place = 1;\r\n			}\r\n			else \r\n			{\r\n				int x;\r\n				x = a.digits[i];\r\n				a.digits[i] = b.digits[i];\r\n				b.digits[i] = x;\r\n				res.sign = 1;\r\n				place = 0;\r\n			}\r\n		}\r\n		if (place == 1)\r\n			res.digits[i] = N + a.digits[i] - b.digits[i];\r\n		else \r\n			res.digits[i] = a.digits[i] - b.digits[i];\r\n		place = 0;\r\n		if (res.digits[i] < 0)\r\n		{\r\n			res.digits[i] *= -1;\r\n			res.sign = 1;\r\n		}\r\n	}\r\n	res.length = i-1;	\r\n	while (res.digits[res.length] == 0)\r\n	{\r\n		res.length--;\r\n		if (res.length < 0)\r\n			break;\r\n	}\r\n	if (res.length < 0)\r\n		res.length = 0;\r\n\r\n	free(a.digits);\r\n	free(b.digits);\r\n\r\n	return res;\r\n}\r\n\r\nstruct long_int mul(struct long_int a1, struct long_int b1)\r\n{\r\n	int place = 0;\r\n	int i = 0, j = 0;\r\n	int *p = NULL, *q = NULL;\r\n\r\n	struct long_int a;\r\n	struct long_int b;\r\n\r\n	size_t allocated = 0;\r\n	struct long_int res;\r\n	struct long_int mult;\r\n	\r\n	a = copy(a1);\r\n	b = copy(b1);\r\n\r\n	res.digits = NULL;\r\n	p = (int*) realloc(res.digits, sizeof(int));\r\n	if (!check_mem_long(p))\r\n		return;\r\n	res.digits = p;\r\n	res.digits[0] = 0;\r\n\r\n	mult.digits = NULL;\r\n	mult.sign = 0;\r\n\r\n	res.sign = 0;\r\n	res.length = 0;\r\n\r\n	for (i = 0; i <= b.length; i++)\r\n	{\r\n		struct long_int res1;\r\n		int k = 0, state = 0, f = -1;\r\n		mult.digits = NULL;\r\n		place = 0;\r\n		allocated = 0;\r\n		for (j = 0; j <= a.length; j++)\r\n		{\r\n			for (k = 0; k < i && state == 0; k++)\r\n			{\r\n				allocated +=sizeof(int);\r\n				q = (int*) realloc(mult.digits, allocated);\r\n				if (!check_mem_long(q))\r\n					return;\r\n				mult.digits = q;\r\n				mult.digits[k] = 0;\r\n				mult.length++;\r\n				f = k;\r\n			}\r\n			f++;\r\n			state = 1;\r\n			allocated += sizeof(int);\r\n			q = (int*) realloc(mult.digits, allocated);\r\n			if (!check_mem_long(q))\r\n				return;\r\n			mult.digits = q;\r\n			mult.digits[f] = a.digits[j] * b.digits[i] + place;\r\n			if (mult.digits[f] > N-1)\r\n			{\r\n				place = mult.digits[f] / N;\r\n				mult.digits[f] %= N;\r\n			}\r\n			else \r\n				place = 0;\r\n		}\r\n		mult.length = f;\r\n		if (place != 0)\r\n		{\r\n			allocated = (mult.length+2) * sizeof(int);\r\n			q = (int*) realloc(mult.digits, allocated);\r\n			if (!check_mem_long(q))\r\n				return;\r\n			mult.digits = q;\r\n			mult.digits[mult.length + 1] = place;\r\n			mult.length++;\r\n		}\r\n		res1 = add(res,mult);\r\n		free(res.digits);\r\n		res = copy(res1);\r\n		free(res1.digits);\r\n		free(mult.digits);\r\n		mult.length = 0;\r\n		place = 0;\r\n		//mult.digits = NULL;\r\n	}\r\n	if (a.sign == b.sign)\r\n		res.sign = 0;\r\n	else \r\n		res.sign = 1;\r\n	\r\n//	free(mult.digits);\r\n	free(a.digits);\r\n	free(b.digits);\r\n\r\n	return res;\r\n}\r\n\r\nstruct long_int DIV(struct long_int a1, struct long_int b1)\r\n{\r\n	int place = 0, k = 0, state = 0, first = 1, st = 0;\r\n	int id = a1.length;\r\n	\r\n	struct long_int a;\r\n	struct long_int b;\r\n\r\n	size_t allocated = 0;\r\n	size_t allocated_res = 0;\r\n	struct long_int res;\r\n	struct long_int part_a;\r\n	struct long_int part_b;\r\n	struct long_int mult;\r\n\r\n	a = copy(a1);\r\n	b = copy(b1);\r\n\r\n	res.digits = NULL;\r\n	res.sign = 0;\r\n	res.length = 0;\r\n	if (A_MIN(a,b))\r\n	{\r\n		res.digits = (int*) calloc(1, sizeof(int));\r\n		if (!check_mem_long(res.digits))\r\n			return;\r\n		res.digits[0] = 0;\r\n		free(a.digits);\r\n		free(b.digits);\r\n		return res;\r\n	}\r\n	part_a.digits = NULL;\r\n	part_a.sign = 0;\r\n	part_a.length = 0;\r\n	part_b.digits = NULL;\r\n	part_b.sign = 0;\r\n	part_b.length = 0;\r\n\r\n\r\n	if (a.sign != b.sign)\r\n	{\r\n		res.sign = 1;\r\n		a.sign = 0;\r\n		b.sign = 0;\r\n	}\r\n	res.digits = (int*) calloc(a.length+1, sizeof(int));\r\n	if (!check_mem_long(res.digits))\r\n		return;\r\n	if (a.length == 0)\r\n		state = 1;\r\n\r\n	allocated = a.length + 1;\r\n	part_a.digits = (int*) calloc(allocated+1, sizeof(int));\r\n	part_a.length = b.length + 1;\r\n	if (!check_mem_long(part_a.digits))\r\n		return;\r\n\r\n	part_b.digits = (int*) calloc(allocated+1, sizeof(int));\r\n	if (!check_mem_long(part_b.digits))\r\n		return;\r\n\r\n	while (id >= 0)\r\n	{\r\n		int i = 0, l = 0, m = 0, left = 0, right = N, index = 0;\r\n\r\n		part_b.sign = 0;\r\n		part_b.length = 0;\r\n\r\n		for (i = 0; i <= allocated; i++) //\r\n			part_b.digits[i] = 0;\r\n		i = 0;\r\n\r\n		while (first == 1)\r\n		{\r\n			if (i <= a.length && i <= part_a.length)\r\n				part_a.digits[part_a.length - i] = a.digits[a.length - i];\r\n			if (i == b.length)\r\n			{\r\n				if (!A_MIN(b, part_a))\r\n					break;\r\n			}\r\n			if (i > b.length)\r\n			{\r\n				int f = 0;\r\n				for (f = 0; f < i; f++)\r\n					part_a.digits[f] = part_a.digits[f+1];\r\n				part_a.digits[i] = 0;\r\n				part_a.length--;\r\n				break;\r\n			}\r\n			i++;\r\n		}\r\n		first = 0;\r\n		part_b.length = part_a.length;\r\n		l = a.length - part_a.length;\r\n\r\n		for (i = 0; i < N; i++)\r\n		{\r\n			int f = 0;\r\n			struct long_int mul_res;\r\n			struct long_int sub_res;\r\n			m = (left + right) / 2;\r\n			mul_res = mul_int(m, b);\r\n			sub_res = sub(part_a, mul_res);\r\n\r\n			if (A_MIN(part_a, mul_res) && left <= right)\r\n			{\r\n				right = m - 1;\r\n				free(mul_res.digits);\r\n				mul_res.length = 0;\r\n				free(sub_res.digits);\r\n				sub_res.length = 0;\r\n				continue;\r\n			}\r\n			if (!A_MIN(sub_res, b) && left <= right)\r\n			{\r\n				left = m + 1;\r\n				free(mul_res.digits);\r\n				mul_res.length = 0;\r\n				free(sub_res.digits);\r\n				sub_res.length = 0;\r\n				continue;\r\n			}\r\n			free(mul_res.digits);\r\n			free(sub_res.digits);\r\n			for (f = 0; f < l; f++)\r\n			{\r\n				part_b.digits[f] = 0;\r\n				part_b.length++;\r\n			}\r\n			for (f = 0; f <= allocated; f++) //\r\n				part_a.digits[f] = 0;\r\n			\r\n			mult = mul_int (m, b);\r\n			for (f = l; f <= (l + mult.length); f++)\r\n				part_b.digits[f] = mult.digits[f-l];\r\n			index = a.length - part_a.length - 1;\r\n			if (index < 0)\r\n				part_a.digits[part_a.length] = -1; //\r\n			else\r\n				part_a.digits[0] = a.digits[index];\r\n			part_a.length = 0;\r\n\r\n			if (!A_MIN(a, part_b) && !A_MIN(part_b, a))\r\n			{\r\n				struct long_int aa;\r\n				aa = sub(a, part_b);\r\n				free(a.digits);\r\n				a = aa;\r\n			}\r\n			else\r\n			{\r\n				struct long_int aa;\r\n				aa = sub(a, part_b);\r\n				free(a.digits);\r\n				a = aa;\r\n				l = 0;\r\n			}\r\n			if (index >= 0)\r\n			{\r\n				for (f = 1, index++; index <= a.length; f++, index++)\r\n				{\r\n					part_a.digits[f] = a.digits[index];\r\n					part_a.length++;\r\n				}\r\n			}\r\n			while (part_a.length >= 0 && part_a.digits[part_a.length] < 0)\r\n				part_a.length--;\r\n			if (part_a.length < 0)\r\n				part_a.length = 0;\r\n			if (part_a.length > a.length)\r\n				part_a.length = a.length;\r\n			free(mult.digits);\r\n			break;\r\n\r\n\r\n\r\n		}\r\n		/*end of binsearch*/\r\n		res.digits[k] = m;\r\n		res.length++;\r\n		if (l != 0)\r\n		{\r\n			int f = 0;\r\n			for (f = res.length; f < (res.length + l); f++)\r\n				res.digits[f] = 0;\r\n			res.length = f--;\r\n		}\r\n\r\n		if (A_MIN(a,b) && part_a.digits[part_a.length] <= 0) \r\n			id = -1;\r\n		k++;\r\n	}\r\n\r\n	res.length--;\r\n	for (k = 0; k <= res.length / 2; k++)\r\n	{\r\n		int ch = 0;\r\n		ch = res.digits[res.length - k];\r\n		res.digits[res.length - k] = res.digits[k];\r\n		res.digits[k] = ch;\r\n	}\r\n	while (res.digits[res.length] == 0)\r\n		res.length--;\r\n	if (res.length < 0)\r\n		res.length = 0;\r\n	\r\n	free(part_a.digits);\r\n	free(part_b.digits);\r\n	free(a.digits);\r\n	free(b.digits);\r\n\r\n	return res;\r\n}\r\n\r\nstatic void length(struct long_int *p_a, struct long_int *p_b)\r\n{\r\n	size_t allocated = 0;\r\n\r\n	int i = 0;\r\n\r\n	if (p_a -> length > p_b -> length)\r\n	{\r\n		allocated = (p_b -> length + 1) * sizeof(int);\r\n		for (i = p_b -> length+1; i <= p_a -> length; i++)\r\n		{\r\n			allocated += sizeof(int);\r\n			p_b -> digits = (int*) realloc(p_b -> digits, allocated);\r\n			p_b -> digits[i] = 0;\r\n			p_b -> length++;\r\n		}\r\n	}\r\n	if (p_a -> length < p_b -> length)\r\n	{\r\n		allocated = (p_a -> length + 1) * sizeof(int);\r\n		for (i = p_a -> length+1; i <= p_b -> length; i++)\r\n		{\r\n			allocated += sizeof(int);\r\n			p_a -> digits = (int*) realloc(p_a -> digits, allocated);\r\n			if (!check_mem_long(p_a -> digits))\r\n				return;\r\n			p_a -> digits[i] = 0;\r\n			p_a -> length++;\r\n		}\r\n	}\r\n}\r\n\r\nstatic int A_MIN(struct long_int a, struct long_int b)\r\n{\r\n	int i;\r\n\r\n	if (a.length < b.length)\r\n		return 1;\r\n	if (a.length > b.length)\r\n		return 0;\r\n	for (i = a.length; i >= 0; i--)\r\n	{\r\n		if (a.digits[i] < b.digits[i])\r\n			return 1;\r\n		if (a.digits[i] > b.digits[i])\r\n			return 0;\r\n	}\r\n	return 0;\r\n}\r\n\r\nstatic int check_mem_long(int *p)\r\n{\r\n	if (p == 0)\r\n	{\r\n		perror(\"calloc\");\r\n		return 0;\r\n	}\r\n	return 1;\r\n}\r\n\r\nstatic struct long_int mul_int(int a, struct long_int b)\r\n{\r\n	struct long_int res;\r\n	int i = 0, place = 0, mul;\r\n\r\n	res.length = 0;\r\n	res.sign = 0;\r\n//	res.digits = NULL;\r\n\r\n	res.digits = (int*) calloc(b.length + 2, sizeof(int));\r\n	if (!check_mem_long(res.digits))\r\n		return;\r\n	for (i = 0; i <= b.length; i++)\r\n	{\r\n		mul = b.digits[i] * a + place;\r\n		if (mul > N-1)\r\n		{\r\n			place = mul / N;\r\n			mul %= N;\r\n		}\r\n		else \r\n			place = 0;\r\n		res.digits[i] = mul;\r\n		res.length++;\r\n	}\r\n	res.length--;\r\n	if (place)\r\n	{\r\n		res.digits[i] = place;\r\n		res.length++;\r\n	}\r\n	return res;\r\n}\r\n\r\nstatic struct long_int copy(struct long_int a1)\r\n{\r\n	int i = 0;\r\n	struct long_int a;\r\n	a.sign = a1.sign;\r\n	a.length = a1.length;\r\n	a.digits = (int*) calloc(a.length + 1, sizeof(int));\r\n	if (!check_calloc(a.digits))\r\n		return;\r\n	for (i = 0; i <= a.length; i++)\r\n		a.digits[i] = a1.digits[i];\r\n	return a;\r\n}\r\n\r\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (207,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<ctype.h>\n//#define _CRTDBG_MAP_ALLOC\n//#include<crtdbg.h>\n\n#include\"long.h\"\n#include\"vars.h\"\n#include\"stack.h\"\n#include\"main.h\"\n\n\nint main()\n{\n	int state = 0;\n	struct long_int a;\n	char c;\n	while ((c = getchar()) != EOF)\n	{\n		state = state_function(c);\n		int_stack = creat(\'i\');\n		char_stack = creat(\'c\');\n		if (state == cipher || state == bracket || state == SIGN)\n		{\n			a = connective_c(c,0);\n			if (state_zero != d_b_z)\n				print_long(a);\n			else \n				state_zero = 0;\n			makenull(int_stack);\n			makenull(char_stack);\n			continue;\n		}\n		if (state == letter)\n		{\n			check_enter(c);\n			makenull(int_stack);\n			makenull(char_stack);\n			continue;\n		}\n	}\n	cleanup();\n//	_CrtDumpMemoryLeaks();\n	return 0;\n}\n\nint state_function(char c)\n{\n	if (\'0\' <= c && c <= \'9\')\n		return cipher;\n	if (\'a\' <= c && c <= \'z\')\n		return letter;\n	if (c == \'(\')\n		return bracket;\n	if (c == \'+\' || c == \'-\')\n		return SIGN;\n}\n\nstruct long_int connective_c(char c, int state_1)\n{\n	int state_cipher = 0;\n	int i = 0;\n	struct long_int a;\n	struct long_int b;\n	size_t allocated = 0;\n	do\n	{\n		char *s = NULL, *ss = NULL;\n		if (c == \' \')\n			continue;\n		if (\'0\' <= c && c <= \'9\') \n		{\n			state_1 = 1;\n			a = scanf_long(c);\n			push(int_stack, &a);\n			free(a.digits);\n			continue;\n		}\n		state_cipher = 0;\n		if (\'a\' <= c && c <= \'z\')\n		{\n			int st_res = 0;\n			state_1 = 1;\n			i = 0;\n			while((\'a\' <=c && c <= \'z\') || c == \'_\' || (\'0\' <= c && c <= \'9\'))\n			{\n				allocated += sizeof(char);\n				ss = (char*) realloc(s, allocated);\n				if (!check_realloc(ss))\n					return;\n				s = ss;\n				s[i] = c;\n				i++;\n				c = getchar();\n			}\n			allocated += sizeof(char);\n			ss = (char*) realloc(s, allocated);\n			if (!check_realloc(ss))\n				return;\n			s = ss;\n			s[i] = \'\\0\';\n			a = get_value(s);\n			if (a.length == -1)\n			{\n				a.length = 0;\n				st_res = 1;\n			}\n			free(s);\n			push(int_stack, &a);\n			if (st_res == 1)\n				free(a.digits);\n		}\n		if (c == \'(\')\n		{\n			state_1 = 0;\n			push(char_stack, &c);\n		}\n		if (state_1 == 0 && (c == \'+\' || c == \'-\'))\n		{\n			if (c == \'+\')\n				continue;\n			state_1 = 1;\n			c = getchar();\n			if (\'0\' <= c && c <= \'9\' )\n			{\n				a = scanf_long(c);\n				a.sign = 1;\n				push(int_stack, &a);\n				free(a.digits);\n				continue;\n			}\n			else \n			{\n				i = 0;\n				allocated = 0;\n				while ((\'a\' <=c && c <= \'z\') || c == \'_\' || (\'0\' <= c && c <= \'9\'))\n				{\n					allocated += sizeof(char);\n					ss = (char*) realloc(s, allocated);\n					if (!check_realloc(ss))\n						return;\n					s = ss;\n					s[i] = c;\n					i++;\n					c = getchar();\n				}\n				allocated += sizeof(char);\n				ss = (char*) realloc(s, allocated);\n				if (!check_realloc(ss))\n					return;\n				s = ss;\n				s[i] = \'\\0\';\n				a = get_value(s);\n				a.sign = (a.sign - 1) * (-1);\n				free(s);\n				push(int_stack, &a);\n			}\n		}\n		if (c == \')\')\n		{\n			char t = 0;\n			state_1 = 1;\n			do\n			{\n				t = *(char*)top(char_stack);\n				pop(char_stack);\n				if (t != \'(\')\n					oper(t);\n			}\n			while (t != \'(\' && !empty(char_stack));\n		}\n		if (c == \'+\' || c == \'-\')\n		{\n			char t = 0;\n			state_1 = 0;\n			do \n			{\n				if (!empty(char_stack))\n				{\n					t = *(char*) top(char_stack);\n					if (t != \'(\')\n					{\n						oper(t);\n						pop(char_stack);\n					}\n				}\n				else \n					t = \'(\';\n			}\n			while (t != \'(\' && !empty(char_stack));\n			push(char_stack, &c);\n		}\n		if (c == \'*\' || c == \'/\')\n		{\n			char t = 0;\n			state_1 = 0;\n			do \n			{\n				if (!empty(char_stack))\n				{\n					t = *(char*) top(char_stack);\n					if (t == \'*\' || t == \'/\')\n					{\n						oper(t);\n						pop(char_stack);\n					}\n				}\n				\n			}\n			while ((t == \'*\' || t == \'-\') && !empty(char_stack));\n			push(char_stack, &c);\n		}\n		if (c == \'\\n\')\n			break;\n	}\n	while ((c = getchar()) != \'\\n\');\n	while(!empty(char_stack))\n	{\n		char t;\n		t = *(char*) top(char_stack);\n		pop(char_stack);\n		oper(t);\n	}\n	return *(struct long_int*) top(int_stack);\n}\n\nvoid oper(char t)\n{\n	struct long_int z;\n	struct long_int x;\n	struct long_int y;\n\n	if (!empty(int_stack))\n	{\n		struct long_int x1;\n		x1 =*(struct long_int*) top(int_stack);\n		x = copy(x1);\n		pop(int_stack);\n	}\n	if (!empty(int_stack))\n	{\n		struct long_int y1;\n		y1 = *(struct long_int*) top(int_stack);\n		y = copy(y1);\n		pop(int_stack);\n	}\n	if (t == \'+\')\n	{\n		z = add(x,y);\n		if (x.digits)\n			free(x.digits);\n		if (y.digits)\n			free(y.digits);\n	}\n	if (t == \'-\')\n	{\n		z = sub(y,x);\n		if (x.digits)\n			free(x.digits);\n		if (y.digits)\n			free(y.digits);\n	}\n	if (t == \'*\')\n	{\n		z = mul(x,y);\n		if (x.digits)\n			free(x.digits);\n		if (y.digits)\n			free(y.digits);\n	}\n	if (t == \'/\')\n	{\n		int l = x.length;\n		while (x.digits[l] == 0)\n			l--;\n		if (l < 0)\n		{\n			printf(\"divide by zero\\n\");\n			state_zero = d_b_z;\n		}\n		else\n		{\n			z = DIV(y,x);\n			if (x.digits)\n				free(x.digits);\n			if (y.digits)\n				free(y.digits);\n		}\n	}\n	push(int_stack, &z);\n	free(z.digits);\n}\n\nvoid check_enter(char c)\n{\n	int i = 0;\n	struct long_int a;\n	char *s1 = NULL, *s2 = NULL;\n	size_t allocated = 0;\n	do\n	{\n		if (c == \' \')\n		{\n			c = getchar();\n			continue;\n		}\n		allocated += sizeof(char);\n		s2 = (char*) realloc(s1, allocated);\n		if (!check_realloc(s2))\n			return;\n		s1 = s2;\n		s1[i] = c;\n		i++;\n		c = getchar();\n	}\n	while((\'a\' <= c && c <= \'z\') || (\'0\' <= c && c <= \'9\') || c == \'_\' || c ==\' \');\n	allocated += sizeof(char);\n	s2 = (char*) realloc(s1, allocated);\n	if (!check_realloc(s2))\n		return;\n	s1 = s2;\n	s1[i] = \'\\0\';\n	if (c == \'\\n\')\n	{\n		int st_res = 0;\n		struct long_int res;\n		res = get_value(s1);\n		if (res.length == -1)\n		{\n			res.length = 0;\n			st_res = 1;\n		}\n		print_long(res);\n		if (st_res == 1)\n			free(res.digits);\n		free(s1);\n		return;\n	}\n	if (c == \'=\')\n	{\n		struct long_int res;\n		res = connective_c(c = getchar(), 0);\n		set_value(s1, &res);\n	//	free(res.digits);\n		free(s1);\n	}\n	else \n	{\n		int st_value = 0;\n		struct long_int value = get_value(s1);\n		free(s1);\n		if (value.length == -1)\n		{\n			value.length = 0;\n			st_value = 1;\n		}\n		push(int_stack, &value);\n		if (st_value == 1)\n			free(value.digits);\n		a = connective_c(c,1);\n		if (state_zero != d_b_z)\n			print_long(a);\n		else \n			state_zero = 0;\n	}\n	\n}\n\nvoid print_long(struct long_int a)\n{\n	int i = 0;\n	if (a.sign == 1 && a.digits[a.length] !=0)\n		printf(\"-\");\n	for (i = a.length; i >= 0; i--)\n	{\n		if (i != a.length)\n		{\n			if (a.digits[i] < 10)\n				printf(\"000\");\n			else if (a.digits[i] < 100)\n				printf(\"00\");\n			else if (a.digits[i] < 1000)\n				printf(\"0\");\n		}\n		printf(\"%d\",a.digits[i]);\n	}\n	printf(\"\\n\");\n}\n\nstruct long_int scanf_long(char c)\n{\n	int i = 1, j = 0, ch = 0, l = 0, st = 0, length_s = 0;\n	char *s = NULL, *s1 = NULL;\n	struct long_int a;\n	size_t allocated = 0;\n	allocated += sizeof(char);\n	s1 = (char*) realloc(s, allocated);\n	if (!check_realloc(s1))\n		return;\n	s = s1;\n	s[0] = c;\n	c = getchar();\n	while (\'0\' <= c && c <= \'9\')\n	{\n		\n		allocated += sizeof(char);\n		s1 = (char*) realloc(s, allocated);\n		if (!check_realloc(s1))\n			return;\n		s = s1;\n		s[i] = c;\n		i++;\n		c = getchar();\n	}\n	ungetc(c, stdin);\n	allocated += sizeof(char);\n	s1 = (char*) realloc(s, allocated);\n	if (!check_realloc(s1))\n		return;\n	s = s1;\n	s[i] = \'\\0\';\n	a.sign = 0;\n	length_s = strlen(s);\n	l = length_s % 4;\n	a.length = length_s / 4 - 1;\n	if (l != 0)\n		a.length++;\n	a.digits = (int*) calloc(a.length + 1, sizeof(int));\n	if (!check_calloc(a.digits))\n		return;\n	j = a.length;\n	\n	for (i = 0; i < length_s; i++)\n	{\n		if (l != 0)\n		{\n			int t = 1, k = 0, i1 = 0; //t1 = 1;\n			for (k = 1; k < l; k++)\n				t *= 10;\n			for (i1 = i; i1 <= i+3 && i1 < length_s; i1++)\n			{\n				ch += (s[i1] - \'0\') * t;\n				t /=10;\n			}\n			if (j >= 0)\n				a.digits[j] = ch;\n			j--;\n			if (i+1 < length_s)\n				i = l;\n			l = 0;\n			ch = 0;\n		}\n		if (st == 4)\n		{\n			if (j >= 0)\n				a.digits[j] = ch;\n			j--;\n			ch = 0;\n			st = 0;\n		}\n		ch = ch * 10 + (s[i] - \'0\');\n		st++;\n		if (i+1 == length_s)\n		{\n			if (j >= 0)\n				a.digits[j] = ch;\n			j--;\n			ch = 0;\n		}\n	}\n	free(s);\n	return a;\n}\n\nstruct long_int copy(struct long_int a1)\n{\n	int i = 0;\n	struct long_int a;\n	a.sign = a1.sign;\n	a.length = a1.length;\n	a.digits = (int*) calloc(a.length + 1, sizeof(int));\n	if (!check_calloc(a.digits))\n		return;\n	for (i = 0; i <= a.length; i++)\n		a.digits[i] = a1.digits[i];\n	return a;\n}\n\nint check_realloc(void *p)\n{\n	if (!p)\n	{\n		perror(\"realloc\");\n		return 0;\n	}\n	return 1;\n}\n\nint check_calloc(void *p)\n{\n	if (!p)\n	{\n		perror(\"calloc\");\n		return 0;\n	}\n	return 1;\n}\n\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (208,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<string.h>\r\n#include\"stack.h\"\r\n#include\"long.h\"\r\n\r\nvoid push(stack *S, void *data)\r\n{\r\n	struct item *p;\r\n	//void *q;\r\n	if (S -> ind == \'c\')\r\n	{\r\n		char *q = NULL;\r\n		q = (char*) calloc(1, sizeof (char));\r\n		if (check_mem(q))\r\n			*(char*) q = *(char*) data;\r\n		else return;\r\n		p = (struct item*) calloc(1, sizeof (struct item));\r\n		p -> data = q;\r\n		p -> next = S -> top;\r\n		S -> top = p;	\r\n	}\r\n	if (S -> ind == \'i\')\r\n	{\r\n		struct long_int *q;\r\n		int i = 0;\r\n		q = (struct long_int*) calloc(1, sizeof (struct long_int));\r\n		if (!check_mem(q))\r\n			return;\r\n		q -> sign = ((struct long_int*) data) -> sign;\r\n		q -> length = ((struct long_int*) data) -> length;\r\n		q -> digits = (int*) calloc(q -> length + 1, sizeof(int));\r\n		if (!check_mem(q -> digits))\r\n			return;\r\n		for (i = 0; i <= q -> length; i++)\r\n			q -> digits[i] = ((struct long_int*) data) -> digits[i];\r\n		p = (struct item*) calloc(1, sizeof (struct item));\r\n		p -> data = q;\r\n		p -> next = S -> top;\r\n		S -> top = p;\r\n	}\r\n}\r\n\r\nvoid pop(stack *S)\r\n{\r\n	//void *q;\r\n	struct item *p;\r\n	if (S -> ind == \'c\')\r\n	{\r\n		p = S -> top;\r\n		S -> top = p -> next;\r\n		free(p -> data);\r\n		free(p);\r\n	}\r\n	if (S -> ind == \'i\')\r\n	{\r\n		struct long_int *q;\r\n		p = S -> top;\r\n		S -> top = p -> next;\r\n		q = (struct long_int*) p -> data;\r\n		free(q -> digits);\r\n		free(p -> data);\r\n		free(p);\r\n	}\r\n}\r\n\r\nvoid *top(stack *S)\r\n{\r\n	if (S -> top)\r\n		return (S -> top -> data);\r\n	else return 0;\r\n}\r\n\r\nint empty(stack *S)\r\n{\r\n	return (S -> top == NULL);\r\n}\r\n\r\nvoid makenull(stack *S)\r\n{\r\n	struct item *p;\r\n	if (S -> ind == \'c\')\r\n	{\r\n		while (S -> top)\r\n		{\r\n			p = S -> top;\r\n			S -> top = p -> next;\r\n			free(p->data);\r\n			free(p);\r\n		}\r\n		free(S);\r\n		return;\r\n	}\r\n	if (S -> ind == \'i\')\r\n	{\r\n		while (S -> top)\r\n		{\r\n			struct long_int *q;\r\n			p = S -> top;\r\n			S -> top = p -> next;\r\n			q = (struct long_int*)p -> data;\r\n			free(q -> digits);\r\n			free(p -> data);\r\n			free(p);\r\n		}\r\n		free(S);\r\n		return;\r\n	}\r\n}\r\n\r\nstack* creat(char c)\r\n{\r\n	stack *S;\r\n	S =  calloc (1, sizeof(stack));\r\n	if (!check_mem(S))\r\n		return 0;\r\n	S -> top = NULL;\r\n	S -> ind = c;\r\n	return S;\r\n}\r\n\r\nstatic int check_mem(void *q)\r\n{\r\n	if (q == 0)\r\n	{\r\n		perror(\"calloc\");\r\n		return 0;\r\n	}\r\n	else return 1;\r\n}\r\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (209,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n//#define _CRTDBG_MAP_ALLOC\n//#include<crtdbg.h>\n#include\"long.h\"\n#include\"vars.h\"\n\nstatic unsigned int hash (char *s)\n{\n	unsigned int res = 0;\n//	return 1;\n	while (*s)\n	{\n		res = (res * 37 + *s) % max_n;\n		s++;\n	}\n	return res;\n}\n\nvoid set_value (char* name, struct long_int *value)\n{\n	int i = 0;\n\n	static struct hash *p;\n	static struct hash *q;\n	\n	int index;\n	\n	index = hash(name);\n	q = h[index];\n	\n	for (p = h[index]; p; p = p -> next)\n		q = p;\n	\n	p = (struct hash *) calloc(1, sizeof (struct hash));\n	if (!check_mem(p))\n		return;\n	\n	p -> count.length = value -> length;\n	p -> count.sign = value -> sign;\n\n	p -> name = (char*) calloc(strlen(name) + 1, sizeof (char));\n	if (!check_mem(p -> name))\n		return;\n	strcpy(p -> name, name);\n	\n	p -> count.digits = (int*) calloc(p -> count.length + 1, sizeof(int));\n	if (!check_mem(p -> count.digits))\n		return;\n	for (i = 0; i <= value -> length; i++)\n		p -> count.digits[i] = value -> digits[i];\n	\n	if (!q || (strcmp(h[index] -> name, name) == 0))\n	{\n		if (!q)\n			h[index] = p;\n		else\n		{\n			q = h[index];\n			free(q -> name);\n			free(q -> count.digits);\n			free(q);\n			h[index] = p;			\n		}\n\n	}\n	else \n		q -> next = p;\n	p -> next = 0;\n}\n\nstruct long_int get_value (char* name)\n{\n	struct hash *p,*q;\n	struct long_int res;\n	int index;\n	index = hash(name);\n	//p = h[index];\n	for (p = h[index]; p; p=q)\n	{\n		if (strcmp(p -> name, name)==0)\n			return p -> count;\n		q = p -> next;\n	}\n	res.sign = 0;\n	res.length = -1;\n	res.digits = (int*) calloc(1, sizeof(int));\n	if (!check_mem(res.digits))\n		return;\n	return res;\n}\n\nvoid cleanup (void)\n{\n	int i;\n	struct hash *p, *q;\n 	for (i = 0; i < max_n; i++)\n	{\n		if (h[i])\n			kill(h[i]);\n	}\n}\n\nstatic int check_mem(void *q)\n{\n	if (q == 0)\n	{\n		perror(\"calloc\");\n		return 0;\n	}\n	else return 1;\n}\n\nvoid kill(struct hash *q)\n{\n	struct hash *p = NULL;\n	p = q;\n	if (p -> next)\n		kill(p -> next);\n	free(p -> name);\n	free(p -> count.digits);\n	free(p);\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (210,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	#define N 1000\n	FILE *f;\n	int i,j, buf;\n	char login[N];	\n	char X[N], Copy[N];\n\n\n  	printf (\"\\nVvedite login:  \");\n	scanf (\"%s\",login);\n	int dlin=strlen(login);\n\n	f=fopen(\"/etc/passwd\",\"r\");\n//	for (;;)\n//	{	\n	while( fgets(X,N,f) )\n	{\n		for (i=0;X[i]!=\':\';i++)  // rjczr ,sk\n		{\n			Copy[i]= X[i];\n		}\n		Copy[i] = 0;\n\n		buf = strcmp (Copy ,login);\n		\n		if (buf == 0)\n		{\n			i=0;\n			j=0;\n			while (j!=4)\n			{\n				if (X[i]==\':\') j++;\n				i++;\n			}\n			printf (\"Imya:  \");\n			while ( (X[i]!=\',\'))\n			{\n				printf (\"%c\",X[i]);\n				i++;\n			}\n			printf(\"   :)\\n\\n\");\n			fclose (f);\n			return 0;\n		}\n	}\n 	\n	printf (\"Net takogo :(  \\n\\n\");\n//	break;\n//	}\n	fclose(f);\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (211,'#include<stdio.h>\n\nint main ()\n{\n	int i,j, N,M, k,a,b,c, buf;\n	int infinity = 100000;       \n	\n	int  t=0;\n	int rast;\n\n	printf (\"Vvedite rasstoyanie: \" );\n	scanf (\"%d\", &rast);\n\n	FILE *f;\n	f=fopen(\"input15.txt\",\"r\");\n\n	fscanf(f,\"%d\", &N);       \n	\n	int used[N+1], D[N+1], prev [N+1];\n	used[0]=0;\n	D[0]=0;\n	prev[0]=-1;\n\n	for (i=1;i<N+1;i++)\n	{\n		D[i]=infinity;  \n	        used[i]=0;\n        	prev[i]=-1; \n	}\n	D[1]=0;              \n\n	int A[N+1][N+1];\n\n	for (i=0;i<N+1;i++)   \n	{\n		for(j=0; j<N+1;j++)\n		{\n			A[i][j]=infinity;\n		}\n	}\n	\n	M=0;                  \n	while ((fscanf(f,\"%d\", &a))!= EOF)   \n	{\n		M++;\n		fscanf(f,\"%d\", &b);\n		fscanf(f,\"%d\", &c);\n		A[a][b]=c;\n		A[b][a]=c;\n\n	}\n	printf (\"\\n???-?? ????? = %d \\n\\n\", M);\n	\n	for (i=1;i<N+1;i++)\n	{\n                for(j=1; j<N+1;j++)\n                {\n			printf (\"%d \", A[i][j]);\n                }\n                printf (\"\\n\");\n        }	\n	printf (\"\\n\\n\");\n\n\n	while (1)\n	{\n		a=0;\n		for(i=1;i<N+1;i++)\n		{\n			if(used[i]==0)\n			{\n				a=1;\n				break;\n			}\n		}\n		if(a==0) break;\n\n		buf=infinity;\n		for(i=1;i<N+1;i++)\n		{\n			if(D[i]<buf && used[i]==0)\n			{\n				buf=D[i];\n				k=i;\n			}\n		}\n		used[k]=1;\n\n		for(i=1;i<N+1;i++)\n		{\n			if(D[i]>D[k]+A[k][i])\n			{\n				D[i]=D[k]+A[k][i];\n				prev[i]=k;\n			}\n		}\n\n	}\n\n        printf (\"ispol\'zovano:     \");\n	for (i=1;i<N+1;i++)\n        {\n                printf (\"%d \", used[i]);\n        }\n        printf (\"\\n\");\n	printf (\"Rasstoyaniya:     \");\n        for (i=1;i<N+1;i++)\n        {\n	        printf (\"%d \", D[i]);\n        }\n        printf (\"\\n\");\n	printf (\"Otkuda prishli:   \");\n        for (i=1;i<N+1;i++)\n        {\n                printf (\"%d \", prev[i]);\n        }\n        printf (\"\\n\\n\");\n\n	for(i=1;i<N+1;i++)\n	{\n		if(rast==D[i])\n		{\n			t=1;\n			printf(\"Rasstoyanie %d do %d vershini\\n\\n\", rast, i);\n\n		}\n\n	}\n	if (t==0) printf(\"Net takih Vershin\\n\\n\");\n\n	fclose (f);\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (212,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint main()\n{\n	int i,j,N,k,Nmax,a,b,c,M,start,p,q,S,l,W,final;\n	#define Nmax 100\n	#define M 10000\n	FILE *f;\n	f=fopen(\"input15.txt\", \"r\");\n	fscanf(f, \"%d\", &N);\n//	N=Nmax;\n	int A[N+1][N+1];\n	char B[20];\n	for(j=0;j<N+1;j++)\n	{\n		for(i=0;i<N+1;i++)\n		{\n			A[i][j]=M;\n		}\n	}\n	while(fgets(B,20,f))\n	{	\n		fscanf(f,\"%d\",&a);\n		i=a;\n		fscanf(f,\"%d\",&b);\n		j=b;\n		fscanf(f,\"%d\",&c);\n		A[i][j]=c;\n		A[j][i]=c;\n	}\n	for(j=0;j<N+1;j++)\n	{\n		for(i=0;i<N+1;i++)\n		{\n			printf(\"%d   \", A[i][j]);\n		}\n		printf(\"\\n\");\n	}\n	//???????? ????????\n	W=M;//??????? ????? ??? ????????? ???? ???????? ?????????? \n	for(l=1;l<N+1;l++)\n	{\n		start=l;\n		int used[N+1];\n		int D[N+1];\n		for(i=0;i<N+1;i++)\n		{\n			D[i]=M;\n			used[i]=0;\n			if(i==start)\n			{\n				D[i]=0;\n			}\n		}\n		used[0]=1;\n		q=M;//??????? ????? ??? ?????????? ???????????? ???????????????? ? ?????? ???\n		for( ; ; )\n		{	\n			p=0;\n			for(i=1;i<N+1;i++)\n			{\n				if(used[i]==1)\n				{\n					p++;\n				}\n			}\n			if(p==N)//???????? ?? ??????? ??????? used\n			{\n				break;\n			}\n			for(i=0;i<N+1;i++)\n			{\n				if(D[i]<q && used[i]!=1)\n				{\n					q=D[i];\n					k=i;\n				}	\n			}\n			used[k]=1;\n			for(i=1;i<N+1;i++)\n			{\n				if(D[i]>D[k]+A[k][i])\n				{\n					D[i]=D[k]+A[k][i];\n				}\n			}\n			q=M;\n		}\n		S=0;//??????? ????? ??????? ??????????\n		printf(\"?????????? (start = %d): \", start);\n		for(i=1;i<N+1;i++)\n		{\n			S=S+D[i];\n			printf(\"%d \", D[i]);\n		}\n		printf(\"\\n\");\n		printf(\"%d\\n\", S);		\n		if(S<W)//?????????? ???????????? ??????? ? ??????????? ??????? ? ???? ?????????\n		{\n			W=S;\n			final=l;\n		}\n	}\n	printf(\"????? ??????? :  %d\\n\", final);\n	fclose(f);\n}\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (213,'#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#define N 10000\n\n\nvoid f(char *s,int a)\n{\n	int j,l;\n	int m=0;\n	int q=0;\n	l=strlen(s);\n	for (j=0;j<l;j++)\n	{\n		if ((s[j]>=\'A\') && (s[j]<=\'Z\'))\n			s[j]=s[j]-\'A\'+10;\n		if ((s[j]>=\'0\') && (s[j]<=\'9\'))\n			s[j]=s[j]-\'0\';\n		if (s[j]>a) printf(\"nesootvetstvie\");\n	}\n	for (j=0;j<l;j++)\n	{\n		\n		m=pow(a,j);\n		printf(\"m=%d \\n\", m);\n		q=q+m*s[l-j-1];\n		printf(\"q=%d \\n\", q);\n	}\n}\n\nint main()\n{	\n	char A[N];\n	scanf(\"%s\", A);\n	int b;\n	scanf(\"%d\", &b);\n	f(A,b);	\n	return(0);\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (214,'#include <stdio.h>\n#include <string.h>\n\n#include <stdlib.h>\n\nint main()\n{\n	struct item\n	{\n	 int data;\n	 struct item *next;\n	};\n	\n	struct item *head = 0;\n\n	FILE *f = fopen(\"input.txt\", \"r\");\n	if (f == 0)\n	{\n		printf(\"?? ???? ???????\\n\");\n		return 0;\n	}\n	int a;\n	struct item *p, *q, *t, *l;\n	fscanf(f, \"%d\", &a);\n	head = malloc(sizeof(struct item));\n	head->data = a;\n	head->next = NULL;\n\n	\n	while (fscanf(f, \"%d\", &a) == 1)\n	{\n		p = head;\n		q = NULL;\n	 	for ( ; p; p = p->next )\n	  	{	\n	   	 if (p->data > a) break;\n	  	 q = p;\n	   	}\n	 if (q == NULL)\n	   {\n	    struct item *k = malloc(sizeof(struct item));\n	    k->data = a;\n	    t = head;\n	    head = k;\n	    k->next = t;\n	   }\n	 else\n	   {\n	    struct item *k = malloc(sizeof(struct item));\n	    k->data = a;\n	    t = q->next;\n	    q->next = k;\n	    k->next = t;\n	   }\n		\n	}\n\n	printf(\"????? while\\n\");\n	fclose (f);\n	for (p = head; p; p = p->next)\n	{\n	 printf (\"%d\\n\", p->data);\n	}\n	\n	// ???????\n	while (head)\n	{\n	p = head;\n	head = p->next;\n	free(p);\n	}\n\n	printf(\"? ????? ?????\\n\");\n\n	for (p = head; p; p = p->next)\n	{\n	 printf (\"%d\\n\", p->data);\n	}\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (215,'#include <stdio.h>\n#include <stdlib.h>\n\nvoid main()\n{\n	int Count = 0;\n	int c;\n	while( (c = getchar())!= EOF)\n	{\n		printf(\"%d\", (int)(( c & 128 ) != 0));\n		printf(\"%d\", (int)(( c & 64 ) != 0));\n		printf(\"%d\", (int)(( c & 32 ) != 0));\n		printf(\"%d\", (int)(( c & 16 ) != 0));\n//		printf(\" \");\n		printf(\"%d\", (int)(( c & 8 ) != 0));\n		printf(\"%d\", (int)(( c & 4 ) != 0));\n		printf(\"%d\", (int)(( c & 2 ) != 0));\n		printf(\"%d\", (int)(( c & 1 ) != 0));\n		Count++;\n		if(Count % 8 == 0)\n			printf(\"\\n\");\n		else\n			printf(\" \");\n	}\n	if(Count % 8 != 0)\n		printf(\"\\n\");\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (216,'#include <stdio.h>\n#include <stdlib.h>\n#include \"chars.h\"\n\nstatic void moveitems(struct tree *tree, int a, int b, int d)\n{\n	if(d)\n	{\n		struct treeItem temp = tree->item[a];\n		tree->item[a] = tree->item[b];\n		tree->item[b] = temp;\n	}\n	else\n		tree->item[b] = tree->item[a];\n\n	int Loop;\n	for(Loop = 0; Loop < tree->size; Loop++)\n		if(tree->item[Loop].type == 1)\n		{\n			if(tree->item[Loop].left == a)\n				tree->item[Loop].left = b;\n			else if(tree->item[Loop].left == b)\n				tree->item[Loop].left = a;\n\n			if(tree->item[Loop].right == a)\n				tree->item[Loop].right = b;\n			else if(tree->item[Loop].right == b)\n				tree->item[Loop].right = a;	\n		}\n}\n\nstruct tree newTree(struct byteFile *file)\n{\n	//?????????????? ???????????????????? ?????Â©???? ?????????????? ??????????????\n	unsigned long count[256];\n	int Loop;\n	for(Loop = 0; Loop < 256; Loop++)\n		count[Loop] = 0;\n	for(Loop = 0; Loop < file->size; Loop++)\n		count[file->data[Loop]]++;\n\n	//?????????????? ?????? ???????????????????????? ?????????????? ?? ????????????\n	struct tree result;\n	result.size = 0;\n\n	for(Loop = 0; Loop < 256; Loop++)\n			if(count[Loop])\n			{\n				result.item[result.size].size = count[Loop];\n				result.item[result.size].type = 0;\n				result.item[result.size].c = Loop;\n				result.size++;\n			}\n\n	//?????????????????? ???????????? ?????????? ??????????\n	result.item[result.size].size = 1;\n	result.item[result.size].type = 0;\n	result.item[result.size].c = EOF;\n	result.size++;\n\n	//???????????? ????????????\n	int roots = result.size;\n	while(roots > 1)\n	{\n		int min1 = 0, min2 = 1;\n		if(result.item[min1].size > result.item[min2].size)\n		{\n			min1 = 1; min2 = 0;\n		}\n\n		//???????? ?????? ???????????????????? ??????????????\n		int Loop;\n		for(Loop = 2; Loop < roots; Loop++)\n			if(result.item[Loop].size < result.item[min1].size)\n			{\n				min2 = min1;\n				min1 = Loop;\n			}\n			else if(result.item[Loop].size < result.item[min2].size)\n				min2 = Loop;\n\n		//?Ã·?????????? ???? ?? ???????????? ?????????? ???? ?????????? ??????????\n		if(min1 > min2)\n		{\n			moveitems(&result, min1, roots-1,1);\n			moveitems(&result, min2, result.size, 0);\n\n			result.item[min2].size = result.item[roots-1].size + \n						 result.item[result.size].size;\n			result.item[min2].type = 1;\n			result.item[min2].left = result.size;\n			result.item[min2].right = roots-1;\n		}\n		else\n		{\n			moveitems(&result, min2, roots-1,1);\n			moveitems(&result, min1, result.size, 0);\n		\n			result.item[min1].size = result.item[roots-1].size +\n						 result.item[result.size].size;\n			result.item[min1].type = 1;\n			result.item[min1].left = roots-1;\n			result.item[min1].right = result.size;\n		}	\n		result.size++;\n		roots--;\n	}\n	return result;\n}\n\nstatic void outputTree_(struct bitBuffer *buffer, struct tree *tree, int position)\n{\n	if(tree->item[position].type == 0)\n	{\n		ouptutBit(buffer, 0);\n		if(tree->item[position].c == EOF)\n			ouptutBit(buffer, 1);\n		else\n		{\n			ouptutBit(buffer, 0);\n//			printf(\" 0\");\n			int Loop;\n			for(Loop = 7; Loop >= 0; Loop--)\n//				printf(\"%d\", (int)((1<<Loop & tree->item[position].c)) != 0);\n				ouptutBit(buffer, 1<<Loop & tree->item[position].c);\n		}\n	}\n	else\n	{\n//		printf(\"1\");\n		ouptutBit(buffer, 1);\n		outputTree_(buffer, tree, tree->item[position].left);\n		outputTree_(buffer, tree, tree->item[position].right);\n	}\n}\n\nvoid outputTree(struct bitBuffer *buffer, struct tree *tree)\n{\n	outputTree_(buffer, tree, 0);\n}\n\n\nstatic void debug_outoutTree_(struct tree *tree, int position, short int size,\n			short int side)\n{\n	static int a[1000];\n	int Loop;\n	for(Loop = 0; Loop < size-1; Loop++)\n		if(a[Loop] == 0)\n			printf(\"???\");\n		else\n			printf(\" \");\n	if(size)\n		if(side)\n			printf(\"???\");\n		else\n			printf(\"??Â°\");\n\n	if(tree->item[position].type == 0)\n	{\n		if(tree->item[position].c == EOF)\n			printf(\"Count:%d Symbol ???%d, EOF Code:\",\n				tree->item[position].size, EOF);\n		else\n			printf(\"Count:%d Symbol ???%d, \\\"%c\\\" Code:\",\n				tree->item[position].size, tree->item[position].c,\n				(char)tree->item[position].c);\n		for(Loop = 0; Loop < size; Loop++)\n			printf(\"%d\", a[Loop]);\n		printf(\"\\n\");\n	}\n	else\n	{\n		printf(\"%d\\n\", tree->item[position].size);\n		a[size] = 0;\n		debug_outoutTree_(tree, tree->item[position].left, size+1, 0);\n		a[size] = 1;\n		debug_outoutTree_(tree, tree->item[position].right, size+1, 1);\n	}\n}\n\nvoid debug_outoutTree(struct tree *tree)\n{\n	debug_outoutTree_(tree, 0, 0, 0);\n}\n\n\nstatic void newCharCode_(struct charCode *code, struct tree *tree,\n			int position, int size)\n{\n	static bits[257];\n	if(tree->item[position].type)\n	{\n		bits[size] = 0;\n		newCharCode_(code, tree, tree->item[position].left, size+1);\n		bits[size] = 1;\n		newCharCode_(code, tree, tree->item[position].right, size+1);\n	}\n	else\n	{\n		int Loop;\n		int sym = tree->item[position].c;\n		if(sym == EOF)\n			sym = 256;\n		code->size[sym] = size;\n		code->bits[sym] = malloc(sizeof(short int)*size);\n		for(Loop = 0; Loop < size; Loop++)\n			code->bits[sym][Loop] = bits[Loop];\n	}\n}\n\nstruct charCode newCharCode(struct tree *tree)\n{\n	struct charCode result;\n	int Loop;\n	for(Loop = 0; Loop < 257; Loop++)\n		result.size[Loop] = 0;\n	newCharCode_(&result, tree, 0, 0);\n	return result;\n}\n\nvoid freeCharCode(struct charCode *code)\n{\n	int Loop;\n	for(Loop = 0; Loop < 257; Loop++)\n		if(code->size[Loop])\n		{\n			code->size[Loop] = 0;\n			free(code->bits[Loop]);\n		}\n}\n\nvoid putCompressedChar(struct bitBuffer *buffer, struct charCode *code, int c)\n{\n	if(c == EOF)\n		c = 256;\n	int Loop;\n	for(Loop = 0; Loop < code->size[c]; Loop++)\n		ouptutBit(buffer, code->bits[c][Loop]);\n}\n\n\nstatic int readTree_(struct bitBuffer *buffer, struct tree *tree)\n{\n	int pos = tree->size;\n	int i = inputBit(buffer);\n	if(i == 0)\n	{\n		int c = 0;\n		if(inputBit(buffer) == 0)\n		{\n			int Loop = 0;\n			for(Loop = 0; Loop < 8; Loop++)\n			{\n				c <<= 1;\n				c |= inputBit(buffer);\n			}\n		}\n		else\n			c = EOF;\n		tree->item[pos].type = 0;\n		tree->item[pos].c = c;\n		tree->size++;\n	}\n	else\n	{\n		tree->item[pos].type = 1;\n		tree->size++;\n		tree->item[pos].left = readTree_(buffer, tree);\n		tree->item[pos].right = readTree_(buffer, tree);\n	}\n	return pos;\n}\n\nstruct tree readTree(struct bitBuffer *buffer)\n{\n	struct tree result;\n	result.size = 0;\n	readTree_(buffer, &result);\n	return result;\n}\n\nint getCompressedChar(struct bitBuffer *buffer, struct tree *tree)\n{\n	int position = 0;\n	while(1)\n	{\n		int a = inputBit(buffer);\n//		printf(\"%d\", a);\n		if(a == EOF)\n			return EOF;\n		if(tree->item[position].type == 1)\n			if(a)\n				position = tree->item[position].right;\n			else\n				position = tree->item[position].left;\n\n		if(tree->item[position].type == 0)\n		{\n//			printf(\"%c \", tree->item[position].c);\n			return tree->item[position].c;\n		}\n	}\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (217,'#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n\n	return 0;\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (218,'#include <stdio.h>\n#include <stdlib.h>\n#include \"file.h\"\n\nint readByteFile(struct byteFile *f)\n{\n	f->mem = 32;\n	f->size = 0;\n	if((f->data = malloc(f->mem)) == NULL)\n		return 1;\n	int c;\n	while((c = getchar()) != EOF)\n	{\n		f->data[f->size] = c;\n		f->size++;\n		if(f->size == f->mem)\n		{\n			f->mem *= 2;\n			if((f->data = realloc(f->data, f->mem)) == NULL)\n				return 1;\n		}\n	}\n	return 0;\n}\n\nvoid freeByteFile(struct byteFile *f)\n{\n	f->size = 0;\n	f->mem = 0;\n	free(f->data);\n}\n\n\n\nstruct bitBuffer newBitBuffer()\n{\n	struct bitBuffer result;\n	result.position = 0;\n	result.bits = 0;\n	return result;\n}\n\nvoid ouptutBit(struct bitBuffer *bitBuffer, short int bit)\n{\n	if(bit)\n		bitBuffer->bits |= 1 << (7-bitBuffer->position);\n	bitBuffer->position++;\n	if(bitBuffer->position == 8)\n	{\n		putchar(bitBuffer->bits);\n		bitBuffer->bits = 0;\n		bitBuffer->position = 0;\n	}\n}\n\nvoid endOuptut(struct bitBuffer *bitBuffer)\n{\n	if(bitBuffer->position)\n	{\n		putchar(bitBuffer->bits);\n		bitBuffer->bits = 0;\n		bitBuffer->position = 0;\n	}\n}\n\nint inputBit(struct bitBuffer *bitBuffer)\n{\n	int c;\n	if(bitBuffer->position == 0)\n	{\n		bitBuffer->position = 8;\n		c = getchar();\n		if(c == EOF)\n			return c;\n		bitBuffer->bits = c;\n	}\n	bitBuffer->position--;\n	return( (bitBuffer->bits & 1 << bitBuffer->position) != 0);\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (219,'#include <stdio.h>\n#include <stdlib.h>\n\n#include \"file.h\"\n#include \"chars.h\"\n\n//#define debug\n\nint main(int argc, char *argv[])\n{\n	if(argc != 2)\n	{\n		fprintf(stderr, \"?????Â©????????????????????: %s {compress|expand}\\n\", argv[0]);\n		return 1;\n	}\n	\n	if(strcmp(argv[1], \"compress\") == 0)\n	{\n		struct byteFile f;\n		if(readByteFile(&f))\n		{\n			fprintf(stderr, \"?Â²?????????????????????? ?Â©?????????? ?????? ???????????? ??????????\\n\");\n			return 2;\n		};\n\n		struct tree tree = newTree(&f);\n\n		struct charCode code = newCharCode(&tree);\n\n		struct bitBuffer buffer = newBitBuffer();\n\n		debug_outoutTree(&tree);\n\n		outputTree(&buffer, &tree);\n\n		int Loop;\n		for(Loop = 0; Loop < f.size; Loop++)\n			putCompressedChar(&buffer, &code, f.data[Loop]);\n		putCompressedChar(&buffer, &code, EOF);\n\n		freeByteFile(&f);\n		freeCharCode(&code);\n		endOuptut(&buffer);\n	}\n	else if(strcmp(argv[1], \"expand\") == 0)\n	{\n		struct bitBuffer buffer = newBitBuffer();\n		struct tree tree = readTree(&buffer);\n//		debug_outoutTree(&tree);\n		int c;\n		while((c = getCompressedChar(&buffer, &tree)) != EOF)\n			putchar(c);\n	}\n	else\n	{\n		fprintf(stderr, \"?????Â©????????????????????: %s {compress|expand}\\n\", argv[0]);\n		return 1;\n	}\n	return 0;\n}\n','ÐÐ»ÑŒÐ±ÐµÑ€Ñ‚','Albert','m');
INSERT INTO `bias` VALUES (220,'#include<math.h>\n#include<stdio.h>\n#include<stdlib.h>\n#define NMAX 100000\n\nint indmax(int *A,int i,int j)\n{\nif (A[i]<A[j])\n	return j;\nelse\n	return i;\n}\n\nvoid sift(int *A, int n, int k)\n	{\n	int q = 2*k + 2;\n	int p = 2*k + 1;\n	if(q<n)\n		if ((A[k]>=A[q])&&(A[k]>=A[p]))\n			return;\n		else\n		{\n			int m=indmax(A,p,q);\n			int j=A[k];\n			A[k]=A[m];\n			A[m]=j;\n			sift(A, n, m);\n		}\n	else\n		if(p<n)\n			{\n			int j=A[k];\n			A[k]=A[p];\n			A[p]=j;\n			sift(A, n, p);\n			}\n\n\n	}\n\nint main()\n{\nint A[NMAX];\nint i,j,k,m,p,q,g,n,f;\nint N;\n//scanf(\"%d\",&k);\nFILE *fg = fopen(\"input.txt\", \"r\");\nfscanf(fg, \"%d\", &N);\nfor (i = 0; i < N; i++)\n{\n	fscanf(fg, \"%d\", &A[i]);\n}\nfclose(fg);\np=2*k+1;\nq=p+1;\nn=N;\nfor(i=n;i>=0;i--)\n	sift(A,n,i);\n\nfor(n=N;n>1;n--)\n	{\n	g=A[n-1];\n	A[n-1]=A[0];\n	A[0]=g;\n	sift(A,n-1,0);\n	}\nf=A[1];\nA[1]=A[0];\nA[0]=f;\nfor(i=0;i<N;i++)\n	printf(\"%d \",A[i]);\nprintf(\"\\n\");\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (221,'#include <stdio.h>\nvoid quicksort(int *A, int l, int r)\n{\n	if (l>=r) return;\n	int i=l,j=r,c;\n	int x=(A[l]+A[r])/2;\n	while (i<=j)\n	{\n		while (A[i]<x)\n			i++;\n		while (A[j]>x)\n			j--;\n		if (i<=j)\n		{\n			c=A[i];\n			A[i]=A[j];\n			A[j]=c;\n			i++;\n			j--;\n		}\n	}\n	quicksort(A,l,j);\n	quicksort(A,i,r);\n}\nint main ()\n{\n	int N,i,x,l,r;\n	int A[100000]={0};\n	FILE *f=fopen(\"input11.txt\",\"r\");\n	fscanf(f,\"%d\",&N);\n	for (i=0;i<N;i++)\n	{	fscanf(f,\"%d\",&x);\n		A[i]=x;\n	}\n	l=0;\n	r=N-1;\n	quicksort(A,l,r);\n	FILE *p=fopen(\"output11.txt\",\"w\");\n	for (i=0;i<N;i++)\n	{\n		x=A[i];\n		fprintf(p,\"%d \",x);\n	}\n	fprintf(p, \"\\n\");\n	fclose(f);\n	fclose(p);\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (222,'#include<stdio.h>\n#include<string.h>\n#define N 100\n\nint main()\n{\n	char K[20]={0};\n	scanf(\"%s\",K);\n	FILE *f;\n	f=fopen(\"/etc/passwd\",\"r\");\n	int i,j,k,l=0,s;\n	i=0;\n	j=0;\n	k=0;\n	l=0;\n	char A[N]={0};\n	while(fgets(A,100,f))\n	{\n		l=1;\n		for(i=0;A[i]!=\':\';i++)\n		{\n			if(A[i]!=K[i])\n			{\n				l=0;\n				break;\n			}\n		}\n		if((A[i]==\':\')&&(l==1))\n		{\n			for(k=0;k<4;i++)\n				if (A[i]==\':\') k++;\n			for(;(A[i]!=\':\')&&(A[i]!=\',\');i++)\n				putchar(A[i]);\n		break;\n		}\n	}\n	printf(\"\\n\");\n	fclose(f);\n	return(0);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (223,'#include<stdio.h>\n#include<malloc.h>\nvoid quick(int *A,int l,int r)\n{\n	int x=(A[l]+A[r])/2;\n	int i=l;\n	int j=r;\n	int t=0;\n	do\n	{\n		while(A[i]<x) \n		i++;\n		while(A[j]>x) \n		j--;\n		if(i<=j)\n		{\n			t=A[i];\n			A[i]=A[j];\n			A[j]=t;\n			i++;\n			j--;\n		}\n	}\n	while(i<=j);\n	if(i<r) quick(A,i,r);\n	if(j>l) quick(A,l,j);\n}	\n\n\n\n\nint main()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n	int N;\n	fscanf(f,\"%d\\n\",&N);\n	int *T;\n	int i=0;\n	T=malloc(N*sizeof(int));\n	while(fscanf(f,\"%d\",&T[i])==1)\n		i++;\n	quick(T,0,N-1);\n	FILE *o=fopen(\"output.txt\",\"w\");\n	for(i=0;i<N;i++)\n	fprintf(o,\"%d \",T[i]);\n	fclose(o);\n	fclose(f);\n	free(T);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (224,'#include <stdio.h>\n#include <string.h>\n#define N 10000\n\nint main()\n{	int i=0;\n	int d=0;\n	int j,k,l,m,p,r;\n	char A[N]={0};\n	char s[N]={0};\n	printf(\"??????? ????? \\n\");\n	scanf(\"%s\", s);\n	k=strlen(s);\n	FILE *f = fopen (\"/etc/passwd\", \"r\");\n	while (fgets(A, N, f))\n	{\n		for (j=0;j<k;j++)\n		\n		{	l=1;\n			if (s[j]!=A[j])\n			{l=0;\n			break;}\n		}\n	if (l==1)\n	{\n	if (A[k]==\':\')\n	{\n	for (;d<4;k++)\n	{\n	if (A[k]==\':\')\n	d++;\n	}\n	for (;((A[k]!=\',\')&&(A[k]!=\':\'));k++)\n	putchar(A[k]);\n	}\n	}\n	}\n\nfclose(f);	\nreturn 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (225,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define n 100000\n\nvoid h(int*s, int i, int count)\n{\nint a;\nif((2*i+1>=count)&&(2*(i+1)>=count))\n	return;\nif(((2*i+1)<count)&&(2*(i+1)>=count))\n	if(s[i]<s[2*i+1])\n	{\n		a=s[i];\n		s[i]=s[2*i+1];\n		s[2*i+1]=a;\n		return;\n	}	\n// 1. ??? ????\n// 2. ???? ?????? 2*i+1\nif((2*(i+1)<count)&&(2*i+1<count))\n	if((s[i]<s[(2*i)+1])||(s[i]<s[2*(i+1)]))\n	{\n		if(s[(2*i)+1]>=s[2*(i+1)])\n		{\n			a=s[i];\n			s[i]=s[(2*i)+1];\n			s[(2*i)+1]=a;\n			h(s,(2*i)+1, count);\n			return;\n		}\n		a=s[i];\n		s[i]=s[2*(i+1)];\n		s[2*(i+1)]=a;\n		h(s,2*(i+1), count);\n	}\n}	\n\nint main()\n{\nint s[n];\nint d[n];\nint t,i,m,a,l,c,j;\nFILE* f=fopen(\"input.txt\",\"r\");\nFILE* g=fopen(\"output.txt\",\"w\");\nfscanf(f,\"%d\",&t);\nfor(i=0;i<t;i++)\n	fscanf(f,\"%d\",&s[i]);\nl=t/2-1;\nfor(i=l;i>=0;i--)\n	h(s,i, t);\nfor(m=t-1;m>0;m--)\n{\n	a=s[0];\n	s[0]=s[m];\n	s[m]=a;\n	h(s,0,m);\n}\nfor(j=0;j<t;j++)\n	fprintf(g, \"%d \", s[j]);\nfclose(f);\nfclose(g);\nreturn(0);\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (226,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n\n\n	int main()\n	{ \n	 struct item\n	 {\n	  char word[11];\n	  int count;\n	  struct item *next;\n	 };\n	 struct item *head = 0;\n	 \n\n	 FILE *f = fopen(\"input1.txt\", \"r\");\n	 if(!f)\n	 { \n	  perror (\"fopen\");\n	 }\n	\n	struct item*p;\n	struct item*q;\n	int x = 0, t;\n	char s[11];\n	while (x != EOF)\n	{\n	int i = 0 ;\n	for (x = fgetc(f); i < 10 && x >= \'a\' && x <= \'z\';  x = fgetc(f))\n	    {\n	      s[i] = x;\n	      i++;\n	    } \n	s[i] = 0;\n\n	// ????????? ??? ???????? ??????, ???? ??????? ????? ?? ????? -- ????????? ? ???? ???????;\n	// ???? ?? ????? ????? ??????? ?? ???? -- ???????? ? ?????? ????? ???????\n	// strcmp(s1, s2) -- 0, ???? ?????\n	// strcpy(????, ???) -- ????????\n	\n	int nashli = 0;\n	for (p = head ;p ;p = p->next)\n	{\n	 if (!strcmp(p -> word, s))\n	 {\n	  p->count++;\n	  nashli = 1;\n	 }\n	}\n\n	 if (!nashli) //????????? ? ?????? ??????\n	 {\n	 struct item *q = malloc(sizeof(struct item));\n	 q ->next = head;\n	 head = q;\n	 strcpy(q->word, s);\n	 q->count = 1;\n	 }\n	}\n	for (p = head; p; p = p->next)\n	printf(\"%s,%d\\n\",p->word,p->count);\n	}\n	\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (227,'#include<stdio.h>\n#include<math.h>\n#include<stdlib.h>\nint sort(int *A, int l, int r)\n{\nprintf(\"??????? sort(%d,%d)\\n\", l, r);\nfloat x,f;\nint d,i,j,c,k,q;\ni=l;\nj=r;\nx=(A[l]+A[r])/2;\n\nwhile (i <= j)\n{\n	while (A[i] < x) i++;\n	while (A[j] > x) j--;\n	// i->>>\n	// <--j\n	if(i<=j)\n	{\n		f=A[i];\n		A[i]=A[j];\n		A[j]=f;\n		i++;\n		j--;\n	}\n}\n\n\n/*for(i=l;i<=r;)\n{\n	if(i > j)\n	{\n		printf(\"%d > %d, break\\n\", i, j);\n		break;\n	}\n	else\n	{\n		if(A[i]>x)\n		{\n			printf(\"i = %d, for (j = %d)\\n\", i, j);\n			for( ;j>=l && j>0 && j >= i;)\n			{\n				if(A[j]<x)\n				{\n				if(i<=j)\n				{\n				f=A[i];\n				A[i]=A[j];\n				A[j]=f;\n				printf(\"????? %d ? %d\\n\", i, j);\n				i++;\n				j--;\n				}\n				break;\n				}\n			}\n		}\n	}	\n}*/\nfor(q=0;q<10;q++)\n	printf(\"%d \",A[q]);\nprintf(\"\\n\");\n\n	printf(\"????? ?????????? i = %d, j = %d\\n\", i, j);\nif(i<r)\n{\n	printf(\"????????????\\n\");\n	sort(A,i,r);\n}\nif(l<j)\n{\n	printf(\"????????????\\n\");\n	sort(A,l,j);\n}\n	// p\n	// ??????? ????\n}\n\n#define NMAX 100000\n\nint main()\n{\nint A[NMAX];\nint i,j,k,m,p,q,g,n,f;\nint N;\n//scanf(\"%d\",&k);\nFILE *fg = fopen(\"input.txt\", \"r\");\nfscanf(fg, \"%d\", &N);\nfor (i = 0; i < N; i++)\n{\n	fscanf(fg, \"%d\", &A[i]);\n}\nfclose(fg);\n\nsort(A, 0, N-1);\nfor(k=0;k<N;k++)\n	printf(\"%d \",A[k]);\nprintf(\"\\n\");\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (228,'#include <stdio.h>\nvoid quicksort(int *A, int l, int r)\n{\nint x=A[(l+r)/2];\nint i=l;\nint j=r;\nint p=0;\nif(r-l<=1) return;\ni=l;\ndo{\nif (A[i]<x) i++;\nelse if (A[j]>x) j--;\n else {p=A[i]; A[i]=A[j]; A[j]=p; i++; j--;}\n } while (i<j);\n	 for (i=l; i<=r; i++) if (A[i]==x) j=i;\n quicksort(A,l,j);\n quicksort(A,j,r);\n		 }\n int main()\n		 {\n FILE *F=fopen(\"inp.txt\",\"rt\");\n FILE *G=fopen(\"out.txt\",\"w\");\nint B[100];\nint i=0;\nint a;\nint N;\nif (F==NULL || G==NULL) { printf(\"otkrit\' ne ydalos\'\"); return 0;}\ndo {\na=fscanf(F,\"%d\",&B[i]); if (a!=1) break;\n i++;\n }\n while (i<100);\nquicksort(B,0,i-1);\n for (N=0;N<i;N++)\nfprintf(G,\"%d \", B[N]);\nfclose(F);\nfclose(G);\n }\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (229,'#include <stdio.h>\nvoid sift(int *A, int N, int k) {\n if (2*k+1 > N - 1) return;\nelse if (2*k+1 == N - 1) \n{\n  if (A[2*k+1] > A[k]) \n  {\n  int a=A[k]; A[k]=A[2*k+1]; A[2*k+1]=a;}\n   }\n   else if ((A[2*k+1] > A[k])&&(A[2*k+1] >= A[2*k+2])) \n   {\n   int a = A[k]; A[k]=A[2*k+1]; A[2*k+1]=a; \n    sift(A,N,2*k+1);}\n    else if (A[2*k+2] > A[k])\n    {int a = A[k]; A[k]=A[2*k+2]; A[2*k+2]=a; \n    sift(A,N,2*k+2);}\n    else return;\n	\n	}\n\n void sort(int *A, int N) {\n int i=0;\n	 for (i=N/2;i>=0;i--) \n	 sift(A,N,i);\n	 while (N>0)\n {\nint a=A[N-1];\n A[N-1]=A[0];\n A[0]=a;\n N--;\n sift(A,N,0);\n }\n				     }\n\n int main()\n {\n FILE *F=fopen(\"inp.txt\",\"rt\");\nFILE *G=fopen(\"out.txt\",\"w\");\nint B[100];\n int i=0;\nint a;\nint N;\nif (F==NULL || G==NULL) { printf(\"otkrit\' ne ydalos\'\"); return 0;}\ndo {\n a=fscanf(F,\"%d\",&B[i]); \nif (a != 1) break;\n i++;\n }while (i<100);\n sort(B,i);\nfor (N=0;N<i;N++)\nfprintf(G,\"%d \", B[N]);\n fclose(F);\n fclose(G);\n	}\n\n\n\n','ÐšÑÐµÐ½Ð¸Ñ','Ksenia','f');
INSERT INTO `bias` VALUES (230,'#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define NL -100000000\nfloat total;\nunsigned int newsize,rd;\nint symbols[256],pos,nos,zero,one;\nchar *cd[256],strw[8],strr[9];\nstruct list\n{\n	struct tree *symbol;\n	struct list *next;\n};\nstruct tree\n{\n	int s;\n	float f;\n	struct tree *pr;\n	struct tree *left;\n	struct tree *right;\n};\nstruct tree *root = NULL, *leafs[256];\nstruct list *head = NULL;\nvoid rec(FILE *f,char c)\n{\n	int i;\n	strw[pos] = c;\n	pos++;\n	if (pos == 8)\n	{\n		fputc(todec(strw),f);\n		pos = 0;\n	}\n}\nvoid addtolist(struct tree *t)\n{\n	struct list *l,*p = head;\n	l = malloc(sizeof(struct list));\n	if (!l)\n		perror(\"malloc\");\n	l->symbol = t;\n	if (head == NULL)\n	{\n		head = l;\n		l->next = NULL;\n		return;\n	}\n	for(;;)\n	{\n		if (p == head)\n		{\n			if (((p->symbol)->f)>(t->f))\n			{\n				l->next = head;\n				head = l;\n				return;\n			}\n		}\n		if (p->next != NULL)\n		{\n			if ((((p->next)->symbol)->f)>(t->f))\n			{\n				l->next = p->next;\n				p->next = l;\n				return;\n			}\n		}\n		else\n		{\n			p->next = l;\n			l->next = NULL;\n			return;\n		}\n		p = p->next;\n	}\n}\nvoid *getcode(int s)\n{\n	int length = 0,i;\n	char *c;\n	struct tree *t = leafs[s];\n	for(;;)\n	{\n		if (!(t->pr))\n			break;\n		length++;\n		t = t->pr;\n	}\n	c = malloc((length+1)*sizeof(char));\n	if (!c)\n		perror(\"malloc\");\n	c[length] = 0;\n	length--;\n	t = leafs[s];\n	while(length>=0)\n	{\n		if (t == ((t->pr)->left))\n			c[length] = \'1\';\n		else\n			c[length] = \'0\';\n		t = t->pr;\n		length--;\n	}\n	cd[s] = c;\n}\nvoid putsize(unsigned int sz,FILE *f)\n{\n	int i=0;\n	unsigned int k = UINT_MAX/2 +1, s =sz;\n	char c[33];\n	c[32] = 0;\n	while(k>0)\n	{\n		c[i] = \'0\' + s/k;\n		s-= (s/k)*k;\n		k/=2;\n		i++;\n	}\n	for(i=0;i<32;i++)\n		rec(f,c[i]);\n}\nint todec(char *c)\n{\n	int i = 0,k = 128,s = 0;\n	while(k>0)\n	{\n		s+= (c[i]-\'0\')*k;\n		k/=2;\n		i++;\n	}\n	return s;\n}\nvoid tobin(int a, char *c)\n{\n	int i,a1 = a,k = 128;\n	for (i=0;i<8;i++)\n	{\n		c[i] = a/k + \'0\';\n		a -= (a/k)*k;\n		k/=2;\n	}\n	c[8] = 0;\n}\nvoid dfs(struct tree *t,FILE *f)\n{\n	int i;\n	char cc[9];\n	if (t->s == NL)\n	{\n		rec(f,\'1\');\n		dfs(t->left,f);\n		dfs(t->right,f);\n	}\n	else\n	{\n		rec(f,\'0\');\n		tobin(t->s, cc);\n		for(i=0;i<8;i++)\n			rec(f,cc[i]);\n	}\n}\nvoid rmtree(struct tree *t)\n{\n	if (t->s == NL)\n	{\n		rmtree(t->left);\n		rmtree(t->right);\n	}\n	free(t);\n}\nvoid toarc(FILE *f,FILE *archive)\n{\n	int i,c;\n	unsigned int size;\n	struct list *curr;\n	struct tree *t;\n	char cc[9];\n	rewind(f);\n	while((c = fgetc(f))!= EOF)\n	{\n		symbols[c]++;\n		total+=1;\n	}\n	if (total == 0)\n	{\n		fputc(0,archive);\n		fputc(0,archive);\n		fputc(0,archive);\n		fputc(0,archive);\n		return;\n	}\n	for(i=0;i<256;i++)\n		if (symbols[i])\n		{\n			nos++;\n			t = malloc(sizeof(struct tree));\n			if (!t)\n				perror(\"malloc\");\n			leafs[i] = t;\n			t->s = i;\n			t->f = (symbols[i]/total);\n			t->left = NULL;\n			t->right = NULL;\n			addtolist(t);		\n		}\n	if (head->next == NULL)\n	{\n		size = symbols[(head->symbol)->s];\n		putsize(size,archive);\n		rec(archive,\'0\');\n		tobin((head->symbol)->s, cc);\n		for(i=0;i<8;i++)\n			rec(archive,cc[i]);\n		while(pos)\n			rec(archive,\'0\');\n		free(head->symbol);\n		free(head);\n		return;\n	}\n	while(head->next)\n	{\n		curr = head;\n		t = malloc(sizeof(struct tree));\n		if (!t)\n			perror(\"malloc\");\n		t->s = NL;\n		(curr->symbol)->pr = t;\n		((curr->next)->symbol)->pr = t;\n		t->f = (curr->symbol)->f + ((curr->next)->symbol)->f;\n		t->left = curr->symbol;\n		t->right = (curr->next)->symbol;\n		head = head->next;\n		free(curr);\n		curr = head;\n		head = head->next;\n		free(curr);\n		addtolist(t);\n	}\n	root = head->symbol;\n	root->pr = NULL;\n	free(head);\n	size = 10*nos - 1;\n	for(i=0;i<256;i++)\n		if (symbols[i])\n		{\n			getcode(i);\n			size+= strlen(cd[i])*symbols[i];\n		}\n	putsize(size,archive);\n	dfs(root,archive);\n	rewind(f);\n	while((c = fgetc(f)) != EOF)\n		for(i=0;cd[c][i];i++)\n			rec(archive,cd[c][i]);\n	for(i=0;i<256;i++)\n		if (symbols[i])\n			free(cd[i]);\n	while(pos)\n		rec(archive,\'0\');\n	rmtree(root);\n}\nchar read(FILE *f)\n{\n	int i;\n	char c;\n	if (pos == 8)\n	{\n		i = fgetc(f);\n		tobin(i, strr);\n		if ((newsize - rd) <8)\n		{\n			strr[newsize-rd] = EOF;\n		}\n		rd+=8;\n		pos = 0;\n	}\n	c = strr[pos];\n	pos++;\n	return c;\n}\nvoid getsize(FILE *f)\n{\n	unsigned int k[4] = {16777216,65536,256,1},s = 0;\n	int i,c;\n	for(i=0;i<4;i++)\n		s+= (c = fgetc(f))*k[i];\n	newsize = s;\n}\nvoid builddfs(struct tree *t,FILE *f,char cur)\n{\n	struct tree *l,*r;\n	int i;\n	char c,s[8];\n	if (cur == \'1\')\n	{\n		one++;\n		t->s = NL;\n		r = malloc(sizeof(struct tree));\n		l = malloc(sizeof(struct tree));\n		if (!(l&&r))\n			perror(\"malloc\");\n		t->left = l;\n		t->right = r;\n		c = read(f);\n		builddfs(t->left,f,c);\n		c = read(f);\n		builddfs(t->right,f,c);\n		if ((zero - one)== 1)\n			return;\n	}\n	else\n	{\n		zero++;\n		for(i=0;i<8;i++)\n			s[i] = read(f);\n		t->s = todec(s);\n		t->left = NULL;\n		t->right = NULL;\n	}\n}\nvoid fromarc(FILE *archive,FILE *f)\n{\n	struct tree *root,*curr;\n	unsigned int k;\n	int i;\n	char c;\n	rewind(archive);\n	getsize(archive);\n	if (newsize == 0)\n		return;\n	pos = 8;\n	c = read(archive);\n	if (c == \'0\')\n	{\n		char s[8];\n		for(i=0;i<8;i++)\n			s[i] = read(archive);\n		c = todec(s);\n		for(k = 0;k<newsize;k++)\n			fputc(c,f);\n		return;\n	}\n	root = malloc(sizeof(struct tree));\n	if (!root)\n		perror(\"malloc\");\n	one++;\n	builddfs(root,archive,c);\n	curr = root;\n	while((c = read(archive))!= EOF)\n	{\n		if (c == \'1\')\n			curr = curr->left;\n		else \n			curr = curr->right;\n		if ((curr->s)!= NL)\n		{\n			fputc(curr->s,f);\n			curr = root;\n		}\n	}\n	if (root)\n		rmtree(root);\n	return;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (231,'#include<stdio.h>\n#include<stdlib.h>\n#include\"harc.h\"\nint main(int argc, char *argv[])\n{\n	int state,i;\n	FILE *f1,*f2;\n	if ((argc != 4)||(argv[1][0]!=\'-\')||((argv[1][1]!=\'a\')&&(argv[1][1]!=\'d\')))\n	{\n		perror(\"wrong arguments\");\n		return 0;\n	}\n	if (argv[1][1] == \'a\')\n		state = 1;\n	else state = 2;\n	f1 = fopen(argv[2],\"r\");\n	f2 = fopen(argv[3],\"w\");\n	if ((!f1)||(!f2))\n	{\n		perror(\"fopen\");\n		return 1;\n	}\n	if (state == 1)\n		toarc(f1,f2);\n	if (state == 2)\n		fromarc(f1,f2);\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (232,'#include<stdio.h>\r\n#include<stdlib.h>\r\n\r\n#include \"main.h\"\r\n#include \"arch.h\"\r\n\r\nstruct node nodes[512];\r\nstruct chars A[256];\r\nchar codes[256][LOC + 1];\r\n\r\nvoid archiving(char *file1, char *file2) //const\r\n{\r\n        unsigned int n = 0, k, i, j, next = 0, f = 8, w, bit = 128, t = 1, first, count = 0;\r\n        char line[LOC + 1] = {0};\r\n        FILE *f1, *f2;\r\n        if ((f1 = fopen(file1, \"rb\")) == NULL)\r\n	{\r\n		printf(\"Can\'t open file %s\\n\", file1);\r\n		return;\r\n	}\r\n        if ((f2 = fopen(file2, \"wb\")) == NULL)\r\n	{\r\n		printf(\"Can\'t create file %s\\n\", file2);\r\n		fclose(f1);\r\n		return;\r\n	}\r\n	printf(\"Archiving...\\n\");\r\n	while ((t = fgetc(f1)) != EOF)\r\n		A[t].P++;\r\n        for (i = 0; i < 256; i++)\r\n        {\r\n		if (A[i].P > 0)\r\n			n++;\r\n                A[i].number = i;\r\n                count += A[i].P;\r\n        }\r\n        if (n == 0)\r\n        {\r\n		printf(\"Ok\\n\");\r\n		fclose(f1);\r\n		fclose(f2);\r\n                return;\r\n        }\r\n        qsort(A, 256, sizeof(struct chars), cmp);\r\n        if (n == 1)\r\n        {\r\n                fprintf(f2, \"%c%c%c%c%c%d\", 128, 0, 0, 0, A[0].number, A[0].P);\r\n		printf(\"Ok\\n\");\r\n		fclose(f1);\r\n		fclose(f2);\r\n                return;\r\n        }\r\n        k = 256;\r\n        for (i = n; i > 1; i--)\r\n        {\r\n                nodes[k].left = A[i - 2].number;\r\n                nodes[k].right = A[i - 1].number;\r\n                A[i - 2].P += A[i - 1].P;\r\n                A[i - 2].number = k++;\r\n		qsort(A, i - 1, sizeof(struct chars), cmp);\r\n        }\r\n        make_code(256, k-1, line, 0);\r\n	for (i = 0; i < 32; i++)\r\n        {\r\n                print_bin(f2, &next, &f, &bit, count % 2);\r\n                count /= 2;\r\n        }\r\n        print_tree(f2, nodes, k-1, &next, &f, &bit);\r\n        rewind(f1);\r\n        while ((t = fgetc(f1)) != EOF)\r\n                for (w = 0; codes[t][w]; w++)\r\n                        print_bin(f2, &next, &f, &bit, codes[t][w] - \'0\');\r\n        if (f != 8)\r\n                fprintf(f2, \"%c\", next);\r\n	printf(\"Ok\\n\");\r\n	fclose(f1);\r\n	fclose(f2);\r\n        return;\r\n}\r\n\r\nstatic void make_code(int N, int M, char *line, int l_ind)\r\n{\r\n	int i;\r\n	char l[LOC + 1];\r\n	for (i = 0; i < LOC + 1; l[i++] = 0)\r\n	{\r\n		if (M < N)\r\n		{\r\n			for (i = 0; i < LOC; i++)\r\n                		codes[M][i] = line[i];\r\n			return;\r\n		}\r\n		for (i = 0; i < LOC; i++)\r\n			l[i] = line[i];\r\n		l[l_ind] = \'1\';\r\n		make_code(N, nodes[M].left,  l, l_ind + 1);\r\n		l[l_ind] = \'0\';\r\n		make_code(N, nodes[M].right, l, l_ind + 1);\r\n        }\r\n}\r\n\r\nstatic int cmp(const void *keyval, const void *datum) \r\n{\r\n        return ((*(struct chars *)datum).P - (*(struct chars *)keyval).P);\r\n}\r\n\r\nstatic void print_bin(FILE *f2, int *next, int *f, int *bit, int curr_bit)\r\n{\r\n        if (curr_bit == 1)\r\n                *next += *bit;\r\n        *bit /= 2;\r\n        if (--(*f) == 0)\r\n	{\r\n		fprintf(f2, \"%c\", *next);\r\n	        *next = 0;\r\n        	*f = 8;\r\n	        *bit = 128;\r\n	}\r\n}\r\n\r\nstatic void print_tree(FILE *f2, struct node *nodes, int numb, int *next, int *f, int *bit)\r\n{\r\n        int i = 0;\r\n        if (numb < 256)\r\n        {\r\n                print_bin(f2, next, f, bit, 0);\r\n                for (i = 0; i < 8; i++)\r\n                {\r\n                        print_bin(f2, next, f, bit, numb % 2); \r\n                        numb /= 2;\r\n                }\r\n        }\r\n        else\r\n        {\r\n                print_bin(f2, next, f, bit, 1);\r\n                print_tree(f2, nodes, nodes[numb].right, next, f, bit);\r\n                print_tree(f2, nodes, nodes[numb].left, next, f, bit);\r\n        }\r\n}\r\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (233,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#include<ctype.h>\r\n\r\n#include \"main.h\"\r\n#include \"dearch.h\"\r\n\r\nstruct node tree[769];\r\n\r\nvoid  dearchiving(char *file1, char *file2)\r\n{\r\n        FILE *f1, *f2;\r\n	unsigned int count = 0, i = 0, p = 9, s_curr = 0, k = 255, power = 1, t;\r\n	printf(\"Unarchiving...\\n\");\r\n        if ((f1 = fopen(file1, \"rb\")) == NULL)\r\n                return;\r\n        if ((f2 = fopen(file2, \"wb\")) == NULL)\r\n                return;\r\n	if ((t = fgetc(f1)) == EOF)\r\n	{\r\n		printf(\"Ok\\n\");\r\n		fclose(f1);\r\n		fclose(f2);\r\n		return;\r\n	}\r\n	else\r\n		ungetc(t,f1);\r\n	for (i = 0; i < 32; i++)\r\n        {\r\n                count += power * get_bit(f1, &p, &s_curr);\r\n                power *= 2;\r\n        }\r\n        /*if (count == 0)\r\n	{\r\n		printf(\"Ok\\n\");\r\n		fclose(f1);\r\n		fclose(f2);\r\n                return;\r\n	}*/\r\n        if (count == 1)\r\n        {\r\n                s_curr = fgetc(f1);\r\n                count = 0;\r\n                while ((k = fgetc(f1)) != EOF)\r\n                        count = 10 * count + (k - \'0\');\r\n                for (i = 0; i < count; i++)\r\n                        fprintf(f2, \"%c\", s_curr);\r\n		printf(\"Ok\\n\");\r\n		fclose(f1);\r\n		fclose(f2);\r\n                return;\r\n        }\r\n	get_tree(f1, tree, &k, &p, &s_curr);\r\n	decode(f1, f2, count, 255, &p, &s_curr);\r\n	printf(\"Ok\\n\");\r\n	fclose(f1);\r\n	fclose(f2);\r\n        return;\r\n}\r\n\r\nstatic void decode(FILE *f1, FILE *f2, int count, int head, int *p, int *s_curr)\r\n{\r\n        int c, s = 0, w;\r\n        do\r\n        {\r\n                w = head;\r\n                while (tree[w].left >= 256)\r\n                {\r\n                        c = get_bit(f1, p, s_curr);\r\n                        if (c == 1)\r\n                                w = tree[w].right;\r\n                        else\r\n                                w = tree[w].left;\r\n                }\r\n                fprintf(f2, \"%c\", tree[w].left);\r\n                s++;\r\n        } while (s < count);\r\n}\r\n\r\nstatic void get_tree(FILE *f1, struct node *tree, int *con, int *p, int *s_curr)\r\n{\r\n        int i, curr, c; \r\n        curr = *con;\r\n        c = get_bit(f1, p, s_curr);\r\n        if (c == 1)\r\n        {\r\n                (*con)++;\r\n                tree[curr].left = *con;\r\n                get_tree(f1, tree, con, p, s_curr);\r\n                (*con)++;\r\n                tree[curr].right = *con;\r\n                get_tree(f1, tree, con, p, s_curr);\r\n        }\r\n        else\r\n        {\r\n                for (i = 1; i <= 128; i *= 2)\r\n                        c += i * get_bit(f1, p, s_curr);\r\n                tree[*con].left = tree[*con].right = c;\r\n        }\r\n}\r\nstatic int get_bit(FILE *f1, int *p, int *s_curr)\r\n{\r\n	int a = 0;\r\n        if (*p == 9)\r\n        {\r\n                *s_curr = fgetc(f1);\r\n//		*s_curr = t;\r\n                *p = 1;\r\n        }\r\n	a = (*s_curr >> (8 - (*p)++));\r\n	return a & 1;\r\n}\r\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (234,'#include <stdio.h>\n\n#include \"main.h\"\n#include \"arch.h\"\n#include \"dearch.h\"\n\nint main(int argc, char *argv[])\n{\n	if (argc == 1)\n	{\n		printf(\"Write two name of file\\n\");\n		return;\n	}\n	if (argv[1][0] != \'-\')\n	{\n		if (argc == 3)\n			archiving(argv[1], argv[2]);\n	}\n	else\n		if (argc == 4)\n			dearchiving(argv[2], argv[3]);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (235,'#include \"functions.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <ctype.h>\r\n#include \"vars.h\"\r\n#include \"list.h\"\r\n#include \"stack.h\"\r\n\r\nint ch = \'0\';\r\n\r\nint priority ( char x )\r\n{\r\n	if ( x == \'(\' )\r\n		return 1;\r\n	else if ( x == \')\' )\r\n		return 2;\r\n	else if ( x == \'=\' )\r\n		return 3;\r\n	else if ( x == \'+\' || x == \'-\' )\r\n		return 4;\r\n	else if ( x == \'*\' || x == \'/\' )\r\n		return 5;\r\n	else\r\n		return 0;\r\n}\r\n\r\nList * ScanInput ()\r\n{	\r\n	int start;\r\n	List *sp;\r\n	List *inf;\r\n	ListCreate (&sp);\r\n	ListCreate (&inf);\r\n	ch = getchar();\r\n	start = 1;\r\n	while (ch!=\'\\n\')\r\n	{\r\n		if (isalpha(ch))\r\n		{\r\n			int i=0, a;\r\n			char *g;\r\n			char *Array;\r\n			struct list *q;\r\n			while (isalpha(ch)||isdigit(ch)||(ch == \'_\'))\r\n			{\r\n				g = malloc (sizeof(char));\r\n				if (g){\r\n				*g = ch;\r\n				PushList (g, 1, sp);\r\n				}\r\n				ch = getchar();\r\n			}\r\n			a = ListLength (sp);\r\n			Array = malloc (sizeof(char)*a+1);\r\n			if (Array){\r\n			for (q=sp->head;q;q=q->next)\r\n			{\r\n				Array[i] = *(char*)q->data;\r\n				free (q->data);\r\n				i++;\r\n			}\r\n			Array[i] = 0;			\r\n			PushList (Array, 1, inf);\r\n			MakeNullList (sp);\r\n			start = 0;\r\n			continue;\r\n			}\r\n		}\r\n		else if (isdigit(ch))\r\n		{\r\n			int n=0;\r\n			int *q;\r\n 			while (isdigit(ch))\r\n			{\r\n				int i=10;\r\n				n = n*i+(ch-\'0\');\r\n				ch = getchar();\r\n			}\r\n			q = malloc (sizeof (int));\r\n			if (q){\r\n			*q = n;\r\n			PushList (q, 2, inf);\r\n			}\r\n			start = 0;\r\n			continue;\r\n		}\r\n		else if ((ch == \'(\') || (ch == \'=\'))\r\n		{\r\n			char *q;\r\n			q = malloc (sizeof (char));\r\n			if (q)\r\n			{\r\n			*q = ch;\r\n			PushList (q, 3, inf);\r\n			}\r\n			start = 1;\r\n			ch = getchar();\r\n			continue;\r\n		}\r\n		else if ((ch == \')\') || (ch == \'*\') || (ch == \'/\'))\r\n		{\r\n			char *q;\r\n			q = malloc (sizeof (char));\r\n			if (q){\r\n			*q = ch;\r\n			PushList (q, 3, inf);\r\n			}\r\n			start = 0;\r\n			ch = getchar();\r\n			continue;\r\n		}\r\n		else if (ch == \'-\' || ch == \'+\')\r\n		{\r\n			if (start == 1)\r\n			{\r\n				char *q;\r\n				int *p;\r\n				q = malloc (sizeof (char));\r\n				if (q){\r\n				p = malloc (sizeof (int));\r\n				if (p){\r\n				*p = 0;\r\n				*q = ch;\r\n				PushList (p, 2, inf);\r\n				PushList (q, 3, inf);\r\n				}\r\n				}\r\n				start = 0;\r\n				ch = getchar();\r\n				continue;\r\n			}\r\n			else \r\n			{\r\n				char *q;\r\n				q = malloc (sizeof (char));\r\n				if (q){\r\n				*q = ch;\r\n				PushList (q, 3, inf);\r\n				}\r\n				start = 0;\r\n				ch = getchar();\r\n				continue;\r\n			}\r\n		}\r\n		else if (ch == EOF)\r\n			break;\r\n	}\r\n	ListDel (sp);\r\n	return (inf);\r\n}\r\n\r\nList* PolishNotation (List *sp)\r\n{\r\n	Stack *st;\r\n	List *polishform;\r\n	struct list *p;\r\n	StackCreate (&st);\r\n	ListCreate (&polishform);\r\n	p = sp->head;\r\n 	while (!EmptyList(sp))\r\n	{\r\n		if (p->type == 1 || p->type == 2)\r\n		{\r\n			PushList (p->data, p->type, polishform);\r\n			PopList (sp);\r\n		}\r\n		else if (*(char*)p->data == \'(\')\r\n		{\r\n			PushStack (p->data, p->type, st);\r\n			PopList (sp);\r\n		}\r\n		else if (*(char*)p->data == \')\')\r\n		{\r\n			struct item *q;\r\n			q = st->top;\r\n			while (*(char*)q->data != \'(\')\r\n			{\r\n 				PushList (q->data, 3, polishform);\r\n				PopStack (st);\r\n				q=st->top;\r\n			}\r\n			free (q->data);/////////////////////\r\n			PopStack (st);\r\n			free (p->data);/////////////////////\r\n			PopList (sp);\r\n		}\r\n		else if (p->type == 3)\r\n		{\r\n			struct item *q;\r\n			q=st->top;\r\n			while (!EmptyStack(st) && ((priority (*(char*)q->data)) >= (priority(*(char*)p->data))))\r\n			{\r\n				PushList(q->data, 3, polishform);\r\n				PopStack (st);\r\n				q=st->top;\r\n			}\r\n			PushStack (p->data,p->type, st);\r\n			PopList (sp);\r\n		}\r\n		p=sp->head;\r\n	}\r\n	while (!EmptyStack(st))\r\n	{\r\n		PushList (top(st), 3, polishform);\r\n		PopStack (st);\r\n	}\r\n	ListDel (sp);\r\n	StackDel (st);\r\n	return (polishform);\r\n}\r\n\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (236,'#include \"list.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\nvoid MakeNullList (List *sp)\r\n{\r\n	struct list *p;\r\n	while (sp->head)\r\n	{\r\n		p=sp->head;\r\n		sp->head = p->next;\r\n		free (p);\r\n	}\r\n}\r\nvoid ListCreate (List **sp)\r\n{\r\n	*sp = malloc (sizeof (struct list));\r\n	if (*sp){\r\n	(*sp)->head = NULL;\r\n	(*sp)->tail = NULL;\r\n	}\r\n}\r\n\r\nvoid *head (List *sp)\r\n{\r\n	if (sp->head)\r\n		return sp->head->data;\r\n	else\r\n		return NULL;\r\n}\r\nvoid PopList(List *sp)\r\n{\r\n	struct list *p;\r\n	if (sp == NULL)\r\n		return;\r\n	p=sp->head;\r\n	sp->head = sp->head->next;\r\n	free(p);\r\n}\r\nvoid PushList (void *data1, int type1, List *sp)\r\n{\r\n	struct list *p;\r\n	p = (struct list *) malloc (sizeof (struct list));\r\n	if (p!=NULL)\r\n	{\r\n		if (sp->head != NULL)\r\n		{\r\n			p->data = data1;\r\n			p->type = type1;\r\n			p->next = NULL;\r\n			sp->tail->next = p;\r\n			sp->tail = p;\r\n		}\r\n		else \r\n		{\r\n			p->data = data1;\r\n			p->type = type1;\r\n			p->next = NULL;\r\n			sp->head = p;\r\n			sp->tail = sp->head;\r\n		}\r\n	}\r\n}\r\n// ???????? ??????? ??????\r\nint EmptyList (List *sp)\r\n{\r\n	return (sp->head == NULL);\r\n}\r\n// ???????? ?????\r\nvoid ListDel (List *sp)\r\n{\r\n	if (sp == NULL)\r\n		return;\r\n	while (!EmptyList(sp))\r\n	{\r\n		PopList(sp);\r\n	}\r\n	free (sp);\r\n}\r\nint ListLength (List *sp)\r\n{\r\n	int i = 0;\r\n	struct list *p;\r\n	if (sp == NULL)\r\n		return 0;\r\n	for (p=sp->head; p; p=p->next)\r\n		i++;\r\n	return i;\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (237,'#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include \"functions.h\"\r\n#include \"list.h\"\r\n#include \"stack.h\"\r\n#include \"vars.h\"\r\n\r\nint main ()\r\n{\r\n	Stack *st;\r\n	struct item *q;\r\n	struct list *p;\r\n	StackCreate (&st);\r\n	TableCreate();\r\n	do\r\n	{\r\n		List* polishform = PolishNotation(ScanInput());\r\n		while (!EmptyList (polishform))\r\n		{\r\n			p = polishform->head;\r\n			if (p->type == 1)\r\n			{\r\n				PushStack(p->data,p->type, st);\r\n				PopList (polishform);\r\n			}\r\n			else if (p->type == 2)\r\n			{\r\n				PushStack(p->data,p->type, st);\r\n				PopList (polishform);\r\n			}\r\n			else if (p->type == 3)\r\n			{\r\n				if (*(char*)p->data == \'=\')\r\n				{\r\n					q = st->top;\r\n					if (q->type == 1)\r\n						SetValue((char*)q->next->data, GetValue((char*)q->data));\r\n					else SetValue((char*)q->next->data, *(int*)q->data);\r\n					free (p->data);//////////////////////////\r\n					PopList (polishform);\r\n					free (q->data);//////////////////////////\r\n					PopStack (st);\r\n					free(st->top->data);/////////////////////\r\n					PopStack (st);\r\n				}\r\n				else\r\n				{\r\n					int *k;\r\n					int val=0;\r\n					q=st->top;\r\n					if (*(char*)p->data == \'+\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val += GetValue((char*)q->data);\r\n						else\r\n							val += *(int*)q->data;\r\n\r\n					}	\r\n					else if (*(char*)p->data == \'-\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val -= GetValue((char*)q->data);\r\n						else\r\n							val -= *(int*)q->data;\r\n					}	\r\n					else if (*(char*)p->data == \'*\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val *= GetValue((char*)q->data);\r\n						else\r\n							val *= *(int*)q->data;\r\n					}	\r\n					else if (*(char*)p->data == \'/\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val /= GetValue((char*)q->data);\r\n						else\r\n							val /= *(int*)q->data;\r\n					}\r\n					free (q->data);////////////\r\n					free (q->next->data);///////////\r\n					PopStack (st);\r\n					PopStack (st);\r\n					k = malloc (sizeof (int));\r\n					if (k){\r\n						*k = val;\r\n						PushStack (k, 2, st);\r\n					}\r\n					free (p->data);/////////////////////////\r\n					PopList (polishform);\r\n				}\r\n			}\r\n		}\r\n		while (!EmptyStack(st))\r\n		{\r\n			if  (st->top->type == 1)\r\n			{\r\n				printf (\"%d \\n\" , GetValue((char*)st->top->data));\r\n				free(st->top->data);///////////////////////////\r\n				PopStack(st);\r\n			}\r\n			else\r\n			{\r\n				printf (\"%d \\n\", *(int *)st->top->data);\r\n				free (st->top->data);//////////////////////////\r\n				PopStack (st);\r\n			}\r\n		}\r\n		ListDel (polishform);\r\n		MakenullStack (st);\r\n	}\r\n	while (ch!=EOF);\r\n	StackDel (st);\r\n	cleanup();\r\n	return 0;\r\n} \r\n\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (238,'#include \"stack.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// ????????? ?????\r\nvoid MakenullStack (Stack *st)\r\n{\r\n	struct item *p;\r\n	while (st->top)\r\n	{\r\n		p=st->top;\r\n		st->top = p->next;\r\n		free (p);\r\n	}\r\n}\r\n// ???????? ?????\r\nvoid StackCreate (Stack **st)\r\n{\r\n	*st = malloc (sizeof (struct item));\r\n	if (*st)\r\n	(*st)->top = NULL;\r\n}\r\n\r\n//  ????????? ???????? ?????????? ???????? ?????\r\nvoid *top (Stack *st)\r\n{\r\n	if (st->top)\r\n		return st->top->data;\r\n	else\r\n		return NULL;\r\n}\r\n// ???????? ?????????? ???????? ?? ?????\r\nvoid PopStack(Stack *st)\r\n{\r\n	struct item *p;\r\n	if (st->top == NULL)\r\n		return;\r\n	p=st->top;\r\n	st->top = p->next;\r\n 	if (p!=NULL)\r\n	{\r\n		free (p);\r\n	}\r\n}\r\n// ?????????? ???????? ? ????? ?????\r\nvoid PushStack (void *data1, int type1, Stack *st)\r\n{\r\n	struct item *p;\r\n	p = malloc (sizeof (struct item));\r\n	if (p)\r\n	{\r\n		p->data = data1;\r\n		p->type = type1;\r\n		p->next = st->top;\r\n		st->top = p;\r\n	}\r\n}\r\n// ???????? ??????? ?????\r\nint EmptyStack (Stack *st)\r\n{\r\n	return (st->top == NULL);\r\n}\r\n// ???????? ?????\r\nvoid StackDel (Stack *st)\r\n{\r\n	if (st == NULL)\r\n		return;\r\n	while (!EmptyStack(st))\r\n		PopStack(st);\r\n	free (st);\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (239,'#include \"vars.h\"\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct table *Table[128];\r\n\r\nunsigned int hash (char *str)\r\n{\r\n	unsigned char *p;\r\n	unsigned int res = 0;\r\n	for (p=(unsigned char *)str; *p!=0; p++)\r\n		res = (res * 37 + (*p));\r\n	return res%128;\r\n}\r\nvoid TableCreate (void)\r\n{\r\n	int i;\r\n	for (i=0; i<128; i++)\r\n		Table[i] = NULL;\r\n}\r\nvoid SetValue (char *string, int value)\r\n{\r\n	int length;\r\n	struct table *p;\r\n	unsigned int i = hash (string);\r\n	p = Table[i];\r\n	while (p)\r\n	{\r\n		if (!strcmp (p->name, string))\r\n		{\r\n			p->value = value;\r\n			return;\r\n		}\r\n		p = p->next;\r\n	}\r\n	p = malloc (sizeof (struct table));\r\n	if (p){\r\n	p->next = Table[i];\r\n	Table[i] = p;\r\n	p->value = value;\r\n	p->name = malloc (sizeof(char)*(length = strlen(string)+1));\r\n	if (p->name){\r\n	memcpy (p->name, string , length*sizeof (char));\r\n	}\r\n	}\r\n}\r\nint GetValue (char *name)\r\n{\r\n	struct table *p;\r\n	unsigned int i = hash (name);\r\n	p = Table[i];\r\n	while (p)\r\n	{\r\n		if (!strcmp (p->name, name))\r\n			return p->value;\r\n		p = p->next;\r\n	}\r\n	return 0;\r\n}\r\nvoid cleanup (void)\r\n{\r\n	struct table *p;\r\n	int i;\r\n	for (i=0;i<128;i++)\r\n	{\r\n		p = Table[i];\r\n		while (p)\r\n		{\r\n			Table[i] = Table[i]->next;\r\n			free (p->name);\r\n			free (p);\r\n			p = Table[i];\r\n		}\r\n	}\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (240,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define N 20\n\n	void Dijkstr (int start, int n, int A[N][N], int D[N])\n	{\n	 int  used[N] = {0}; //?????????????? ???????\n 	  //?????? ?????????? ??  start\n	 int k;   // ??????? ???????\n	 int i, j;\n	  //??????? ?????????? ?????\n\n	 for (i = 0; i < N; i++)\n	 	D[i] = 1000;\n	 D[start] = 0;\n\n	 for ( ; ; )\n	 {\n	 // ???????? ? ???????? ??????? ??????? ? ??????????? ????????? ?? D, ???? ??? ?????????? - ?????\n	   k = -1;\n	   for (i = 1; i <= n; i++)\n	   {\n	    if (used[i] == 0 && (k == -1 || D[i] < D[k])) \n	    {\n	     k = i;\n	    }\n	   }\n	   \n	   if (k == -1)\n	   break;\n\n	   used[k] = 1;\n\n	   for (i = 1; i <= n; i++)\n	   {\n	    if (D[i] > D[k] + A[k][i])\n	    {\n	       D[i] = D[k] + A[k][i];\n	       printf(\"D[%d] = %d (????? %d)\\n\", i, D[i], k);\n	    }\n	   }\n\n	 }\n	}\n\n\n	int main()\n	{\n	 int i, j;\n	 int x;\n	 int A[N][N];\n	 int used[N];\n	 int D[N];\n	 FILE*f = fopen (\"input.txt\", \"r\");\n	 if (!f)\n	 {\n	  perror (\"fopen\");\n	 }\n\n	 for (i = 1; i <= N; i++)\n	 {\n	  for (j = 1; j <= N; j++)\n	  {\n	   A[i][j] = 1000;\n	  }\n	   A[i][i] = 0;\n	 }\n\n	int n = 0; // ???????? ?????????? ??????\n\n	 while (fscanf(f, \"%d%d%d\", &i, &j, &x) == 3)\n	 {\n	  printf(\"i, j, x: %d %d %d\\n\", i, j, x);\n	  A[i][j] = x;\n	  A[j][i] = x;\n	  if (i > n) n = i;\n	  if (j > n) n = j;\n	 }\n\n	printf(\"n: %d\\n\", n);\n\n	 Dijkstr (1, n, A, D);\n	 for (i = 1; i <= n; i++)\n	  printf (\"%d \", D[i]);\n	 printf(\"\\n\");\n	}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (241,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\nFILE *f;\nint i,j,l,k;\nchar st[15],s[255];\nscanf (\"%s\",st);\nl=strlen(st);\nf=fopen(\"/etc/passwd\",\"r\");\nwhile (fgets(s,255,f))\n{\n	j=1;\n	for (i=0;i<l;i++)\n	if (s[i]!=st[i]) j=0;\n	if (s[l]!=\':\') j=0;\n	if (j==1)\n	{\n		fclose(f);\n		i=0;\n		for (k=0;k!=4;)\n		{\n			if (s[i]==\':\') k++;\n			i++;\n		}\n		for (;(s[i]!=\':\')&&(s[i]!=\',\');i++)\n		printf (\"%c\",s[i]);\n		printf(\"\\n\");\n		return 0;\n	}\n}\nprintf (\"?? ??????\");\nprintf(\"\\n\");\nreturn 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (242,'#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#define n 11\r\n\r\nint main()\r\n{\r\n	struct item \r\n	{\r\n		char word[n];\r\n		int count;\r\n		struct item *next;\r\n	};\r\n	FILE *f=fopen(\"input14.txt\",\"r\");\r\n	FILE *g=fopen(\"output.txt\",\"w\");\r\n	struct item* p=malloc(sizeof(struct item));\r\n	struct item* head=NULL;\r\n	struct item* q;\r\n	struct item* k=NULL;\r\n	int i=0;\r\n	char c;\r\n	while(fscanf(f,\"%c\", &c)==1)		\r\n	{\r\n		if(((c<\'a\')||(c>\'z\'))&&(i>0))\r\n		{\r\n			p->word[i]=0;\r\n			if(head)\r\n			{\r\n				for(q=head;q;q=q->next)\r\n				{\r\n					if(strcmp(p->word,q->word)==0)\r\n					{\r\n						q->count++;			\r\n						free(p);\r\n						break;\r\n					}\r\n					k=q;\r\n				}\r\n				if(!q)\r\n				{\r\n					printf(\"????? ?????: %s\\n\", p->word);\r\n					p->count=1;\r\n					k->next=p;\r\n					p->next=NULL;\r\n				}\r\n			}\r\n			else\r\n			{\r\n				head=p;\r\n				printf(\"????? ?????: %s\\n\", p->word);\r\n				head->count=1;\r\n				head->next=NULL;\r\n			}\r\n			p=malloc(sizeof(struct item));\r\n			i=0;\r\n		}		\r\n		else\r\n		{\r\n			if((i<n)&&((c>=\'a\')&&(c<=\'z\')))\r\n			{\r\n				p->word[i]=c;\r\n				i++;\r\n			}\r\n			if(i>=n)\r\n			{\r\n				fprintf(g,\"????? ?? ??????? ??????? \\n\");\r\n				return;\r\n			}\r\n		}\r\n	}\r\n	if(i>0)\r\n	{\r\n		p->word[i]=0;\r\n		for(q=head;q;q=q->next)\r\n		{\r\n			if(strcmp(p->word,q->word)==0)\r\n			{\r\n				q->count++;			\r\n				free(p);\r\n				break;\r\n			}\r\n			k=q;\r\n		}\r\n		if(!q)\r\n		{\r\n			printf(\"????? ?????: %s\\n\", p->word);\r\n			p->count=1;\r\n			k->next=p;\r\n			p->next=NULL;\r\n		}\r\n	}\r\n	\r\n	if (!head)\r\n	{\r\n		fprintf(g,\"?????\");\r\n		return;\r\n	}\r\n	while(head)\r\n	{\r\n		fprintf(g,\"????? %s ??????????? %d ???\\n\",head->word,head->count);\r\n		p = head->next;\r\n		free(head);\r\n		head = p;\r\n	}\r\n	fclose(f);\r\n	fclose(g);\r\n	return 0;\r\n}\r\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (243,'#include <stdio.h>\r\n#define n 8\r\n#define k 4\r\n#define m 100000\r\n\r\nint main()\r\n{\r\n	FILE*f=fopen(\"input15.txt\",\"r\");\r\n	FILE*g=fopen(\"output.txt\",\"w\");\r\n	int from[n];\r\n	int to[n];\r\n	int v[k][k];\r\n	int d[k];\r\n	int visited[k];\r\n	int ma[k][k];\r\n	int i,j,max=0,l, min=m;\r\n	for(i=0;i<k;i++)\r\n	{\r\n		for(j=0;j<k;j++)\r\n			v[i][j]=m;\r\n		d[i]=m;\r\n		visited[i]=0;\r\n	}\r\n	for(i=0;i<n;i++)\r\n	{\r\n		fscanf(f,\"%d %d\",&from[i],&to[i]);\r\n		fscanf(f,\"%d\",&v[from[i]][to[i]]);\r\n	}\r\n	for(i=0;i<k;i++)\r\n	{\r\n		d[i]=0;\r\n		for(l=0;l<k;l++)\r\n		{\r\n			min=k-i-1;\r\n			for(j=0;j<k;j++)\r\n				if((visited[j]!=1)&&(d[min]>d[j])) \r\n					min=j;	\r\n			visited[min]=1;\r\n			for(j=0;j<k;j++)\r\n				if((visited[j]!=1)&&(d[j]>d[min]+v[min][j])) \r\n					d[j]=d[min]+v[min][j];\r\n		}\r\n		printf(\"from %d: \", i);\r\n		for(j=0;j<k;j++)\r\n		{\r\n			ma[i][j]=d[j];\r\n			printf(\"%d \", d[j]);\r\n			d[j]=m;\r\n			visited[j]=0;\r\n		}\r\n		printf(\"\\n\");\r\n		\r\n	}\r\n	max = 0;\r\n	for(i=0;i<k;i++)\r\n	{\r\n		for(j=0;j<k;j++)\r\n			if (ma[i][j] > max)\r\n				max = ma[i][j];\r\n	}\r\n	fprintf(g,\"%d\",max);\r\n	fclose(f);\r\n	fclose(g);\r\n	return 0;\r\n}\r\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (244,'#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nint main ()\n{\n	FILE *f=fopen(\"input14.txt\",\"r\");\n	int i,j=0;\n	char c,z[11];\n	struct item *head,*p,*r,*q;\n	for (;c!=EOF;)\n	{\n		c=fgetc(f);\n		for (;!(((c>=\'a\')&&(c<=\'z\'))||((c>=\'A\')&&(c<=\'Z\')))&&(c!=EOF);)\n			c=fgetc(f);\n		if (c==EOF)\n			break;\n		i=0;\n		z[i]=c;\n		i++;\n		for (;(((c>=\'a\')&&(c<=\'z\'))||((c>=\'A\')&&(c<=\'Z\')))&&(c!=EOF);)\n		{\n			c=fgetc(f);\n			z[i++]=c;\n		}\n		z[i-1]=0;\n		if (j==0)\n		{\n			r=malloc(sizeof(struct item));\n			head=r;\n			r->count=1;\n			r->next=0;\n			strcpy(r->word,z);\n			j++;\n		}\n		else\n		{\n			q=head;\n			for (p=head;(p)&&(strcmp(z,p->word));p=p->next)\n				q=p;\n			if (p==0)\n			{\n				r=malloc(sizeof(struct item));\n				r->count=1;\n				r->next=0;\n				strcpy(r->word,z);\n				q->next=r;\n			}\n			else\n			{\n				p->count++;\n			}\n		}\n	}\n	f=fopen(\"output14.txt\",\"w\");\n	for (p=head;p;p=p->next)\n		fprintf(f,\"%s %d\\n\",p->word,p->count);\n\n	// ?????????? ?????????? ??????\n	while (head)\n	{\n		p=head;\n		head=head->next;\n		free(p);\n	}\nreturn 0;\n} \n \n\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (245,'#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nint main ()\n	// ?????????? ?????????? ??????\n	while (head)\n	{\n		p=head;\n		head=head->next;\n		free(p);\n	}\nreturn 0;\n} \n \n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (246,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\nFILE *f;\nint a,b,c,d;\nchar S[10],A[100];\nf=fopen(\"/etc/passwd\",\"r\");\nscanf (\"%s\",S);\nc=strlen(S);\n//f=fopen(\"/etc/passwd\",\"r\");\nfor (;fgets(A,100,f);b=1)\n{\n	a=0;\n	while (a<c)\n	{\n		a++;\n		if (A[a]!=S[a]) \n			b=0;\n	}\n	if (A[c]!=\':\') \n		b=0;\n	if (b!=0)\n	{\n		//fclose(f);\n		a=0;\n		d=0;\n		while (d!=4)\n		{\n			if (A[a]==\':\') \n				d++;\n			a++;\n		}\n		while ((A[a]!=\':\')&&(A[a]!=\',\'))\n\n		{\n			a++;\n			printf (\"%c\",A[a]);\n		}\n		printf(\"\\n\");\n		//return 0;\n	}\n}\nprintf (\"?? ??????\\n\");\n//printf(\"\\n\");\n//return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (247,'#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nint main ()\n	// ?????????? ?????????? ??????\n	while (head)\n	{\n		p=head;\n		head=head->next;\n		free(p);\n	}\nreturn 0;\n} \n \n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (248,'#include <stdio.h>\n#include <string.h>\n#define N 100000\n\nvoid quicksort (int *A, int left, int right)\n{	int x=A[(left+right)/2];\n	int j=right;\n	int i=left;\n	int d;\nwhile (i<=j) \n	{	if ((A[i]<=x) && (A[j]>=x)) {i++; j--;}\n		if ((A[i]>=x) && (A[j]<=x) && (i<=j))\n		{	d = A[j];\n	 		A[j] = A[i];\n	 		A[i] = d;\n		}\n		if((A[i]>=x) && (A[j]>=x))\n			j--;\n		else if ((A[i] <= x) && (A[j] <= x))\n			i++;		\n		}\n																												     \n\n\n\nif (left < j) quicksort(A,left,j);\n\nif (i < right) quicksort(A,i,right);\nreturn;\n}\nint main()\n{\nint B[N]={0};\nint i,a;\nFILE *f = fopen (\"input_big.txt\", \"r\");\nfscanf(f,\"%d\",&a);\nfor (i=0;i<a;i++)\nfscanf(f,\"%d\", &B[i]);\nfclose(f);\nquicksort (B,0,a-1);\nfor (i=0;i<a;i++)\nprintf (\"%d \",B[i]);\nreturn (0);\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (249,'#include<stdio.h>\n#include<malloc.h>\n\n// A[i] >= A[2*i], A[2*i+1]\n\nvoid sift(int *A, int M, int k)\n{\n	int newItem=A[k];\n	int index;\n	while(k <= M/2)\n	{\n		index=2*k;\n		if (index < M && A[index] < A[index+1]) index++; // search max item\n		if (newItem >= A[index]) break;                  // compare\n		A[k] = A[index];                                 // move max item up\n		k = index;                                       // prepare for rebuild\n	}\n	A[k] = newItem;\n}\n\nint main()\n{\n		FILE *f=fopen(\"input.txt\",\"r\");\n		int N,P;\n		fscanf(f,\"%d\\n\",&N);\n		int *T;\n		int tmp;\n		int i=0,y,x;\n		T=(int*) malloc(N*sizeof(int));\n		while(fscanf(f,\"%d\",&T[i])==1)\n		i++;\n		x=N;\n	for (i = N/2 - 1; i >= 0; i--) sift(T, N-1, i); //build\n	for (i =N - 1; i > 0; i--)\n	{\n		tmp=T[i];\n		T[i] = T[0];\n		T[0] = tmp; // swap\n		sift(T, i - 1, 0);	// rebuild\n	}\n	FILE *o=fopen(\"output.txt\",\"w\");\n	for(i=0;i<x;i++)\n	fprintf(o,\"%d \",T[i]);\n	fclose(o);\n	fclose(f);\n	free(T);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (250,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nvoid getstring(char *s, char *l,FILE*g)\n{\nint i=0;\nint j=0;\nint a,k;\nint p=1;\na = strlen(l);\n//FILE*g=fopen(\"/etc/passwd\",\"r\");\nwhile(s[i]!=0)\n{\n	if(s[i]==\':\')\n		j++;\n	if(j==4) break;\n	else i++;\n}\n//scanf(\"%s\",l);\n//a=strlen(l);\nfor(k=0;k<a;k++)\n	if (s[k]!=l[k])\n		return;\nif (s[a] != \':\')\n	return;\n//fclose(f);\nwhile(s[p+i]!=\',\')\n{\nprintf(\"%c\",s[p+i]);\np++;\n}\n}			\nint main()\n{\nchar l[20];\nchar s[100];\nscanf(\"%s\",l);\nFILE*g=fopen(\"/etc/passwd\",\"r\");\nwhile(fgets(s,100,g))\n{\n//FILE*g=fopen(\"/etc/passwd\",\"r\");\ngetstring(s, l, g);\n//fclose(g);\n}\nfclose(g);\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (251,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n	struct item\r\n	{\r\n		int data;\r\n		struct item * next;\r\n	};\r\n	int c;\r\n	struct item *head;\r\n	struct item *p;\r\n	struct item *q=NULL;\r\n	struct item *k;\r\n	FILE* f=fopen(\"input.txt\",\"r\");\r\n	FILE* g=fopen(\"output.txt\",\"w\");\r\n	if(fscanf(f,\"%d\", &c)==1)\r\n	{\r\n		head=malloc(sizeof(struct item));\r\n		head->data=c;\r\n		head->next=NULL;\r\n	}\r\n	else\r\n		{\r\n		fprintf(g,\"?????\");\r\n		return 0;\r\n		}\r\n	while (fscanf(f,\"%d\", &c)==1)\r\n	{\r\n		k=malloc(sizeof(struct item));\r\n		k->data=c;\r\n		k->next=NULL;\r\n		for(p=head;p!=NULL;p=p->next)\r\n		{\r\n			if(c<(p->data))\r\n				break;\r\n			q=p;\r\n		}\r\n		if(!q)\r\n		{\r\n			q=head;\r\n			head=k;\r\n			k->next=q;\r\n		}\r\n		// ? ???? q == NULL?\r\n		else \r\n		{	\r\n			q->next=k;\r\n			k->next=p;\r\n		}\r\n		q=NULL;\r\n	}\r\n	while(head)\r\n		{\r\n		fprintf(g, \"%d \", head->data);\r\n		head=head->next;\r\n		}\r\n	fclose(f);\r\n	fclose(g);\r\n	return 0;\r\n}\r\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (252,'#include <stdlib.h>\r\n#include <string.h>\r\n#include \"huffman.h\"\r\n#include <stdlib.h>\r\n#define SIZE 256\r\n\r\nstruct Tree{\r\n        int child0, child1;\r\n        int used;\r\n        int leaf;\r\n        int ch;\r\n        int w;\r\n};\r\n\r\nstruct Code{\r\n        int code[256];\r\n};\r\nstruct Tree trees[512];\r\nstruct Code codes[SIZE];\r\nint w[SIZE];\r\n\r\nint getlowesttree(void){\r\n        int i, min = 2147483647, result = 0;\r\n        for(i = 0; i < 512; i++)\r\n\r\n                if(!trees[i].used && trees[i].w && trees[i].w < min){\r\n                        min = trees[i].w;\r\n                        result = i;\r\n                }\r\n\r\n        return(result);\r\n}\r\n\r\nvoid gencodes(int tree, int what, struct Code code, int a){\r\n        struct Code code1;\r\n        if(what) code.code[a] = what;\r\n        if(trees[tree].leaf){\r\n                memcpy(codes[tree].code, code.code, 255);\r\n                return;\r\n        }\r\n        memcpy(code1.code, code.code, 255);\r\n        gencodes(trees[tree].child0, 1, code, a+1);\r\n        gencodes(trees[tree].child1, 2, code1, a+1);\r\n        return;\r\n}\r\n\r\nint readweights(FILE *fn){\r\n        unsigned char c;\r\n        int k=0;\r\n        while(fread(&c, 1, 1, fn)){\r\n                w[c]++;\r\n                k=1;\r\n        }\r\n        return k;\r\n}\r\n\r\nint growtree(){\r\n        int i, sizetr = 255, count = -1;\r\n        struct  Code ttt;\r\n        for(i = 0; i < 256; i++){\r\n                trees[i].w = w[i];\r\n                trees[i].leaf = 1;\r\n                trees[i].ch = i;\r\n                if(trees[i].w) count++;\r\n        }\r\n        if(!count) count++;\r\n        while(count){\r\n                int b, a = getlowesttree();\r\n                trees[a].used = 1;\r\n                b = getlowesttree();\r\n                trees[b].used = 1;\r\n                trees[++sizetr].child0 = a;\r\n                trees[sizetr].child1 = b;\r\n                trees[sizetr].w = trees[a].w + trees[b].w;\r\n                trees[sizetr].leaf = 0;\r\n                count--;\r\n        }\r\n        memset(ttt.code, 0, 255);\r\n        gencodes(sizetr, 0, ttt, -1);\r\n        return(sizetr);\r\n}\r\n\r\nunsigned char bit; int curbit;\r\n\r\nvoid writebit(int flush, int bitt, FILE *fn){\r\n        if(flush){\r\n                fwrite(&bit, 1, 1, fn);\r\n//              printf(\"%i\\n\", bit);\r\n                return;\r\n        }\r\n        (bitt - 1) ? (bit |= (1 << curbit)) : (bit &= ~(1 << curbit));\r\n        curbit++;\r\n//      printf(\"%i : %i\\n\", bitt - 1, bit);\r\n        if(curbit == 8){\r\n                fwrite(&bit, 1, 1, fn);\r\n//              printf(\"%i\\n\", bit);\r\n                curbit = 0;\r\n                bit = 0;\r\n        }\r\n}\r\n\r\nvoid coder(char* inname, char* outname){\r\n        FILE *out = fopen(outname, \"w\");\r\n        FILE *in = fopen(inname,\"r\");\r\n        unsigned char c;\r\n        int i, length = 0, m;\r\n        m = readweights(in);\r\n        if (m)\r\n        {\r\n        growtree();\r\n        rewind(in);\r\n        fwrite(w, sizeof(int), 256, out);\r\n        for(i = 0; i < 256; i++) length += w[i];\r\n        fwrite(&length, sizeof(int), 1, out);\r\n        while(fread(&c, 1, 1, in)){\r\n                int a = 0;\r\n                while(codes[c].code[a])\r\n                        writebit(0, codes[c].code[a++], out);\r\n        }\r\n        writebit(1, 0, out);\r\n        }\r\n        printf(\"The End\\n\");\r\n        fclose(out);\r\n        fclose(in);\r\n}\r\n\r\nint ib = 8;\r\nunsigned char cb;\r\n\r\nchar getnextbit(FILE *in){\r\n        if(ib == 8){\r\n                if( !fread(&cb, 1, 1, in) ) return(-1);\r\n//              printf(\"%i\\n\", cb);\r\n                ib = 0;\r\n        }\r\n        return( (cb >> ib++) & 1 );\r\n}\r\n\r\nvoid decoder(char* inname, char* outname){\r\n        FILE *in = fopen(inname, \"r\");\r\n        FILE *out = fopen(outname, \"w\");\r\n        char c;\r\n        int length, m;\r\n        int root;\r\n        m = fread(w, sizeof(int), 256, in);\r\n        if (m)\r\n        {\r\n        fread(&length, sizeof(int), 1, in);\r\n        root = growtree();\r\n        while( (c = getnextbit(in) ) != -1 && length){\r\n                int tree = root;\r\n                while(1){\r\n                        (c) ? (tree = trees[tree].child1) : (tree = trees[tree].child0);\r\n                        if(trees[tree].leaf) break; else c = getnextbit(in);\r\n                }\r\n                length--;\r\n                fwrite(&trees[tree].ch, 1, 1, out);\r\n        }\r\n        }\r\n        printf(\"The End\\n\");\r\n        fclose(in);\r\n        fclose(out);\r\n        return;\r\n}\r\n','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (253,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"huffman.h\"\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n        if (argc < 4)\r\n                {\r\n                        printf (\"ERROR\\n\");\r\n                        return 0;\r\n                }\r\n                if (argc > 4)\r\n                {\r\n                        printf (\"ERROR\\n\");\r\n                        return 0;\r\n                }\r\n        if (argv[1][1] == \'a\')\r\n        {\r\n                coder (argv[2],argv[3]);\r\n                return 0;\r\n        }\r\n        if (argv[1][1] == \'d\')\r\n        {\r\n                decoder (argv[2],argv[3]);\r\n                return 0;\r\n        }\r\n        printf (\"ERROR\\n\");\r\n        return 0;\r\n}\r\n\r\n','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (254,'#include <stdio.h>\n#include <malloc.h>\n\nmain()\n{\n	struct item\n	{\n		int data;\n		struct item *next;\n	};\n\n	struct item *head = 0;\n	struct item *var;\n	struct item *cur;\n	struct item *pre;\n\n	FILE *f = fopen(\"inpet3.txt\",\"r\");\n	int a;\n\n	fscanf(f, \"%d\", &a);\n	head = malloc(sizeof(struct item));\n	head->data = a;\n	head->next = 0;\n	\n	while(fscanf(f, \"%d\", &a) == 1)\n	{\n		var = malloc(sizeof(struct item));\n		var->data = a;\n		var->next = 0;\n		cur = head;\n		pre = 0;\n		while (cur->data <= a && cur->next)\n		{\n			pre = cur;\n			cur = cur->next;\n		}\n		if (cur->next)      // insert in the midle\n		{\n			if (pre)    // is the header\n				pre->next = var;     // No\n			else\n				head = var;          // Yes\n				var->next = cur;\n		}\n		else                               // insert in the end\n		{\n			if (cur->data > a)\n			{\n				if (pre)          // is the header\n					pre->next = var;     //      no\n				else\n					head = var;            //    yes\n				var->next = cur;\n			}		\n			else\n				cur->next = var;\n		}\n	}\n\n	fclose(f);\n	FILE *ff = fopen(\"output.txt\",\"w\");\n	cur = head;\n	while (cur->next)\n	{\n		fprintf(ff,\"%d \",cur->data);\n		cur = cur->next;\n	}\n	fprintf(ff,\"%d \",cur->data);\n	fclose(ff);\n	pre=head;\n	cur=head->next;\n	while(cur)\n	{\n		free(pre);\n		pre=cur;\n		cur=cur->next;\n\n	}\n	free(pre);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (255,'#include <stdio.h>\n#include <malloc.h>\n#include <ctype.h>\n#include <string.h>\n\n\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nmain()\n{\n	struct item *head = 0;\n	struct item *var = 0;\n	struct item *cur = 0;\n	char ch;\n	int counter=0;\n	FILE *f = fopen(\"input.txt\",\"r\");\n	while(1)\n	{\n		while(ch != EOF && counter < 10) // read word\n		{\n			ch = fgetc(f);\n			if (ch == EOF || !isalpha(ch)) break;\n				if (counter) var->word[counter] = ch;\n				else\n				{\n					var = malloc(sizeof(struct item));\n					memset(var->word,0,11);\n					var->word[0] = ch;\n					var->count = 1;\n					var->next = 0;\n				}\n				counter++;\n		}\n		counter = 0;\n		if (!head)\n		{\n			if (var) head = var;\n		}\n		else\n		if(var) //count(head, var); calculate\n		{\n			cur = head;\n			while(cur->next)\n			{\n				if (strcmp(cur->word,var->word)==0)\n				{\n					cur->count++;\n					free(var);\n					var=0;\n					break;\n				}\n				cur = cur->next;\n			}\n			if (var)\n			{\n				if (strcmp(cur->word,var->word)==0)\n				{\n					cur->count++;\n					free(var);\n					var=0;\n				}\n				cur->next = var;\n			}\n		}\n		if (ch == EOF) break;\n	}\n	fclose(f);\n	FILE *ff = fopen(\"output.txt\",\"w\");\n	cur = head;\n	if (cur)\n	{\n		while (cur->next)\n		{\n			fprintf(ff,\"\\n%s\\t\\t%d \",cur->word, cur->count);\n			var = cur;\n			cur = cur->next;\n			free(var);             // free mem\n		}\n		fprintf(ff,\"\\n%s\\t\\t%d \",cur->word, cur->count);\n		free(cur);\n	}\n	else\n	fprintf(ff,\"\\nEmpty input.txt\");\n	fclose(ff);\n	return(0);\n}\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (256,'#include<stdio.h>\n#include<malloc.h>\nvoid f(int curr,int start,int len,int visited1[100],int path[100],int N1, int A1[100][100])\n{\n	int i;\n	int k=1;\n	int m=0;\n	visited1[curr]=1;\n	path[len] = curr;\n	if (len == N1 - 1 && A1[curr][1])\n	{\n		printf(\"found\\n\");\n		for (i = 0; i <= len; i++)\n		{\n			printf(\"%d \", path[i]);\n		}\n		printf(\"\\n\");\n		return;\n	}\n	for(i=1;i<=N1;i++)\n	{\n		if(!visited1[i]&&A1[curr][i])\n			f(i,start,len+1,visited1,path,N1,A1);\n	}\n	visited1[curr]=0;\n}\n\nint main()\n{\n	FILE *g=fopen(\"input.txt\",\"r\");\n	int A[100][100]={0};\n	int visited[100]={0};\n	int path[100] = {0};\n	int a,b;\n	int d=0;\n	while ((fscanf(g,\"%d%d\",&a, &b)==2))\n	{\n		A[a][b]=1;\n		A[b][a]=1;\n		if(a>b)\n			b=a;\n		if(b>d)\n			d=b;\n	}\n	f(1,0,0,visited,path,d,A);\n	return(0);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (257,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct node\n {\n  int number;\n  int isTested;\n  int conCount;\n  struct node *con[100];\n };\n\nint test(struct node *var, struct node *head, int *counter, int *nodes, int nodeCount)\n{\n int nodeCur=0;\n  while(nodeCur < var->conCount)\n  {\n   if (var->con[nodeCur]->isTested==0 && var->con[nodeCur]->conCount > 1)\n   {\n	nodes[(*counter)++] = var->number;\n	var->isTested = 1;\n	if (test(var->con[nodeCur], head, counter, nodes, nodeCount))\n	{\n	return(1);\n	}\n	else\n	{\n	 var->isTested = 0;\n	 nodes[(*counter)--] = 0;\n	}\n   }\n   if (var->con[nodeCur] == head && *counter == (nodeCount-1))\n   {\n	nodes[(*counter)++] = var->number;\n	return (1);\n   }\n   nodeCur++;\n  }\n\n  return (0);\n\n}\n\n\nmain()\n{\n\n int nodesize = sizeof(node);\n\n struct node *nodeArray[100];\n struct node *varA;\n struct node *varB;\n struct node *isA;\n struct node *isB;\n\n FILE *f = fopen(\"input.txt\",\"r\");\n\n int a,b;\n int retVal=1;\n int nodeCount=0;\n int nodeCur=0;\n\n // spisok init\n\nwhile(nodeCount < 100)\n {\n retVal=fscanf(f, \"%d\", &a);\n if (retVal <= 0 || retVal == EOF) break;\n retVal=fscanf(f, \"%d\", &b);\n if (retVal <= 0 || retVal == EOF) break;\n\n isA = 0;\n isB = 0;\n nodeCur = 0;\n while(nodeCur < nodeCount && (isA == 0 || isB == 0))\n {if(nodeArray[nodeCur]->number == a && isA == 0) isA = nodeArray[nodeCur];\n  if(nodeArray[nodeCur]->number == b && isB == 0) isB = nodeArray[nodeCur];\n  nodeCur++;\n }\n if ( isA ) varA = isA;\n else\n {\n  varA = (node*) malloc(nodesize);\n  varA -> number = a;\n  varA -> conCount = 0;\n  varA -> isTested = 0;\n  nodeArray[nodeCount++]=varA;\n }\n if ( isB ) varB = isB;\n else\n {\n  varB = (node*) malloc(nodesize);\n  varB -> number = b;\n  varB -> conCount = 0;\n  varB -> isTested = 0;\n  nodeArray[nodeCount++]=varB;\n }\n varA->con[varA->conCount]=varB;\n varA->conCount++;\n varB->con[varB->conCount]=varA;\n varB->conCount++;\n }\n fclose(f);\n\n int nodes[100];\n int counter=0;\n int isEnd = 0;\n\n retVal = test(nodeArray[0], nodeArray[0], &counter, nodes, nodeCount);\n\n FILE *ff = fopen(\"output.txt\",\"w\");\n\n for (nodeCur = 0; nodeCur < nodeCount; nodeCur++)\n	{\n	 fprintf(ff,\"%d %d %d\\n\",nodeCur,nodeArray[nodeCur]->number,nodeArray[nodeCur]->conCount);\n	}\n for (nodeCur = 0; nodeCur < nodeCount; nodeCur++)\n	{\n	 fprintf(ff,\"%d %d\\n\",nodeCur,nodes[nodeCur]);\n	}\n if (/*counter == nodeCount*/ retVal ) fprintf(ff,\"Cicle is present\\n\");\n else fprintf(ff,\"Cicle is ebsent\\n\");\n fclose(ff);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (258,'#include <stdio.h>\n\nint N;\nint A[100][100];\nint visited[100];\n\nvoid dfs(int curr)\n{\n	int i;\n	visited[curr] = 1;\n	for (i = 0; i < N; i++)\n	{\n		if (!visited[i] && A[curr][i])\n			dfs(i);\n	}\n}\n\nint count_cc(void)\n{\n	int i, count;\n\n	count = 0;\n\n	for (i = 0; i < N; i++)\n		visited[i] = 0;\n\n	for (i = 0; i < N; i++)\n	{\n		if (!visited[i])\n		{\n			dfs(i);\n			count++;\n		}\n	}\n\n	return count;\n}\n\nint main()\n{\n	int curr;\n	int p,a, b, i,t,j;\n	//printf(\"%d\\n\", count);\n	int count = 0;\n	FILE *f = fopen(\"input.txt\", \"r\");\n	if (!f)\n	{\n		perror(\"fopen\");\n		return 0;\n	}\n\n	fscanf(f, \"%d\", &N);\n\n	while (fscanf(f, \"%d%d\", &a, &b) == 2)\n	{\n		A[a][b] = A[b][a] = 1;\n	}\nfor(i=0;i<N;i++)\n	for(j=0;j<i;j++)\n		if(A[i][j]==1)\n		{\n		t=count_cc();\n		printf(\"t: %d, \", t);\n		A[i][j]=0; A[j][i] = 0;\n		p=count_cc();\n		printf(\"p: %d\\n\", p);\n		if(t<p)\n			printf(\"???? ???? %d - %d\\n\", i, j);\n		A[i][j]=1;\n		A[j][i]=1;\n		}\n\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (259,'#include <stdio.h>\n#define N 9 \n\nvoid dfs( int A[N][N], int *visited, int curr)\n{\nint i;\nvisited[curr]=1;\nfor(i=1;i<=N;i++)\nif((visited[i]==0) && (A[curr][i]==1))\ndfs(A,visited,i);\nreturn;\n}\n\nint main()\n{\nint A[N][N]={{0},{0}};\nint visited[N]={0};\nint i,j,start;\nprintf(\"??????? ?????? ????????? ??????? \\n\");\nscanf (\"%d\",&start);\nprintf(\"??????? ?????, Ctrl+D ??? ??????????\\n\");\nwhile (scanf(\"%d%d\", &i, &j) == 2)\n{\n	A[i][j] = A[j][i] = 1;\n	printf(\"????????? ????? %d - %d\\n\", i, j);\n}\n/*for (i=1;i<=N;i++)\n{for (j=1;j<=N;j++)\n{printf(\"????????? A[%d][%d] ??????? ??????? ????????? \\n\", i, j);\n scanf (\"%d\",&A[i][j]);\n}\n}*/\ndfs (A, visited, start);\nfor (i=0;i<=N;i++)\nif(!visited[i])\nprintf(\"??????? %d ??????????? \\n\", i);\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (260,'#include <stdio.h>\nint min (int d[100],int n,int visited[100])\n{int m = -1;\nint i;\nfor (i = 1; i <= n; i++)\n{\n	if (!visited[i] && (m == -1 || d[i] < d[m]))\n		m = i;\n}\nreturn m;\n}\nint main()\n{\n	int n,i,j,s,a,u,v,S=1000;\n	int A[100][100]={0};\n	int d[100]={0};\n	int visited[100]={0};\n	FILE* f;\n	f=fopen(\"input15.txt\", \"r\");\n	fscanf(f, \"%d \", &n);\n	for (i = 0; i < 100; i++)\n	{\n		for (j = 0; j < 100; j++)\n		{\n			if (i != j)\n				A[i][j] = S;\n			else\n				A[i][j] = 0;\n		}\n	}\n	while(fscanf(f,\"%d %d %d \",&i, &j, &s) == 3)\n	{\n		A[i][j]=s;\n		A[j][i]=s;\n	}\n	for (a=1;a<=n;a++)\n	{\n		int visited[100]={0};\n		for (i=1;i<=n;i++)\n		{\n			if (i==a)\n				d[i]=0;\n			else	\n				d[i]=S;																\n		}													\n		for (i = 1; i <= n; i++)\n		{\n			v=min(d,n,visited);\n			if (v == -1) break;\n			visited[v]=1;\n			printf(\"curr: %d\\n\", v);\n			for (u=1;u<=n;u++)												\n			{\n				if(d[u]>d[v]+A[v][u])\n					{\n						d[u]=d[v]+A[v][u];\n						printf(\"d[%d] = %d\\n\", u, d[u]);\n					}\n			}\n		}\n\n		printf(\"?? %d: \", a);\n		for (i = 1; i <= n; i++)\n			printf(\"%d \", d[i]);\n		printf(\"\\n\");\n	}\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (261,'#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nint main ()\n{\n	FILE *f=fopen(\"input14.txt\",\"r\");\n	int j,d=0;\n	char s,z[11];\n	struct item *head,*a,*A,*b;\n	while (s!=EOF)\n	{\n		s=fgetc(f);\n		while (!(((s>=\'a\')&&(s<=\'z\'))||((s>=\'A\')&&(s<=\'Z\')))&&(s!=EOF))\n		s=fgetc(f);\n		if (s==EOF)\n		break;\n		j=0;\n		z[j]=s;\n		j++;\n		while ((((s>=\'a\')&&(s<=\'z\'))||((s>=\'A\')&&(s<=\'Z\')))&&(s!=EOF))\n		{\n			s=fgetc(f);\n			z[j++]=s;\n		}\n		z[j-1]=0;\n		if (d==0)\n		{\n			A=malloc(sizeof(struct item));\n			head=A;\n			A->count=1;\n			A->next=0;\n			strcpy(A->word,z);\n			d++;\n		}\n		else\n		{\n			b=head;\n			for (a=head;(a)&&(strcmp(z,a->word));a=a->next)\n			b=a;\n			if (a==0)\n			{\n				A=malloc(sizeof(struct item));\n				A->count=1;\n				A->next=0;\n				strcpy(A->word,z);\n				b->next=A;\n			}\n			else\n			{\n				a->count++;\n			}\n		}\n	}\n	f=fopen(\"output14.txt\",\"w\");\n	for (a=head;a;a=a->next)\n	fprintf(f,\"%s %d\\n\",a->word,a->count);\n	//???????? ??????\n	while (head)\n	{\n		a=head;\n		head=head->next;\n		free(a);\n	}\n}\n\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (262,'#include <stdio.h>\n#include <string.h>\n#define NN 100000\n\nvoid replace(int *A, int i, int j)\n{\n        int a;\n	a=A[i];\n	A[i]=A[j];\n	A[j]=a;\n}\nvoid sift (int *A, int N, int k)\n{	\n int max=k;\n if ((2*k+1<N) && (A[max]<A[2*k+1])) max=2*k+1;\n if ((2*k+2<N) && (A[max]<A[2*k+2])) max=2*k+2;	\n	if (max!=k)\n	{\n		replace (A, max, k);\n		sift (A,N,max);\n	}\n 	return;\n}		\nint main()\n{\n	int B[NN]={0};\n	int i,s,a,b;\n	FILE *f = fopen (\"input_big.txt\", \"r\");\n	fscanf(f,\"%d\",&s);\n	for (i=0;i<s;i++)\n	fscanf(f,\"%d\", &B[i]);\n	fclose(f);\n\nfor (i=(s/2)-1; i>=0; i--)\n	{\n	sift (B,s,i);\n	}\n\nint dl = s;\n\nfor (i=dl-1;i>=0;i--)\n{	replace(B,0,s-1);\n	s = s-1;\n	sift(B,s,0);\n}\n\n\nfor(i=0;i<dl;i++)\nprintf (\"%d \",B[i]);\nprintf(\"\\n\");\nreturn 0;\n}\n\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (263,'#include \"functions.h\"	\r\n\r\n#include <ctype.h>\r\n#include \"variable.h\"\r\n#include \"list.h\"\r\n#include \"stack.h\"\r\n\r\nint ch = \'0\';\r\n\r\nint priority ( char x )\r\n{\r\n	if ( x == \'(\' )\r\n		return 1;\r\n	else if ( x == \')\' )\r\n		return 2;\r\n	else if ( x == \'=\' )\r\n		return 3;\r\n	else if ( x == \'+\' || x == \'-\' )\r\n		return 4;\r\n	else if ( x == \'*\' || x == \'/\' )\r\n		return 5;\r\n	else\r\n		return 0;\r\n}\r\n\r\n\r\nList * ScanInput ()\r\n{	\r\n	char *g;\r\n	struct list *p;\r\n	int start,i=0,n,ln=0,a;\r\n	int state = 0;\r\n	char* Array1,*q1;\r\n	List *sp;\r\n	List *inf;\r\n	ListCreate (&sp);\r\n	ListCreate (&inf);\r\n	\r\n	\r\n	while (ch=getchar())\r\n	{\r\n		if (ch == EOF)\r\n			break;	\r\n		else if (isalpha(ch) && state == 0)\r\n		{\r\n			\r\n				state = 1;\r\n				PushList (&ch, 1, 1, sp);\r\n		}\r\n		else if (state == 1 && (isalpha(ch) || isdigit(ch) || ch == \'_\'))\r\n		{\r\n			PushList (&ch, 1, 1, sp);\r\n		}\r\n		else if ((state == 1) && (!isalpha(ch)) && (!isdigit(ch)) && (ch != \'_\'))\r\n		{\r\n			char *Array;	\r\n			a = ListLength (sp);\r\n			Array = malloc (sizeof(char)*a+1);\r\n			if (!Array)\r\n				perror(\"malloc\");\r\n			i=0;\r\n			while(!EmptyList(sp))\r\n			{\r\n				Array[i] =*(char*)sp->head->data;\r\n				i++;\r\n				PopList(sp);\r\n			}\r\n			Array[i] = 0;			\r\n			PushList (Array, a, 1, inf);\r\n			free(Array);\r\n			if (ch == \'+\' || ch == \'(\' || ch == \')\' || ch == \'=\' || ch == \'-\' || ch == \'*\' || ch == \'/\')\r\n			{\r\n				PushList (&ch, 0, 3, inf);\r\n			}\r\n			\r\n			MakeNullList (sp);\r\n			state = 0;\r\n						\r\n		}\r\n		else if (isdigit(ch) && state == 0)\r\n		{\r\n			\r\n			 n=ch-\'0\';\r\n			state = 3;\r\n		}\r\n		else if (isdigit(ch) && state == 3)\r\n		{\r\n			n=n*10+ch-\'0\';\r\n			ln++;\r\n		}\r\n		else if (state == 3 && (!isdigit(ch)))\r\n		{			\r\n			PushList (&n, ln, 2, inf);\r\n			ln=0;\r\n			if (ch != \'\\n\')\r\n			\r\n				PushList (&ch, 0, 3 , inf);\r\n					\r\n			state = 0;\r\n			n=0;\r\n		}\r\n		else if (ch != \'\\n\') \r\n		\r\n				PushList (&ch, 0, 3 , inf);\r\n			\r\n		\r\n		if (ch == \'\\n\')break;\r\n		\r\n\r\n	}\r\n	ListDel (sp);\r\n	return (inf);\r\n}\r\n\r\nList* PolishNotation (List *sp)\r\n{\r\n	Stack *st;\r\n	List *polishform;\r\n	struct list *p;\r\n	struct item *g;\r\n	StackCreate (&st);\r\n	ListCreate (&polishform);\r\n	p = sp->head;\r\n 	while (!EmptyList(sp))\r\n	{\r\n		if (p->type == 1 || p->type == 2)\r\n		{\r\n			PushList (p->data, p->ln, p->type, polishform);\r\n			PopList (sp);\r\n		}\r\n		else if (*(char*)p->data == \'(\')\r\n		{\r\n			PushStack (p->data, p->ln, p->type, st);\r\n			PopList (sp);\r\n		}\r\n		else if (*(char*)p->data == \')\')\r\n		{\r\n			struct item *q;\r\n			q = st->top;\r\n			while (*(char*)q->data != \'(\')\r\n			{\r\n 				PushList (q->data, q->ln, 3, polishform);\r\n				PopStack (st);\r\n				q=st->top;\r\n			}\r\n			PopStack (st);\r\n			PopList (sp);\r\n		}\r\n		else if (p->type == 3)\r\n		{\r\n			struct item *q;\r\n			q=st->top;\r\n			while (!EmptyStack(st) && ((priority (*(char*)q->data)) >= (priority(*(char*)p->data))))\r\n			{\r\n				PushList(q->data, q->ln, 3, polishform);\r\n				PopStack (st);\r\n				q=st->top;\r\n			}\r\n			PushStack (p->data, p->ln, p->type, st);\r\n			PopList (sp);\r\n		}\r\n		if (sp->head)\r\n		p=sp->head;\r\n	}\r\n	while (!EmptyStack(st))\r\n	{\r\n		PushList (top(st), 0, 3, polishform);\r\n		PopStack (st);\r\n	}\r\n	ListDel (sp);\r\n	StackDel (st);\r\n	return (polishform);\r\n}\r\n\r\n','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (264,'		#include \"list.h\"\r\n\r\n\r\nvoid MakeNullList (List *sp)\r\n{\r\n	struct list *p;\r\n	while (sp->head)\r\n	{\r\n		p=sp->head;\r\n		sp->head = p->next;\r\n		free(p->data);\r\n		free (p);\r\n	}\r\n}\r\nvoid ListCreate (List **sp)\r\n{\r\n	*sp = malloc (sizeof (struct list));\r\n	if (*sp){\r\n	(*sp)->head = NULL;\r\n	(*sp)->tail = NULL;\r\n	}\r\n}\r\n\r\nvoid *head (List *sp)\r\n{\r\n	if (sp->head)\r\n		return sp->head->data;\r\n	else\r\n		return NULL;\r\n}\r\nvoid PopList(List *sp)\r\n{\r\n	\r\n	struct list *p;\r\n	if (sp == NULL)\r\n		return ;\r\n	p=sp->head;\r\n	sp->head = sp->head->next;\r\n	free(p->data);\r\n	free(p);\r\n	\r\n}\r\nvoid PushList (void *data1, int ln1, int type1, List *sp)\r\n{\r\n\r\n	struct list *p;\r\n	char *Array;\r\n	char c;\r\n	int n,i;\r\n\r\n\r\n	p = (struct list *) malloc (sizeof (struct list));\r\n	if (!p)\r\n		perror(\"malloc\");\r\n	\r\n	if (type1 == 3)\r\n	{\r\n		p->data = malloc(sizeof(char));\r\n		if(!p->data)\r\n			perror(\"malloc\");\r\n		c =*(char*) data1;\r\n	\r\n	*(char*)p->data = c;\r\n	}\r\n	\r\n	else if (type1 == 2)\r\n	{\r\n		p->data = malloc(sizeof(int));\r\n		if (!p->data) \r\n			perror(\"malloc\");\r\n		n = *(int*) data1;\r\n		*(int*)p->data = n;\r\n		\r\n	}\r\n	else\r\n	{\r\n\r\n		Array = data1;\r\n		p->data = malloc(sizeof(char)*ln1+1);\r\n		if (!p->data) \r\n			perror(\"malloc\");\r\n		for (i=0;i<ln1;i++)\r\n			((char*)p->data)[i]=Array[i];\r\n		((char*)p->data)[ln1]=0;\r\n		\r\n	}\r\n	\r\n	\r\n	if (sp->head != NULL)\r\n	{\r\n		//p->data = q;\r\n		p->ln = ln1;\r\n		p->type = type1;\r\n		p->next = NULL;\r\n		sp->tail->next = p;\r\n		sp->tail = p;\r\n	}\r\n	else \r\n	{\r\n		//p->data = q;\r\n		p->ln = ln1;\r\n		p->type = type1;\r\n		p->next = NULL;\r\n		sp->head = p;\r\n		sp->tail = sp->head;\r\n		\r\n	}\r\n	\r\n}\r\n\r\nint EmptyList (List *sp)\r\n{\r\n	return (sp->head == NULL);\r\n}\r\n\r\nvoid ListDel (List *sp)\r\n{\r\n	if (sp == NULL)\r\n		return;\r\n	while (!EmptyList(sp))\r\n		PopList(sp);\r\n	free (sp);\r\n}\r\nint ListLength (List *sp)\r\n{\r\n	int i = 0;\r\n	struct list *p;\r\n	if (sp == NULL)\r\n		return 0;\r\n	for (p=sp->head; p; p=p->next)\r\n		i++;\r\n	return i;\r\n}','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (265,'\r\n#include <math.h>\r\n#include \"functions.h\"\r\n#include \"list.h\"\r\n#include \"stack.h\"\r\n#include \"variable.h\"\r\n\r\nint main ()\r\n{\r\n	Stack *st;\r\n	struct item *q;\r\n	struct list *p;\r\n	StackCreate (&st);\r\n	TableCreate();\r\n	do\r\n	{\r\n		List* polishform = PolishNotation(ScanInput());\r\n		while (!EmptyList (polishform))\r\n		{\r\n			p = polishform->head;\r\n			if (p->type == 1)\r\n			{\r\n				PushStack(p->data, p->ln, p->type, st);\r\n				PopList (polishform);\r\n			}\r\n			else if (p->type == 2)\r\n			{\r\n				PushStack(p->data, p->ln, p->type, st);\r\n				PopList (polishform);\r\n			}\r\n			else if (p->type == 3)\r\n			{\r\n				if (*(char*)p->data == \'=\')\r\n				{\r\n					q = st->top;\r\n					if (q->type == 1)\r\n						SetValue((char*)q->next->data, GetValue((char*)q->data));\r\n					else\r\n						SetValue((char*)q->next->data, *(int*)q->data);\r\n					PopList (polishform);\r\n					PopStack (st);\r\n					PopStack (st);\r\n				}\r\n				else\r\n				{\r\n					int *k;\r\n					int val=0;\r\n					q=st->top;\r\n					if (*(char*)p->data == \'+\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val += GetValue((char*)q->data);\r\n						else\r\n							val += *(int*)q->data;\r\n					}	\r\n					else if (*(char*)p->data == \'-\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val -= GetValue((char*)q->data);\r\n						else\r\n							val -= *(int*)q->data;\r\n					}	\r\n					else if (*(char*)p->data == \'*\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val *= GetValue((char*)q->data);\r\n						else\r\n							val *= *(int*)q->data;\r\n					}	\r\n					else if (*(char*)p->data == \'/\')\r\n					{\r\n						if (q->next->type == 1)\r\n							val += GetValue((char*)q->next->data);\r\n						else \r\n							val += *(int*)q->next->data;\r\n						if (q->type == 1)\r\n							val /= GetValue((char*)q->data);\r\n						else\r\n							val /= *(int*)q->data;\r\n					}	\r\n					PopStack (st);\r\n					PopStack (st);\r\n					k = malloc (sizeof (int));\r\n					if (k){\r\n						*k = val;\r\n						PushStack (k, 4, 2, st);\r\n						PopList (polishform);\r\n					}\r\n				}\r\n			}\r\n		}\r\n		while (!EmptyStack(st))\r\n		{\r\n			if (st->top->type == 1)\r\n				printf (\"%d \\n\" , GetValue((char*)st->top->data));\r\n			else\r\n				printf (\"%d \\n\", *(int *)st->top->data);\r\n			PopStack (st);\r\n		}\r\n		ListDel (polishform);\r\n		MakenullStack (st);\r\n	}\r\n	while (ch!=EOF);\r\n	StackDel (st);\r\n	cleanup();\r\n	return 0;\r\n} \r\n','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (266,'#include \"stack.h\"\r\n\r\nvoid MakenullStack (Stack *st)\r\n{\r\n	struct item *p;\r\n	while (st->top)\r\n	{\r\n		p=st->top;\r\n		st->top = p->next;\r\n		free (p);\r\n	}\r\n}\r\nvoid StackCreate (Stack **st)\r\n{\r\n	*st = malloc (sizeof (struct item));\r\n	if (*st)\r\n	(*st)->top = NULL;\r\n}\r\n\r\nvoid *top (Stack *st)\r\n{\r\n	if (st->top)\r\n		return st->top->data;\r\n	else\r\n		return NULL;\r\n}\r\nvoid PopStack(Stack *st)\r\n{\r\n	struct item *p;\r\n	if (st->top == NULL)\r\n		return;\r\n	p=st->top;\r\n	st->top = p->next;\r\n 	if (p!=NULL)\r\n	{\r\n		free(p->data);\r\n		free (p);\r\n	}\r\n}\r\nvoid PushStack (void *data1, int ln1, int type1, Stack *st)\r\n{\r\n	struct item *p;\r\n	char *Array;\r\n	char c;\r\n	int n,i;\r\n	p = malloc (sizeof (struct item));\r\n	if (!p)\r\n		perror(\"malloc\");\r\n\r\n\r\n	if (type1 == 3)\r\n	{\r\n		p->data = malloc(sizeof(char));\r\n		if(!p->data)\r\n			perror(\"malloc\");\r\n		c =*(char*) data1;\r\n		*(char*)p->data = c;\r\n	\r\n		\r\n	}\r\n	else if (type1 == 2)\r\n	{\r\n		\r\n		p->data = malloc(sizeof(int));\r\n		if (!p->data) \r\n			perror(\"malloc\");\r\n		n = *(int*) data1;\r\n		*(int*)(p->data) = n;\r\n	}\r\n	else\r\n	{\r\n		Array = data1;\r\n		p->data = malloc(sizeof(char)*ln1+1);\r\n		if (!p->data) \r\n			perror(\"malloc\");\r\n		for (i=0;i<ln1;i++)\r\n			((char*)p->data)[i]=Array[i];\r\n		((char*)p->data)[ln1]=0;\r\n	}\r\n	\r\n	\r\n	p->type = type1;\r\n//	p->data = q;\r\n	p->ln = ln1;\r\n	p->next = st->top;\r\n	st->top = p;\r\n	\r\n}\r\n\r\nint EmptyStack (Stack *st)\r\n{\r\n	return (st->top == NULL);\r\n}\r\n\r\nvoid StackDel (Stack *st)\r\n{\r\n	if (st == NULL)\r\n		return;\r\n	while (!EmptyStack(st))\r\n		PopStack(st);\r\n	free (st);\r\n}\r\n','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (267,'#include \"variable.h\"\r\n\r\n\r\nstruct table *Table[128];\r\n\r\nunsigned int hash (char *str)\r\n{\r\n	unsigned char *p;\r\n	unsigned int res = 0;\r\n	for (p=(unsigned char *)str; *p!=0; p++)\r\n		res = (res * 37 + (*p));\r\n	return res%128;\r\n}\r\nvoid TableCreate (void)\r\n{\r\n	int i;\r\n	for (i=0; i<128; i++)\r\n		Table[i] = NULL;\r\n}\r\nvoid SetValue (char *string, int value)\r\n{\r\n	int length;\r\n	struct table *p;\r\n	unsigned int i = hash (string);\r\n	p = Table[i];\r\n	while (p)\r\n	{\r\n		if (!strcmp (p->name, string))\r\n		{\r\n			p->value = value;\r\n			return;\r\n		}\r\n		p = p->next;\r\n	}\r\n	p = malloc (sizeof (struct table));\r\n	if (p){\r\n	p->next = Table[i];\r\n	Table[i] = p;\r\n	p->value = value;\r\n	p->name = malloc (sizeof(char)*(length = strlen(string)+1));\r\n	if (p->name){\r\n	memcpy (p->name, string , length*sizeof (char));\r\n	}\r\n	}\r\n}\r\nint GetValue (char *name)\r\n{\r\n	struct table *p;\r\n	unsigned int i = hash (name);\r\n	p = Table[i];\r\n	while (p)\r\n	{\r\n		if (!strcmp (p->name, name))\r\n			return p->value;\r\n		p = p->next;\r\n	}\r\n	return 0;\r\n}\r\nvoid cleanup (void)\r\n{\r\n	struct table *p;\r\n	int i;\r\n	for (i=0;i<128;i++)\r\n	{\r\n		p = Table[i];\r\n		while (p)\r\n		{\r\n			Table[i] = Table[i]->next;\r\n			free (p->name);\r\n			free (p);\r\n			p = Table[i];\r\n		}\r\n	}\r\n}','ÐÐ¸ÐºÐ¾Ð»Ð°Ð¹','Nikolay','m');
INSERT INTO `bias` VALUES (268,'#include \"functions.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <ctype.h>\r\n#include \"vars.h\"\r\n#include \"list.h\"\r\n#include \"stack.h\"\r\n#include \"long.h\"\r\n\r\nint ch = \'0\';\r\n\r\nint priority ( char x )\r\n{\r\n	if ( x == \'(\' )\r\n		return 1;\r\n	else if ( x == \')\' )\r\n		return 2;\r\n	else if ( x == \'=\' )\r\n		return 3;\r\n	else if ( x == \'+\' || x == \'-\' )\r\n		return 4;\r\n	else if ( x == \'*\' || x == \'/\' )\r\n		return 5;\r\n	else\r\n		return 0;\r\n}\r\n\r\nList * ScanInput ()\r\n{\r\n	struct long_int *r;\r\n	int start;\r\n	List *sp;\r\n	List *inf;\r\n	ListCreate (&sp);\r\n	ListCreate (&inf);\r\n	ch = getchar();\r\n	start = 1;\r\n	while (ch!=\'\\n\')\r\n	{\r\n		if (isalpha(ch))\r\n		{\r\n			int i=0, a;\r\n			char *g;\r\n			char *Array;\r\n			struct list *q;\r\n			while (isalpha(ch)||isdigit(ch)||(ch == \'_\'))\r\n			{\r\n				g = malloc (sizeof(char));\r\n				if (!g) \r\n				{\r\n					perror(\"malloc 1\");\r\n					exit(1);\r\n				}\r\n				*g = ch;\r\n				PushList (g, 1, sp);\r\n				ch = getchar();\r\n			}\r\n			a = ListLength (sp);\r\n			Array = malloc (sizeof(char)*a+1);\r\n				if (!Array) \r\n				{\r\n					perror(\"malloc 2\");\r\n					exit(1);\r\n				}\r\n			for (q=sp->head;q;q=q->next)\r\n			{\r\n				Array[i] = *(char*)q->data;\r\n				free (q->data);//////////\r\n				i++;\r\n			}\r\n			Array[i] = 0;\r\n			PushList (Array, 1, inf);\r\n			MakeNullList (sp);\r\n			start = 0;\r\n			continue;\r\n		}\r\n		else if (isdigit(ch))\r\n		{\r\n			int a,i,k,l=D,f;\r\n			char *g;\r\n			int *Array;\r\n			struct list *q;\r\n 			while (isdigit(ch))\r\n			{\r\n				g = malloc (sizeof(int));\r\n				if (!g) \r\n				{\r\n					perror(\"malloc 3\");\r\n					exit(1);\r\n				}\r\n				*g = ch-\'0\';\r\n				PushList (g, 2, sp);\r\n				ch = getchar();\r\n			}\r\n			a = ListLength (sp);\r\n			f = a%4;\r\n			if (f != 0)\r\n				a=a/4+1;\r\n			else\r\n				a=a/4;\r\n			Array = malloc (sizeof(int)*a);\r\n				if (!Array) \r\n				{\r\n					perror(\"malloc 4\");\r\n					exit(1);\r\n				}\r\n			for (k=0;k<a;k++)\r\n			{\r\n				Array[k]=0;\r\n			}\r\n			i=0;\r\n			for (q=sp->head;q;q=q->next)\r\n			{\r\n				l/=10;\r\n				while (f!=4 && f!=0)\r\n				{\r\n					l/=10;\r\n					f++;\r\n				}\r\n				Array[i] += *(char*)q->data*l;\r\n				free (q->data);\r\n				if (l == 1)\r\n				{\r\n					l=D;\r\n					i++;\r\n				}\r\n			}\r\n			for (i=0;i<a/2;i++)\r\n			{\r\n				k = Array[i];\r\n				Array[i] = Array[a-1-i];\r\n				Array[a-1-i] = k;\r\n			}\r\n			r = malloc (sizeof (struct long_int));\r\n				if (!r) \r\n				{\r\n					perror(\"malloc 5\");\r\n					exit(1);\r\n				}\r\n			r->digits = Array;\r\n			r->length = a;\r\n			r->sign = 0;\r\n			PushList (r, 2, inf);\r\n			MakeNullList (sp);\r\n			start = 0;\r\n			continue;\r\n		}\r\n		else if ((ch == \'(\') || (ch == \'=\'))\r\n		{\r\n			char *q;\r\n			q = malloc (sizeof (char));\r\n				if (!q) \r\n				{\r\n					perror(\"malloc 6\");\r\n					exit(1);\r\n				}\r\n			*q = ch;\r\n			PushList (q, 3, inf);\r\n			start = 1;\r\n			ch = getchar();\r\n			continue;\r\n		}\r\n		else if ((ch == \')\') || (ch == \'*\') || (ch == \'/\'))\r\n		{\r\n			char *q;\r\n			q = malloc (sizeof (char));\r\n				if (!q) \r\n				{\r\n					perror(\"malloc 7\");\r\n					exit(1);\r\n				}\r\n			*q = ch;\r\n			PushList (q, 3, inf);\r\n			start = 0;\r\n			ch = getchar();\r\n			continue;\r\n		}\r\n		else if (ch == \'-\' || ch == \'+\')\r\n		{\r\n			if (start == 1)\r\n			{\r\n				char *q;\r\n				int *p;\r\n				q = malloc (sizeof (char));\r\n				if (!q) \r\n				{\r\n					perror(\"malloc 8\");\r\n					exit(1);\r\n				}\r\n				p = malloc (sizeof (int));\r\n				if (!p) \r\n				{\r\n					perror(\"malloc 9\");\r\n					exit(1);\r\n				}\r\n				*p = 0;\r\n				*q = ch;\r\n				PushList (p, 2, inf);\r\n				PushList (q, 3, inf);\r\n				start = 0;\r\n				ch = getchar();\r\n				continue;\r\n			}\r\n			else \r\n			{\r\n				char *q;\r\n				q = malloc (sizeof (char));\r\n				if (!q) \r\n				{\r\n					perror(\"malloc 10\");\r\n					exit(1);\r\n				}\r\n				*q = ch;\r\n				PushList (q, 3, inf);\r\n				start = 0;\r\n				ch = getchar();\r\n				continue;\r\n			}\r\n		}\r\n		else if (ch == EOF)\r\n		{\r\n			break;\r\n		}\r\n	}\r\n	ListDel (sp);\r\n	return (inf);\r\n}\r\n\r\nList* PolishNotation (List *sp)\r\n{\r\n	Stack *st;\r\n	List *polishform;\r\n	struct list *p;\r\n	StackCreate (&st);\r\n	ListCreate (&polishform);\r\n	p = sp->head;\r\n 	while (!EmptyList(sp))\r\n	{\r\n		if (p->type == 1 || p->type == 2)\r\n		{\r\n			PushList (p->data, p->type, polishform);\r\n			PopList (sp);\r\n		}\r\n		else if (*(char*)p->data == \'(\')\r\n		{\r\n			PushStack (p->data, p->type, st);\r\n			PopList (sp);\r\n		}\r\n		else if (*(char*)p->data == \')\')\r\n		{\r\n			struct item *q;\r\n			q = st->top;\r\n			while (*(char*)q->data != \'(\')\r\n			{\r\n 				PushList (q->data, 3, polishform);\r\n				PopStack (st);\r\n				q=st->top;\r\n			}\r\n			free (q->data);/////////////////////\r\n			PopStack (st);\r\n			free (p->data);/////////////////////\r\n			PopList (sp);\r\n		}\r\n		else if (p->type == 3)\r\n		{\r\n			struct item *q;\r\n			q=st->top;\r\n			while (!EmptyStack(st) && ((priority (*(char*)q->data)) >= (priority(*(char*)p->data))))\r\n			{\r\n				PushList(q->data, 3, polishform);\r\n				PopStack (st);\r\n				q=st->top;\r\n			}\r\n			PushStack (p->data, p->type, st);\r\n			PopList (sp);\r\n		}\r\n		p=sp->head;\r\n	}\r\n	while (!EmptyStack(st))\r\n	{\r\n		PushList (top(st), 3, polishform);\r\n		PopStack (st);\r\n	}\r\n	ListDel (sp);\r\n	StackDel (st);\r\n	return (polishform);\r\n}\r\n\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (269,'#include \"list.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\nvoid MakeNullList (List *sp)\r\n{\r\n	struct list *p;\r\n	while (sp->head)\r\n	{\r\n		p=sp->head;\r\n		sp->head = p->next;\r\n		free (p);\r\n	}\r\n}\r\nvoid ListCreate (List **sp)\r\n{\r\n	*sp = malloc (sizeof (struct list));\r\n	if (!*sp)\r\n	{\r\n		perror(\"malloc 11\");\r\n		exit(1);\r\n	}\r\n	(*sp)->head = NULL;\r\n	(*sp)->tail = NULL;\r\n	\r\n}\r\n\r\nvoid *head (List *sp)\r\n{\r\n	if (sp->head)\r\n		return sp->head->data;\r\n	else\r\n		return NULL;\r\n}\r\nvoid PopList(List *sp)\r\n{\r\n	struct list *p;\r\n	if (sp == NULL)\r\n		return;\r\n	p=sp->head;\r\n	sp->head = sp->head->next;\r\n	free(p);\r\n}\r\nvoid PushList (void *data1, int type1, List *sp)\r\n{\r\n	struct list *p;\r\n	p = (struct list *) malloc (sizeof (struct list));\r\n	if (p!=NULL)\r\n	{\r\n		if (sp->head != NULL)\r\n		{\r\n			p->data = data1;\r\n			p->type = type1;\r\n			p->next = NULL;\r\n			sp->tail->next = p;\r\n			sp->tail = p;\r\n		}\r\n		else \r\n		{\r\n			p->data = data1;\r\n			p->type = type1;\r\n			p->next = NULL;\r\n			sp->head = p;\r\n			sp->tail = sp->head;\r\n		}\r\n	}\r\n	else\r\n	{\r\n		perror(\"malloc 12\");\r\n		exit(1);\r\n	}\r\n}\r\n// ???????? ??????? ??????\r\nint EmptyList (List *sp)\r\n{\r\n	return (sp->head == NULL);\r\n}\r\n// ???????? ?????\r\nvoid ListDel (List *sp)\r\n{\r\n	if (sp == NULL)\r\n		return;\r\n	while (!EmptyList(sp))\r\n		PopList(sp);\r\n	free (sp);\r\n}\r\nint ListLength (List *sp)\r\n{\r\n	int i = 0;\r\n	struct list *p;\r\n	if (sp == NULL)\r\n		return 0;\r\n	for (p=sp->head; p; p=p->next)\r\n		i++;\r\n	return i;\r\n}','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (270,'#include \"long.h\"\r\n#include \"functions.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint compare (struct long_int* a, struct long_int *b)\r\n{\r\n	int i;\r\n	if (a->length > b->length)\r\n		return 1;\r\n	if (a->length < b->length)\r\n		return -1;\r\n	for (i=a->length-1; i>=0; i--)\r\n		if (a->digits[i]>b->digits[i])\r\n			return 1;\r\n		else if (a->digits[i]<b->digits[i])\r\n			return -1;\r\n	return 0;\r\n}\r\n\r\nstatic void makenulld (int *d, int length)\r\n{\r\n	int i;\r\n	for (i=0; i<length; i++)\r\n		d[i] = 0;\r\n	return;\r\n}\r\nstruct long_int* add(struct long_int* a, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	int i, nmax, nmin, ind;\r\n	int buffer = 0;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 13\");\r\n		return s;\r\n	}\r\n	if (a->length >= b->length)\r\n	{\r\n		nmax = a->length;\r\n		nmin = b->length;\r\n		ind = 1;\r\n	}\r\n	else\r\n	{\r\n		nmax = b->length;\r\n		nmin = a->length;\r\n		ind = 2;\r\n	}\r\n	d = malloc (sizeof(int)*(nmax+1));\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 14\");\r\n		exit (0);\r\n	}\r\n	makenulld (d, nmax+1);\r\n	for (i=0; i<nmax; i++)\r\n	{\r\n		if (i<nmin)\r\n		{\r\n			d[i] = (a->digits)[i] + (b->digits)[i];\r\n			d[i] += buffer;\r\n			if (d[i] >= D) // TODO: constant in .h file\r\n			{\r\n				d[i] -= D;\r\n				buffer = 1;\r\n			}\r\n			else \r\n				buffer = 0;\r\n		}\r\n		else \r\n		{\r\n			if (ind == 1)\r\n			{\r\n				d[i] = (a->digits)[i] + buffer;\r\n				buffer = 0;\r\n			}\r\n			else\r\n			{\r\n				d[i] = (b->digits)[i] + buffer;\r\n				buffer = 0;\r\n			}\r\n		}\r\n	}\r\n	if (buffer != 0) \r\n	{\r\n		d[i] = 1;\r\n	}\r\n	else\r\n		d[i] = 0;\r\n	s->digits = d;\r\n	s->length = nmax + 1;\r\n	s->sign = 0;\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\nstruct long_int* sub(struct long_int* a, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	int i, nmax, nmin, ind;\r\n	int buffer = 0;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 15\");\r\n		return s;\r\n	}\r\n	if (a->length >= b->length)\r\n	{\r\n		nmax = a->length;\r\n		nmin = b->length;\r\n		ind = 1;\r\n	}\r\n	else if (a->length < b->length)\r\n	{\r\n		nmax = b->length;\r\n		nmin = a->length;\r\n		ind = 2;\r\n	}\r\n\r\n	d = malloc (sizeof(int)*nmax);\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 16\");\r\n		exit (0);\r\n	}\r\n	makenulld (d, nmax);\r\n	if (ind == 1)\r\n	{\r\n		for (i=0; i<nmax; i++)\r\n		{\r\n			if (i<nmin)\r\n			{\r\n				d[i] = (a->digits)[i] - (b->digits)[i];\r\n				d[i] += buffer;\r\n				if (d[i] < 0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else \r\n						buffer = 0;\r\n			}\r\n			else \r\n			{\r\n					d[i] = (a->digits)[i] + buffer;\r\n					if (d[i]<0)\r\n					{\r\n						d[i] += D;\r\n						buffer = -1;\r\n					}\r\n					else\r\n						buffer = 0;\r\n			}\r\n		}\r\n		if (buffer == -1)\r\n		{\r\n			for (i=0; i<nmax; i++)\r\n			{\r\n				buffer = 0;\r\n				d[i] = (b->digits)[i] - (a->digits)[i];\r\n				d[i] += buffer;\r\n				if (d[i] < 0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else \r\n					buffer = 0;\r\n			}\r\n			s->sign = 1; \r\n		}\r\n		else \r\n			s->sign = 0;\r\n		s->digits = d;\r\n		s->length = nmax;\r\n	}\r\n	else\r\n	{\r\n		for (i=0; i<nmax; i++)\r\n		{\r\n			if (i<nmin)\r\n			{\r\n				d[i] = (b->digits)[i] - (a->digits)[i];\r\n				d[i] += buffer;\r\n				if (d[i] < 0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else \r\n					buffer = 0;\r\n			}\r\n			else \r\n			{\r\n				d[i] = (b->digits)[i] + buffer;\r\n				if (d[i]<0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else\r\n					buffer = 0;\r\n			}\r\n		}\r\n		s->digits = d;\r\n		s->length = nmax;\r\n		if (buffer == -1)\r\n			s->sign = 0;\r\n		else \r\n			s->sign = 1;\r\n	}\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\n\r\n\r\n\r\nstruct long_int* shortmul(struct long_int* a, int b, int k)\r\n{\r\n	struct long_int *s;\r\n	int i;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 17\");\r\n		scanf(\"\\n\");\r\n		exit(1);\r\n	}\r\n	s->length = a->length+k+1;\r\n//	printf(\"after initialization: %d\\n\", s->length);\r\n	s->sign = a->sign;\r\n	d = malloc (sizeof(int)*(a->length+k+1));\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 18\");\r\n		exit(1);\r\n	}\r\n	makenulld (d, s->length);\r\n//	printf(\"max possible length: %d\\n\", a->length);\r\n	for (i=0; i<a->length; i++)\r\n	{\r\n		d[k+i] += a->digits[i] * b;\r\n		d[k+i+1] = d[k+i]/D;\r\n		d[k+i] %= D;\r\n	}\r\n	s->digits = d;\r\n//	printf(\"s->length: %d\\n\", s->length);\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\n\r\nstruct long_int* mul(struct long_int* a, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	int i,j;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 19\");\r\n		return s;\r\n	}\r\n	d = malloc (sizeof(int)*(a->length + b->length));\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 20\");\r\n		return s;\r\n	}\r\n	makenulld (d, a->length + b->length);\r\n	for (i=0;i<(a->length + b->length);i++)\r\n		d[i] = 0;\r\n	for (i=0;i<a->length;i++)\r\n		for (j=0;j<b->length;j++)\r\n		{\r\n			d[i+j] += (a->digits[i])*(b->digits[j]);\r\n			if (d[i+j] >= D)\r\n			{\r\n				d[i+j+1] += d[i+j]/D;\r\n				d[i+j] = d[i+j]%D;\r\n			}\r\n		}\r\n	s->digits = d;\r\n	s->length = a->length + b->length;\r\n	if (a->sign + b->sign == 1)\r\n		s->sign = 1;\r\n	else \r\n		s->sign = 0;\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\nstatic void shift(struct long_int* a, struct long_int* b)\r\n{\r\n        int i;\r\n        for(i=0; i<a->length; i++)\r\n        {\r\n                if(i < b->length)\r\n                        a->digits[i] -= b->digits[i];\r\n                if(a->digits[i] < 0)\r\n                {\r\n                        a->digits[i] += D;\r\n                        a->digits[i+1]--;\r\n                }\r\n        }\r\n        while(a->length && a->digits[a->length-1] == 0)\r\n               a->length--;\r\n}\r\n\r\nstruct long_int* div1(struct long_int* x, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	struct long_int *a;\r\n	int *d,i;\r\n	a = malloc (sizeof (struct long_int));\r\n	a->length = x->length;\r\n	a->sign = x->sign;\r\n	a->digits = malloc (sizeof (int) * x->length);\r\n	for (i=0;i<x->length;i++)\r\n		a->digits[i] = x->digits[i]; \r\n	s = malloc (sizeof (struct long_int));\r\n				if (!s) \r\n				{\r\n					perror(\"malloc 21\");\r\n					exit(1);\r\n				}\r\n	if (compare (a,b) == -1)\r\n	{\r\n		s->sign = 0;\r\n		s->length = 1;\r\n		d = malloc (sizeof (int));\r\n				if (!d) \r\n				{\r\n					perror(\"malloc 22\");\r\n					exit(1);\r\n				}\r\n		d[0] = 0;\r\n		s->digits = d;\r\n		free_int (a);\r\n		return (s);\r\n	}\r\n	s->length = a->length - b->length +1;\r\n	if (a->sign + b->sign == 1) \r\n		s->sign = 1;\r\n	else\r\n		s->sign = 0;\r\n	d = malloc (sizeof (int) * s->length);\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 23\");\r\n		exit(1);\r\n	}\r\n	makenulld (d, s->length);\r\n	for (i=s->length-1;i>=0;i--)\r\n	{\r\n		struct long_int *pr;\r\n		int left = 0, right = D, mid;\r\n		do\r\n		{\r\n			int res;\r\n			mid = (left+right)/2;\r\n			pr = shortmul (b, mid, i);\r\n			res = compare (a, pr);\r\n			if (res == 1)\r\n			{\r\n				left = mid+1;\r\n				free_int (pr);\r\n			}\r\n			if (res == -1)\r\n			{\r\n				right = mid-1;\r\n				free_int (pr);\r\n			}\r\n			if (res == 0)\r\n			{\r\n				d[i] = mid;\r\n				shift (a, pr);\r\n				s->digits = d;\r\n				free_int (pr);\r\n				free_int (a);//////////////\r\n				while (s->length && s->digits[s->length-1] == 0)\r\n					s->length--;\r\n				return (s);\r\n			}\r\n		}\r\n		while (left <= right);\r\n		d[i] = mid = (left+right)/2;\r\n		pr = shortmul (b, mid, i);\r\n		shift (a, pr);\r\n		free_int (pr);\r\n	}\r\n	s->digits=d;\r\n	free_int (a);\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\nvoid Print (struct long_int* s)\r\n{\r\n	int printnow = 0, i;\r\n	if (s->sign == 1)\r\n		printf (\"-\");\r\n	for (i=(s->length)-1;i>=0;i--)\r\n	{\r\n		if (printnow == 1)\r\n		{\r\n			printf (\"%04d\", s->digits[i]);\r\n			continue;\r\n		}\r\n		if (s->digits[i] > 0)\r\n		{\r\n			printnow = 1;\r\n			printf (\"%d\", s->digits[i]);\r\n			continue;\r\n		}\r\n\r\n	}\r\n		if (!printnow)\r\n			printf (\"0\");\r\n		printf (\"\\n\");\r\n}\r\nvoid free_int (struct long_int *s)\r\n{\r\n	if (s->digits)\r\n		free (s->digits);\r\n	free (s);\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (271,'#include \"long.h\"\r\n#include \"functions.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint compare (struct long_int* a, struct long_int *b)\r\n{\r\n	int i;\r\n	if (a->length > b->length)\r\n		return 1;\r\n	if (a->length < b->length)\r\n		return -1;\r\n	for (i=a->length-1; i>=0; i--)\r\n		if (a->digits[i]>b->digits[i])\r\n			return 1;\r\n		else if (a->digits[i]<b->digits[i])\r\n			return -1;\r\n	return 0;\r\n}\r\n\r\nstatic void makenulld (int *d, int length)\r\n{\r\n	int i;\r\n	for (i=0; i<length; i++)\r\n		d[i] = 0;\r\n	return;\r\n}\r\nstruct long_int* add(struct long_int* a, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	int i, nmax, nmin, ind;\r\n	int buffer = 0;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 13\");\r\n		return s;\r\n	}\r\n	if (a->length >= b->length)\r\n	{\r\n		nmax = a->length;\r\n		nmin = b->length;\r\n		ind = 1;\r\n	}\r\n	else\r\n	{\r\n		nmax = b->length;\r\n		nmin = a->length;\r\n		ind = 2;\r\n	}\r\n	d = malloc (sizeof(int)*(nmax+1));\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 14\");\r\n		exit (0);\r\n	}\r\n	makenulld (d, nmax+1);\r\n	for (i=0; i<nmax; i++)\r\n	{\r\n		if (i<nmin)\r\n		{\r\n			d[i] = (a->digits)[i] + (b->digits)[i];\r\n			d[i] += buffer;\r\n			if (d[i] >= D) // TODO: constant in .h file\r\n			{\r\n				d[i] -= D;\r\n				buffer = 1;\r\n			}\r\n			else \r\n				buffer = 0;\r\n		}\r\n		else \r\n		{\r\n			if (ind == 1)\r\n			{\r\n				d[i] = (a->digits)[i] + buffer;\r\n				buffer = 0;\r\n			}\r\n			else\r\n			{\r\n				d[i] = (b->digits)[i] + buffer;\r\n				buffer = 0;\r\n			}\r\n		}\r\n	}\r\n	if (buffer != 0) \r\n	{\r\n		d[i] = 1;\r\n	}\r\n	else\r\n		d[i] = 0;\r\n	s->digits = d;\r\n	s->length = nmax + 1;\r\n	s->sign = 0;\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\nstruct long_int* sub(struct long_int* a, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	int i, nmax, nmin, ind;\r\n	int buffer = 0;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 15\");\r\n		return s;\r\n	}\r\n	if (a->length >= b->length)\r\n	{\r\n		nmax = a->length;\r\n		nmin = b->length;\r\n		ind = 1;\r\n	}\r\n	else if (a->length < b->length)\r\n	{\r\n		nmax = b->length;\r\n		nmin = a->length;\r\n		ind = 2;\r\n	}\r\n\r\n	d = malloc (sizeof(int)*nmax);\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 16\");\r\n		exit (0);\r\n	}\r\n	makenulld (d, nmax);\r\n	if (ind == 1)\r\n	{\r\n		for (i=0; i<nmax; i++)\r\n		{\r\n			if (i<nmin)\r\n			{\r\n				d[i] = (a->digits)[i] - (b->digits)[i];\r\n				d[i] += buffer;\r\n				if (d[i] < 0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else \r\n						buffer = 0;\r\n			}\r\n			else \r\n			{\r\n					d[i] = (a->digits)[i] + buffer;\r\n					if (d[i]<0)\r\n					{\r\n						d[i] += D;\r\n						buffer = -1;\r\n					}\r\n					else\r\n						buffer = 0;\r\n			}\r\n		}\r\n		if (buffer == -1)\r\n		{\r\n			for (i=0; i<nmax; i++)\r\n			{\r\n				buffer = 0;\r\n				d[i] = (b->digits)[i] - (a->digits)[i];\r\n				d[i] += buffer;\r\n				if (d[i] < 0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else \r\n					buffer = 0;\r\n			}\r\n			s->sign = 1; \r\n		}\r\n		else \r\n			s->sign = 0;\r\n		s->digits = d;\r\n		s->length = nmax;\r\n	}\r\n	else\r\n	{\r\n		for (i=0; i<nmax; i++)\r\n		{\r\n			if (i<nmin)\r\n			{\r\n				d[i] = (b->digits)[i] - (a->digits)[i];\r\n				d[i] += buffer;\r\n				if (d[i] < 0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else \r\n					buffer = 0;\r\n			}\r\n			else \r\n			{\r\n				d[i] = (b->digits)[i] + buffer;\r\n				if (d[i]<0)\r\n				{\r\n					d[i] += D;\r\n					buffer = -1;\r\n				}\r\n				else\r\n					buffer = 0;\r\n			}\r\n		}\r\n		s->digits = d;\r\n		s->length = nmax;\r\n		if (buffer == -1)\r\n			s->sign = 0;\r\n		else \r\n			s->sign = 1;\r\n	}\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\n\r\n\r\n\r\nstruct long_int* shortmul(struct long_int* a, int b, int k)\r\n{\r\n	struct long_int *s;\r\n	int i;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 17\");\r\n		scanf(\"\\n\");\r\n		exit(1);\r\n	}\r\n	s->length = a->length+k+1;\r\n//	printf(\"after initialization: %d\\n\", s->length);\r\n	s->sign = a->sign;\r\n	d = malloc (sizeof(int)*(a->length+k+1));\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 18\");\r\n		exit(1);\r\n	}\r\n	makenulld (d, s->length);\r\n//	printf(\"max possible length: %d\\n\", a->length);\r\n	for (i=0; i<a->length; i++)\r\n	{\r\n		d[k+i] += a->digits[i] * b;\r\n		d[k+i+1] = d[k+i]/D;\r\n		d[k+i] %= D;\r\n	}\r\n	s->digits = d;\r\n//	printf(\"s->length: %d\\n\", s->length);\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\n\r\nstruct long_int* mul(struct long_int* a, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	int i,j;\r\n	int *d;\r\n	s = malloc (sizeof (struct long_int));\r\n	if (!s)\r\n	{\r\n		perror(\"malloc 19\");\r\n		return s;\r\n	}\r\n	d = malloc (sizeof(int)*(a->length + b->length));\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 20\");\r\n		return s;\r\n	}\r\n	makenulld (d, a->length + b->length);\r\n	for (i=0;i<(a->length + b->length);i++)\r\n		d[i] = 0;\r\n	for (i=0;i<a->length;i++)\r\n		for (j=0;j<b->length;j++)\r\n		{\r\n			d[i+j] += (a->digits[i])*(b->digits[j]);\r\n			if (d[i+j] >= D)\r\n			{\r\n				d[i+j+1] += d[i+j]/D;\r\n				d[i+j] = d[i+j]%D;\r\n			}\r\n		}\r\n	s->digits = d;\r\n	s->length = a->length + b->length;\r\n	if (a->sign + b->sign == 1)\r\n		s->sign = 1;\r\n	else \r\n		s->sign = 0;\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\nstatic void shift(struct long_int* a, struct long_int* b)\r\n{\r\n        int i;\r\n        for(i=0; i<a->length; i++)\r\n        {\r\n                if(i < b->length)\r\n                        a->digits[i] -= b->digits[i];\r\n                if(a->digits[i] < 0)\r\n                {\r\n                        a->digits[i] += D;\r\n                        a->digits[i+1]--;\r\n                }\r\n        }\r\n        while(a->length && a->digits[a->length-1] == 0)\r\n               a->length--;\r\n}\r\n\r\nstruct long_int* div1(struct long_int* x, struct long_int* b)\r\n{\r\n	struct long_int *s;\r\n	struct long_int *a;\r\n	int *d,i;\r\n	a = malloc (sizeof (struct long_int));\r\n	a->length = x->length;\r\n	a->sign = x->sign;\r\n	a->digits = malloc (sizeof (int) * x->length);\r\n	for (i=0;i<x->length;i++)\r\n		a->digits[i] = x->digits[i]; \r\n	s = malloc (sizeof (struct long_int));\r\n				if (!s) \r\n				{\r\n					perror(\"malloc 21\");\r\n					exit(1);\r\n				}\r\n	if (compare (a,b) == -1)\r\n	{\r\n		s->sign = 0;\r\n		s->length = 1;\r\n		d = malloc (sizeof (int));\r\n				if (!d) \r\n				{\r\n					perror(\"malloc 22\");\r\n					exit(1);\r\n				}\r\n		d[0] = 0;\r\n		s->digits = d;\r\n		free_int (a);\r\n		return (s);\r\n	}\r\n	s->length = a->length - b->length +1;\r\n	if (a->sign + b->sign == 1) \r\n		s->sign = 1;\r\n	else\r\n		s->sign = 0;\r\n	d = malloc (sizeof (int) * s->length);\r\n	if (!d)\r\n	{\r\n		perror(\"malloc 23\");\r\n		exit(1);\r\n	}\r\n	makenulld (d, s->length);\r\n	for (i=s->length-1;i>=0;i--)\r\n	{\r\n		struct long_int *pr;\r\n		int left = 0, right = D, mid;\r\n		do\r\n		{\r\n			int res;\r\n			mid = (left+right)/2;\r\n			pr = shortmul (b, mid, i);\r\n			res = compare (a, pr);\r\n			if (res == 1)\r\n			{\r\n				left = mid+1;\r\n				free_int (pr);\r\n			}\r\n			if (res == -1)\r\n			{\r\n				right = mid-1;\r\n				free_int (pr);\r\n			}\r\n			if (res == 0)\r\n			{\r\n				d[i] = mid;\r\n				shift (a, pr);\r\n				s->digits = d;\r\n				free_int (pr);\r\n				free_int (a);//////////////\r\n				while (s->length && s->digits[s->length-1] == 0)\r\n					s->length--;\r\n				return (s);\r\n			}\r\n		}\r\n		while (left <= right);\r\n		d[i] = mid = (left+right)/2;\r\n		pr = shortmul (b, mid, i);\r\n		shift (a, pr);\r\n		free_int (pr);\r\n	}\r\n	s->digits=d;\r\n	free_int (a);\r\n	while (s->length && s->digits[s->length-1] == 0)\r\n		s->length--;\r\n	return (s);\r\n}\r\nvoid Print (struct long_int* s)\r\n{\r\n	int printnow = 0, i;\r\n	if (s->sign == 1)\r\n		printf (\"-\");\r\n	for (i=(s->length)-1;i>=0;i--)\r\n	{\r\n		if (printnow == 1)\r\n		{\r\n			printf (\"%04d\", s->digits[i]);\r\n			continue;\r\n		}\r\n		if (s->digits[i] > 0)\r\n		{\r\n			printnow = 1;\r\n			printf (\"%d\", s->digits[i]);\r\n			continue;\r\n		}\r\n\r\n	}\r\n		if (!printnow)\r\n			printf (\"0\");\r\n		printf (\"\\n\");\r\n}\r\nvoid free_int (struct long_int *s)\r\n{\r\n	if (s->digits)\r\n		free (s->digits);\r\n	free (s);\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (272,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n#include \"functions.h\"\r\n#include \"list.h\"\r\n#include \"stack.h\"\r\n#include \"vars.h\"\r\n#include \"long.h\"\r\n\r\nint main ()\r\n{\r\n	Stack *st;\r\n	struct item *q;\r\n	struct list *p;\r\n	StackCreate (&st);\r\n	TableCreate();\r\n	do\r\n	{\r\n		List* polishform = PolishNotation(ScanInput());\r\n		while (!EmptyList (polishform))\r\n		{\r\n			p = polishform->head;\r\n			if (p->type == 1)\r\n			{\r\n				PushStack(p->data, p->type, st);\r\n				PopList (polishform);\r\n			}\r\n			else if (p->type == 2)\r\n			{\r\n				PushStack(p->data, p->type, st);\r\n				PopList (polishform);\r\n			}\r\n			else if (p->type == 3)\r\n			{\r\n				if (*(char*)p->data == \'=\')\r\n				{\r\n					q = st->top;\r\n					if (q->type == 1)\r\n					{\r\n						if (GetValue((char*)q->next->data))\r\n						{\r\n							free (GetValue((char*)q->next->data)->digits);\r\n							free (GetValue((char*)q->next->data));\r\n						}\r\n						SetValue((char*)q->next->data, GetValue((char*)q->data));\r\n						free (q->data);/////////////////////////\r\n					}\r\n					else \r\n					{\r\n						if (GetValue((char*)q->next->data))\r\n						{\r\n							free (GetValue((char*)q->next->data)->digits);\r\n							free (GetValue((char*)q->next->data));\r\n						}\r\n						SetValue((char*)q->next->data, (struct long_int *)q->data);\r\n					}\r\n					free (p->data);//////////////////////////\r\n					PopList (polishform);\r\n					PopStack (st);\r\n					free(st->top->data);/////////////////////\r\n					PopStack (st);\r\n				}\r\n				else\r\n				{\r\n					struct long_int *v;\r\n					struct long_int *asd;\r\n					struct long_int *val;\r\n					int point=0;\r\n					q=st->top;\r\n					if (*(char*)p->data == \'+\')\r\n					{\r\n						if (q->next->type == 1)\r\n							v = GetValue((char*)q->next->data);\r\n						else\r\n						{\r\n							v = q->next->data;\r\n							point = 1;\r\n						}\r\n						if (q->type == 1)\r\n						{\r\n							val = add(v,GetValue((char*)q->data));\r\n							if (point == 1)\r\n								free (v->digits);\r\n						}\r\n						else\r\n						{\r\n							val = add(v,q->data);\r\n							if (point == 1)\r\n								free (v->digits);\r\n							asd = q->data;\r\n							free (asd->digits);\r\n						}\r\n					}	\r\n					else if (*(char*)p->data == \'-\')\r\n					{\r\n						if (q->next->type == 1)\r\n							v = GetValue((char*)q->next->data);\r\n						else \r\n						{\r\n							v = q->next->data;\r\n							point = 1;\r\n						}\r\n						if (q->type == 1)\r\n						{\r\n							val = sub(v,GetValue((char*)q->data));\r\n							if (point == 1)\r\n								free (v->digits);\r\n						}\r\n						else\r\n						{\r\n							val = sub(v,q->data);\r\n							if (point == 1)\r\n								free (v->digits);\r\n							asd = q->data;\r\n							free (asd->digits);\r\n						}\r\n					}	\r\n					else if (*(char*)p->data == \'*\')\r\n					{\r\n						if (q->next->type == 1)\r\n							v = GetValue((char*)q->next->data);\r\n						else\r\n						{\r\n							v = q->next->data;\r\n							point = 1;\r\n						}\r\n						if (q->type == 1)\r\n						{\r\n							val = mul(v,GetValue((char*)q->data));\r\n							if (point == 1)\r\n								free (v->digits);\r\n						}		\r\n						else\r\n						{\r\n							val = mul(v,q->data);\r\n							if (point == 1)\r\n								free (v->digits);\r\n							asd = q->data;\r\n							free (asd->digits);\r\n						}\r\n					}	\r\n					else if (*(char*)p->data == \'/\')\r\n					{\r\n						if (q->next->type == 1)\r\n							v = GetValue((char*)q->next->data);\r\n						else\r\n						{\r\n							v = q->next->data;\r\n							point = 1;\r\n						}\r\n						if (q->type == 1)\r\n						{\r\n							val = div1(v,GetValue((char*)q->data));\r\n							if (point == 1)\r\n								free (v->digits);\r\n						}\r\n						else\r\n						{\r\n							val = div1(v,q->data);\r\n							if (point == 1)\r\n								free (v->digits);\r\n							asd = q->data;\r\n							free (asd->digits);\r\n						}\r\n					}		\r\n				        free (q->data);////////////\r\n					free (q->next->data);///////////\r\n					PopStack (st);\r\n					PopStack (st);\r\n					PushStack (val, 2, st);\r\n					free (p->data);/////////////////////////\r\n					PopList (polishform);\r\n				}\r\n			}\r\n		}\r\n		while (!EmptyStack(st))\r\n		{\r\n			if  (st->top->type == 1)\r\n			{\r\n				Print (GetValue((char*)st->top->data));\r\n				free (st->top->data);/////////////////////\r\n			}\r\n			else\r\n			{\r\n				Print (st->top->data);\r\n				free_int (st->top->data);/////////////////////\r\n			}\r\n			PopStack (st);\r\n		}\r\n		ListDel (polishform);\r\n		MakenullStack (st);\r\n	}\r\n	while (ch!=EOF);\r\n	StackDel (st);\r\n	cleanup();\r\n	return 0;\r\n} \r\n\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (273,'#include \"stack.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n// ????????? ?????\r\nvoid MakenullStack (Stack *st)\r\n{\r\n	struct item *p;\r\n	while (st->top)\r\n	{\r\n		p=st->top;\r\n		st->top = p->next;\r\n		free (p);\r\n	}\r\n}\r\n// ???????? ?????\r\nvoid StackCreate (Stack **st)\r\n{\r\n	*st = malloc (sizeof (struct item));\r\n				if (!*st) \r\n				{\r\n					perror(\"malloc 24\");\r\n					exit(1);\r\n				}\r\n	(*st)->top = NULL;\r\n}\r\n\r\n//  ????????? ???????? ?????????? ???????? ?????\r\nvoid *top (Stack *st)\r\n{\r\n	if (st->top)\r\n		return st->top->data;\r\n	else\r\n		return NULL;\r\n}\r\n// ???????? ?????????? ???????? ?? ?????\r\nvoid PopStack(Stack *st)\r\n{\r\n	struct item *p;\r\n	if (st->top == NULL)\r\n		return;\r\n	p=st->top;\r\n	st->top = p->next;\r\n 	if (p!=NULL)\r\n	{\r\n		free (p);\r\n	}\r\n}\r\n// ?????????? ???????? ? ????? ?????\r\nvoid PushStack (void *data1, int type1, Stack *st)\r\n{\r\n	struct item *p;\r\n	p = malloc (sizeof (struct item));\r\n	if (p)\r\n	{\r\n		p->data = data1;\r\n		p->type = type1;\r\n		p->next = st->top;\r\n		st->top = p;\r\n	}\r\n	else\r\n	{\r\n		perror(\"malloc 25\");\r\n	}\r\n}\r\n// ???????? ??????? ?????\r\nint EmptyStack (Stack *st)\r\n{\r\n	return (st->top == NULL);\r\n}\r\n// ???????? ?????\r\nvoid StackDel (Stack *st)\r\n{\r\n	if (st == NULL)\r\n		return;\r\n	while (!EmptyStack(st))\r\n		PopStack(st);\r\n	free (st);\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (274,'#include \"vars.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"functions.h\"\r\n#include <string.h>\r\n#include \"long.h\"\r\n\r\nstruct table *Table[128];\r\n\r\nunsigned int hash (char *str)\r\n{\r\n	unsigned char *p;\r\n	unsigned int res = 0;\r\n	for (p=(unsigned char *)str; *p!=0; p++)\r\n		res = (res * 37 + (*p));\r\n	return res%128;\r\n}\r\nvoid TableCreate (void)\r\n{\r\n	int i;\r\n	for (i=0; i<128; i++)\r\n		Table[i] = NULL;\r\n}\r\nvoid SetValue (char *string, struct long_int *value1)\r\n{\r\n	size_t length;\r\n	struct table *p;\r\n	unsigned int i = hash (string);\r\n	p = Table[i];\r\n	while (p)\r\n	{\r\n		if (!strcmp (p->name, string))\r\n		{\r\n			p->value = value1;\r\n			return;\r\n		}\r\n		p = p->next;\r\n	}\r\n	p = malloc (sizeof (struct table));\r\n				if (!p) \r\n				{\r\n					perror(\"malloc 26\");\r\n					exit(1);\r\n				}\r\n	p->next = Table[i];\r\n	Table[i] = p;\r\n	p->value = value1;\r\n	p->name = malloc (sizeof(char)*(length = strlen(string)+1));\r\n				if (!p->name) \r\n				{\r\n					perror(\"malloc 27\");\r\n					exit(1);\r\n				}\r\n	memcpy (p->name, string , length*sizeof (char));\r\n}\r\nstruct long_int* GetValue (char *name)\r\n{\r\n	struct table *p;\r\n	unsigned int i = hash (name);\r\n	p = Table[i];\r\n	while (p)\r\n	{\r\n		if (!strcmp (p->name, name))\r\n			return p->value;\r\n		p = p->next;\r\n	}\r\n	return 0;\r\n}\r\nvoid cleanup (void)\r\n{\r\n	struct table *p;\r\n	int i;\r\n	for (i=0;i<128;i++)\r\n	{\r\n		p = Table[i];\r\n		while (p)\r\n		{\r\n			Table[i] = Table[i]->next;\r\n			free_int (p->value);\r\n			free (p->name);\r\n			free (p);\r\n			p = Table[i];\r\n		}\r\n	}\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (275,'#include <stdlib.h>\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include \"functions.h\"\r\nchar *codes[256];\r\nint comp(const void *data1, const void *data2) // ????????? ???? ?????\r\n{\r\n	return ((*(Tree **)(void **)data1)->weight-(*(Tree **)(void **)data2)->weight); \r\n};\r\nTree *BuildHuffmanTree(int *count) // ?????????? ??????\r\n{\r\n	Tree *Arr[256];\r\n	int c=0;\r\n	for (c=0; c<256; ++c)\r\n	{\r\n		Tree *item;\r\n		Arr[c]=item=(Tree *)malloc(sizeof(Tree));\r\n		item->c=c;\r\n		item->left=Arr[c]->right=NULL;\r\n		item->weight=count[c];\r\n	};\r\n	c=0;\r\n	qsort(Arr, 256, sizeof(Tree *), comp);\r\n	while(c<256 && !Arr[c]->weight)\r\n	{\r\n		free(Arr[c]);\r\n		c++;\r\n	}\r\n	if (c==256)\r\n		return NULL;\r\n	while(c<255)\r\n	{\r\n		Tree *item=Arr[c];\r\n		int p=c+1;\r\n		while(p<256 && Arr[p]->weight<item->weight)\r\n		{\r\n			Arr[p-1]=Arr[p];\r\n			p++;\r\n		}\r\n		Arr[p-1]=item;\r\n		item=(Tree *)malloc(sizeof(Tree));\r\n		item->left=Arr[c];\r\n		item->right=Arr[c+1];\r\n		item->weight=Arr[c]->weight+Arr[c+1]->weight;\r\n		item->c=-1;\r\n		Arr[++c]=item;\r\n	}\r\n	return Arr[255];\r\n};\r\nvoid MakeCodes(Tree *item, char *code, int h) // ???????? ????\r\n{\r\n	if(item->c==-1)\r\n	{\r\n		code[h+1]=0;\r\n		code[h]=\'0\';\r\n		MakeCodes(item->left, code, h+1);\r\n		code[h]=\'1\';\r\n		MakeCodes(item->right, code, h+1);\r\n		code[h]=0;\r\n	}\r\n	else\r\n	{\r\n		codes[item->c]=malloc(sizeof(char)*(h+1));\r\n		strcpy(codes[item->c], code);\r\n	}\r\n	free(item);\r\n};\r\nvoid DestroyTree(Tree *item)\r\n{\r\n	if(item->c==-1)\r\n	{\r\n		DestroyTree(item->left);\r\n		DestroyTree(item->right);\r\n	}\r\n	free(item);\r\n};\r\nvoid Encode(char *in, FILE *fout)\r\n{\r\n	unsigned char buf[BLOCK_SIZE], obuf[BLOCK_SIZE], c, w=0, *str;\r\n	char mask[8]={128, 64, 32, 16, 8, 4, 2, 1}, code[256];\r\n	int count[256], j=0, bufcnt=0;\r\n	FILE *fin=fopen(in, \"rb\");\r\n	size_t size, cnt, len=0;\r\n	Tree *HuffmanTree;\r\n\r\n	fwrite(in, sizeof(char), strlen(in)+1, fout);\r\n	for (cnt=0; cnt<256; ++cnt)\r\n	{\r\n		count[cnt]=0;\r\n		codes[cnt]=NULL;\r\n	}\r\n\r\n	do\r\n	{\r\n		size=fread(buf, sizeof(char), BLOCK_SIZE, fin);\r\n		cnt=0;\r\n		while(cnt<size)\r\n		{\r\n			c=buf[cnt++];\r\n			++count[c];\r\n		}\r\n	} while(size==BLOCK_SIZE);\r\n		\r\n	HuffmanTree=BuildHuffmanTree(count);\r\n	if(!HuffmanTree) // ???? ????\r\n	{\r\n		fwrite(&len, sizeof(len), 1, fout);\r\n		fwrite(count, sizeof(int), 256, fout);\r\n		fclose(fin);\r\n		return;\r\n	}\r\n	if(HuffmanTree->c!=-1) // ? ????? 1 ??????\r\n	{\r\n		fwrite(&len, sizeof(len), 1, fout);\r\n		fwrite(count, sizeof(int), 256, fout);\r\n		free(HuffmanTree);\r\n		fclose(fin);\r\n		return;\r\n	}\r\n	\r\n	MakeCodes(HuffmanTree, code, 0);\r\n	for (cnt=0;cnt<256;++cnt)\r\n		if(codes[cnt])\r\n			len+=strlen(codes[cnt])*count[cnt];\r\n	fwrite(&len, sizeof(len), 1, fout);\r\n	fwrite(count, sizeof(int), 256, fout);\r\n\r\n	rewind(fin); // ??????????? ???? ? ??????\r\n	do\r\n	{\r\n		size=fread(buf, sizeof(char), BLOCK_SIZE, fin);\r\n		cnt=0;\r\n		while(cnt<size)\r\n		{\r\n			str=codes[buf[cnt++]];\r\n			while(c=*str++)\r\n			{\r\n				if(c==\'1\')\r\n					w=w|mask[j];\r\n				if(++j==8)\r\n				{\r\n					obuf[bufcnt++]=w;\r\n					j=w=0;\r\n					if(bufcnt==BLOCK_SIZE)\r\n					{\r\n						fwrite(obuf, sizeof(unsigned char), BLOCK_SIZE, fout);\r\n						bufcnt=0;\r\n					}\r\n				}\r\n			}\r\n		}	\r\n	} while(size==BLOCK_SIZE);\r\n	if(j) // ???? ????????? ???? ?? ????????\r\n		obuf[bufcnt++]=w;\r\n	fwrite(obuf, sizeof(unsigned char), bufcnt, fout);\r\n\r\n	for (cnt=0;cnt<256;++cnt)\r\n		free(codes[cnt]);\r\n	fclose(fin);\r\n};\r\nvoid Decode(FILE *fin) // ?????????????\r\n{\r\n	char OutFile[256], *p=OutFile, c, buf[BLOCK_SIZE], obuf[BLOCK_SIZE];\r\n	int count[256], nbyte, os, size, cnt, j, ocnt=0, len;\r\n	char mask[8]={128, 64, 32, 16, 8, 4, 2, 1};\r\n	Tree *HuffmanTree, *item;\r\n	FILE *fout;\r\n\r\n	do\r\n	{\r\n		fread(&c, sizeof(char), 1, fin);\r\n		*p++=c;\r\n	} while(c!=0);\r\n	*p=0;\r\n	fout=fopen(OutFile, \"wb\");\r\n	fread(&len, sizeof(len), 1, fin);\r\n	fread(count, sizeof(int), 256, fin);\r\n	item=HuffmanTree=BuildHuffmanTree(count);\r\n\r\n	if(!HuffmanTree)\r\n		return;\r\n	if(HuffmanTree->c!=-1)\r\n	{\r\n		int i=HuffmanTree->weight, k=HuffmanTree->c;\r\n		memset(obuf, 256*256*256*k+256*256*k+256*k+k, BLOCK_SIZE);\r\n		do\r\n		{\r\n			fwrite(obuf, sizeof(char), k=(i>BLOCK_SIZE)?BLOCK_SIZE:i, fout);\r\n			i-=BLOCK_SIZE;\r\n		} while(k==BLOCK_SIZE);\r\n		free(HuffmanTree);\r\n		return;\r\n	}\r\n\r\n	nbyte=len/8;\r\n	os=len%8;\r\n	\r\n	do\r\n	{\r\n		size=(nbyte>BLOCK_SIZE)?BLOCK_SIZE:nbyte;\r\n		nbyte-=BLOCK_SIZE;\r\n		fread(buf, sizeof(char), size, fin);\r\n		cnt=0;\r\n		while(cnt<size)\r\n		{\r\n			c=buf[cnt++];\r\n			for(j=0;j<8;j++)\r\n			{\r\n				item=((c&mask[j])==mask[j])?item->right:item->left;\r\n				if(item->c!=-1)\r\n				{\r\n					obuf[ocnt++]=item->c;\r\n					if(ocnt==(BLOCK_SIZE))\r\n					{\r\n						fwrite(obuf, sizeof(char), BLOCK_SIZE, fout);\r\n						ocnt=0;\r\n					}\r\n					item=HuffmanTree;\r\n				}\r\n			}\r\n		}\r\n	} while(size==BLOCK_SIZE);\r\n	if(os) // ???????? ????\r\n	{\r\n		fread(&c, sizeof(char), 1, fin);\r\n		for(j=0;j<os;j++)\r\n		{\r\n			item=((c&mask[j])==mask[j])?item->right:item->left;\r\n			if(item->c!=-1)\r\n			{\r\n				obuf[ocnt++]=item->c;\r\n				if(ocnt==(BLOCK_SIZE))\r\n				{\r\n					fwrite(obuf, sizeof(char), BLOCK_SIZE, fout);\r\n					ocnt=0;\r\n				}\r\n				item=HuffmanTree;\r\n			}\r\n		}\r\n	}\r\n	fwrite(obuf, sizeof(char), ocnt, fout);\r\n	fclose(fout);\r\n\r\n	if(HuffmanTree)\r\n		DestroyTree(HuffmanTree);\r\n};\r\n\r\n\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (276,'#include \"functions.h\"\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n\r\nint main (int argc, char* argv[])\r\n{\r\n	FILE *fin, *fout;\r\n	printf (\"Print: Huffman.exe -add name_of_file name_of_archive //for archiving\\nPrint: Huffman.exe -unpack name_of_archive //for unzipping\\n\");\r\n 	if (argc < 2)\r\n	{\r\n		printf (\"Not enaugh arguments\\n\");\r\n		return 0;\r\n	}\r\n	if (!strcmp (\"-add\", argv[1]))\r\n	{\r\n		if (argc > 4)\r\n		{\r\n			printf (\"Too much arguments\\n\");\r\n			return 0;\r\n		}\r\n		if (argc < 4)\r\n		{\r\n			printf (\"Not enaugh arguments\\n\");\r\n			return 0;\r\n		}\r\n		fin = fopen (argv[3], \"rb\");\r\n		if (!fin)\r\n		{\r\n			printf (\"Can not open file\");\r\n			return 0;\r\n		}\r\n		fout = fopen (argv[2], \"wb\");\r\n		fclose (fin);\r\n		Encode (argv[3], fout);\r\n		fclose(fout);\r\n		return 0;\r\n	}\r\n	if (!strcmp (\"-unpack\", argv[1]))\r\n	{\r\n		if (argc > 3)\r\n		{\r\n			printf (\"Too much arguments\\n\");\r\n			return 0;\r\n		}\r\n		if (argc < 3)\r\n		{\r\n			printf (\"Not enaugh arguments\\n\");\r\n			return 0;\r\n		}\r\n		fin = fopen (argv[2], \"rb\");\r\n		if (!fin)\r\n		{\r\n			printf (\"Can not open file\");\r\n			return 0;\r\n		}\r\n		Decode (fin);\r\n		fclose (fin);\r\n		return 0;\r\n	}\r\n	printf (\"unknown command\");\r\n	return 0;\r\n}','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (277,'#include <stdio.h>\n\nlong f(long a, long b)\n{\n	return (a + b);\n}\n\nint main()\n{\n	long a = 0;\n	long b = 1;\n	long tmp = 0;\n	int flag = 0;\n\n	scanf(\"%d\", &flag);\n	\n	for(int i = 0; i < flag; i++)\n	{\n		printf(\"%d\\n\", f(a, b));\n		tmp = a;\n		a = b;\n		b = f(tmp, b);\n	}\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (278,'#include <stdio.h>\nint main()\n{\n	int a,b,c,d,e,r;\n	int N=7;\n	a=0;\n	b=1;\n	for (r=0;r<N;r++)\n	{\n	d=a;\n	a=b;\n	b=b+d;\n	printf (\"%d\\n\",b);\n	}\n	\n	return (0);\n}\n\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (279,'#include <stdio.h>\n\nint f(int a, int b)\n{\n	int tmp = 0;\n	if(a % b == 0)\n		return b;\n	else\n	{\n		while(a % b != 0)\n		{\n			tmp = b;\n		 	b = a % b;\n			a = tmp;\n		}\n		return b;\n	}\n}\n\nint main()\n{\n	int x, y = 0;\n	scanf(\"%d %d\", &x, &y);\n	printf(\"%d\\n\",	f(x, y));\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (280,'#include <stdio.h>\nint main ()\n{\nint a,b,c,d,e,f;\na=10;\nb=7;\ne=1;\nwhile (e!=0)\n{\n	if (a>b)\n{\n	c=a;\n	d=b;\n}\nelse \n{\n	c=b;\n	d=a;\n}\n	e=c%d;\n	a=d;\n	b=e;\n	}\nprintf (\"%d\\n\",d);\n\nreturn (0);\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (281,'#include <stdio.h>\nint main()\n{\n	int N, f0 = 0,f1 = 1, f, i ;\n	printf(\"N=\") ;\n	scanf(\"%d\" ,&N) ;\n	for(i = 0 ; i < N ; i++)\n	{ \n//		if(i == 0) printf(\"0 \") ;\n//		if(i == 1) printf(\"1 \") ;\n//		else\n		{\n			printf(\"%d \", f0) ;\n			f = f0 + f1 ;\n			f0 = f1 ;\n			f1 = f ;\n		}\n	}\n\n	return 0;\n\n}\n\n\n\n\n	\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (282,'#include <stdio.h>\n\nint main()\n{\n	int n, a1=1, a2=0, a3;\n\n	scanf(\"%d\", &n);\n	for (n; n>=1; n--)\n		{\n			printf(\"%d \", a1);\n			a3 = a1 + a2;\n			a2 = a1;\n			a1 = a3;\n		}\n\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (283,'\n#include <stdio.h>\nint main()\n{\n	int n,i,x=0,y=1,t,f;\n	printf(\" Enter n:\");\n	scanf(\"%d\",&n);\n	\n        printf(\"1\\n\");\n	for (i=2; i<=n; i++)\n	{\n		f=x+y;\n		x=y;\n		y=f;\n		printf(\"%d\\n\",f);\n	}\n	return 0;\n	\n	       \n	\n}		\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (284,'#include <stdio.h>\nint main()\n{\n	int a=0,b=0;\n	printf(\" Vvedite pervoe chislo: \");\n	scanf(\"%d\",&a);\n	printf(\" Vvedite vtoroe chislo: \");\n	scanf(\"%d\",&b);\n	while(a!=0 && b!=0)\n	{\n	  if (a>b) a=a%b;\n	     else\n		   b=b%a;\n	}\n	printf(\" NOD= %d\\n\",a+b);\n	return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (285,'#include <stdio.h>\nint main ()\n{\n	int a,b,c,d,e,f;\n	scanf(\"%d%d\", &a, &b);\n	e=1;\n	while (e!=0)\n	{\n		if (a>b)\n		{\n			c=a;\n			d=b;\n		}\n		else \n		{\n			c=b;\n			d=a;\n		}\n		e=c%d;\n		a=d;\n		b=e;\n	}\n	printf (\"%d\\n\",d);\n	return (0);\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (286,'#include <stdio.h>\n\nint main()\n{\n	int a=0;\n	int b=1;\n	int c;\n	int n;\n	int i;\n	printf(\"??????? N\\n\");\n	scanf(\"%d\",&n);\n	if(n>0)\n	{\n		printf(\"??? ??? ???????? ?? %d ?????????\\n\",n);\n		printf (\"%d \\n%d \\n\",a,b);\n		for(i=3;i<=n;i++)\n		{\n			c=a+b;\n			a=b;\n			b=c;\n			printf(\"%d\\n\",b);\n		}\n	}\n	else printf(\"n ?????? ???? ?? ????? 3?\\n\");\n	return(0);\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (287,'#include <stdio.h>\n\nint main()\n{\n	int a,b,c;\n	\n	printf(\"??????? ??? ?????\\n\");\n	scanf(\"%d%d\",&a,&b);\n/*	if(b>=a)\n	{\n		c=a;\n		a=b;\n		b=c;\n	}*/\n	while(a%b!=0)\n	{\n		c=b;\n		b=a%b;\n		a=c;\n	}\n	printf(\"?????????? ????? ????????? ???????? ????? - %d\\n\",b);\n	\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (288,'#include <stdio.h>\nint main ()\n{\n	int a=0, b=1,N,c,i;\n	scanf(\"%d\",&N);\n	for(i=0;i<N;i++)\n	{\n		printf(\"%d \",a);\n		c=a+b;\n		a=b;\n		b=c;\n	}\n	printf(\"\\n\");\n	return 0;\n}\n\n\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (289,'#include <stdio.h>\n#include <math.h>\n\nfloat a = 0;\nfloat b = 0;\n\nfloat f(float x)\n{\n	return sin(x); \n}\n\nfloat delta(float a, float b)\n{\n	if(a > b)\n		return a - b;\n	return b - a;\n}\n\nbool sign(float a)\n{\n	if(a <= 0)\n		return 1;\n	return 0;\n}\n\nint main()\n{\n	scanf(\"%f\", &a);\n	scanf(\"%f\", &b);\n	bool signA = sign(f(a));\n	bool signB = sign(f(b));\n	\n	if(signA == signB)\n	{\n		printf(\"No solution\\n\");\n		return 0;\n	}\n\n	while(delta(a, b) >= 0.002)\n	{\n		float m = (a + b) / 2;\n		bool signM = sign(f(m));\n		if(signA != signM)\n		{\n			b = m;\n			signB = signM;\n		}\n		else\n		{\n			a = m;\n			signB = signM;\n		}\n	}\n	\n	printf(\"%f, %f -> %f\\n\", a, b, (a + b) / 2);\n	return 0;\n}\n\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (290,'#include <stdio.h>\nint main()\n{\n	long  pred=1, tek=1,n;\n	printf(\"Enter N: \");\n	scanf(\"%d\",&n);\n	do\n	{\n		printf(\"%d \",pred);\n		tek=pred+tek;\n		pred=tek-pred;\n		n--;\n	} while (n>0);\n	return 0;\n\n\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (291,'\n\n#include <stdio.h>\n\n	\n\nint main()\n{   int a=0,b=1,c,n,i;\n    scanf (\"%d\",&n);\n    for (i=1;i<n;i++)\n    {       c=a+b;\n	    a=b;\n	    b=c;\n	    printf(\"%d \", c);\n    }\n\nreturn 0; \n}	 \n\n\n\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (292,'#include<stdio.h>\nint main()\n{\n	int n=10, a1=0, a2=1, b, i;\n\n	for ( i=0 ; i < n; i++)\n	{\n		printf(\"%d \",a1);\n		b=a1+a2;\n		a1=a2;\n		a2=b;\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (293,'#include <stdio.h>\n#include <math.h>\n\n#define EPS 0.00001\n\nfloat f (float x )\n{\n	return (sin(x));\n}\nint main ( )\n{\n	float m ;\n	float a = 6 ;\n	float b = 7 ;\n	if ( f(a)*f(b) > 0 )\n		printf ( \"??? ??????\" ) ;\n	else\n	{\n		do	\n		{\n			m = ( a + b ) / 2;\n			printf(\"%f %f %f\\n\", a, b, m);\n			printf(\"%f %f %f\\n\", f(a), f(b), f(m));\n			if ((f(a)>0&&f(m)<0)||(f(a)<0&&f(m)>0)) \n				b=m;\n			//if (f(m)>0&&f(b)<0||f(m)<0&&f(b)>0)\n			else\n				a=m;\n		}\n		while(fabs(f(m)) > EPS);\n		printf (\"%.4f\\n\", m);\n	}\n	return 0;\n}\n\n\n		\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (294,'#include <stdio.h>\n\nint main()\n{\n	int a, b;\n\n	scanf(\"%d%d\", &a, &b);\n	\n	while (a != 0 && b != 0)\n	{	\n		if (a >= b)\n			a = a%b;\n		else b = b%a;\n	}\n	printf(\"%d\", a+b);\n\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (295,'#include <stdio.h>\nint main()\n{\n	int a=0,b=1,c,i,n;\n	printf(\"Vvedite kol-vo 4isel\\n\");\n	scanf(\"%d\",&n);\n	for(i=0;i<n;i++)\n	{\n		printf(\"%d \",a);\n		c=a+b;\n		a=b;\n		b=c;\n	}\nreturn 0;	\n}\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (296,'#include <stdio.h>\nint main()\n{\n	int a,b,s;\n	scanf(\"%d%d\", &a, &b);\n	if(a%b==0) printf(\"%d\",b);\n	else\n	{\n		do\n		{\n			s=a%b;\n			a=b;\n			b=s;\n		}\n		while(s!=0);\n		printf(\"%d\\n\", a);\n	}\n	return 0;\n}\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (297,'#include<stdio.h>\nint main()\n{\n	int x = 100, y = 41;\n	//scanf(\"%d%d\", &x, &y);\n	while (x != 0 && y != 0)\n	{\n		if (x >= y)\n		x=x%y;\n		else y=y%x;\n	}\n	printf(\"%d\\n\",x+y);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (298,'#include <stdio.h>\n#include <math.h>\n\n#define EPS 0.0001\n\nfloat f(float x)\n{\n	return sin(x);\n}\n\nint main()\n{\n	float a=6;\n	float b=7;	\n	printf(\"%f %f\\n\",a,b);\n	printf(\"%f %f\\n\",f(a),f(b));\n	if( ( (f(a)>0) && (f(b)>0) ) || ( (f(a)<0) && (f(b)<0) ) )\n		printf(\"??? ??????? 1\\n\");\n	else \n	{\n		while( ( fabs(f((a+b)/2)) > EPS ) && (b-a>EPS))\n		{\n			if(( (f(a)>0) && (f((a+b)/2)>0) ) || ( (f(a)<0) && (f((a+b)/2)<0) ))\n				a=(a+b)/2;\n			else \n				b=(a+b)/2;\n		}\n		if(fabs(f((a+b)/2)) <= EPS)\n			printf(\"%f \\n\",(a+b)/2);\n		else\n			printf(\"??? ??????? 2\\n\");\n	}\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (299,'#include <stdio.h>\nint main()\n{\n	int a,b,nod,temp;\n	printf(\"Enter A and B:\\n\");\n	scanf(\"%d%d\",&a,&b);\n	while(a%b!=0)	\n	{\n		temp=a;\n		a=b;\n		b=temp%b;\n		\n	}\n	nod=b;\n	printf(\"NOD= %d\",nod);\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (300,'#include <stdio.h>\n#include <math.h>\n\nfloat a = 6;\nfloat b = 7;\nfloat l = 0;\nint i;\nfloat y,r,e;\nfloat f(float x)\n{\n	return (-sin(x));\n}\nint main()\n{\n	if (f(a)*f(b)>0)\n	{\n		printf (\"no\");\n		return 0;\n	}\n	\n		while ((b-a)>0.002)\n		{\n			l=(a+b)/2;\n	if (f(a)*f(l)>0)\n	{\n		a=l;\n	}\n		if (f(b)*f(l)>0)\n		{\n			b=l;\n		}\n	\n		}		\n	\n	printf (\"%f\",l);\n	return (0);\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (301,'#include <stdio.h>\n#include <math.h>\n\n#define EPS 0.002\n\nfloat a; \nfloat b;\nfloat s=0;\n\nfloat f(float x)\n{\n	return (sin(x));\n}\n\nint main()\n{\n	printf(\"Vvedite granicy: \");\n	scanf(\"%f %f\", &a,&b);\n	if ((f(a)*f(b))>0) \n	 {\n		printf(\"Net korney\\n\");\n		return 0;\n	 }\n	  while ((b-a)>EPS)\n	    {\n		s=(a+b)/2;\n		if ((f(a)*f(s))>0) a=s;\n			else b=s;\n			\n	    } \n	printf(\"%f\\n\",s);\n	return 0;\n}\n			\n			\n			\n			\n	\n	\n\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (302,'#include <stdio.h>\n#include <math.h>\n\nconst float EPS = 0.001;\n\nfloat f(float x)\n{	\n	return (x*x - 5);\n}\n\nint main()\n{\n	float a, b, m;\n\n	scanf(\"%f%f\", &a, &b);\n	\n	while ( (fabs(f(a)) > EPS) && (fabs(f(b)) > EPS) )\n	{	m = (a + b)/2;\n		printf(\"a: %f, b: %f\\n\", a, b);\n		if (f(a)*f(m)>=0)\n			a = m;\n		else b = m;\n	}\n	if ( fabs(f(a)) <= EPS)	\n		printf(\"%f\\n\", a);\n	else\n		printf(\"%f\\n\", b);\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (303,'#include <stdio.h>\nint is_prime(int x)\n{\n	int i;\n	for (i=2;i*i<=x;i++)\n	{\n		if (x%i==0)\n			return 0;\n	}\n	return 1;\n}\n\nint main ()\n{\n	int i,y,a,l=0,N,A[100];\n	FILE*F=fopen(\"input.txt\",\"r\");\n	fscanf (F,\"%d\",&N);\n	for (i=0;i<N;i++)\n	{\n		fscanf (F,\"%d\",&y);\n		A[i]=y;\n		printf (\"%d\\n\",A[i]);\n	}\n	for (a=0;a<N;a++)\n	{\n		if (is_prime(A[a]))\n		{\n			l++;\n			if (l==N)\n				break;\n		}\n	}\n	if (l==N)\n	{\n		printf (\"vse elemti - prostie\\n\");\n	}\n	else \n	{\n		printf (\"%d - prostie\\n\",l);\n	}	\n	fclose(F);\n	return (0);\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (304,'#include <stdio.h>\n#include <math.h>\n\nfloat f(float x)\n{\n	return(x*x-2);\n}\nint main()\n{\n	float a=0;\n	float b=3;\n	float ser=(a+b)/2;\n	if (f(a)*f(b)>0) printf(\"Korney net!\");\n	else while (fabs(f(ser))>0.001)\n	{\n		printf(\"a: %f, b: %f\\n\", a, b);\n		if (f(a)*f(ser)>0) a=ser;\n		else if (f(b)*f(ser)>0) b=ser;\n		ser=(a+b)/2;\n	}\n	printf(\"%.03f\\n\",ser);\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (305,'#include <stdio.h>\nint main()\n{\n	int x,y;\n	printf(\"Vvedite pervoe 4islo\\n\");\n	scanf(\"%d\",&x);\n	printf(\"Vvedite vtoroe 4islo\\n\");\n	scanf(\"%d\",&y); \n	while (x!=0 && y!=0)\n		if (x>y)	\n			x=x%y;\n		else \n			y=y%x;\n	printf(\"%d\\n\",x+y);\n	return 0; 	\n} \n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (306,'#include <stdio.h>\nint main ()\n{\n	int N,z,m,l,r,a,b,y,g,c,i,B[100],A[100];\n	int p,o,k;\n	FILE*F=fopen(\"input.txt\",\"r\");\n	fscanf (F,\"%d\",&N);\n	for (i=0;i<N;i++)\n	{\n		fscanf(F,\"%d\",&y);\n		A[i]=y;\n	}\n	printf (\"vvedite kol-vo chisel\");\n	scanf (\"%d\" ,&b);\n	for (i=0;i<b;i++)\n	{\n		scanf (\"%d\",&z);\n		B[i]=z;\n	}\n	for (g=0;g<b;g++)\n	{\n		l=0;\n		r=N-1;\n		for (i=0;i<N;i++)\n		{\n			if (l>r)\n			{\n				printf (\"net - %d\\n\",B[g]);\n				break;\n			}\n			m=(r+l)/2;\n			if (B[g]==A[m])\n			{\n				printf (\"da - %d\\n\",A[m]);\n				break;\n			}\n			if (B[g]<A[m])\n			{\n				r=m-1;\n			}\n			else\n			{\n				l=m+1;\n			}\n		}\n	}\n	fclose(F);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (307,'#include <stdio.h>\n\nint main()\n{\n	int i;\n	int a;\n	int b;\n	int c;\n	int n;\n	n=15;\n	a=0;\n	b=1;\n	for(i=1;i<n;i++)\n	{\n		c=a+b;\n		a=b;\n	        b=c;\n		printf(\"%d\\n\",c);\n	}   \n	return 0;\n}\n\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (308,'#include<stdio.h>\n\n#define EPS 0.001\n\nfloat f(float x)\n{\n	return(x*x-2);\n}\n\nint main()\n	\n{\n	float a = 0;\n	float b = 3;\n	float c;\n	\n	/*\n	1. ???? ???? f(a) ? f(b) ????????? -- ?????? ???, ?????\n	2. ???? b-a > EPS, ????????? ???????? ??????? ?\n		???????, ? ????? ???????? ??????? ?????? (?? ??????)\n		? ?????? ???? a, ???? b\n	*/\n	if(f(a)>0 && f(b)>0) return 0;\n	if(f(a)<0 && f(b)<0) return 0;\n	while (b-a > EPS) \n	{\n		c = (a+b)/2;\n		if (f(c)*f(a)>0) a=c;\n		if (f(c)*f(b)>0) b=c;\n		\n	}\n	printf(\"%f\\n\",c);\n	return 0;	\n	\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (309,'#include <stdio.h>\nint is_prime(int x)\n{\n	int i;\n	int a;\n	for(i=2;i*i<=x;i++)\n	{\n		if(x%i==0) return 0;\n	}\n	return 1;\n}\n\nint main()\n{\n	FILE *f;\n	int a[4];\n	int i;\n	int k=0;\n	f=fopen(\"input.txt\",\"r\");\n	for(i=0;i<4;i++)\n		fscanf(f,\"%d \",&a[i]);\n	fclose(f);\n	for(i=0;i<4;i++)\n	{\n		if (is_prime(a[i])==1) k++;\n	}\n	if(k==4) printf(\"Vse prostye!\\n\");\n	\n	for(i=0;i<4;i++)\n		if(is_prime(a[i])==0) \n		{\n			printf(\"Est\' ne prostye\\n%d\\n\",a[i]);\n			break;\n		}\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (310,'#include <stdio.h>\n\nint isprime(int x)\n{\n	int i;\n	for(i=2;i*i<=x;i++)\n		if(x%i==0)return 0;\n	return 1;\n}\n\nint main()\n{\n	FILE *f;\n	int a [7];\n	int i;\n	int pr1=0,pr2=0;\n	f=fopen(\"input.txt\",\"r\");\n	for(i=0;i<7;i++)\n		fscanf(f,\"%d \",&a[i]);\n	for(i=0;i<7;i++)\n		printf(\"%d\\n\",a[i]);\n	i=0;\n	while( (i<7)&&((pr1!=1)||(pr2!=1)) ) \n	{\n		if(isprime(a[i])==1)\n			pr1=1;\n		else\n			pr2=1;\n		i++;\n	}\n	fclose(f);\n	\n	if(pr1==1)\n		printf(\"??????? ????? ????\\n\");\n	else		\n		printf(\"??????? ????? ???\\n\");\n	if(pr2==1)\n		printf(\"?? ??? ????? ???????\\n\");\n	else		\n		printf(\"??? ????? ???????\\n\");\n	\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (311,'#include <stdio.h>\n#include <math.h>\n\nint date1()\n{\n	int i, day1, mon1, y1, a;\n	int kd1 = 0;\n\n	scanf(\"%d%d%d\", &day1, &mon1, &y1);\n	for (i=1; i<y1; i++)\n	{\n		if ( i%400==0 || (i%4 ==0 && i%100!=0) )\n			kd1 += 366;\n		else kd1 += 365;\n	}\n	for (i=1; i<mon1; i++)\n	{\n		switch (mon1)\n		{\n			case 1:\n			case 3:\n			case 5:\n			case 7:\n			case 8:\n			case 10:\n			case 12:\n				kd1 += 31;\n				break;\n			case 4:\n			case 6:\n			case 9:\n			case 11:\n				kd1 += 30;\n				break;\n			case 2:\n			{	\n				if ( y1%400==0 || (y1%4 ==0 && y1%100!=0) )\n					 kd1 += 29;\n				else kd1 += 28;\n			\n			}\n		}\n	}\n	kd1 += day1;\n	\n	return kd1;\n}\n\nint main()\n{\n	int x;\n	\n	x = abs(date1() - date1()) + 1;\n	printf(\"%d\\n\", x);\n\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (312,'#include <stdio.h>\n#define con 0.002\nfloat f(float x)\n{\n	{\n		return(x*x-2);\n	}\n}\nint main()	\n{\n	float a,b,k;\n	printf(\"Vvedite koord\\n \");\n	scanf(\"%f %f\",&a,&b);\n	if (f(a)*f(b)>0) \n	{\n		printf(\"net korney\\n\");\n		return 0; \n	}\n	while (b-a>con)\n	{\n		k=(a+b)/2;\n		if (f(a)*f(k)>0) a=k;\n	     	else b=k;	\n	}\n	printf(\"%f\\n\", k);\n	return 0;	\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (313,'#include <iostream>\r\n\r\n\r\nclass string\r\n{\r\nprivate:\r\n        char *data;\r\n        int d;\r\npublic:\r\n\r\n    string(char *s1) // ??????????? ??????\r\n        {\r\n                d=length(s1);\r\n                char *q = new char[d+1];\r\n                data=q;\r\n                while (((*q++) = (*s1++)) != \'\\0\') ;\r\n        }\r\n\r\n        string()       // ??????????? ?????? ??????\r\n        {\r\n                d=0;\r\n                data = new char[1];\r\n                *data=0;\r\n        }\r\n\r\n        string (const string& s1) // ???????????\r\n        {\r\n                char *e = s1.data;\r\n                data = new char[s1.d+1];\r\n                d=s1.d;\r\n                char *t=data;\r\n                while (((*t++) = (*e++)) != \'\\0\') ;\r\n        }\r\n\r\n        /*char* getString () // ????????? ?????? ??? ??????\r\n        {\r\n                return data;\r\n        }*/\r\n\r\n        string operator= (const string& s1) // ???????? ????????????\r\n        {\r\n                delete[] data;\r\n                d=s1.d;\r\n                data = new char[s1.d+1];\r\n                char *e=s1.data;\r\n                char *t=data;\r\n                while (((*t++) = (*e++)) != \'\\0\') ;\r\n                return *this;\r\n        }\r\n\r\n        operator const char*() // ?????????? ? ???? ????????? ?????????\r\n        {\r\n                return (const char*)data;\r\n        }\r\n\r\n        ~string()  // ??????????\r\n        {\r\n                delete[] data;\r\n                std::cout <<\"Destructer\\n\";\r\n        }\r\n\r\n        int length(char *s1) // ????? ??????\r\n        {\r\n                int k=0;\r\n                while (*s1++) k++;\r\n                return k;\r\n        }\r\n\r\n\r\n\r\n\r\n};\r\n\r\nint main()\r\n{\r\n        string h; // ???????? ???????????? ?????? ??????\r\n        std::cout << h <<\"\\n\";\r\n        char *p = \"sadfsd\";\r\n        string s(p); // ???????? ??????????? ??????\r\n        std::cout << s <<\"\\n\" ;\r\n        string w=s; // ??????? ???????????\r\n        std::cout << w <<\"\\n\";\r\n        char *q = \"fgfgfg\";\r\n\r\n        string r(q);\r\n        r=w; // ???????? ????????????\r\n\r\n        std::cout << r <<\"\\n\"; // ????? ????????? ?????????? ? ???? ????????? ?????????\r\n        return 0;\r\n}\r\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (314,'#include <iostream>\r\n#include <cstring>\r\n\r\nint length(char *s1) // ????? ??????\r\n        {\r\n                int k=0;\r\n                while (*s1++) k++;\r\n                return k;\r\n        }\r\n\r\nclass string\r\n{\r\nprivate:\r\n        char *data;\r\n        int d;\r\npublic:\r\n\r\n    string(char *s1) // ??????????? ??????\r\n        {\r\n                d=length(s1);\r\n                char *q = new char[d+1];\r\n                data=q;\r\n                while (((*q++) = (*s1++)) != \'\\0\') ;\r\n        }\r\n\r\n        string()       // ??????????? ?????? ??????\r\n        {\r\n                d=0;\r\n                data = new char[1];\r\n                *data=0;\r\n        }\r\n\r\n        string (const string& s1) // ???????????\r\n        {\r\n                char *e = s1.data;\r\n                data = new char[s1.d+1];\r\n                d=s1.d;\r\n                char *t=data;\r\n                while (((*t++) = (*e++)) != \'\\0\') ;\r\n        }\r\n\r\n        /*char* getString () // ????????? ?????? ??? ??????\r\n        {\r\n                return data;\r\n        }*/\r\n\r\n        string operator= (const string& s1) // ???????? ????????????\r\n        {\r\n                if (&s1 != this)\r\n                {\r\n                        delete[] data;\r\n                        d=s1.d;\r\n                        data = new char[s1.d+1];\r\n                        char *e=s1.data;\r\n                        char *t=data;\r\n                        while (((*t++) = (*e++)) != \'\\0\') ;\r\n                        return *this;\r\n                }\r\n                {\r\n                        return *this;\r\n                }\r\n        }\r\n\r\n        string operator+ (const string& s1)\r\n        {\r\n                char *t = new char [d + s1.d+1];\r\n                strcpy (t, data);\r\n                strcpy (t+d, s1.data);\r\n                return t;\r\n        }\r\n\r\n        string operator+= (const string& s1)\r\n        {\r\n                char *q = data;\r\n                char *g;\r\n                g = new char[d+s1.d+1];\r\n                strcpy (g,q);\r\n                strcpy (g+d,s1.data);\r\n                d = d+s1.d;\r\n                delete[] data;\r\n                data=g;\r\n                return *this;\r\n        }\r\n\r\n        operator const char*() // ?????????? ? ???? ????????? ?????????\r\n        {\r\n                return (const char*)data;\r\n        }\r\n\r\n        ~string()  // ??????????\r\n        {\r\n                delete[] data;\r\n                std::cout <<\"Destructer\\n\";\r\n        }\r\n};\r\n\r\nint main()\r\n{\r\n        string h; // ???????? ???????????? ?????? ??????\r\n        std::cout << h <<\"\\n\";\r\n        char *p = \"sadfsd\";\r\n        string s(p); // ???????? ??????????? ??????\r\n        std::cout << s <<\"\\n\" ;\r\n        string w = s; // ??????? ???????????\r\n        std::cout << w <<\"\\n\";\r\n        char *q = \"fgfgfg\";\r\n\r\n        string r(q);\r\n        r = w; // ???????? ????????????\r\n        r = r; // ???????? ???????????? ???? a = a\r\n        std::cout << r <<\"\\n\"; // ????? ????????? ?????????? ? ???? ????????? ?????????\r\n        string r1(q);\r\n        string r2;\r\n        r2 = r1 + r; // ??????? ????????? +\r\n        std::cout << r2 <<\"\\n\";\r\n        string r3(p);\r\n        r3+=r1; // ??????? ????????? +=\r\n        std::cout << r3 <<\"\\n\";\r\n\r\n        return 0;\r\n}\r\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (315,'#include <stdio.h>\n\nint main()\n{\n	int month[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};	\n	\n	int a[6];\n	long int i;\n	\n	FILE *f;\n\n	f=fopen(\"date.txt\",\"r\");\n	for(i=0;i<6;i++)\n		fscanf(f,\"%d \",&a[i]);\n	\n	if( (a[0]%400==0) || ((a[0]%4==0) && (a[0]%100!=0)) )\n		month[2]=29;\n	\n	i=1;\n	\n	while( (a[0]!=a[3]) || (a[1]!=a[4]) || (a[2]!=a[5]) )\n	{\n		a[2]++;\n		i++;\n		if(a[2]>month[a[1]])\n		{\n			a[2]=1;\n			a[1]++;\n			if(a[1]>12)\n			{\n				a[0]++;\n				a[1]=1;\n				if( (a[0]%400==0) || ((a[0]%4==0) && (a[0]%100!=0)) )\n					month[2]=29;\n				else\n					month[2]=28;\n			}\n				\n		}\n	}\n	\n	printf(\"????? ?????? %d ????\\n\",i);\n	fclose(f);\n	\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (316,'#include <stdio.h>\nint isprime(int a)\n{\n	int i;\n	for (i=2; i*i<=a; i++)\n	{\n		if (a%i==0)\n			return 0;\n	}\n	return 1;\n}\nint main()\n{\n	int i,x,c=0,n,A[100];\n	FILE*f=fopen(\"input.txt\",\"r\");\n	fscanf(f,\"%d\",&n);\n	for (i=0; i<n; i++)\n	{\n		fscanf(f,\"%d\",&x);\n	        A[i]=x;\n	}\n	 for (i=0; i<n; i++)\n	 {\n		 if (isprime(A[i]))\n				 c++;\n	 }\n	 if (c==n) printf(\"Vse prostye\\n\");\n	 else \n	      {\n		 printf(\"Ne vse prostye\\n\");\n		 if (c!=0) printf(\"Est xotaby odno prostoe\\n\");\n	      }\n			 \n  return 0;\n}  \n\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (317,'#include <stdio.h>\nint main()\n{\n	int a[5]={1, 3, 5, 7, 9};\n	int n,l,v,m,k,r;\n	printf(\"Kakoe chislo ishem ?\\n\");\n	scanf(\"%d\", &k);\n	l=0;\n	r=5-1;\n	while (l <= r)\n	{\n		    m=(l+r)/2;\n		    if (a[m]==k) \n			    printf(\"Chislo naideno, ego nomer= %d\\n\",m);\n		          if (k<a[m]) \n				  r=m-1;\n			         else \n					 l=m+1;\n	}\n\n\n		return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (318,'#include <stdio.h>\n\nbool isPrime(int a)\n{\n	for(int i = 2; i * i <= a; i++)\n	{\n		if(a % i == 0)\n		{\n			printf(\"%d divide by %d\\n\", a, i);\n			return 0;\n		}\n		else\n		{\n			printf(\"%d !divide by %d\\n\", a, i);\n		}\n	}\n	return 1;\n}\n\nint main()\n{\n	FILE * Input = fopen(\"i\", \"r\");\n	FILE * Output = fopen(\"o\", \"w\");\n	\n	int arr[200];\n	int n = 0;\n	bool all = true, one = false;\n	bool q = false, w = false;\n	\n	fscanf(Input, \"%d\", &n);\n	for(int i = 0; i < n && (!q || !w); i++)\n	{\n		fscanf(Input, \"%d\", &arr[i]);\n		if(isPrime(arr[i]))\n		{\n			printf(\"%d is prime\\n\", arr[i]);\n			one = true;\n			w = true;\n		}\n		else\n		{\n			printf(\"%d is !prime\\n\", arr[i]);\n			all = false;\n			q = true;\n		}\n	}\n\n	if(all)\n		fprintf(Output, \"1) true\\n\");\n	else\n		fprintf(Output, \"1) false\\n\");\n	if(one)\n		fprintf(Output, \"2) true\\n\");\n	else\n		fprintf(Output, \"2) false\\n\");\n\n	fclose(Input);\n	fclose(Output);\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (319,'#include <stdio.h>\nfloat f(float x)\n{\n	return (x*x-5.0);\n};\nint main()\n{\n	int i; 	float a=0.0,b=3.0,temp=a+0.001,pred=a;\n	if (a*b>0) \n	{\n		printf(\"Not solution\\n\");\n	} else\n		if (a<=b)\n		while (temp<=b)\n		{\n			if(f(temp)*f(pred)<0)	printf(\"%f\\n\",temp);\n			temp=temp+0.001;\n			pred=pred+0.001;\n		\n		}\n		if (a>b)\n		{\n		temp=a-0.001;\n		pred=a;\n		while (temp>=b)\n		{\n			if(f(temp)*f(pred)<0) printf(\"%f\\n\",temp);\n			temp=temp-0.001;\n			pred=pred+0.001;\n		}\n		}\n		\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (320,'#include <stdio.h>\nint  change(int d1,int d2,int m1,int m2,int y1,int y2)\n{\n	if (y1>y2) return 1;\n		else if(y1<y2) return 0;\n	if (m1>m2) return 1;\n		else if(m1<m2) return 0;\n	if (d1>d2) return 1;\n		else if(d1<d2) return 0;	\n}\nint main()\n{\n	char s1[9],s2[9],s3[9]; int m1,m2,d1,d2,y1,y2,i=0,temp;\n	int months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n	printf(\"First date:  \"); scanf(\"%s\",s1);\n	printf(\"Second date: \"); scanf(\"%s\",s2);\n	d1=(s1[0]-\'0\')*10+s1[1]-\'0\';\n	d2=(s2[0]-\'0\')*10+s2[1]-\'0\';\n	m1=(s1[3]-\'0\')*10+s1[4]-\'0\';\n	m2=(s2[3]-\'0\')*10+s2[4]-\'0\';\n	y1=(s1[6]-\'0\')*1000+(s1[7]-\'0\')*100+(s1[8]-\'0\')*10+s1[9]-\'0\';\n	y2=(s2[6]-\'0\')*1000+(s2[7]-\'0\')*100+(s2[8]-\'0\')*10+s2[9]-\'0\';\n	if (change(d1,d2,m1,m2,y1,y2)==1)\n	{\n		temp=d1; d1=d2; d2=temp;\n		temp=m1; m1=m2; m2=temp;\n		temp=y1; y1=y2; y2=temp;\n	}\n	//printf(\"%d %d %d %d %d %d\\n\",d1,d2,m1,m2,y1,y2);\n	while(d1!=d2||m1!=m2||y1!=y2)\n	{\n		d1++;	\n		if(d1>months[m1]+((m1==2)&&((y1%4==0&&y1%100!=0)||(y1%400==0)))){d1=1;m1++;}\n		if (m1>12){m1=1;d1=1; y1++;}\n		//printf(\"%d-%d--%d)\",months[m1]+((y1%4==0||y1%400==0)&&(y1%100!=0)),d1,m1);\n		i++;		\n	}\n	printf(\"Count of days: %d\\n\",i+1);\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (321,'#include<stdio.h>\nint isprime(int a)\n{\n	int i;\n	if (a==1) \n		return 0;\n	for (i=2;i*i<=a;i++) \n		if (a%i==0) \n			return 0;\n	return 1;\n}\nint main()\n{\n	int i, N=6,a,f1=0,f2=0;\n	FILE* inp=fopen(\"input.txt\",\"r\");\n	for(i=1;i<=N;i++)\n	{\n		fscanf(inp,\"%d\",&a);\n		if (isprime(a)) \n			f1=1; \n		else \n			f2=1;\n	}\n	if (f2!=1) \n		printf(\"VSE PROSTYE\\n\"); \n	else if (f1==1) \n		printf(\"PROSTYE PRISUTSTVUYUT\\n\"); \n	else \n		printf(\"PROSTYH NET\\n\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (322,'#include <stdio.h>\nint main()\n{\n	int a=100;\n	int b=40;\n	int nodab;\n	int k=1;\n	while (k==1)\n	{\n		if (a%b==0)\n	        {\n		nodab=b;\n	        printf(\"naibolsii delitel %d\\n\",nodab);\n		k=2;	\n		}\n		else \n	        {	\n		int t = a;\n		a=b;\n		b=t%b;\n	        }\n	}\n	return 0;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (323,'#include <stdio.h>\nint main(){\n	int s[256],i,m=0,N=0,p=1;\n        for(i=0;m!=\'\\n\';)\n	{\n		m=getchar();\n  	      if((m!=\' \')&&(m!=\'.\')&&(m!=\',\')&&(m!=\'\\n\'))\n				{\n					s[i]=m;\n					N++;\n				        i++;\n				}\n	}\n	for(i=0;i<=N/2;i++)\n	{\n		printf(\"%c <-> %c\\n\", s[i], s[N-i-1]);\n		if(s[i]!=s[N-i-1]){\n			printf(\"bad \\n\");\n			p=0;\n			break;\n		}\n	}\n	if(p)\n		printf(\"Yes \\n\");\n	else \n		printf(\"No \\n\");\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (324,'#include <stdio.h>\n	\nint arr[200] = {0};\nint c[200] = {0};\nint N = 0;\n\nint compare(int a)\n{\n	int l = 0;\n	int r = 0;\n	l = 0;\n	r = N - 1;\n	while (l <= r)\n	{\n		int m = (l + r) / 2;\n		if(a < arr[m])\n		{\n			printf(\"R %d -> %d\\n\", r, (l + r) / 2);\n			r = (l + r) / 2 - 1;\n		}\n		else if (a > arr[m])\n		{\n			printf(\"L %d -> %d\\n\", l, (l + r) / 2);\n			l = (l + r) / 2 + 1;\n		}\n		else\n		{\n			return m;\n		}\n	}	\n	return (-1);\n}\n\nint main()\n{\n	FILE * I = fopen(\"i\", \"r\");\n	FILE * O = fopen(\"o\", \"w\");\n	\n	int N2 = 0;\n\n	fscanf(I, \"%d\", &N);\n	\n	for(int i = 0; i < N; i++)\n		fscanf(I, \"%d\", &arr[i]);\n	\n	fscanf(I, \"%d\", &N2);\n	\n	for(int i = 0; i < N2; i++)\n		fscanf(I, \"%d\", &c[i]);\n\n	for(int i = 0; i < N2; i++)\n	{\n		if(-1 != compare(c[i]))\n			printf(\"+\\n\");\n		else\n			printf(\"-\\n\");\n	}\n\n	fclose(I);\n	fclose(O);\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (325,'#include <stdio.h>\r\n         \r\nint is_prime(int a)\r\n{\r\n    int i;\r\n    \r\n    for (i=2; i*i<=a; i++) {\r\n        if (a%i == 0) {\r\n                return 0;\r\n                break;\r\n        }\r\n    }\r\n    return 1;        \r\n}\r\n\r\nmain()\r\n{\r\n      int i, n, a = 0, x[100];\r\n      \r\n      freopen(\"input.txt\", \"rt\", stdin);\r\n      freopen (\"output.txt\", \"wr\", stdout);\r\n      scanf(\"%d\", &n);\r\n            \r\n      for (i=0; i<n; i++) {\r\n          scanf(\"%d\", &x[i]);\r\n      }\r\n      \r\n      for (i=0; i<n; i++) {\r\n          if (is_prime(x[i])) a++;\r\n      }\r\n      \r\n      if (a>0) {\r\n               	if (a==n) printf(\"All elements contained in array are prime\\n\");\r\n      		else printf(\"At least one element contained in array is prime\\n\");\r\n      }\r\n\r\n      printf(\"a = %d\\n\", a);\r\n      \r\n      return 0;\r\n}   \r\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (326,'#include<stdio.h>\nint isprime(int a)\n{\n	int i;\n	int f=1;\n	for (i=2; i*i<=a; i++)\n	{\n		if (a%i==0)\n		{f=0; break;}\n	}\n	if(f==1) return 1;\n	return 0;\n}\n\nint main()\n{\n	int A[5] = { 7, 7, 7, 19, 7 },i,n = 5,a=0;\n	printf(\"n: %d\\n\", n);\n	\n	for(i=0; i<n; i++)\n	{\n		if (isprime(A[i])) a++;\n	}\n	\n	if (a==5) printf(\"??? ????? ???????\\n\");\n	if (a>0 && a<5) printf(\"???? ??????? ?????\\n\");\n\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (327,'#include <stdio.h>\n\nint main()\n{\n	int d1=1;\n	int m1=1;\n	int g1=1988;\n	int d2=31;\n	int m2=12;\n	int g2=1988;\n	int days[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n	int kol1=0;\n	int kol2=0;\n	int res;\n	int s=0;\n	int z=0;\n	int i;\n	kol1=g1*365+g1/4 - g1/100 + g1/400 + d1;\n	kol1=kol1+s;\n	for(i=0;i<m1;i++)\n		kol1+=days[i];\n	kol2=g2*365+ g2/4 - g2/100 + g2/400 + d2;\n	if (((g2%4==0 && g2 % 100 != 0) || (g2 % 400 == 0)) && m2>=3) kol2++;\n	for(i=0;i<m2;i++)\n		kol2+=days[i];\n	kol2=kol2+z;\n	res=kol2-kol1+1;\n	if(res>0) printf(\"%d\\n\",res);\n	else printf(\"%d\\n\",-res);\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (328,'#include <iostream>\r\n#include <cstring>\r\n#include <stdexcept>\r\n\r\nint length(char *s1) // ????? ?????? \r\n	{\r\n		int k=0;\r\n		while (*s1++) k++;\r\n		return k;\r\n	}\r\n\r\nclass string\r\n{\r\nprivate:\r\n	char *data;\r\n	int d; \r\npublic:\r\n\r\n    string(char *s1) // ??????????? ??????\r\n	{\r\n		d=length(s1);\r\n		char *q = new char[d+1];\r\n		data=q;\r\n		while (((*q++) = (*s1++)) != \'\\0\') ;\r\n	}\r\n\r\n	string()       // ??????????? ?????? ??????\r\n	{\r\n		d=0;\r\n		data = new char[1];\r\n		*data=0;\r\n	}\r\n\r\n	string (const string& s1) // ???????????\r\n	{\r\n		char *e = s1.data;\r\n		data = new char[s1.d+1];\r\n		d=s1.d;\r\n		char *t=data;\r\n		while (((*t++) = (*e++)) != \'\\0\') ;\r\n	}\r\n\r\n	/*char* getString () // ????????? ?????? ??? ??????\r\n	{\r\n		return data; \r\n	}*/\r\n\r\n	string& operator= (const string& s1) // ???????? ????????????\r\n	{\r\n		if (&s1 != this)\r\n		{\r\n			delete[] data;\r\n			d=s1.d;\r\n			data = new char[s1.d+1];\r\n			char *e=s1.data;\r\n			char *t=data;\r\n			while (((*t++) = (*e++)) != \'\\0\') ;\r\n			return *this;\r\n		}\r\n		{\r\n			return *this;\r\n		}\r\n	}\r\n\r\n	string operator+ (const string& s1) // ???????? +\r\n	{\r\n		char *t = new char [d + s1.d+1];\r\n		strcpy (t, data);\r\n		strcpy (t+d, s1.data);\r\n		string result(t);\r\n		delete[] t;\r\n		return result;\r\n	}\r\n\r\n	string& operator+= (const string& s1) // ???????? +=\r\n	{\r\n		char *q = data;\r\n		char *g;\r\n		g = new char[d+s1.d+1];\r\n		strcpy (g,q);\r\n		strcpy (g+d,s1.data);\r\n		d = d+s1.d;\r\n		delete[] data;\r\n		data = g;\r\n		return *this;\r\n	}\r\n\r\n	char operator[] (const int index) const // ???????? ?????? ????????\r\n	{\r\n		if ((index <= d-1)&&(index >= 0))\r\n		{ \r\n			std::cout <<\"Constantnii []\\n\";\r\n			return data[index];\r\n		} \r\n		else\r\n		{\r\n			throw std::runtime_error(\"nema takoga indexa!!!!!!\");\r\n		}\r\n	}\r\n\r\n	char& operator[] (const int index) // ????????? ????????? ? ??????\r\n	{\r\n		if ((index<=d-1)&&(index >= 0))\r\n		{ \r\n			std::cout <<\"Ssilochnii []\\n\";\r\n			return data[index];\r\n		} else\r\n		{\r\n			throw std::out_of_range(\"nema takoga indexa!!!!!!\");\r\n		}\r\n	}\r\n\r\n	operator const char*() // ?????????? ? ???? ????????? ?????????\r\n	{\r\n		return (const char*)data;\r\n	}\r\n\r\n	~string()  // ??????????\r\n	{\r\n		delete[] data;\r\n		//std::cout <<\"Destructer\\n\";\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	string h; // ???????? ???????????? ?????? ??????\r\n	std::cout << h <<\"\\n\";\r\n	char *p = \"sadfsd\";\r\n	string s(p); // ???????? ??????????? ??????\r\n	std::cout << s <<\"\\n\" ;\r\n	string w = s; // ??????? ???????????\r\n	std::cout << w <<\"\\n\";\r\n	char *q = \"fg\";\r\n	\r\n	string r(q);\r\n	r = w; // ???????? ????????????\r\n	r = r; // ???????? ???????????? ???? a = a\r\n	std::cout << r <<\"\\n\"; // ????? ????????? ?????????? ? ???? ????????? ?????????\r\n	string r1(q);\r\n	string r2;\r\n	r2 = r1 + r; // ??????? ????????? +\r\n	std::cout << r2 <<\"\\n\"; \r\n	string r3(p);\r\n	(r3=r2)+=r1; // ??????? ????????? +=\r\n	std::cout << r3 <<\"\\n\";\r\n	const string r4(q);\r\n	std::cout <<r4[1] <<\"\\n\"; // ????????????? ???????????\r\n	string r5(q);\r\n	std::cout <<r5[1] <<\"\\n\"; // ????????????? ??????????\r\n	r5[1] = \'d\'; // ????????????? ??????????\r\n	std::cout <<r5[1] <<\"\\n\"; // ????????????? ??????????\r\n	const string &k = r5; // ????????????? ???????????\r\n	std::cout <<k[0] <<\"\\n\";\r\n	return 0;\r\n}\r\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (329,'#include <iostream>\r\n#include <conio.h>\r\nclass String{\r\n		char* s;\r\n	public:\r\n		String(){\r\n			s=new char;\r\n			s[0]=0;\r\n			}\r\n		String(char* c){\r\n			int k;\r\n			for (k=0; c[k]!=0; k++);\r\n			s=new char[k+1];\r\n			for (k=0; c[k]!=0; k++){\r\n				s[k]=c[k];\r\n				}\r\n			s[k]=0;\r\n			}\r\n		String(const String& s0){\r\n			int k;\r\n			for (k=0; s0.s[k]!=0; k++);\r\n			s=new char[k+1];\r\n			for (k=0; s0.s[k]!=0; k++){\r\n				s[k]=s0.s[k];\r\n				}\r\n			s[k]=0;\r\n			}\r\n		~String(){\r\n			delete[] s;\r\n			}\r\n		String operator=(const String& s0){\r\n			if (&s0 == this)\r\n				return *this;\r\n			delete[] s;\r\n			int k;\r\n			for (k=0; s0.s[k]!=0; k++);\r\n			s=new char[k+1];\r\n			for (k=0; s0.s[k]!=0; k++){\r\n				s[k]=s0.s[k];\r\n				}\r\n			s[k]=0;\r\n			return *this;\r\n			}\r\n		String operator=(const char* s0){\r\n			delete s;\r\n			int k;\r\n			for (k=0; s0[k]!=0; k++);\r\n			s=new char[k+1];\r\n			for (k=0; s0[k]!=0; k++){\r\n				s[k]=s0[k];\r\n				}\r\n			return *this;\r\n			}\r\n		String operator+(const String& s0){\r\n			String result;\r\n			int k,l;\r\n			for (l=0; s[l]!=0; l++);\r\n			for (k=0; s0.s[k]!=0; k++, l++);\r\n			l++;\r\n			result.s=new char[l];\r\n			for (l=0; s[l]!=0; l++){\r\n				result.s[l]=s[l];\r\n				}\r\n			for (k=0; s0.s[k]!=0; k++){\r\n				result.s[k+l]=s0.s[k];\r\n				}\r\n			result.s[k+l]=0;\r\n			return result;\r\n			}\r\n		String operator+=(const String& s0){\r\n			/*String s1=*this;\r\n			delete s;\r\n			int k,l;\r\n			for (l=0; s1.s[l]!=0; l++);\r\n			for (k=0; s0.s[k]!=0; k++, l++);\r\n			l++;\r\n			s=new char[l];\r\n			for (l=0; s1.s[l]!=0; l++){\r\n				s[l]=s1.s[l];\r\n				}\r\n			for (k=0; s0.s[k]!=0; k++){\r\n				s[k+l]=s0.s[k];\r\n				}\r\n			s[k+l]=0;\r\n			return *this;*/\r\n			*this = *this + s0;\r\n			return *this;\r\n			}\r\n		char operator[](int k) const{\r\n			std::cout << \"const char operator\\n\";\r\n			return s[k];\r\n			}\r\n		char& operator[](int k){\r\n			std::cout << \"char& operator\\n\";\r\n			return this->s[k];\r\n			}\r\n		void print(){\r\n			int k;\r\n			for (k=0; s[k]!=0; k++){\r\n				std::cout << s[k];\r\n				}\r\n			std::cout << \"\\n\";\r\n			}\r\n		operator const char *() const\r\n		{\r\n			return s;\r\n		}\r\n	};\r\nint main(){\r\n	String s1 = \"abc\";\r\n	const String s2 = \"def\";\r\n\r\n	s1 = s1 + s1;\r\n	s1 += s1;\r\n\r\n	std::cout << s2[0] << \"\\n\";\r\n\r\n	std::cout << \"s1: \" << s1 << \", s2: \" << s2 << \"\\n\";\r\n\r\n	return 0;\r\n	}','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (330,'#include<iostream>\r\n\r\n\r\nclass String\r\n{\r\n		char *data;\r\n		int lenght;\r\n	public:\r\n		String()//??????????? ?? ?????????\r\n		{\r\n			data=new char[1];\r\n			data[0]=0;\r\n			lenght=0;\r\n			std::cout<<\"??????????? ?? ?????????\\n\";\r\n		};\r\n		String(char*s)//??????????? ? ?????????? char*\r\n		{\r\n			int i=0;\r\n			lenght=strlen(s);  \r\n			data=new char[lenght+1];\r\n			strcpy(data,s);\r\n			std::cout<<\"??????????? ? ?????????? char*\\n\";\r\n		};\r\n		String(const String &orig)//??????????? ???????????\r\n		{\r\n			lenght=orig.lenght;\r\n			data=new char[lenght+1];\r\n			strcpy(data,orig.data);\r\n			int i=0;\r\n			std::cout<<\"??????????? ???????????\\n\";\r\n		};\r\n		~String()//??????????\r\n		{\r\n				std::cout<<\"??????????\\n\";\r\n				delete[]data;\r\n	\r\n		};\r\n		String& operator=(const String &orig)//???????? ????????????\r\n		{	\r\n			if(this==&orig)\r\n			{\r\n				std::cout<<\"???????? ????????????\\n\";\r\n				return  *this;\r\n			}\r\n			delete[]data;\r\n			lenght=orig.lenght;\r\n			data=new char[lenght+1];\r\n			std::cout<<\"???????? ????????????\\n\";\r\n			return *this; // a = b = c;\r\n			// ?? ????? ???????? a = a;\r\n		};\r\n		operator char*() const//???????? ?????????? ????\r\n		{\r\n			std::cout<<\"???????? ?????????? ????\\n\";\r\n			return data;	\r\n		};\r\n		\r\n};','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (331,'#include <iostream>\r\n#include <locale.h>\r\nusing namespace std;\r\n\r\nclass String\r\n{\r\nprivate:\r\n       int length;\r\n       char *n;\r\npublic:\r\n        String() //??????????? ??? ?????????, ?????? ??????\r\n        {\r\n			length = 0;\r\n			n = new char[1];\r\n			*n = 0;\r\n			std::cout << \"\\n???????? @ ???????\";\r\n        }\r\n\r\n		String(const char *t) //??????????? ? char *, ??????\r\n		{\r\n			int i=0;\r\n			for (i;t[i];i++)\r\n				;\r\n			length=i;\r\n			n = new char[length+1];\r\n			for (i=0;t[i];i++)\r\n				n[i]=t[i];\r\n			n[i]=0;\r\n			std::cout << \"\\n???????? @ ???????: \";\r\n			print();\r\n		}\r\n\r\n		String(const String &t) //??????????? ??????????? ??????\r\n		{\r\n			int i=0;\r\n			length=t.len();\r\n			n = new char[length+1];\r\n			for (i=0;t.n[i];i++)\r\n				n[i]=t.n[i];\r\n			n[i]=0;\r\n			std::cout << \"\\n???????? @ ???????: \";\r\n			print();\r\n		}\r\n\r\n		~String() // ??????????\r\n		{\r\n			std::cout << \"\\n????? @ ??????: \";\r\n			print();\r\n			delete[] n;\r\n		}\r\n\r\n		operator char*() const\r\n		{\r\n			return n;\r\n		}\r\n\r\n		void print() const\r\n        {\r\n			for (int i=0;n[i];i++)    \r\n				std::cout << n[i];\r\n        }\r\n\r\n		int len() const\r\n		{\r\n			return length;\r\n		}\r\n\r\n		String operator+(const String &t) const // ????????????\r\n        {\r\n			String result;\r\n			result.n = new char [length + t.len() + 1];\r\n			int i=0,p;\r\n			for (i=0;n[i];i++)\r\n				result.n[i] = n[i];\r\n			p=i;\r\n			for (i=0;t.n[i];i++)\r\n				result.n[i+p] = t.n[i];\r\n			result.n[i+p] = 0;\r\n			result.length = i+p;\r\n			\r\n			std::cout << \"\\n???????? @ ??? \";\r\n			print();\r\n			std::cout << \" ? ??? \";\r\n			t.print();\r\n			std::cout << \" ??????? \";\r\n			result.print();\r\n            return result;\r\n        }\r\n\r\n		String& operator=(const String &t) //????????????\r\n		{\r\n			int i;\r\n			std::cout << \"\\n????????\";\r\n			String result(t);\r\n			delete[] n;\r\n			n = new char [result.len()+1];\r\n			for (i=0;result.n[i];i++)\r\n				n[i] = result.n[i];\r\n			n[i]=0;\r\n			length = i; \r\n			return *this; // a = b = c = d;\r\n		}\r\n\r\n		String& operator+=(const String &t) // +=)\r\n        {\r\n			std::cout << \"\\n?????? @ ????????\";\r\n		/*	int i=0;\r\n			for (i=0;t.n[i];i++)\r\n				n[i+length] = t.n[i];\r\n			length+=t.len();*/\r\n			*this = *this + t;\r\n			return *this;\r\n		}\r\n\r\n		char const operator[](const int i) const // []\r\n        {\r\n			std::cout << \"\\n???????? @ CONST \";\r\n			return n[i];\r\n        }\r\n\r\n		char & operator[](const int i) // char&\r\n        {\r\n			std::cout << \"\\n???????? @ UNCONST \";\r\n			return n[i];\r\n        }\r\n\r\n};\r\n\r\n\r\n\r\nint main()\r\n{\r\n	setlocale(LC_ALL, \"Russian\");\r\n\r\n	String a1,a2,a3; //???????? ?????? ??????\r\n	String b(\"qwerty\"); //???????? ???????????? ?? char*\r\n	String c(b); //???????? ????????????\r\n\r\n	a1 = b;\r\n	a2 += b;\r\n	a3 = b + c;\r\n\r\n	char* t1 = b;\r\n	std::cout << \"\\nt1 = \" << t1;\r\n	char t2 = b[3];\r\n	std::cout << \"\\nb[3] = \" << t2; //????????? ?? ???????\r\n	b[3] = \'W\';\r\n	std::cout << \"\\nb[3] = \" << b[3];\r\n	\r\n	const String cs(\"abc\");\r\n	std::cout << \"cs[0] = \" << cs[0] << \"\\n\";\r\n\r\n	a1 = a1;\r\n	std::cout << \"\\na1 = \" << a1 << \"\\n\";\r\n\r\n//	t1[3] = 0;\r\n//	std::cout << t1;\r\n\r\n	return 0;\r\n}\r\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (332,'#include <stdio.h>\n#define N 5 \nint binom(int x)\n{\n	int a[N]={1,3,5,7,9};\n	int l=0;\n	int r=N-1;\n	int m=(l+r)/2;\n	do\n	{\n		if(x==a[m]) return 1;\n		if(x>a[m]) l=m+1;\n		else r=m-1;\n		m=(l+r)/2;\n	}\n	while(l<=r);\n	return 0;\n}\n\nint main()\n{\n	int x;\n	scanf(\"%d\",&x);\n	if(binom(x)==0) printf(\"Net \\n\");\n	else printf(\"Est\'\\n \");\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (333,'#include <stdio.h>\nint main()\n{\n	int days[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n	int i=0,d1,d2,m1,m2,y1,y2,dat1=0,dat2=0,f=0;\n	printf(\"Vvedite pervuy daty: \\n\");\n	scanf(\"%d %d %d\", &d1, &m1, &y1);\n	printf(\"Vvedite vtoruy daty: \\n\");\n	scanf(\"%d %d %d\", &d2, &m2, &y2);\n        if ( (y1%4==0 && y1%100!=0) || y1%400==0 ) \n		if (m1 <= 2)\n		{\n			printf(\"1-? ??????????\\n\");\n			dat1--;\n		}\n	if ((((y2%4==0) && (y2%100)!=0)) || ((y2%400)==0)) \n		if (m2 >= 3 || (m2 == 2 && d2 >= 29))\n			dat2++;\n	dat1=365*y1+y1/4-y1/100+y1/400+d1;\n	dat2=365*y2+y2/4-y2/100+y2/400+d2;\n	 for (i=0;i<m1;i++)\n		 dat1=dat1+days[i];\n	 for (i=0;i<m2;i++)\n		 dat2=dat2+days[i];\n	f=dat2-dat1+1;\n	if (f>0)  \n                 \n		printf(\"Proshlo dney: %d\\n\", f);\n	else\n        \n		printf(\"Proshlo dney: %d\\n\",-f);\n	 return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (334,'#include <stdio.h>\n#define N 13\nint main ()\n{\n	int a,b,c,d,e,f,i,k,l,u=0;\n	int p,h,j;\n	int A[N]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n	int B[N]={0,31,29,31,30,31,30,31,31,30,31,30,31};\n	int *P;\n	scanf (\"%d/%d/%d/\",&a,&b,&c);\n	scanf (\"%d/%d/%d\",&d,&e,&f);\n	if(c>f)\n	{\n		p=c;\n		c=f;\n		f=p;\n\n		p=b;\n		b=e;\n		e=p;\n\n		p=a;\n		a=d;\n		d=p;\n	}\n	while (c!=f || a!=d || b!=e)\n	{\n		if (c % 400 == 0 || (c % 4 == 0 && c % 100 != 0))\n			P = B;\n		else\n			P = A;\n		a++;\n		u++;\n		printf (\"a = %d\",a);\n		if (a>P[b])\n		{	\n			b++;\n			a=1;\n		}\n		printf (\"b = %d\",b);\n		if (b>12)\n		{\n			c++;\n			b=1;\n			printf (\"c = %d\",c);\n		}\n	}\n	printf (\"u = %d \\n\",u+1);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (335,'#include <stdio.h>\n\nint main()\n{\n	int i,j;\n	int a[11];\n	int b[15]={1, 3, 5, 7, 9};\n	int l,r;\n	int k;\n\n	for(i=0;i<11;i++)\n		scanf(\"%d\",&a[i]);\n\n	for(i=0;i<5;i++)\n		printf(\"%d \",b[i]); 	\n	printf(\"??????, ? ??????? ?? ????\\n\");\n	\n	for(i=0;i<11;i++)\n	{\n		l=0;\n		r=4;\n		k=0;\n		do\n		{\n			if(b[(l+r)/2] == a[i])\n				k=1;\n			else\n				if( b[(l+r)/2] > a[i])\n					r=(l+r)/2-1;\n				else\n					l=(l+r)/2+1;		\n			printf(\"%d %d ? ???????? %d %d     \",b[l],b[r],l,r); 		\n		}\n		while((l<=r)&&(k!=1));\n		if(k==1)\n			printf(\"%d - ????\\n\",a[i]);\n		else \n			printf(\"%d - ???\\n\",a[i]);\n	}\n	\n	return 0;\n}\n\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (336,'#include <stdio.h>\nint main()\n{\n	int N=5;\n	int a[N],i,p,c=0,d=N-1;\n	FILE* inp=fopen(\"input6.txt\",\"r\");\n	for (i=0;i<N;i++)\n	{\n		fscanf(inp,\"%d\",&a[i]);\n	}\n	printf(\"Enter number: \");\n	scanf(\"%d\",&p);\n	while(c!=d)\n	{\n		if (p>a[(c+d)/2] && p<=a[d])\n		{\n			c=(c+d)/2+1;\n		} else if(p<=a[(c+d)/2] && p>=a[c]) \n			{\n				d=(c+d)/2;\n			} else \n				{\n					break;\n				}\n		\n	}	\n	if (p==a[c])\n		printf(\"Element imeet nomer %d\\n\", c);\n	else\n		printf(\"Element ne naiden\\n\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (337,'#include <stdio.h>\n#include <string.h>\nint main()\n{\n	char s[256];\n	int i,be,en,flag=1;\n	printf(\"Enter string: \");\n	scanf(\"%s\",s);\n	be=0; en=strlen(s)-1;\n	for (i=0;i<strlen(s);i++)\n	{\n		if (s[i]>=\'A\'&&s[i]<=\'Z\')\n		{\n			s[i]=s[i]-\'A\'+\'a\';\n		}\n	}\n	while (be<=en)\n	{\n		while ((s[be]<\'a\') ||  (s[be]>\'z\'))\n		{\n			be++;\n		}\n		while ((s[en]<\'a\') || (s[en]>\'z\'))\n		{\n			en--;\n		}\n		if (s[be]!=s[en])\n		{\n			flag=0;\n		}\n		be++;\n		en--;\n	}\n	if (flag==1)\n	{\n		printf(\"PALINDROM\\n\");\n	}\n	else\n		printf(\"NOT PALINDROM\\n\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (338,'#include <stdio.h>\nint main()\n{\n	char s[64];\n	double res=0;\n	int i,b,temp,toch=-1;\n	printf(\"Enter base: \");\n	scanf(\"%d\",&b);\n	printf(\"Enter number: \");\n	scanf(\"%s\",s);\n	for (i=0;i<strlen(s);i++)\n	{\n		if (s[i]==\'.\')\n		{\n			toch=i;\n			i++;\n		}\n		if (s[i]>=\'A\')\n		{\n			temp=s[i]-\'A\'+10;\n		}\n		else\n			temp=s[i]-\'0\';\n		res=res*b+temp;\n	}\n	for (i=1;i<strlen(s)-toch;i++)\n		res/=b;\n	printf(\"%f\\n\",res);\n	\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (339,'#include <stdio.h>\n#define N 100\nint main()\n{\n	int per;\n	int s[N]={0};\n	int i,j,k=0,bad;\n	for(i=0;i<N; )\n	{\n		per=getchar();\n		if((per != \'\\n\')&&(per!=\' \')&&(per!=\'.\')&&(per!=\',\'))\n		{\n			s[i]=per;\n			i++;\n		}\n		if (per == \'\\n\') \n			break;\n	}\n	bad = 0;\n	for(j=0;j<=i/2;j++)\n	{                                                                                                                       \n		if(s[j]==s[i-1-j])\n		{\n			printf(\"%c == %c\\n\", s[j], s[i-1-j]);\n			k++;\n		}\n		else\n		{\n			bad = 1;\n			printf(\"%c != %c\\n\", s[j], s[i-1-j]);\n		}\n	}\n	if(!bad) printf(\"Palindrom\\n\");\n	else printf(\"Ne palindrom\\n\");\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (340,'#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n	char str[200] = {0};\n	FILE * f = argc == 2 ? fopen(argv[1], \"r\") : stdin;\n	int l = 0;\n	char t = \' \';\n//	scanf(\"%d\", &l);\n\n	int q = l;\n	\n	for(int i = 0, j = 0; ; i++, j++, q++, l++)\n	{\n		fscanf(f, \"%c\", &t);\n		if (t == \'\\n\') break;\n		if(t != \' \' && t != \'\\n\')\n		{\n//			printf(\"!%c! \", t);\n			str[j] = t;\n		}\n		else\n		{\n//			printf(\"[%c] \", t);\n			l--;\n			j--;\n		}\n//		printf(\"(%c)\\n\", str[j]);\n	}\n\n	for(int i = 0; i < l / 2; i++)\n	{\n		if(str[i] == str[l - 1 - i])\n		{\n//			printf(\"(%d)%c == (%d)%c\\n\",i , str[i], (l - 1 - i), str[l - 1 - i]);\n			continue;\n		}\n		else\n		{\n//			printf(\"%c != %c\\n\", str[i], str[l - 1 - i]);\n			printf(\"\\n-\\n\");\n			return 0;\n		}\n	}\n	printf(\"+\\n\");\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (341,'// str.cpp : Defines the entry point for the console application.\r\n//\r\n#include \"stdafx.h\"\r\n#include <cstring>\r\n#include <stdlib.h>\r\n#include <iostream>\r\nusing namespace std;\r\nclass String\r\n{\r\n      private: \r\n      char* data;\r\n\r\n      public:\r\n      \r\n      String()\r\n      {\r\n	  data = new char[1];\r\n	  data[0] = 0;\r\n	  cout<<\"Pustaya stroka\\n\";}\r\n      \r\n      String(char* a)\r\n      {//data=a;\r\n		  int len = strlen(a);\r\n		  data = new char[len + 1];\r\n		  strcpy(data, a);\r\n	  cout<<\"Konstruktor storoki\\n\";}\r\n      \r\n      String(const String& orig)\r\n      {\r\n		  int len = strlen(orig.data);\r\n		data = new char[len + 1];\r\n		strcpy(data,orig.data);\r\n	  }\r\n      \r\n      ~String()\r\n      {\r\n		  delete[] data;\r\n	  cout<<\"Destructor\\n\";}\r\n      \r\n      String& operator=(const String& orig)\r\n      {\r\n			if (this == &orig)\r\n				return *this;\r\n			delete[] data;\r\n		    int len = strlen(orig.data);\r\n		    data = new char[len + 1];\r\n		    strcpy(data,orig.data);\r\n		    return *this;\r\n      }    \r\n      \r\n      operator const char*() const\r\n      {\r\n		  cout<<\"Privedenie typov\\n\";\r\n		  return data;\r\n	  }\r\n      \r\n      int Lenght()\r\n      {\r\n          int i;\r\n		  for( i=0 ; *(data+i) != 0; i++ );\r\n          return i;    \r\n      }\r\n      \r\n      String operator+(const String &another) \r\n      {\r\n \r\n		  int l;\r\n		  l=strlen(data)+strlen(another.data)+1;\r\n		    char *n = new char[l];\r\n			strcpy(n,data); \r\n			strcat(n,another.data); \r\n			String s(n);\r\n			delete[] n;\r\n            return s;     \r\n	\r\n      }  \r\n      \r\n      String& operator+=(const String &other)\r\n      {\r\n\r\n			  *this = *this +  other;\r\n			  return *this;\r\n              }\r\n      \r\n      \r\n      char operator[](const int index) const\r\n           {\r\n			   std::cout << \"const operator []\\n\";\r\n           return *(data+index);\r\n           }\r\n           \r\n       char &operator[](const int index)\r\n           {\r\n			   std::cout << \"non-const operator []\\n\";\r\n           return *(data+index);\r\n           }    \r\n};\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	char* s1=\"abcde\";\r\n	char* s2=\"edcba\";\r\n	const char*st;\r\n	int l;\r\n	String b=String(s1);\r\n	String a=String(b) ;\r\n	st=a;\r\n	l=a.Lenght();\r\n	cout<<l<<endl;  \r\n	String c=String(s2);\r\n	b=a+c;\r\n	a+=c;\r\n	a[5]=\'x\';\r\n	cout<<a[5]<<endl;\r\n	cout<<a<<endl;\r\n	cout<<b<<endl;\r\n	cout<<c<<endl;\r\n\r\n	cout << \"b: \" << b << \"\\n\";\r\n	b = b;\r\n	cout << \"b: \" << b << \"\\n\";\r\n\r\n	const String q(\"abc\");\r\n	q[0];\r\n\r\n	return 0;\r\n}\r\n','ÐÐ½Ð½Ð°','Anna','f');
INSERT INTO `bias` VALUES (342,'#include <iostream>\r\n#include <stdlib.h>\r\n#include <conio.h>\r\nchar debugmode = 0;\r\n\r\nint debugout (int num)\r\n{\r\n    \r\n    if (debugmode != \'1\')\r\n    {\r\n        return 0;\r\n    }\r\n    switch (num)\r\n    {\r\n        case 0: std::cout << \"--empty constructor--\\n\"; break;\r\n        case 1: std::cout << \"--constructor char*--\\n\"; break;\r\n        case 2: std::cout << \"--constructor string--\\n\"; break;\r\n        case 3: std::cout << \"--operator = char*--\\n\"; break;\r\n        case 4: std::cout << \"--operator = string--\\n\"; break;\r\n        case 5: std::cout << \"--operator += char*--\\n\"; break;\r\n        case 6: std::cout << \"--operator + string--\\n\"; break;\r\n        case 7: std::cout << \"--operator += char*--\\n\"; break;\r\n        case 8: std::cout << \"--operator += string--\\n\"; break;\r\n        case 9: std::cout << \"--operator char*()--\\n\"; break;\r\n        case 10: std::cout << \"--operator [] const--\\n\"; break;\r\n        case 11: std::cout << \"--operator [] notconst--\\n\"; break;\r\n        case 12: std::cout << \"--destructor--\\n\"; break;\r\n    }\r\n    return 0;\r\n}\r\n\r\nint length (const char* other) \r\n{\r\n	int m = 0;\r\n	for (char c = *other; c; m++) \r\n    {\r\n		c = *(other+m);\r\n	}\r\n	return m;\r\n}\r\n\r\nclass string \r\n{\r\n	char *s;\r\n	int dim;\r\npublic:\r\n	string () \r\n    {\r\n		s = new char;\r\n		*s = 0;\r\n		dim = 0;\r\n		debugout(0);\r\n	}\r\n\r\n	string (const char *other) \r\n    {\r\n		int m = length (other);\r\n		s = new char[m];\r\n		for (int i = 0; i < m; i++) \r\n        {\r\n			*(s+i) = *(other+i);\r\n		}\r\n		dim = m;\r\n		debugout(1);\r\n	}\r\n\r\n	string(const string& other) \r\n    {\r\n		dim = other.dim;\r\n		s = new char[other.dim];\r\n		for (int i = 0; i < dim; i++) \r\n        {\r\n			*(s+i) = *(other.s+i);\r\n		}\r\n		debugout(2);\r\n	}\r\n\r\n/*	\r\n	char *data() {\r\n		return s;\r\n	}\r\n\r\n	int len() {\r\n		return dim;\r\n	}\r\n*/\r\n\r\n	string& operator= (const string& other) \r\n    {\r\n		if (dim != other.dim) {\r\n			delete[] s;\r\n			s = new char[other.dim];\r\n			dim = other.dim;\r\n		}\r\n		for (int i = 0; i < dim; i++) \r\n        {\r\n			*(s + i) = *(other.s + i);\r\n		}\r\n		debugout(3);\r\n		return *this;\r\n	}\r\n\r\n	string& operator= (const char* other) \r\n    {\r\n		int m = length (other);\r\n		if (dim != m) {\r\n			delete[] s;\r\n			s = new char[m];\r\n			dim = m;\r\n		}\r\n		for (int i = 0; i < dim; i++) \r\n        {\r\n			*(s + i) = *(other + i);\r\n		}\r\n		debugout(4);\r\n		return *this;\r\n	}\r\n\r\n	string& operator+ (const string& other) const\r\n    {\r\n		char *b = new char[dim + other.dim - 1];\r\n		for (int i = 0; i < dim-1; i++) \r\n        {\r\n			*(b + i) = *(s + i);\r\n		}\r\n		for (int i = 0; i < other.dim; i++) \r\n        {\r\n			*(b + dim - 1 + i) = *(other.s + i);\r\n		}\r\n		string *r = new string;\r\n		*r = b;\r\n		debugout(5);\r\n		return *r;\r\n	}\r\n\r\n	string& operator+ (const char *other) const\r\n    {\r\n		int m = length(other);\r\n		char *b = new char[dim + m - 1];\r\n		for (int i = 0; i < dim - 1; i++) \r\n        {\r\n			*(b + i) = *(s + i);\r\n		}\r\n		for (int i = 0; i < m; i++) \r\n        {\r\n			*(b + dim - 1 + i) = *(other + i);\r\n		}\r\n		string *r = new string;\r\n		*r = b;\r\n		debugout(6);\r\n		return *r;\r\n	}\r\n\r\n	string& operator+= (const char * other) \r\n    {\r\n		*this = *this + other;\r\n		debugout(7);\r\n		return *this;\r\n	}\r\n\r\n	string& operator+= (const string& other) \r\n    {\r\n		*this = *this + other.s;\r\n		debugout(8);\r\n		return *this;\r\n	}\r\n\r\n	operator char* () \r\n    {\r\n        debugout(9);\r\n		return s;\r\n	}\r\n	\r\n	char operator[] (const int ind) const \r\n    {\r\n		if (ind < dim) {\r\n            debugout(10);\r\n			return *(s + ind);\r\n		}\r\n		throw \"invalid index\";\r\n	}\r\n\r\n	char& operator[] (const int ind) \r\n    {\r\n		if (ind < dim) {\r\n            debugout(11);\r\n			return *(s + ind);\r\n		}\r\n		throw \"invalid index\";\r\n	}\r\n\r\n	~string() {\r\n		delete[] s;\r\n		debugout(12);\r\n	}\r\n};\r\n\r\nint main() \r\n{\r\n    //debug mode initialization\r\n    std::cout << \"Debug mode?\\n\";\r\n    debugmode = getch();\r\n    //test program\r\n    string s1;\r\n    std::cout << \"s1 = \" << s1 << \" (s1 is empty)\\n\";\r\n	string s2 = \"I know\";\r\n	std::cout << \"s2 = \" << s2 << \"\\n\";\r\n	string s3 = s2;\r\n	std::cout << \"s3 (= s2) = \" << s3 << \"\\n\";\r\n	s1 = \" nothing\";\r\n	std::cout << \"now s1 = \" << s1 << \"\\n\";\r\n	s3 += s1;\r\n	std::cout << \"now s3 (= s3 + s1) = \" << s3 << \"\\n\";\r\n	s3 += \", but I\";\r\n	std::cout << \"now s3 (= s3 + \\\", but I\\\") = \" << s3 << \"\\n\";\r\n	s1 = \" will learn c++\";\r\n	s2 = \"become a wise man.\";\r\n	std::cout << \"s3 + s1 + \\\" and \\\" + s2 =\\n\" << s3 + s1 + \" and \" + s2 << \"\\n\\n\";\r\n	s1 = \"lol\";\r\n	const string s4 = \"nac\";\r\n	s1[0] = s4[2];\r\n	s1[1] = s4[1];\r\n	s1[2] = \'n\';\r\n	std::cout << s1 + \" I ever reach succes?\" << \"\\n\";\r\n	getch();\r\n	return 0;\r\n}\r\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (343,'#include <string.h>\r\n#include <iostream>\r\nclass String\r\n{\r\nprivate:\r\n	char* data;\r\n	int length;\r\npublic:\r\n	String(void)\r\n	{\r\n		data=new char[1];\r\n		if(!data){\r\n			std::cout<<\"?????? ????????? ??????!\";\r\n			exit(1);\r\n		}\r\n		*data=\'\\0\';\r\n		length=0;\r\n	}\r\n\r\n	String(char* x)\r\n	{\r\n		length=0;\r\n		while(x[length]!=\'\\0\'){\r\n			length++;\r\n		}\r\n		data=new char[length+1];\r\n		for(int i=0;i<=length;i++){\r\n			data[i]=x[i];\r\n		}\r\n	}\r\n\r\n	String(const String &x)\r\n	{\r\n		length=x.length;\r\n		data=new char[x.length+1];\r\n		for(int i=0;i<=length;i++){\r\n			data[i]=x.data[i];\r\n		}\r\n	}\r\n\r\n	~String(void){\r\n		if(data!=NULL)\r\n			delete[]data;\r\n	}\r\n\r\n	String& operator=(const String &x){//???????? ????????????\r\n		if(this!=&x)\r\n		{\r\n			delete[]data;\r\n			length=x.length;\r\n			data=new char[x.length+1];\r\n			for(int i=0;i<=length;i++)\r\n				data[i]=x.data[i];\r\n		}\r\n		return((String&)*this);\r\n	};\r\n\r\n	operator const char*() {//???????? ?????????? ? const char*\r\n		return data;\r\n	}\r\n\r\n	String& operator +(const String &x)//???????? ???????????? +\r\n	{\r\n		int k=length;\r\n		length=length+x.length;\r\n		char* Res;\r\n		Res=new char[length+1];\r\n		for(int i=0;i<=k;i++)\r\n		{\r\n			Res[i]=data[i];\r\n		}\r\n		for(int j=0;j<=x.length;j++)\r\n		{\r\n			Res[j+k]=x.data[j];\r\n		}\r\n		data=new char[length+1];\r\n		for(int i=0;i<=length;i++)\r\n		{\r\n			data[i]=Res[i];\r\n		}\r\n		return((String&)*this);\r\n	}\r\n\r\n	void operator +=(String &x)//???????? ???????????? +=\r\n	{\r\n		int k=length;\r\n		length=2*length;\r\n		char* Res;\r\n		Res=new char[length+1];\r\n		for(int i=0;i<=k;i++)\r\n		{\r\n			Res[i]=data[i];\r\n		}\r\n		for(int j=0;j<=k;j++)\r\n		{\r\n			Res[j+k]=data[j];\r\n		}\r\n		data=new char[length+1];\r\n		for(int i=0;i<=length;i++)\r\n		{\r\n			data[i]=Res[i];\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\n	String st;\r\n	String st1=\"abcd\";\r\n	String st2=st1;\r\n	String st3=\"aaaa\";\r\n	st=st3;\r\n	st=st1+st;\r\n	st2+=st1;\r\n	st2 = st2;\r\n	std::cout << \" st: \" << st << \"\\n\";\r\n	std::cout << \"st1: \" << st1 << \"\\n\";\r\n	std::cout << \"st2: \" << st2 << \"\\n\";\r\n	std::cout << \"st3: \" << st3 << \"\\n\";\r\n	return 0;\r\n};\r\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (344,'#include<iostream>\r\n\r\n\r\nclass String\r\n{\r\n		char *data;\r\n		int lenght;\r\n	public:\r\n		String()//??????????? ?? ?????????\r\n		{\r\n			data=new char[1];\r\n			data[0]=0;\r\n			lenght=0;\r\n			//std::cout<<\"??????????? ?? ?????????\\n\";\r\n		};\r\n		String(char*s)//??????????? ? ?????????? char*\r\n		{\r\n			int i=0;\r\n			lenght=strlen(s);  \r\n			data=new char[lenght+1];\r\n			strcpy(data,s);\r\n			//std::cout<<\"??????????? ? ?????????? char*\\n\";\r\n		};\r\n		String(const String &orig)//??????????? ???????????\r\n		{\r\n			lenght=orig.lenght;\r\n			data=new char[lenght+1];\r\n			strcpy(data,orig.data);\r\n			//std::cout<<\"??????????? ???????????\\n\";\r\n		};\r\n		~String()//??????????\r\n		{\r\n				//std::cout<<\"??????????\\n\";\r\n				delete[]data;\r\n	\r\n		};\r\n		String& operator=(const String &orig)//???????? ????????????\r\n		{	\r\n			if(this==&orig)\r\n			{\r\n				//std::cout<<\"???????? ????????????\\n\";\r\n				return  *this;\r\n			}\r\n			if(lenght!=orig.lenght || lenght==0)\r\n			{\r\n				delete[]data;\r\n				lenght=orig.lenght;\r\n				data=new char[lenght+1];\r\n			}\r\n			//std::cout<<\"???????? ????????????\\n\";\r\n			strcpy(data,orig.data);\r\n			return *this; // a = b = c;\r\n		};\r\n		operator const char*() const//???????? ?????????? ????\r\n		{\r\n			//std::cout<<\"???????? ?????????? ????\\n\";\r\n			return data;	\r\n		};\r\n		String operator+=(const String &other)\r\n		{	\r\n			lenght=lenght+strlen(other.data);\r\n			char *p=new char[lenght+1];\r\n			int i=0;\r\n			strcpy(p,data);\r\n			strcat(p,other.data);\r\n			delete []data;\r\n			data=new char[lenght+1];\r\n			strcpy(data,p);\r\n			delete []p;\r\n			std::cout<<\"???????? +=\\n\";\r\n			return *this;\r\n		};\r\n		String operator+(const String &other)\r\n		{\r\n			String result;\r\n			result.lenght=lenght+strlen(other.data);\r\n			delete []result.data;\r\n			result.data = new char [result.lenght + 1];\r\n			strcpy(result.data,data);\r\n			strcat(result.data,other.data);\r\n			std::cout<<\"???????? +\\n\";\r\n            return result;                          \r\n		};\r\n		const char operator[](const int i)const\r\n		{\r\n			std::cout<<\"??????????? ???????? ?????????\\n\";\r\n			return data[i];\r\n		};\r\n		char& operator[](const int i)\r\n		{\r\n			std::cout<<\"???????? ????????? ??? ?????????\\n\";\r\n			return data[i];\r\n		};\r\n\r\n};','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (345,'#include <iostream>\r\n#include <string.h>\r\n\r\nclass String\r\n{\r\n	private:\r\n		char *data;\r\n		int len;\r\n	public:\r\n		String ();\r\n		String (const char * c);\r\n		~String ();\r\n		int length() const;\r\n		String (const String &r);\r\n		void print() const;\r\n		String& operator=(const String &r);\r\n		operator const char*() const;\r\n\r\n		String& operator+=(const String &r);\r\n		String operator+(const String &r) const;\r\n\r\n		char const operator [] (const int i)const;   ////  ????? ????? ? ???????\r\n		char & operator [] (const int i);\r\n};\r\n\r\nString::String ()  ////??????\r\n{\r\n	data =new char [1];\r\n	*data = \'\\0\';\r\n	len=0;\r\n	std::cout << \"??????????? ?????? ??????\\n\";\r\n}\r\nString::String (const char *c)  /////?????? ???????\r\n{  \r\n	len=strlen(c);\r\n//	len=0;\r\n//	while(c[len]!=\'\\0\')\r\n//	len++;\r\n	data=new char[len+1];\r\n	strcpy(data,c);\r\n//	for(int i=0; i<len; i++)\r\n//	{\r\n//		data[i]=c[i];\r\n//	}\r\n//	data[len]=\'\\0\';\r\n	std::cout << \"??????????? char*\\n\";\r\n}\r\nString::~String () ///?????\r\n{\r\n	delete []data;\r\n	std::cout << \"??????????\\n\";\r\n}\r\nint String::length() const\r\n{\r\n	return len;\r\n}\r\nString::String (const String &r) ///// ?????\r\n{           \r\n	len=r.length();\r\n	data=new char[len+1];\r\n	strcpy(data,r.data);\r\n//	for(int i=0; i<len; i++)\r\n//	{\r\n//		data[i]=r.data[i];\r\n//	}\r\n//	data[len]=\'\\0\';\r\n\r\n	std::cout << \"r[0]: \" << r[0] << \"\\n\";\r\n\r\n	std::cout << \"??????????? ???????????\\n\";\r\n}\r\nvoid String::print() const   //// ??????\r\n{\r\n	for(int i=0;i<len;i++)\r\n	{\r\n		std::cout << data[i];\r\n	}\r\n	std::cout << \"\\n\";\r\n}\r\n\r\nString& String::operator=(const String &r) ///////// ????????????\r\n{\r\n//	if(*this==&r)   ///// ?????? ???????\r\n//	{\r\n//		return *this;\r\n//	}\r\n	String result(r);\r\n	len=result.length();\r\n	delete []data;\r\n	data=new char[len+1];\r\n	strcpy(data,result.data);\r\n//	for(int i=0; i<len; i++)\r\n//	{\r\n//		data[i]=r.data[i];\r\n//	}\r\n//	data[len]=\'\\0\';\r\n	return *this;\r\n}\r\nString::operator const char*()const\r\n{\r\n	return data;\r\n}\r\n\r\nString& String::operator+=(const String &r) /////////// ??????????+=\r\n{\r\n	char *c=new char[len+1];\r\n	strcpy(c,data);\r\n	len = len + r.length();\r\n	delete []data;\r\n	data=new char[len+1];\r\n	strcpy(data,c);\r\n	strcat(data,r.data);\r\n	delete []c;\r\n	return *this;\r\n}\r\nString String::operator+(const String &r) const/////////// ??????????+ ( ?????(: )\r\n{\r\n	String result(*this);\r\n	result += r;\r\n	return result;\r\n}\r\n\r\nchar const String::operator [] (const int i)const\r\n{\r\n	std::cout << \"const operator[]\\n\";\r\n	return data[i];\r\n}\r\nchar & String::operator [] (const int i)\r\n{\r\n	std::cout << \"operator[]\\n\";\r\n	return data[i];\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////\r\nint main ()\r\n\r\n{\r\n	setlocale (LC_ALL, \"Russian\");\r\n	String a(\"e\");\r\n	String b(\"w\");\r\n/*	\r\n	a += b;\r\n	a.print();\r\n	std::cout << \"\\n^___^\\n\";\r\n*/\r\n	String c(b);\r\n/*	c.print();\r\n	std::cout << \"\\n^___^\\n\";\r\n\r\n	String t;\r\n	t = a;\r\n	a.print();\r\n\r\n	const char* op = a;\r\n	std::cout << op <<\"\\n\";\r\n\r\n	std::cout << \"\\n^___^\\n\";\r\n\r\n	String s1(\"aaaaa\");\r\n	String s2(\"bbbbb\");\r\n	String s3;\r\n	s3 = s1 + s2;\r\n	s3.print();\r\n	\r\n	String s4(\"Verni\");\r\n	s4[3]=\'t\';\r\n	s4.print();\r\n\r\n	char tmp=s4[2];\r\n	std::cout<<\"s4[2] = \" <<tmp <<\"\\n\";\r\n\r\n	String q(\"abc\");\r\n	q = q;\r\n	std::cout << \"q: \" << q << \"\\n\";\r\n*/\r\n	return 0;\r\n}\r\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (346,'#include<stdio.h>\nfloat ss(int b)\n{\n	int i=0, N=0, a[7]={10,11,12,13,14,15,16},c[100],f=0;\n	char s[100];\n	float K=0,t;\n	scanf(\"%s\",&s);\n	while (s[i] != 0)\n	{\n		if(s[i]==\'.\')\n		{\n			f=1;\n			break;\n		}\n		if(s[i]>=\'A\'&&s[i]<=\'G\')\n			c[i]=a[s[i]-\'A\'];\n		else\n			c[i]=s[i]-\'0\';\n		if(i==0)\n			N=c[0];\n		else\n			N=N*b+c[i];\n		i++;\n	}\n	t=1.0/b;\n	i++;\n	if(f==1)\n	{\n		while(s[i] != 0)\n		{\n			if(s[i]>=\'A\'&&s[i]<=\'G\')\n				c[i]=a[s[i]-\'A\'];\n			else\n				c[i]=s[i]-\'0\';\n		        K=K+c[i]*t;\n		        t/=b;\n		        i++;\n		}\n	}\n	return(K+N);\n}\n\nint main()\n{\n	int b;\n	scanf(\"%d\",&b);\n	printf(\"%f \\n\",ss(b));\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (347,'#include<stdio.h>\nint main()\n{\n	int b, c[100],i=0,k=0,f=0,N=0,l=0;\n	float K;\n	char s[100]={0},a[6]={\'A\',\'B\',\'C\',\'D\',\'E\',\'F\'};\n	scanf(\"%d\",&b);\n	scanf(\"%f\",&K);\n	N=(int)K;\n	K-=N;\n	if(N==0)\n		s[0]=\'0\';\n	else\n	{\n		while( N != 0 )\n		{\n			c[i]=N%b;\n			N/=b;\n			i++;\n		}\n		k=i-1;\n		for(i=k;i>=0;i--)\n		{\n			if(c[i]>=10)\n				s[k-i]=a[c[i]-10];\n			else\n				s[k-i]=\'0\'+c[i];\n		}\n	}\n	f=k;\n	if(K!=0)\n	{\n		s[k+1]=\'.\';\n		k++;\n		while(K!=0 && k < 95)\n		{\n			c[k]=b*K;\n			K=K*b-c[k];\n			k++;\n		}\n	l=f+2;\n	for(i=f+1;i<k;i++)\n	{\n		if(c[i]>=10)\n			s[l]=a[c[i]-10];\n		else\n			s[l]=\'0\'+c[i];\n		l++;\n	}\n	}\n	i=0;\n	while(s[i]!=0)\n	{\n		printf(\"%c\",s[i]);		\n		i++;\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (348,'#include  <stdio.h>\n\n#define ZERO 0.001\n\nfloat f(float x)\n{return (x * x - 1);\n}\n\nint main()\n{\n float a; \n float b;\n float c;\n float S,test;\n float koren;\n\n scanf(\"%f\",&a);\n scanf(\"%f\",&b);\n\n \n S= f(a)* f(b)  ;\n  printf (\"%f\\n\",f(a));\n  printf (\"%f\\n\",f(b)); \n  printf (\"%f\\n\",S);\n\n if (S>ZERO) printf(\"korney net\");\n\n // a = 1.0 - epsilon\n // f(a) = -epsilon\n\n if (S<=ZERO) { while (b - a > ZERO) {\n	 printf(\"left: %f, right: %f\\n\", a, b);\n	 c = (a+b)/2;\n	 if ((f(a)<0) && (f(c)<0))  a=c; \n	 if ((f(b)>0) && (f(c)>0))  b=c; \n	\n//	 test+=1;\n//	 printf (\"%f\\n\",test);\n	 /* c = (a+b)/2;\n	 if (f(c)<0) a=c;\n	 if (f(c)>0) b=c; */\n }\n       }\n \n printf (\"%f\\n\",a);\nreturn 0;}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (349,'#include <stdio.h>\r\n\r\nint bin_search(int *x, int n, int y)\r\n{\r\n    int i, a=0, b=n, m;\r\n    \r\n    do {\r\n        m = (a + b)/2;\r\n        //printf(\"%d %d %d\\n\", a, b, m);\r\n    	if (y == x[m])\r\n           return 1;\r\n        else\r\n            if (y < x[m])\r\n            	b = m - 1;\r\n            else \r\n            	a = m + 1;\r\n    }\r\n    while (a <= b);\r\n    \r\n    return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    int i=0, key, n=0;\r\n    int x[100]={0};\r\n    char c;\r\n    FILE *f;\r\n\r\n    printf(\"\\nSearch the numbers in the array by the dichotomy\\n\");\r\n    \r\n    f = fopen(\"input.txt\", \"r\");\r\n/*    while ((c = getc(f)) != EOF){\r\n            if (c != \' \' && c != \'\\n\')\r\n    	            x[i] = x[i]*10 + (c - \'0\');\r\n    	    else\r\n                    i++;\r\n    }*/\r\n    while (fscanf(f, \"%d\", &x[i]) == 1)\r\n    {\r\n	    i++;\r\n    }\r\n    fclose(f);\r\n    n = i;\r\n    \r\n    printf(\"%d\\n\", n+1);\r\n    for(i=0; i<n; i++)\r\n	    printf(\"%d \", x[i]);\r\n    printf(\"\\n\");\r\n    \r\n    do{\r\n    	printf(\"1.Input the numbers:\\n\");\r\n	scanf(\"%d\", &key);\r\n        getchar();\r\n	\r\n	if (bin_search(x, n, key))\r\n		printf(\"2.Your number IS INCLUDED in the array\\n\");\r\n	else\r\n		printf(\"2.Your number IS NOT INCLUDED in the array\\n\");\r\n        printf(\"3.Press ENTER to continue. To exit the program press any key\\n\\n\");\r\n    }while ((c = getchar()) == \'\\n\');\r\n    \r\n    return 0;\r\n}\r\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (350,'#include <stdio.h>\n\nint main()\n{\n	int nchar=0, nwords=0, nlines=0, f=1;\n	char c;\n	FILE *file;\n\n	file = fopen(\"input.txt\", \"r\");\n	while ((c = getc(file)) != EOF){\n		nchar++;\n		if (c == \'\\n\')\n			nlines++;\n		if (c == \'\\n\' || c == \' \' || c == \'\\t\')\n			f = 1;\n		else\n			if (f){\n				f = 0;\n				nwords++;\n			}\n	}\n	fclose(file);\n\n	printf(\"%d %d %d\\n\", nchar, nwords, nlines);\n\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (351,'#include <stdio.h>\n#include <string.h>\nint main ()\n{\n	int a = 0, n, b, j,c=0,i,k;\n	char d[100];\n	char s[100];\n	char l,r;\n	freopen(\"input.txt\", \"r\", stdin);\n	fgets (d,100,stdin);\n	d[strlen(d)-1]=0;\n	n=strlen(d);\n	l=0;\n	r=n-1;\n//	printf (\"l = %c, r = %c \\n\",l,r);\n	for(i = 0; l <= r; i++)\n	{\n		printf(\"i: %d, l: %d, r: %d\\n\", i, l, r);\n		while(d[l]==\' \' || d[l]==\',\' || d[l]==\'.\')\n		{\n			l++;\n		}\n		while(d[r]==\' \' || d[r]==\',\' || d[r]==\'.\')\n		{\n			r--;\n		}\n			\n		if(d[l]==d[r])\n		{\n			l++;\n			r--;\n		}\n		else\n		{\n			printf(\"break\\n\");\n			c++;\n			break;\n		}\n	}\n		\n	if(c==0)\n	{\n		printf(\"da\\n\");\n	}\n	else\n	{\n	printf(\"net\\n\");\n	}\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (352,'#include <stdio.h>\n\nint main(int argc , char *argv[])\n{\n	FILE *f_inp;\n	FILE *f_out;\n	\n	char a;\n\n	if(argc-1<2)\n	{\n		printf(\"????????? ???? ??????????\\n\");\n		return 1;\n	}\n	if(argc-1>2)printf(\"????????? ?????? ?????????, ????? ????????????? ???? ?????? ???\\n\");\n	\n	f_inp=fopen(argv[1],\"r\");\n	\n	if(f_inp==0)\n	{\n		printf(\"???? %s ?? ??????????\\n\",argv[1]);\n		return 1;\n	}\n\n	f_out=fopen(argv[2],\"w\");\n	\n	if(f_out==0)\n	{\n		printf(\"???? %s ?? ??????????\\n\",argv[2]);\n		return 1;\n	}\n\n	while (fscanf(f_inp,\"%c\",&a)==1)\n	{\n		fprintf(f_out,\"%c\",a);\n	}\n	\n	fclose(f_inp);\n	fclose(f_out);\n	\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (353,'#include <stdio.h>\n#include <math.h>\nfloat f(float x)\n{\n	return(sin(x));\n}\n\nint main()\n{\n	float a=6;\n	float b=7;\n	float m;\n	while (b-a>0.001)\n	{\n		m=(a+b)/2;\n		if (((f(m)>0)&&(f(a)>0))||((f(m)<0)&&(f(a)<0))) \n			a=m;\n		else\n			b=m;\n	}\n\n	printf(\"%f\\n\", (a+b)/2);\n	return 0;\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (354,'#include <iostream>\n#include <string.h>\nclass string\n{\nprivate: \n	char* data;\npublic:\n	string()\n	{\n		data=new char[1];\n		*data=0;\n	}\n	string(const char* a)\n	{\n		int l=strlen(a);\n		data=new char[l+1];\n		strcpy(data,a);\n		data[l+1]=0;\n	}\n	string(const string& a)\n	{\n		data= new char[strlen(a.data)+1];\n                strcpy(data, a.data);\n                data[strlen(a.data)+1]=0;	\n	}\n	~string()\n	{\n		delete[] data;\n	}\n	string& operator= (const string &a)\n	{\n		if (this == &a) return *this;\n		delete[] data;\n		data= new char[strlen(a.data)+1];\n        	strcpy(data, a.data);\n		data[strlen(a.data)+1]=0;\n		return *this;\n	}\n	operator const char*() \n	{\n		return data;\n	}\n	string operator+ (const string& b) const\n	{\n        	int i;\n        	int k=strlen(data);\n        	int p=strlen(b.data);\n        	string result;\n		result.data=new char(k+p+1); \n       		for (i=0; i<k; i++)\n                result.data[i]=data[i];\n       		for (i=0; i<=p; i++)\n                	result.data[k+i]=b.data[i];\n		result.data[k+p+1]=0;\n        	return result.data;	\n	}\n	string& operator+= (const string& b)\n	{\n		int l=strlen(data)+strlen(b.data);\n        	data=strcat(data,b.data);\n		data[l+1]=0;\n		return* this;\n	}\n	char& operator[] (const int i)\n	{\n		int l=strlen(data);\n        	if((i<l)&&(i>=0))\n			return data[i];\n		else\n			throw \"incorrect index\";\n	}\n	const char operator[] (const int i) const\n	{\n        int l=strlen(data);\n        if((i<l)&&(i>=0))\n			return data[i];\n		else\n			throw \"incorrect index\";\n	}\n};\n\nint main()\n{     \n        string s;\n        string s1=\"abc\";\n        string s2=s1; \n	std::cout<<s1<<\"\\n\";\n        std::cout<<s2<<\"\\n\";\n        s=s1+s2;         \n        std::cout<<s<<\"\\n\";\n        s1+=s1; \n        std::cout<<s1<<\"\\n\";\n        std::cout<<s1[1]<<\"\\n\";\n        s[1]=\'c\';\n	std::cout<<s<<\"\\n\";    \n	s = s;\n	std::cout<<s<<\"\\n\";    \n	return 0;\n}\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (355,'#include <iostream>\n#include <string.h>\nclass xstring\n{\nprivate:\n	char *data;\n	int length;\npublic:\n	xstring()\n	{\n		length=0;\n		data=new char[length+1];\n		data[length]=0;\n	}\n	xstring(const char *s)\n	{\n		int i;\n		length=strlen(s);\n		data=new char[length+1];\n		for (i=0; i<length; i++)\n			data[i]=s[i];	\n	}\n	xstring(const xstring &orig)\n	{\n		int i;\n		length=orig.length;\n		data=new char [length+1];\n		for (i=0;i<length;i++)\n			data[i]=orig.data[i];\n	}\n	~xstring()\n	{\n		delete [] data;\n	}\n	xstring& operator=(const xstring &orig)\n	{\n		int i;\n		length=orig.length;\n		if(&orig!=this)\n		{\n			delete [] data;\n			data=new char [length+1];\n			for (i=0;i<length;i++)\n			data[i]=orig.data[i];\n		}\n		return *this;\n	}\n	operator const char*() const\n	{\n		return(data);\n	}\n	void print()\n	{\n		std::cout<<data<<\"\\n\";\n	}	\n};\nint main()\n{\n	xstring s1, strrr;\n	//s1.print();\n	xstring s2(\"asdasd\");\n	s2.print();\n	xstring s3=s2;\n	s3.print();\n	s2=s2;\n	s2.print();\n	strrr=s2;\n	strrr.print();\nreturn 0;\n}\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (356,'#include <iostream>\nclass String\n{\nprivate:\n	char* data;//?????????? ??????\n	int length;//????? ??????\npublic:\n	String() //??????????? ?? ?????????(??? ??????????)\n	{\n		data=new char[1];\n		data[0]=0;\n		length=0;\n	}\n\n	String(const char* str) //??????????? ? ?????????? char*\n	{\n		for(length=0;str[length];length++);\n		data=new char[length+1];\n		for(int i=0;i<=length;i++)\n		{\n			data[i]=str[i];\n		}\n	}\n	\n	String(const String& str) //??????????? ???????????\n	{\n		length=str.length;\n		data=new char[length+1];\n		for(int i=0;i<length;i++)\n		{\n			data[i]=str.data[i];\n		}\n	}\n	\n	~String() //??????????\n	{\n		delete[]data;\n	}\n\n	String& operator= (const String& str)//???????? ????????????\n	{\n		delete []data;\n		length=str.length;\n		char *p=new char[length+1];\n		for(int i=0;i<length;i++)\n		{\n			p[i]=str[i];\n		}\n		return *this;\n	}\n\n	operator const char *() const //???????? ?????????? ? const char *\n	{\n		return data;\n	}\n};\n\nint main()\n{\n	String a;\n	String b(\"parametr\");\n	String c;\n	String d(b);\n\n	c=d;\n	\n	std::cout<<a<<\"\\n\";\n	std::cout<<b<<\"\\n\";\n	std::cout<<c<<\"\\n\";\n	std::cout<<d<<\"\\n\";\n\n}\n\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (357,'#include <iostream>\n#include <string.h>\n\nclass String\n{\n	char *data;\n	public:\n	\n		String ()\n		{\n	 		data = new char[1];\n			data[0] = 0;\n		}	\n		\n		String(const char *s)\n		{\n			 int size = strlen(s);\n			 data = new char[size + 1];\n			 strcpy(data, s);\n		}\n\n		String(const String& orig) // ??????????? ???????????\n		{\n			if (&orig == this)\n				return;\n			int size = strlen(orig.data);\n			data = new char[size + 1];\n			strcpy(data, orig.data);\n				\n		}\n\n		~String() //???????????? ?????????? ??????\n		{\n			delete[] data;\n		}\n\n		String& operator=(const String &orig)\n		{\n			if (&orig == this)\n				return *this;\n			delete[] data;\n			int size = strlen(orig.data);\n			data = new char[size + 1];\n			strcpy(data, orig.data);\n			return *this;\n		}\n		\n	// ???????? ?????????? ? const char*\n		operator const char *() const\n		{\n			return data;\n		}\n		\n		String operator+(const String &second) const\n		{\n			int size1 = strlen(data);\n			int size2 = strlen(second.data);\n			char *result = new char[size1 + size2 + 1];\n			strcpy(result, data);\n			strcat(result, second.data);\n			String s(result);\n			return s;\n		} \n\n		String& operator+=(const String &second)\n		{\n			*this = *this + second;\n			return *this;\n		}\n		\n		char operator[](const int index) const\n		{\n			return data[index];	\n		}\n		\n		char& operator[](const int index) \n		{\n			return data[index];	\n		}\n		\n\n\n\n};\n\nint main()\n{\n	String t;\n	String s(\"stroka\");\n	String d(s);\n	String k;\n	String p;\n	k = d;\n	p = s + d;\n	p += \"vasya\";\n\n	p = p;\n	\n	\n	std::cout << p[1] << \"\\n\";\n		\n\n	p[1] = \'z\';\n	std::cout << p[1] << \"\\n\";\n\n	std::cout << s << \"\\n\";\n	std::cout << d << \"\\n\";\n	std::cout << t << \"\\n\";\n	std::cout << k << \"\\n\";\n	std::cout << p << \"\\n\"; \n	return 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (358,'#include <iostream>\r\n#include <string.h>\r\n\r\nclass strings\r\n{\r\nprivate:\r\nchar *data;\r\nint length;\r\n\r\npublic:\r\n\r\nstrings()\r\n	{\r\n		data = new char;\r\n		data[0] = 0;\r\n		length = 1;\r\n		std::cout << \"Constructor_po_ymolchaniu\\n\";\r\n	}\r\nstrings (const char* orig)\r\n	{\r\n		length = strlen(orig);\r\n		data = new char[length + 1];\r\n		int i;\r\n		for(i = 0; i < length; i++)\r\n			data[i] = orig[i];\r\n		data[length] = 0;\r\n		std::cout << \"Constructor_iz_stroki\\n\";\r\n	}\r\nstrings(const strings &orig)\r\n	{\r\n		data = new char[orig.length];\r\n		length = orig.length;\r\n		int i;\r\n		for(i = 0; i < length; i++)\r\n			data[i] = orig.data[i];\r\n		std::cout << \"Constructor copy\\n\";\r\n	}\r\n\r\n~strings()\r\n	{\r\n		delete [] data;\r\n		std::cout << \"Destructor\\n\";\r\n	}\r\nstrings &operator=(strings &orig)\r\n	{\r\n		if (*this == orig.data)\r\n			return *this;\r\n\r\n		delete [] data;\r\n		length = orig.length;\r\n		data = new char[length];\r\n		int i;\r\n		for(i = 0; i < length; i++)\r\n			data[i] = orig.data[i];\r\n		std::cout << \"Operator =\\n\";\r\n		return *this;\r\n	}\r\nstrings &operator=(const char* orig)\r\n	{\r\n		if (*this == orig)\r\n			return *this;\r\n\r\n		delete [] data;\r\n		length = std::strlen(orig) + 1;\r\n		data = new char[length];\r\n		int i;\r\n		for(i = 0; i < length; i++)\r\n			data[i] = orig[i];\r\n		std::cout << \"Operator =\\n\";\r\n		return *this;\r\n	}\r\n	operator const char*()const\r\n	{\r\n		return (const char*) data;\r\n	}\r\nstrings& operator+=(const strings &other)\r\n	{\r\n		strings save(*this);\r\n		delete [] data;\r\n		length += other.length;\r\n		data = new char[length - 1];\r\n		int i;\r\n		for(i = 0; i < save.length; i++)\r\n			data[i] = save.data[i];\r\n		for(i = 0; i < other.length; i++)\r\n			data[(i - 1) + save.length] = other.data[i];\r\n		std::cout << \"Operator +=\\n\";\r\n		return *this;\r\n	}\r\nstrings operator+(strings &other) const\r\n	{\r\n		strings result(*this);\r\n		std::cout << result << \"\\n\";\r\n		result += other;\r\n		std::cout << \"Operator +\\n\";\r\n		return result;\r\n	}\r\n};\r\n\r\nint main()\r\n{\r\nstrings a, e;\r\nchar d[] = \"fgh\";\r\nstrings b(a);\r\nchar c[] = \"abcde\";\r\nstrings z(c);\r\nstd::cout << z << \"\\n\";\r\na = c;\r\nb = d;\r\na += b;\r\ne = (b + b);\r\nstrings x, y;\r\n         x = y + y;\r\n         std::cout << x << y << \"\\n\";\r\n\r\nstd::cout << b << \"\\n\" << a << \"\\n\" << e << \"\\n\";\r\nreturn 0;\r\n}','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (359,'#include <stdio.h>\n#include <string.h>\nint main ()\n{\n int i,n;\n char a[100];\n char l,r;\n printf(\"Vvedite predlojenie: \");\n fgets(a, 100, stdin);\n a[strlen(a) - 1] = 0;\n n=strlen(a);\n   l=0;\n   r=n-1;\n   for (i=0; l<=r; i++)\n   {\n       while (a[l]==\' \' || a[l]==\',\' || a[l]==\'.\')\n       {\n	       l++;\n       }\n       while (a[r]==\' \' || a[r]==\',\' || a[r]==\'.\')\n       {\n	       r--;\n       }\n       if (a[l]==a[r])\n          {\n		  l++; \n		  r--;\n	  }\n       else \n	     {\n               \n	       printf(\"Dannoe predlojenie - ne palindrom\\n\");\n	       exit();\n	     }\n   }\n        \n               printf(\"Dannoe predlojenie - palindrom\\n\");\n  \nreturn 0;\n}\n	 \n		 \n	 \n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (360,'#include <stdio.h>\nint main()\n{	\n	int month[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n	int d,d1,d2,m,m1,m2,g,g1,g2,i=0,c=0,per=0;\n	printf(\"Vvedite Ha4 daty\");\n	scanf(\"%d %d %d\",&d1, &m1, &g1);\n	printf(\"Vvedite koH daty\");\n	scanf(\"%d %d %d\",&d2, &m2, &g2);\n	d=d1; m=m1; g=g1;\n	i=m-1;\n	while (d!=d2 || m!=m2 || g!=g2)\n	{\n		d++;\n		if ((g%400==0) || (g%4==0) && (g%100!=0)) \n			month[1]=29;\n		else month[1]=28;\n	\n		if(d>32)\n		{\n			printf(\"%d\",i);\n			break;\n			\n		}\n		if (d>month[i])\n		{\n			m++;\n			d=1;\n			i++;\n		}\n		if (m>12)\n		{\n			g++;\n			i=0;\n			d=1;\n			m=1;\n		}\n		c++;\n	}\n	printf(\"%d\\n\",c+1);\nreturn 0;\n}\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (361,'#include <stdio.h>\n\nint main(int argc , char *argv[])\n{\n	FILE *f_inp;\n	\n	char a;\n	int str=0;\n	int slv=0;\n	int smv=0;\n	int bzu=0;\n\n	if(argc-1<1)\n	{\n		printf(\"????????? ???? ??????????\\n\");\n		return 1;\n	}\n	if(argc-1>1)printf(\"????????? ?????? ?????????, ????? ??????????? ???? ?????? ????????\\n\");\n	\n	f_inp=fopen(argv[1],\"r\");\n	\n	if(f_inp==0)\n	{\n		printf(\"???? %s ?? ??????????\\n\",argv[1]);\n		return 1;\n	}\n\n	\n	while (fscanf(f_inp,\"%c\",&a)==1)\n	{\n		smv++;\n		if((a!=\' \')&&(a!=\'\\n\')&&(a!=\'\\t\'))\n			bzu=1;\n		else\n		{\n			slv+=bzu;\n			bzu=0;\n		}\n		if(a==\'\\n\')\n			str++;\n	}\n	\n	printf(\"? ????? %s : \\n %d - ???????? \\n %d - ???? \\n %d - ?????\\n\",argv[1],smv,slv,str);\n	fclose(f_inp);\n	\n	return 0;\n}\n                                                                                                              \n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (362,'#include <stdio.h>\n#include <string.h>\n\nint sdvig(int pos,int sd, char a[255])\n{\n	int bzu=pos+sd;\n	if( ((a[bzu]>=65)&&(a[bzu]<=90)) || ((a[bzu]>=97)&&(a[bzu]<=122)) )\n		return bzu;\n	else\n		return sdvig(bzu,sd,a);\n}\n\nint main(int argc , char *argv[])\n{\n	char a[50];\n	int left=0, right=0;\n	\n	printf(\"??????? ??????\\n\");\n	fgets(a,50,stdin);	\n	\n	right=sdvig(strlen(a),-1,a);\n	\n	while (right>=left)\n	{\n		printf(\"left  %d %c \\nright %d %c\\n\",left,a[left],right,a[right]);\n		if( (a[left]!=a[right]) && (a[left]+32!=a[right]) && (a[left]!=a[right]+32) )\n		{\n			printf(\"?? ?????????\\n\");\n			return 0;\n		}\n		else\n		{\n			left=sdvig(left,1,a);\n			right=sdvig(right,-1,a);\n		}\n	}\n	\n	printf(\"?????????\\n\");\n	\n	return 0;\n}\n                                                                                                              \n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (363,'#include <stdio.h>\n\nvoid swapDates(int date[3][3])\n{\n	for(int i = 0; i < 3; i++)\n	{\n		date[2][i] = date[0][i];\n		date[0][i] = date[1][i];\n		date[1][i] = date[2][i];\n	}\n}\n\nvoid check(int date[3][3], int y[12])\n{\n	if(date[1][2] % 400 == 0 || (date[1][2] % 100 != 0 && date[1][2] %4 == 0))\n		y[1] = 29;\n	else\n		y[1] = 28;\n	if(date[1][0] > y[date[1][1] - 1])\n	{\n		date[1][0] = 1;\n		date[1][1]++;\n//		printf(\"day = 1; month++;\\n\");\n	}\n	if(date[1][1] > 12)\n	{\n		if(date[1][2] % 400 == 0 || (date[1][2] % 100 != 0 && date[1][2] %4 == 0))\n			y[1] = 29;\n		else\n			y[1] = 28;\n		date[1][1] = 1;\n		date[1][2]++;\n//		printf(\"month = 1; year++\\n\");\n	}\n	for(int i = 0; i < 3; i++)\n	{\n		printf(\"%d;\", date[1][i]);\n	}\n	printf(\"\\n\");\n\n}\n\nint main()\n{\n	int y[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n	int date[3][3] = {0};	//0 - day, 1 - month, 2 - year;\n\n	scanf(\"%d %d %d %d %d %d\", &date[0][0], &date[0][1], &date[0][2], &date[1][0], &date[1][1], &date[1][2]);\n	\n	if(date[0][2] < date[1][2])\n		swapDates(date);\n	else if(date[0][2] == date[1][2])\n	{\n		if(date[0][1] < date[1][1])\n			swapDates(date);\n		else if(date[0][1] == date[1][1])\n		{\n			if(date[0][0] < date[1][0])\n				swapDates(date);\n			else if(date[0][0] == date[1][0])\n			{\n				printf(\"0!\\n\");\n				return 0;\n			}\n		}\n	}\n\n	int i = 0;\n\n	for(i = 0; date[0][0] != date[1][0] || date[0][1] != date[1][1] || date[0][2] != date[1][2]; i++)	\n	{\n		printf(\"[ %10d ]\\n\", i);\n		date[1][0]++;\n		check(date, y);\n	}\n\n	i++;\n\n	printf(\"%d day(s)!\\n\", i);\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (364,'#include <stdio.h>\n\nint main(int agrc, char *agrv[])\n{\n	if(agrc != 3)\n	{\n		printf(\"Invalid parametres!\\n\");\n		return 1;\n	}\n	FILE * input = fopen(agrv[1], \"r\");\n	FILE * output = fopen(agrv[2], \"w\");\n	\n	int c = 0;\n	\n	while((c = fgetc(input)) != EOF)\n	{\n		fputc(c, output);\n	}\n\n	fclose(input);\n	fclose(output);\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (365,'#include <stdio.h>\n\nint main(int agrc, char *agrv[])\n{\n	FILE * input;\n	FILE * output;\n	\n	if(agrc == 3)\n	{\n		input = fopen(agrv[1], \"r\");\n		output = fopen(agrv[2], \"w\");\n	}\n	else if(agrc == 2)\n	{\n		input = fopen(agrv[1], \"r\");\n		output = stdout;\n	}\n	else\n	{\n		printf(\"Invalid parametres!\\n\");\n		return 1;\n	}\n\n	int tmp = \' \';\n	int c = 0;\n	int symbolCount = 0;\n	int wordCount = 0;\n	int stringCount = 0;\n	\n	while((c = fgetc(input)) != EOF)\n	{\n		\n//		printf(\"c: [%c], tmp: [%c]\\n\", c, tmp);\n//		if(c != \'\\n\')\n		symbolCount++;\n		if(c == \'\\n\')\n			stringCount++;\n		if((c == \' \' || c == \'\\n\' || c == \'\\t\') && tmp != \' \' && tmp != \'\\n\' && tmp != \'\\t\')\n		{	\n			wordCount++;\n//			printf(\"------------------wordCount++!!!\\n\");\n		}\n		tmp = c;\n	}\n\n	if(symbolCount == 0)\n		stringCount = 0;\n\n	fprintf(output, \"symbol(s): %6d\\nword(s):   %6d\\nstring(s): %6d\\n\", symbolCount, wordCount, stringCount);\n	\n	fclose(input);\n	fclose(output);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (366,'#include<stdio.h>\nint main(int argc, char *argv[])\n{\n	FILE *f ;\n	int S = 0, s, STR =0 , W = 0, t = 0 ;\n\n	if (argc == 1)\n	{\n		printf(\"Usage: %s filename\\n\", argv[0]);\n		return 0;\n	}\n	\n	f = fopen( argv[1] , \"r\" ) ;\n	if (!f)\n	{\n		perror(\"fopen\");\n		return 0;\n	}\n	while ( (s=fgetc(f))!= EOF )\n	{\n		if( (s==\' \') || (s==\'\\n\') || (s==\'\\t\') ) \n			t=1;\n		else\n			if(t)\n			{\n				W++;\n				t=0;\n			}\n		S++;\n		if(s==\'\\n\')\n		{ \n		\n			STR++ ;\n			\n		}\n				\n	}\n	fclose(f) ;\n	printf(\" S=%d  W= %d  STR= %d\\n\", S, W+1, STR ) ;\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (367,'#include <stdio.h>\nint main(int argc,char *argv[])\n{\n	int c;\n	FILE *inp, *out;\n	inp=fopen(argv[1],\"r\");\n	out=fopen(argv[2],\"w\");\n	while ((c=fgetc(inp))!=EOF)\n		fputc(c,out);\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (368,'#include <stdio.h>\nint main(int argc, char *argv[])\n{\n	FILE *f;\n	int  flag=0,cc=0,wc=0,sc=0,c;\n	f=freopen(argc == 1 ? \"input.txt\" : argv[1],\"r\",stdin);\n	while ((c=getchar())!=-1)\n	{\n		cc++;\n		if (flag==1)\n			if (c==\'\\t\' || c==\'\\n\' || c==\' \')\n			{\n				flag=0;\n				wc++;\n			}\n		if (flag==0)	\n			if (c!=\'\\n\' && c!=\'\\t\' && c!=\' \')\n			{\n				flag=1;\n			}\n		if (c==\'\\n\') sc++; \n	}\n	printf(\"%d %d %d\\n\", sc,wc,cc);\n	\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (369,'#include <stdio.h>\nint  TO(int a)\n{\n	if (a>=10 &&a<=15)\n		return (\'A\'+a-10);\n	return a+\'0\';\n	\n}\nint main()\n{\n	int i=1,b,ic,ost,cch[101]={0};\n	float d;\n	printf(\"Enter DEC number: \");\n	scanf(\"%f\",&d);\n	printf(\"Enter base: \");\n	scanf(\"%d\",&b);\n	ic=d;\n	while(ic!=0)\n	{		\n		ost=ic%b;\n		ic/=b;\n		cch[i]=ost;\n		i++;\n	}\n	i--;\n	for (0;i>0;i--)\n	printf(\"%c\",TO(cch[i]));\n	printf(\".\");\n	d=d-(int)d;\n	if (d==0.0) printf(\"0\");\n	while (d!=0.0)\n	{\n		printf(\"%c\",TO(d*b));\n		d=d*b-(int)(d*b);\n	}\n	printf(\"\\n\");		\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (370,'#include <stdio.h>\n#include <string.h>\n#define N 7\nchar s[N]={\'1\',\'2\',\'3\',\'4\',\'5\', \'6\', \'7\'};\nvoid copy(char*a,char*b)\n{\n	int i;\n	for (i=0;i<N;i++)\n	{\n		a[i]=b[i];\n	}\n}\nvoid per(char to[N],char from[N],int dlt)\n{\n	int i,j;\n	char tempt[N]={0},tempf[N]={0};\n	if (dlt==N)\n	{\n		to[dlt]=0;\n		printf(\"%s \",to);\n		return;\n	}\n	for (i=0;i<N-dlt;i++)\n	{\n		copy(tempt,to);\n		copy(tempf,from);\n		tempt[dlt]=tempf[i];\n		for(j=i;j<N-dlt-1;j++)\n		{\n			tempf[j]=tempf[j+1];\n		}\n		per(tempt,tempf,dlt+1);\n	}\n}\nint main()\n{\n	per(\"\",s,0);\n	return 0;\n\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (371,'#include<stdio.h>\nint main(int argc, char *argv[])\n{\n	FILE *f ;\n	int S = 0, s, STR =0 , W = 0, t = 0 ;\n\n	if (argc == 1)\n	{\n		printf(\"Usage: %s filename\\n\", argv[0]);\n		return 0;\n	}\n	\n	f = fopen( argv[1] , \"r\" ) ;\n	if (!f)\n	{\n		perror(\"fopen\");\n		return 0;\n	}\n	while ( (s=fgetc(f))!= EOF )\n	{\n		if( (s==\' \') || (s==\'\\n\') || (s==\'\\t\') ) \n			t=1;\n		else\n			if(t)\n			{\n				W++;\n				t=0;\n			}\n		S++;\n		if(s==\'\\n\')\n		{ \n		\n			STR++ ;\n			\n		}\n				\n	}\n	fclose(f) ;\n	printf(\" S=%d  W= %d  STR= %d\\n\", S, W+1, STR ) ;\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (372,'#include <stdio.h>\n/*(int date(int d, int m, int y)*/\n	\nint main()\n{\n	int d[12]={31,28,31,30,31,30,31,31,30,31,30,31}, d1, d2, m1, m2, y1, y2, i=0, c=0, s, date1=0, date2=0;\n	printf(\"??????? ?????? ????: \\n\");\n	scanf(\"%d%d%d\", &d1, &m1, &y1);\n	printf(\"??????? ?????? ????: \\n\");\n	scanf(\"%d%d%d\", &d2, &m2, &y2);\n	\n	 d[1]=28;\n	 if((y1%400==0) || (y1%4==0) && (y1%100!=0))\n	 {\n		d[1]=29;\n	 }\n		 \n	while(d1!=d2 || m1!=m2 || y1!=y2)\n	{\n		 d1++;\n		 if (d1 > d[m1-1])\n		 {\n			 m1++;\n			 d1 = 1;\n		 }\n		 if(m1>12)\n		 {\n			 y1++;\n			 m1=1;\n			 d[1]=28;\n			 if((y1%400==0) || (y1%4==0) && (y1%100!=0))\n			 {\n				d[1]=29;\n			 }\n		 }\n		 c++;\n	}\n	printf(\"%d\\n\", c+1);\n	return 0;\n}\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (373,'#include <stdio.h>\n#include <string.h>\n\nint reverse(char *a, int n)\n{\n	char c;\n	int i=0;\n	\n	for (; i<=(n-1)/2; i++){\n		if (a[i]!=a[n-i-1])\n			return 0;\n	}\n	return 1;\n}	\n\n\nint main()\n{\n	char s[255], c=\' \', f=\' \';\n	int i=0, j=0;\n	\n	printf(\"Test line at palindromic\\n\");\n	\n	do{\n		i = 0;\n		c = \' \';\n		printf(\"Input S string:\\n\");\n		while (c !=\'\\n\'){\n			scanf(\"%c\", &c);\n			if (c == \'\\n\')\n				break;\n			if (c >= \'0\' && c <= \'9\'){\n				s[i] = c;\n				i++;\n			}\n			if (c >= \'a\' && c <= \'z\'){\n	                	s[i] = c;\n		        	i++;\n			}\n			if (c >= \'A\' && c <= \'Z\'){\n				c = c + (\'a\' - \'A\');\n				s[i] = c;\n				i++;\n			}\n		}\n		if (reverse(s, i))\n			printf(\"S is palindrom\\n\");\n		else \n			printf(\"S isn\'t palindrom\\n\");\n	\n		printf(\"Press ENTER te continue. To quite press any key\\n\");\n	}\n	while ((f = getchar()) == \'\\n\');\n	\n	return 0;\n}\n	\n	\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (374,'#include <string.h>\r\n#include <iostream>\r\n\r\nclass ispstring\r\n{\r\n	private:\r\n		char *data;\r\n		int lengh;\r\n	\r\n	public:\r\n		ispstring() //?????????? ?? ?????????\r\n		{\r\n			data = new char[1];\r\n			data[0] = \'\\0\';\r\n			lengh = 0;\r\n		}\r\n\r\n		ispstring(char *s) //??????????? ? ?????????? char*\r\n		{\r\n			lengh = strlen(s);\r\n			data = new char[lengh+1];\r\n			strcpy(data,s);\r\n		}\r\n\r\n		ispstring(const ispstring &orig) //??????????? ???????????\r\n		{\r\n			lengh = orig.lengh;\r\n			data = new char[orig.lengh+1];\r\n			strcpy(data,orig.data);\r\n		}\r\n\r\n		~ispstring() //??????????\r\n		{\r\n			delete[] data;\r\n		}\r\n\r\n		ispstring& operator=(const ispstring orig) \r\n		{\r\n\r\n			if (&orig==this) return *this;\r\n			lengh = orig.lengh;\r\n			delete[] data;\r\n			data = new char[orig.lengh+1];\r\n			strcpy(data,orig.data);\r\n			return *this;\r\n		}\r\n\r\n		ispstring& operator=(char *s)\r\n		{\r\n			lengh = strlen(s)+1;\r\n			delete[] data;\r\n			data = new char[lengh+1];\r\n			strcpy(data,s);\r\n			return *this;\r\n		}	\r\n\r\n		operator const char*() const //???????? ?????????? ? const char*\r\n		{\r\n			char *b = new char[lengh+1];\r\n			strcpy(b,data);\r\n			return (const char*) b;\r\n		}\r\n\r\n		ispstring operator+(const ispstring& orig) //???????? ?????\r\n		{\r\n			char *buf = new char[lengh+orig.lengh+1];\r\n			strcpy(buf,data);\r\n			strcat(buf,orig.data);\r\n			ispstring s(buf);\r\n			delete[] buf;\r\n			return s;\r\n		}\r\n\r\n		ispstring& operator+=(const ispstring& orig) //???????? ?????\r\n		{\r\n			char *nar = new char[lengh+1];\r\n			strcpy(nar,data);\r\n			char *nar1 = new char[orig.lengh+1];\r\n			\r\n			lengh = lengh + orig.lengh;\r\n			strcpy(nar1,orig.data);\r\n			delete[] data;\r\n			data = new char[lengh + 1];\r\n			strcpy(data,nar);\r\n			strcat(data,nar1);\r\n			delete[] nar1;\r\n			delete[] nar;\r\n			return *this;\r\n		}\r\n\r\n		char operator[](int x) const //??????????? ???????? ??? ????????? ?? ???????\r\n		{\r\n			if ((x>=0)&&(x<lengh)) \r\n				return data[x]; \r\n		}\r\n\r\n		char& operator[](int x) //????????, ???????????? char & ??? ?????????\r\n		{\r\n			if ((x>=0)&&(x<lengh))\r\n				return data[x];\r\n		}\r\n};\r\n\r\nint main(){\r\n/*	ispstring s1,s2,s3;\r\n	s1 = \" jkgjkl\";\r\n	s2 = \" sasjkfgyewghdsfbyuewghjsdagksdayweghd\";\r\n	s3 = s1 + \" kajsdfhasdgfhgeuiwhjkdk,whgeiu!\";\r\n	std::cout << s3 << std::endl;\r\n\r\n	s1 = \" the\";\r\n	s1+=\" ilya\";\r\n	\r\n	std::cout << s1 << std::endl;\r\n	\r\n	std::cout << s1[4] << std::endl;\r\n\r\n	char example[100];\r\n	strcpy(example,s1);\r\n	s2 = \" kjs\";\r\n    s3 = s1 + s2 + \" !\";\r\n	s3[2] =\'0\';\r\n	std::cout << s3 <<std::endl;\r\n\r\n	//get(stdin);*/\r\n\r\n	ispstring s1 = \"abc\";\r\n	ispstring s2 = s1;\r\n	s1 = s2 + s2;\r\n	s1 += s1;\r\n	std::cout << s1 << \"\\n\";\r\n	std::cout << s2 << \"\\n\";\r\n\r\n	return 0;\r\n}//','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (375,'#include <iostream>\r\n#include <string.h>\r\ntemplate <typename T> class List\r\n{\r\n	private:\r\n		struct element\r\n		{\r\n			T data;\r\n			element *next;\r\n		};\r\n		element *head;\r\n\r\n		List(const List &r);			\r\n		List& operator=(const List &r);		//?????? ?????????? \r\n 	public:\r\n		List()\r\n		{\r\n			head = 0;\r\n			std::cout <<\"Go\\n\";\r\n		}\r\n		~List()\r\n		{\r\n			element *p;\r\n			p=head;\r\n			while(head)\r\n			{\r\n				p=head;\r\n				head=head->next;\r\n				delete p;\r\n			}\r\n			std::cout <<\"End\\n\";\r\n		}\r\n		void addfirst(const T a) // ????????\r\n		{\r\n			element *p;\r\n			p = new element;\r\n			if (p==0)\r\n			{\r\n				head=p;\r\n				p->data=a;\r\n				p->next=0;\r\n			}\r\n			else\r\n			{\r\n				p->data=a;\r\n				p->next = head;\r\n				head = p;\r\n			}\r\n		}\r\n		void addlast(const T a)  // ????????\r\n		{\r\n			element *p=head;\r\n			element *h = new element;\r\n			if(p==0)\r\n			{\r\n				head=h;\r\n				h->data=a;\r\n				head->next=0;\r\n			}\r\n			else\r\n			{\r\n				element *q=0;\r\n				while(p!=0)\r\n				{\r\n					q=p;\r\n					p=p->next;\r\n				}\r\n				q->next=h;\r\n				h->data=a;\r\n				h->next=0;\r\n			}\r\n		}\r\n		void delfirst()// ????????\r\n		{\r\n			element *p=head;\r\n			if(p==0) {std::cout<<\"Pusto bilo\"; return;}\r\n			if(p->next==0)\r\n			{\r\n				head=0;\r\n				delete p;\r\n			}\r\n			else\r\n			{\r\n				head = head->next;\r\n				delete p;\r\n			}\r\n		}\r\n		void dellast() //  ????????\r\n		{\r\n			struct element *p=head;\r\n			if(p==0){std::cout<<\"Pusto bilo\";return;}\r\n			if(p->next==0)\r\n			{\r\n				head =0;\r\n				delete p;\r\n			}\r\n			else  // ?????? ?? ???????\r\n			{\r\n				struct element *q=0;\r\n				while(p->next!=0)\r\n				{\r\n					q=p;\r\n					p=p->next;\r\n				}\r\n				q->next=0;\r\n				delete p;\r\n			}\r\n		}\r\n		void printAll() const   //// ?????? ?????\r\n		{	\r\n			struct element *p;\r\n			for(p=head;p;p=p->next)\r\n				std::cout << p->data;\r\n			std::cout << \"\\n\";\r\n		}\r\n};\r\n\r\n \r\nint main()\r\n{\r\n	List<int> f;\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		f.addlast(i);\r\n		f.addfirst(i);\r\n	}\r\n	f.printAll();\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		f.delfirst();\r\n		f.dellast();\r\n		f.printAll();\r\n	}\r\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (376,'#include <stdio.h>\n#include <string.h>\n#define N 100\nint main()\n{\n	int per1,per2,i=0,b,j=0,k,t,res1=0,st;\n	double res2=0;\n	int m[N]={0},p[N]={0};\n	printf(\"Vvedite s.s:\\n\");\n	scanf(\"%d\",&b);\n	getchar();\n	if(b<2 || b>16)\n	{\n		printf(\"Nevernoe chislo b\\n\");\n		return 0;\n	}\n	printf(\"Vvedite chislo v %d s.s\\n\", b);\n	for(i=0;((per1=getchar())!=\'.\' && per1!=\'\\n\') && (i<N);i++)\n		p[i]=per1;\n	if(per1!=\'\\n\')\n		for(j=0;((per2=getchar())!=\'\\n\') && (j<N);j++)\n			m[j]=per2;\n	if(i==0)\n	{\n		printf(\"Nevernoe chislo\\n\");\n		return 0;\n	}\n	if(i!=0)\n	{\n		st=1;\n		for(k=i-1;k>=0;k--)\n		{\n			if((p[k]>=\'a\') && (p[k]<=\'f\'))\n				p[k]=p[k]-\'a\'+10;\n			if((p[k]>=\'A\') && (p[k]<=\'F\'))\n				p[k]=p[k]-\'A\'+10;\n			if((p[k]>=\'0\') && (p[k]<=\'9\'))\n				p[k]=p[k]-\'0\';\n			if(p[k]>=0 && p[k]<=b)\n			{\n				printf(\"res1 += %d * %d\\n\", p[k], st);\n				res1=res1+p[k]*st;\n				printf(\"res1: %d\\n\", res1);\n				st=st*b;\n			}\n			else\n			{\n				printf(\"Nevernoe chislo\\n\");\n				return 0;\n			}\n		}\n	}\n	if(j!=0)\n	{\n		st=1;\n		for(t=0;t<j;t++)\n		{\n			if((m[t]>=\'a\') && (m[t]<=\'f\'))\n				m[t]=m[t]-\'a\'+10;\n			if((m[t]>=\'A\') && (m[t]<=\'F\'))\n				m[t]=m[t]-\'A\'+10;\n			if((m[t]>=\'0\') && (m[t]<=\'9\'))\n				m[t]=m[t]-\'0\';\n			if(m[t]>=0 && m[t]<=b)\n			{\n				st=st*b;\n				res2=res2+(float)m[t]/st;\n				printf(\"res2 += %f\\nres2 = %f\\n\", (float)m[t] / st, res2);\n			}\n			else\n			{\n				printf(\"Nevernoe chislo\\n\");\n				return 0;\n			}\n		}\n	}\n	if(j==0)\n	{\n		printf(\"Chislo = %d\\n\", res1);\n		return 0;\n	}\n	printf(\"res1: %d, res2: %f\\n\", res1, res2);\n	printf(\"Vashe chislo = %f\\n\", res1+res2);\n	return 0;\n}\n\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (377,'#include <stdio.h>\n#define N 10000\n\n\nvoid sort_pr(int *a, n)\n\nint main()\n	FILE *f;\n	int n;\n	int a[N]={0};\n	f=fopen(\"input1.txt\",\"r\");\n	\n			\n		\n	\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (378,'#include <stdio.h>\nint main()\n{\n	FILE *f;\n	int c;\n	int s=0;\n	int st=0;\n	int w=0;\n	int h=0;\n	f=fopen(\"input.txt\",\"r\");\n	while((c=fgetc(f))!=EOF)\n	{\n		s++;\n	        if (c==\' \' || c==\'\\n\' || c==\'\\t\')\n			h=0;\n		else\n			if (h==0)\n			{\n				h=1;\n		                w++;\n			}\n		if (c==\'\\n\')\n			st++;\n	}\n	fclose(f);\n	printf(\"%d, %d, %d\\n\", w, st, s);\n	return 0;\n}\n		\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (379,'#include <stdio.h>\n#include <string.h>\nint abs(int x) \n{ \n	return (x < 0) ? -x : x; \n} \n\nfloat pow(int x,int y)\n{\n	int i;\n	float j=x,p;\n	if(y==0)\n		return 1;\n	for (i=1;i<abs(y);i++)\n		x*=j;\n	if(y>0)\n		return (x);\n	return (p=1.0/x);\n}\nint main ()\n{\n	int d,z=0,f=0,b,i=0,j,a=0,l;\n	float k=0;\n	char c[100];\n	int q = 0;\n	scanf (\"%s %d\",&c, &b);\n	d=strlen(c);\n//	printf (\"\\n\");\n//	printf (\"d - %d\\n\",d);\n	while (c[i]!=0)\n	{\n		z++;\n		if(c[i]==\'.\')\n		{\n			z--;\n			a++;\n			break;\n		}\n		i++;\n	}\n	if(a>0)\n	{\n		f=d-z-1;\n	}\n	else\n	{\n		f=0;\n	}\n//	printf (\"%d %d \",z,f);\n	for(i=0;i<d;i++)\n	{\n		if(c[i]==\'.\')\n		{\n			i++;\n		}\n		if(c[i]>=\'A\' && c[i]<=\'Z\')\n		{\n			c[i] = c[i] - \'A\' + 10;\n		}\n		else\n		{\n			c[i]=c[i]-\'0\';\n		}\n//	printf (\"%d\",c[i]);\n//		printf (\"%d   -   %d\\n\",i,c[i]);\n	}\n	for(i=0;i<=d;i++)\n	{\n//			printf (\"pow   %f\",pow(b,z-(i+1)));\n		if(c[i]==\'.\')\n		{\n			i++;\n			q = 1;\n		}\n		printf(\"???????: %d\\n\", z-(i+1)+q);\n		k+=c[i]*pow(b,z-(i+1) + q);\n		//			c[i]*=pow(b,z-(i+1));\n//			k+=c[i];\n	}\n	printf (\"%f\\n\",k);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (380,'#include <stdio.h>\nint main (int argc, char* argv[])\n{\n	int a=0;\n	FILE* source = fopen(argv[1],\"r\");\n	FILE* destination = fopen(argv[2],\"w\");\n	while((a=fgetc(source))!= EOF)\n	{\n		fputc (a,destination);\n	}\n	fclose(source);\n	fclose(destination);\n	\nreturn 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (381,'#include<stdio.h>\nint main(int argc,char *argv[])\n{\n	FILE *f1, *f2;\n	char s;\n	f1=fopen(argv[1],\"r\");\n	if(!f1)\n	{\n	    perror(\"fopen\");\n	    return 0;\n	}\n	f2=fopen(argv[2],\"w\");\n	if(!f2)\n	{\n	        perror(\"fopen\");\n		return 0;\n	}\n	while((s=getc(f1))!=EOF)\n	{\n		fprintf(f2,\"%c\",s);\n	}\n	return 0;\n}\n		\n		\n		\n	\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (382,'#include<stdio.h>\nvoid print(int *a,int p)\n{\n	int i;\n	for(i=0;i<p;i++)\n		printf(\"%d\",a[i]);\n	printf(\"\\n\");\n}\nvoid permut(int *a,int *b, int N, int n)\n{\n	int i;\n	if(n==N)\n	{\n		print(a,N);\n		return;\n	}\n	for(i=0;i<N;i++)\n	{\n		if (b[i] == 0)\n			continue;\n		a[n]=b[i];\n		b[i] = 0;\n		permut(a,b,N, n+1);\n		b[i] = a[n];\n	}\n}\nint main()\n{\n	int N;\n	int a[100]={0},b[100]={0},i;\n//	scanf(\"%d\", &N);\n	N = 10;\n	for(i=0;i<N;i++)\n		b[i]=i+1;\n	permut(a,b,N,0);\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (383,'#include<stdio.h>\nint main(int argc,char *argv[])\n{\n	FILE *f1, *f2;\n	char s;\n	f1=fopen(argv[1],\"r\");\n	if(!f1)\n	{\n	    perror(\"fopen\");\n	    return 0;\n	}\n	f2=fopen(argv[2],\"w\");\n	if(!f2)\n	{\n	        perror(\"fopen\");\n		return 0;\n	}\n	while((s=getc(f1))!=EOF)\n	{\n		fprintf(f2,\"%c\",s);\n	}\n	return 0;\n}\n		\n		\n		\n	\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (384,'#include <stdio.h>\nint main(int argc, char* argv[])\n{\n	int s=0;\n	FILE* source = fopen(argv[1],\"r\");\n	FILE* destination = fopen(argv[2],\"w\");\n	while ((s = fgetc(source))!= EOF)\n	{\n		fputc(s, destination);\n	}\n        fclose(source);\n	fclose(destination);\n	return 0;\n}	\n			\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (385,'#include <stdio.h>\nint main()\n{\n	int words=0, t=\'\\n\',symb=0,str=0,s;\n	FILE*f;\n	f=fopen(\"source.txt\",\"r\");\n	while ((s=fgetc(f))!=EOF)\n	     {\n		     symb++;\n		     if ((t!=\'\\n\')&&(t!=\'\\t\')&&(t!=\' \'))\n                     if ((s==\'\\n\')||(s==\'\\t\')||(s==\' \'))\n			             words++;\n		     if	(s==\'\\n\') str++;\n		     t=s;\n	     }\n	if (symb==0) str=0;\n	fclose(f);\n	printf(\"%d %d %d\\n\",words, symb, str);\n	return 0;\n}\n		    \n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (386,'#define N 100\n#include <stdio.h>\nint is_prime(int(a))\n{\n	int i=0;\n	for(i=2;i*i<=a;i++)\n		if (a%i==0) \n			return 0;\n	return 1;	\n}\nint main()\n{\n	FILE *f1;\n	int i,c;\n	int A[N];\n	int n;\n	f1 = fopen(\"input.txt\",\"r\");\n	fscanf(f1, \"%d\", &n);\n	for (i=0;i<n;i++)\n		fscanf(f1,\"%d\",&A[i]);\n		\n	for (i=0; i<n; i++)		\n		if (is_prime(A[i])==1)\n		{	\n			printf(\"???? ??????? ?????\\n\");\n			c+=1;\n		}\n	if (c==n) \n		printf(\"??? ????? ???????\");\n	fclose(f1);\n	return 0;\n}\n\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (387,'#include<stdio.h>\n#include<math.h>\nint main(int argc,char *argv[])\n{\n	FILE *file1,*file2;\n	char x;\n	file1=fopen(argv[1],\"r\");\n	file2=fopen(argv[2],\"w\");\n	while((x=fgetc(file1))!=EOF)\n			putc(x,file2);\n	fclose(file1);\n	fclose(file2);\n	return 1;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (388,'#include <stdio.h>\n#include <string.h>\n\nint prisvoit(char input[51],int i)\n{\n	int a;\n	if( (input[i]>=\'0\') && (input[i]<=\'9\') )\n		a=input[i]-\'0\';\n	else\n	if( (input[i]>=\'A\') && (input[i]<=\'F\') )\n		a=input[i]-\'A\'+10;\n	else\n		a=-1;\n	return a;\n}\n\nint proverka(int a,int osn)\n{\n	if(a==-1)\n	{\n		printf(\"\\n??????????? ??????\\n\");\n		return 1;\n	}\n	if(a>=osn)\n	{\n		printf(\"\\n?????? ????? ?? ?????? ???? ?????? ??? ????? ????????? ?.?.\\n\");\n		return 1;\n	}\n	return 0;\n}\n\nint main()\n{\n	char input[51];\n	float output=0;\n	float tmp=0;\n	int right=0;\n	int osn=2;\n	int i=0;\n	int a;\n	printf(\"??????? ????????? ?.?.\\n\");\n	scanf(\"%d\",&osn);\n	if((osn<2)||(osn>16))\n	{\n		printf(\"????????? ?.?. ?????? ???? ????? 2 ? 16\\n\");\n		return 1;\n	}\n	printf(\"??????? ?????\\n\");\n	scanf(\"%s\",input);\n	right=strlen(input)-1;\n	\n	while ( (input[i]!=\'.\') && (i<=right) )\n	{\n		a=prisvoit(input,i);\n		if(proverka(a,osn)==1)return 1;\n		output=output*osn+a;\n		i++;\n	}\n	if(input[i]==\'.\')\n	{\n		while(right>i)\n		{\n			a=prisvoit(input,right);\n			if(proverka(a,osn)==1)return 1;\n			tmp=(tmp+a)/osn;\n			right--;\n		}\n		output+=tmp;\n	}\n	printf(\"\\n???? ????? ? 10 ?.?. =  %f\\n\",output);\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (389,'#include <stdio.h>\nint vis(int x)\n{\n	if ((x%400==0)||((x%4==0)&&(x%100!=0)))\n		return 1;\n	return 0;\n}\nint main()\n{\n	int otv=0;\n	int a0;\n	int b0;\n	int c0;\n	int a;\n	int b;\n	int c;\n	int nd=0;\n	int kd=0;\n	int kolvis0=0;\n	int kolvis=0;\n	int i;\n	scanf(\"%d/%d/%d\",&a0,&b0,&c0);\n	scanf(\"%d/%d/%d\",&a,&b,&c);\n	for(i=1578;i<c0;i++)\n       	kolvis0 +=vis(i);\n        nd=(365*(c0-1))+kolvis0;\n	if (vis(c0)==1)\n			switch (b0)\n			{\n	\n		case 12:nd+=335;break;\n		case 11:nd+=305;break;\n		case 10:nd+=274;break;\n		case 9:nd+=244;break;\n		case 8:nd+=213;break;\n		case 7:nd+=182;break;\n		case 6:nd+=152;break;\n		case 5:nd+=121;break;\n		case 4:nd+=91;break;\n		case 3:nd+=60;break;\n		case 2:nd+=31;break;\n	                 } \n	else\n	  switch (b0)\n	  {\n	        case 12:nd+=334;break;\n		case 11:nd+=304;break;\n		case 10:nd+=273;break;\n		case 9:nd+=243;break;\n		case 8:nd+=212;break;\n		case 7:nd+=181;break;\n		case 6:nd+=151;break;\n		case 5:nd+=120;break;\n		case 4:nd+=90;break;\n		case 3:nd+=59;break;\n	      	case 2:nd+=31;break;\n	  }\n	nd+=a0;\n\n		\n\n	\n	\n	for(i=1578;i<c;i++)\n       	kolvis +=vis(i);\n       	kd=(365*(c-1))+kolvis;\n	if (vis(c)==1)\n			switch (b)\n			{\n	\n		case 12:kd+=335;break;\n		case 11:kd+=305;break;\n		case 10:kd+=274;break;\n		case 9:kd+=244;break;\n		case 8:kd+=213;break;\n		case 7:kd+=182;break;\n		case 6:kd+=152;break;\n		case 5:kd+=121;break;\n		case 4:kd+=91;break;\n		case 3:kd+=60;break;\n		case 2:kd+=31;break;\n	                 } \n	else\n	  switch (b)\n	  {\n	        case 12:kd+=334;break;\n		case 11:kd+=304;break;\n		case 10:kd+=273;break;\n		case 9:kd+=243;break;\n		case 8:kd+=212;break;\n		case 7:kd+=181;break;\n		case 6:kd+=151;break;\n		case 5:kd+=120;break;\n		case 4:kd+=90;break;\n		case 3:kd+=59;break;\n	      	case 2:kd+=31;break;\n	  }\n	kd+=a;\n	otv=kd-nd+1;\nprintf(\"%d\\n\",otv);\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (390,'#include <stdio.h>\nint isprime(int a)\n{\n	int i=0;\n	for (i=2;i<a;i++)\n	{\n		if (a%i==0)\n		    return 0;\n	}\n	return 1;\n}\nint main()\n{\nint i=0;\nint k=0;\nint n=3;\nint B[3];\nfor (i=0;i<n;i++)\n       scanf (\"%d\",&B[i]);\nfor (i=0;i<n;i++)\n{\n	if(isprime(B[i])==1)\n		k++;\n}\nif (k==n)\n	printf(\"vse elementu prostue\\n\");\nelse\n     {\n	     if (k>0)\n		     printf(\"sredi elementov est kak minimum odno prostoe\\n\");\n     }\nreturn 0;\n}\n		     \n\n	\n	\n	\n	\n\n\n\n\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (391,'#include <stdio.h>\nint main()\n{\nint t;\nint i=0;\nint n=5;\nint j=n+1;\nint x;\nint k;\nint A[n];\nprintf(\"element: \");\nscanf(\"%d\", &x);\nprintf(\"massiv: \");\nfor(t=0;t<n;t++)\n      scanf(\"%d\",&A[t]);\nwhile(i <= j)\n{\n	k=(i+j)/2;\n	if (x == A[k])\n	{\n		printf(\"element naiden on pod nomerom %d\\n\", k);\n		return 0;\n	}\n	else if (x>A[k])\n		i = k + 1;\n	else\n		j = k - 1;\n}\n\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (392,'// Spisok.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n\r\n#include \"stdafx.h\"\r\n#include <iostream>\r\n#include <stdlib.h> \r\nusing namespace std;\r\n\r\ntemplate <typename T> class List\r\n{\r\n         private:\r\n                 struct element\r\n                 {\r\n                        T data;\r\n                        element* next;\r\n                        };\r\n				element *head;\r\n				List& operator=(const List& orig);\r\n				List(const List& orig);\r\n         \r\n			public:\r\n                \r\n				List()\r\n                {\r\n                      head=NULL;\r\n                }\r\n\r\n                void AddHead(T item)\r\n                {\r\n                 element* p;\r\n                   p=new element;\r\n                   p->data=item;\r\n                   p->next=head;\r\n                   head=p;\r\n                 }\r\n\r\n                 void DelHead()\r\n                 {\r\n                 element* p;\r\n				 p=head->next;\r\n				 if (head!=NULL)\r\n                 delete (head);\r\n                 head=p;   \r\n                 }\r\n\r\n				 void AddTail(T item)\r\n				 { \r\n					element* p; \r\n					element* ptr;\r\n					p=new element;\r\n					p->data=item;\r\n					p->next=NULL;\r\n					ptr=head;\r\n					if (head!=NULL)\r\n					{while(ptr->next)\r\n						ptr=ptr->next;\r\n					\r\n					ptr->next=p;}\r\n					else {head=p;}\r\n				 }\r\n\r\n				void DelTail()\r\n				 { \r\n					element* ptr;\r\n					element* p;\r\n					ptr=head;\r\n					if ((head!=NULL)&&(head->next!=NULL))\r\n					{while(ptr->next)\r\n					{\r\n						p=ptr;\r\n						ptr=ptr->next;\r\n					}\r\n					delete (ptr);\r\n					p->next=NULL;}\r\n					else\r\n					{delete(head);\r\n					head=NULL;}\r\n				 }\r\n\r\n                 ~List()\r\n                 {\r\n                        element* p;\r\n                        while(head)\r\n                        {\r\n                           p=head->next;\r\n                           delete(head);\r\n                           head=p;     \r\n                        }\r\n                 }\r\n				 \r\n				 class iterator\r\n                {\r\n                    private: \r\n                             element* i;\r\n                    public:\r\n                           \r\n                    iterator(element* item)  \r\n                    {i=item;}\r\n                     \r\n                    iterator operator++(int)\r\n                    {	\r\n						i = i->next;\r\n						return *this;\r\n					}\r\n                    \r\n                    bool operator!=(iterator& other)\r\n                    {if (other.i!=i) return true;\r\n                                return false;\r\n					}\r\n					T operator*()\r\n					{\r\n						return(i->data);\r\n					}\r\n                };\r\n				\r\n                iterator begin() const\r\n                {return iterator(head); }\r\n                \r\n                iterator end() const\r\n                {\r\n                   return iterator(0);    \r\n                }\r\n\r\n				void PrintList()\r\n				 {\r\n					element* p;\r\n					p=head;\r\n					while (p)\r\n					{\r\n						cout<<p->data<<\' \';\r\n						p=p->next;\r\n					}\r\n					cout<<endl;\r\n	/*				 for (List::iterator p=begin(); p!=end(); p++)\r\n					 { cout<< List::iterator *p <<\' \';}\r\n					cout<<endl;\r\n				 \r\n				 */}\r\n\r\n\r\n         };\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n\r\n	List<double> l;\r\n	for (double i = 1.1; i < 6; i++)\r\n	{\r\n		l.AddTail(i);\r\n		l.AddHead(i + 0.1);\r\n	}\r\n\r\n	for (List<double>::iterator p=l.begin(); p!=l.end(); p++)\r\n	{ \r\n		cout<< *p <<\' \';\r\n	}\r\n	cout<<endl;\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		l.DelHead();\r\n		l.DelTail();\r\n		for (List<double>::iterator p=l.begin(); p!=l.end(); p++)\r\n		{ \r\n			cout<< *p <<\' \';\r\n		}\r\n		cout<<endl;\r\n	}\r\n\r\n	for (double i = 1.1; i < 6; i++)\r\n	{\r\n		l.AddHead(i + 0.1);\r\n		l.AddTail(i);\r\n	}\r\n\r\n	for (List<double>::iterator p=l.begin(); p!=l.end(); p++)\r\n	{ \r\n		cout<< *p <<\' \';\r\n	}\r\n	cout<<endl;\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		l.DelTail();\r\n		l.DelHead();\r\n		for (List<double>::iterator p=l.begin(); p!=l.end(); p++)\r\n		{ \r\n			cout<< *p <<\' \';\r\n		}\r\n		cout<<endl;\r\n	}\r\n\r\n	return 0;\r\n}\r\n','ÐÐ½Ð½Ð°','Anna','f');
INSERT INTO `bias` VALUES (393,'#include <stdio.h>\n#include <stdlib.h>\n\nvoid next_mask(int* mask, int* limits, int length)\n{\n	int i, inc = 1, r;\n\n	for (i = 0; i < length; i++)\n	{\n		if (mask[i]+inc >= limits[i]+1) r = 0;\n		else r = mask[i]+inc;\n		mask[i] = r;\n		if (r == 0) inc &= 1;\n		else inc = 0;\n	}\n}\n\nvoid full_print(int* val, int* rep, int length)\n{\n	int i, j;\n	\n	printf(\"( \");\n	for (i = 0; i < length; i++)\n		for (j = 0; j < rep[i]; j++)\n			printf(\"%d \", val[i]);\n	printf(\") \");\n}\n\nint main(int argc, char** argv)\n{\n	int length, maxi = 1, sum, i, j, s;\n	int* mask, *limits, *cash;\n\n	sum = atoi(argv[1]);\n	length = argc-2;\n	limits = (int*)malloc(length*sizeof(int));\n	cash = (int*)malloc(length*sizeof(int));\n	for (i = 0; i < length; i++)\n	{\n		cash[i] = atoi(argv[i+2]);\n		limits[i] = sum / cash[i];\n		maxi *= limits[i]+1;\n	}\n	mask = (int*)calloc(length, sizeof(int));\n	printf(\"( \");\n	for (i = 0; i < maxi; i++)\n	{\n		next_mask(mask, limits, length);\n		s = 0;\n		for (j = 0; j < length; j++)\n			s += cash[j]*mask[j];\n		if (s == sum)\n			full_print(cash, mask, length);\n	}\n	printf(\")\\n\");\n	\n	free(limits);\n	free(mask);\n	free(cash);\n	\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (394,'#include <cstdlib>\n\n#include <list>\nusing std::list;\n\n#include <iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::ostream;\n\ntypedef int number_t;\n\n// <Translated from Common Lisp to C++ functions>\nlist <number_t> divz(number_t n, number_t m)\n{\n	list <number_t> res;\n	if (m == 1) return res;\n	if (n % m == 0)\n	{\n		res = divz(n, m - 1);\n		res.push_front(m);\n		return res;\n	}\n	else return divz(n, m - 1);\n}\n\nlist <list <list <number_t> > > factorlists(number_t n);\n\nlist <list <number_t> > dlist(number_t n, number_t d)\n{\n	list <list <number_t> > res;\n	if (n == d)\n	{\n		list <number_t> r;\n		r.push_front(d);\n		res.push_front(r);\n		return res;\n	}\n	list <list <list <number_t> > > flists = factorlists (n / d);\n	for (list <list <list <number_t> > >::iterator it = flists.begin(); it != flists.end(); ++it)\n	{\n		list <number_t> r = it->front();\n		r.push_front(d);\n		res.push_back(r);\n	}\n	return res;\n}\n\nlist <list <list <number_t> > > factorlists(number_t n)\n{\n	list <list <list <number_t> > > res;\n	list <number_t> dz = divz(n, n);\n	for (list <number_t>::iterator it = dz.begin(); it != dz.end(); ++it)\n	{\n		res.push_back( dlist(n, *it) );\n	}\n	return res;\n}\n\nlist <list <number_t> > factors(number_t n)\n{\n	list <list <number_t> > res;\n	list <list <list <number_t> > > fs = factorlists(n);\n	for (list <list <list <number_t> > >::iterator it = fs.begin(); it != fs.end(); ++it)\n	{\n		for (list <list <number_t> >::iterator jt = it->begin(); jt != it->end(); ++jt)\n		{\n			res.push_back( *jt );\n		}\n	}\n	return res;\n}\n// </ Translated from Common Lisp to C++ functions>\n\ntemplate <class T> ostream & operator << (ostream &out, list <T> l)\n{\n	out << \'(\';\n	for (class list<T>::const_iterator it = l.begin();;)\n	{\n		out << *it;\n		if (++it != l.end()) out << \' \';\n		else break;\n	}\n	out << \')\';\n	return out;\n}\n\nint main(int argc, char *argv[])\n{\n	if (argc < 2)\n	{\n		cout << \"Too few arguments for \" << argv[0] << endl;\n		return 1;\n	};\n	cout << factors( atoi(argv[1]) ) << endl;\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (395,'#include <stdio.h>\nint bin_search(int *A, int N, int k)\n{\n	int l=0, r=N-1, m;\n//	???? l <= r, ?????????:\n	while(l<=r)\n	{\n		m=(l+r)/2;\n	        if(k==A[m])\n                	return m;\n	        if(k<A[m])\n	        {\n		r=m-1;\n	        }\n	        else\n                l=m+1;\n	}	\n//	????? ?????: ??? ?? ???, ?????? ??????? ????? ??????,\n//	????? ??????? -1\n	return -1;\n}\n\nint main()\n{\n	int P[5] = { 1, 3, 5, 7, 9 }, k, x;\n	printf(\"Vvedite chislo: \\n\");\n	scanf(\"%d\", &k);\n	x = bin_search(P, 5, k);\n	if(x != -1)\n	{\n		printf(\"ECTb \\n\");\n	}\n	else\n		printf(\"HET \\n\");\n//	printf(\"%d\\n\", x);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (396,'#include <stdio.h>\n#define N 100\nint main()\n{\n	int z,b,i,s,kol=0,per,k;\n	int a[N]={0};\n	double dr,n;\n	char sim1;\n	printf(\"Vvedite s.s\\n\");\n	scanf(\"%d\", &b);\n	if(b<2 || b>16)\n	{\n		printf(\"Nevernaya b\\n\");\n		return 0;\n	}\n	printf(\"Vvedite chislo v 10 s.s\\n\");\n	scanf(\"%lf\", &n);\n        z=(int)n;\n	dr=n-z;\n	printf(\"Vashe chiclo v %d-s.s\\n\", b);\n	if(z!=0)\n	{\n		for(i=0;z!=0;i++)\n		{\n			a[i]=z%b;\n			z=z/b;\n		}\n		i--;\n		for(k=i;k>=0;k--)\n		{\n			if(a[k]>=10)\n				sim1=a[k]-10+\'A\';\n			else\n				sim1=a[k]+\'0\';\n			printf(\"%c\", sim1);\n		}\n	}\n	else\n		printf(\"0\");\n	if(dr!=0)\n	{\n		printf(\".\");\n		do\n		{\n		        dr=dr*b;\n			per=(int)dr;\n			dr=dr-per;\n			if(per>=10)\n				sim1=per-10+\'A\';\n			else\n				sim1=per+\'0\';\n			printf(\"%c\",sim1);\n			kol++;\n		}\n		while(dr<1 && kol<10);\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (397,'#include <stdio.h>\n\nint main(int agrc, char *agrv[])\n{\n	FILE *f1 = NULL;\n	FILE *f2 = NULL;\n	int c;\n\n	if(agrc==3)\n	{\n		f1=fopen(agrv[1],\"r\");\n		if (!f1)\n		{\n			perror(\"fopen\");\n			return 0;\n		}\n		f2=fopen(agrv[2],\"w\");\n		if (!f2)\n		{\n			perror(\"fopen\");\n			return 0;\n		}\n	}\n	else printf(\"Error!\\n\");\n\n	while((c=fgetc(f1))!=EOF)\n		fputc(c, f2);\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (398,'#include <stdio.h>\n#include <string.h>\n\nint main(int agrc, char* agrv[])\n{\n	char login[20] = {0};\n	if(agrc == 2)\n	{\n//		printf(\"parameters: 2\\n\");\n		strcpy(login, agrv[1]);\n	}\n	else if(agrc <= 1)\n	{\n		fgets(login, 20, stdin);\n		login[strlen(login) - 1] = 0;\n	}\n	else\n	{\n		printf(\"Invalid parameters!\\n\");\n		return 0;\n	}\n\n	FILE* I = fopen(\"/etc/passwd\", \"r\");\n	if(I == NULL)\n	{\n		printf(\"failed to read /etc/passwd ...\\n\");\n		return 0;\n	}\n\n	char str[200] = {0};\n	char subStr[200] = {0};\n	char res[200] = {0};\n	char tmp[200] = {0};\n	\n	while(fgets(str, 200, I) != NULL)\n	{\n		int counter = 0;\n		strncpy(subStr, str, strlen(login));\n		if((strcmp(login, subStr) == 0) && (str[strlen(login)] == \':\'))\n		{\n			int c = 0;\n			for(int i = 0; i < 200 && c <= 3; i++)\n			{\n				if(str[i] == \':\')\n					c++;\n				if(c == 4)\n				{\n					i++;\n					while(str[i] != \',\' && str[i] != \':\')\n					{\n						printf(\"%c\", str[i]);\n						i++;\n					}\n					printf(\"\\n\");\n					return 0;\n				}\n			}\n		}\n	}\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (399,'#include <stdio.h>\n#define N 200\nint main()\n{\n	char s[N],r[N];\n	int i,j,c=\'1\',flag,d,fg,found=0;\n	FILE* f;\n	f=fopen(\"/etc/passwd\",\"r\");\n	scanf(\"%s\",s);\n	while (c!=EOF)\n	{\n		flag=0;\n		j=0;\n		d=0;\n		fg=0;\n		for (i=0;i<100;i++) r[i]=0;\n		while (((c=fgetc(f))!=EOF) && c!=\'\\n\')\n		{\n			if (flag==0) \n			{\n				if (c!=\':\') {r[j]=c; j++;}\n				if (c==\':\') {flag=1; r[j]=0;}\n			}\n			if (flag==1 && strcmp(s,r)==0) \n			{\n				if (c==\':\') d++;\n				if (d==4 ) \n				{\n					if (c!=\',\' && c!=\':\' && fg!=-1) {printf(\"%c\",c); fg=1; found=1;}\n					if (fg==1 && (c==\',\' || c==\':\')) {printf(\"\\n\"); return 0;}\n				}\n			}\n			\n		}\n	}\n	printf(\"\\n\");\n	if (found==0)	printf(\"NOT FOUND\\n\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (400,'#include <stdio.h>\nint main ()\n{\n	int d,k=0,i,a,l=0,j=0;\n	char c[200];\n	char s[200];\n	FILE* f=fopen(\"/etc/passwd\",\"r\");\n	scanf(\"%s\",&c);\n	d = strlen(c);\n	fgets(s,200,f);\n	for(i=0;s[i]!=\':\';i++)\n	{\n		if(s[i]!=c[i])\n		{\n			if(fgets(s,200,f)==NULL)\n			{\n				break;\n			}\n			else\n			{\n				l=0;\n				i=0;\n				j=0;\n			}\n		}\n		if (c[i]==s[i])\n		{\n			l++;\n		}\n	}\n	for(j=0;k<4;j++)\n	{\n		if(s[j]==\':\')\n		{\n			k++;\n		}\n	}\n	if (l==i)\n	{\n		for (j;s[j]!=\',\'&&s[j]!=\':\';j++)\n		{\n			printf(\"%c\",s[j]);\n		}\n		printf(\"\\n\");\n	}\n	else\n	{\n		printf (\"net\\n\");\n	}\n	\n	\n	fclose (f);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (401,'#include <stdio.h>\nfloat stepen(int osn, float input, int *k,int *l)\n{\n	float tmp=1;\n	float tmp1=1;\n	int i=0;\n	int j=0;\n	if(input>=osn)\n	{\n		while(tmp<=input)\n		{\n			tmp1=tmp;\n			tmp=tmp*osn;\n			i++;\n		}\n		i--;\n	}\n	else if(input<1)\n		while(tmp1>input)\n		{\n			tmp1/=osn;\n			i--;\n		}\n\n	while(input>=0)\n	{\n		tmp=input;\n		input-=tmp1;\n		j++;\n	}\n	*k=i;\n	*l=j-1;\n	\n	return tmp;\n}\n\nchar inttochar(int a)\n{\n	char b;\n	if(a<10)\n		b=\'0\'+a;\n	else \n		b=\'A\'+a-10;\n}\nint main()\n{\n	float input=0;\n	float bzu=0;\n	char output[26]={0};\n	int i=0,j=0,k=0;\n	int osn;\n	int max_s,num,prev,tmp_s;\n\n	printf(\"??????? ?????\\n\");\n	scanf(\"%f\",&input);\n	printf(\"??????? ????????? ?.?.\\n\");\n	scanf(\"%d\",&osn);\n	if((osn<2)||(osn>16))\n		return 1;\n	\n	input=stepen(osn,input,&i,&j);	\n	output[0]=inttochar(j);\n	max_s=i;\n	prev=0;\n	tmp_s=i;\n	\n	while(input>0.000010)\n	{\n		input=stepen(osn,input,&i,&j);\n			\n		if((tmp_s>=0)&&(i<0))\n		{\n			for(k=prev+1;k<=max_s;k++)\n				output[k]=\'0\';\n			max_s++; 		\n			output[max_s]=\'.\';\n			prev=max_s;\n		}\n		for(k=prev+1;k<max_s - i;k++)\n			output[k]=\'0\';\n		output[max_s-i]=inttochar(j);\n		prev=max_s-i;\n		tmp_s=i;\n				\n	}\n	\n	if (i>0)\n		for(k=prev+1;k<=max_s;k++)\n			output[k]=\'0\';\n\n	printf(\"%s\\n\",output);\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (402,'#include<stdio.h>\nint main()\n{\n	int a=0, a1=0, a2=0, a3=0;\n	char x;\n	FILE *file;\n	file=fopen(\"input.txt\", \"r\");\n	while((x=getc(file))!=EOF)\n	{\n		a1++;\n		if(x==\'\\n\')\n			a3++;\n		if(x==\' \' || x==\'\\n\' || x==\'\\t\')\n			a=0;\n		else\n			if(a==0)\n			{\n				a=1;\n				a2++;\n			}\n	}\n	fclose(file);\n	printf(\"Simvols: %d\\nSlova: %d\\nStroks: %d\\n\", a1, a2, a3);\n	getchar();\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (403,'#include <stdio.h>\nint main(int argc,char *argv[])\n{\n	FILE *f1,*f2; \n	char c;\n	f1=fopen(argv[1],\"r\");\n	f2=fopen(argv[2],\"w\");\n	while ((c=fgetc(f1))!=EOF)\n		putc(c,f2);\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (404,'#include <stdio.h>\nint main()\n{\n	int c,nl,nw,nc,inword;\n	FILE *f1=fopen(\"da.txt\",\"r\");\n	inword=0;\n	nl=nw=nc=0;\n	while((c=fgetc(f1))!=EOF)\n	{\n	nc++;\n	if(c==\'\\n\')\n		++nl;\n	if (c==\' \' || c==\'\\n\' || c==\'\\t\')\n		inword=0;\n	else \n		if (inword==0)\n		{\n			inword=1;\n	                ++nw;\n		}	\n	}\n	fclose(f1);\n	printf(\"stroki  %d slova %d simvoly %d\\n\",nl,nw,nc-1);\n	return 0;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (405,'#include <stdio.h>\nint main()\n{\n	int k=0;\n	int a=0;\n	int d=0;\n	int i=0;\n	int t=0;\n	char s[]=\"on,diven palindrom i ni mord ni lap ne vidno\";\n	for(k=0;s[k];k++)\n		;\n	printf(\"k=%d\\n\",k);\n	for (i=0;i<k;i++)\n	{\n		if ((s[i]==\' \')||(s[i]==\',\')||(s[i]==\'.\'))\n		{\n		t=i;   \n		for (t;t<k;t++)\n		      {\n			s[t]=s[t+1];\n		      }\n		k=k-1;\n		}	\n	}\n	printf(\"k obnov=%d\\n\",k);\n	for (a=0;a<k;a++)\n		if (s[a]==s[k-a-1])\n			d++;\n	printf(\"d=%d\\n\",d);\n	if (d==k)\n		printf(\"eto palindrom\\n\");\n	else \n		printf(\"eto ne palindrom\\n\");\n	return 0;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (406,'#include <stdio.h>\nint main()\n{\n	int i,n;\n	char pred[100];\n	char l,r;\n	printf(\"??????? ???????????: \");\n	fgets(pred, 100, stdin);\n	pred[strlen(pred)-1]=0;\n	n=strlen(pred);\n	l=0;\n	r=n-1;\n	for (i=0; l<=r; i++) \n	{\n		while (pred[l]==\' \' || pred[l]==\',\' || pred[l]==\'.\')\n			l++;\n		while (pred[r]==\' \' || pred[r]==\',\' || pred[l]==\'.\')\n			r--;\n	}\n	if (pred[l]==pred[r])\n	{\n		l++;\n		r--;\n	}\n	else\n	{\n		printf(\"??????????? ?? ?????????\\n\");\n		return 0;\n	}\n	printf(\"?????????? ?????????\");\nreturn 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (407,'#include<stdio.h>\n#include<string.h>\n#define N 100\nint del(int num, char s[N],int c)\n{\n	do\n	{\n		num=num+c;	\n	}\n	while((s[num]<\'a\')||(s[num]>\'z\'));\n	return num;\n}\nint main()\n{\n	\n	char s[N+1]={0};\n	int i=0, j=0;\n	printf(\"??????? ?????: \");\n	fgets(s,N,stdin);\n	j=strlen(s)-1;\n	for(i=0; i<j; i++, j--)\n	{\n		if((s[i]<\'a\')||(s[i]>\'z\'))\n			i=del(i,s,1);\n		if((s[j]<\'a\')||(s[j]>\'z\'))\n			j=del(j,s,-1);\n		\n		if(s[i]!=s[j])\n		{\n			printf(\"?? ?????????\\n\");\n			return 0;\n		}\n		\n	}	\n\n	printf(\"?????????\\n\");\n	return 0;\n}	\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (408,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	int i, c=0, k;\n	FILE *f=fopen(\"/etc/passwd\",\"r\");\n	char s[200]={0}, s2[50], login[50];\n	\n	printf(\"Input login:\\n\");\n	scanf(\"%s\", &login);\n	k = strlen(login);\n	\n	while((fgets(s, 200, f)) != NULL)\n	{\n		if (strncmp(login, s, k) == 0)\n		{\n			if (s[k] == \':\')\n			{	\n				for (i=k+1; i<200; i++)\n				{\n					if (s[i] == \':\')\n						c++;\n					if (c == 3)\n					{\n						if (s[i+1] == \',\')\n							break;\n						if (s[i+1] == \':\')\n							break;\n						printf(\"%c\", s[i+1]);\n					}\n				}\n				printf(\"\\n\");\n				return 0;\n			}\n		}\n	}\n	fclose(f);\n\n	printf(\"No information\\n\");\n	\n	return 0;\n}\n	\n		\n		\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (409,'#include <stdio.h>\n#include <string.h>\n\nint main(int agrc, char* agrv[])\n{\n	char login[20] = {0};\n	if(agrc == 2)\n	{\n//		printf(\"parameters: 2\\n\");\n		strcpy(login, agrv[1]);\n	}\n	else if(agrc <= 1)\n	{\n		fgets(login, 20, stdin);\n		login[strlen(login) - 1] = 0;\n	}\n	else\n	{\n		printf(\"Invalid parameters!\\n\");\n		return 0;\n	}\n\n	\n	FILE *I = fopen(\"/etc/passwd\", \"r\");\n	if(I == NULL)\n	{\n		printf(\"Error\\n\");\n		exit(-1);\n	}\n	if(I == NULL)\n	{\n		printf(\"failed to read /etc/passwd ...\\n\");\n		return 0;\n	}\n\n	char str[200] = {0};\n	char subStr[200] = {0};\n	char res[200] = {0};\n	char tmp[200] = {0};\n	\n	while(fgets(str, 200, I) != NULL)\n	{\n		int counter = 0;\n		strncpy(subStr, str, strlen(login));\n		if((strcmp(login, subStr) == 0) && (str[strlen(login)] == \':\'))\n		{\n			int c = 0;\n			for(int i = 0; i < 200 && c <= 3; i++)\n			{\n				if(str[i] == \':\')\n					c++;\n				if(c == 4)\n				{\n					i++;\n					while(str[i] != \',\' && str[i] != \':\')\n					{\n						printf(\"%c\", str[i]);\n						i++;\n					}\n					printf(\"\\n\");\n					return 0;\n				}\n			}\n		}\n	}\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (410,'#include <stdio.h>\n\nvoid swap(int* array, int a, int b)\n{\n	int tmp = array[a];\n	array[a] = array[b];\n	array[b] = tmp;\n}\n\nvoid simpleSort(int* array, int length)\n{\n	int c = 0;\n	int min = 0;\n	\n	for(int i = 0; i < length; i++)\n	{\n		for(int j = c; j < length; j++)\n		{\n			if(array[min] > array[j])\n			{\n				min = j;\n//				printf(\"-----------min: %d\\n\", array[min]);\n			}\n		}\n//		printf(\"min[%d] <---> [%d]\\n\", array[min], array[i]);\n		swap(array, min, i);\n		min = ++c;\n//		printf(\"----------------------   [%d]\\n\", array[i]);\n\n	}\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (411,'#include <stdio.h>\nint main()\n{\n	int N,a=0,b=0,n,c,i,d,j,r;\n	int A[100];\n	FILE* f=fopen(\"input.txt\",\"r\");\n	FILE* I=fopen(\"output.txt\",\"w\");\n	fscanf (f,\"%d\",&N);\n	for(i=0;i<N;i++)\n	{\n	fscanf(f,\"%d\",&A[i]);\n	}\n/*	for(i=0;i<N;i++)\n	{\n	a=0;\n		for(j=0;j<N;j++)\n		{\n			if(A[i]>A[j])\n			{\n				a++;\n			}\n			if(A[i]==A[j])\n			{\n				d=A[j];\n				A[j]=A[i+1];\n				A[i+1]=d;\n			}\n		}\n		d=A[i];\n		A[i]=A[a+1];\n		A[a+1]=d;\n	}\n	for(i=0;i<N;i++)\n	{\n		fprintf (I,\"%d \",A[i]);\n	}*/\n	i=0;\n	while(i<N)\n	{\n		r=0;\n		for(j=0;j<N;j++)\n		{\n			if(A[i]>A[j])\n			{\n				r++;\n			}\n		}\n		if(r<=i)\n		{\n			i++;\n		}\n		else\n		{\n			while(A[r]=A[i])\n			{\n				r++;\n			}\n			d=A[r];\n			A[r]=A[i];\n			A[i]=d;\n		}\n	}\n	\n	\n	for(i=0;i<N;i++)\n	{\n		fprintf (I,\"%d \",A[i]);\n	}\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (412,'#include <iostream>\r\n#include <conio.h>\r\ntemplate <typename T> class List{\r\n	private:\r\n		struct element{\r\n			T data;\r\n			struct element* next;\r\n			};\r\n		struct element *head;\r\n		List(const List &L){\r\n			head=L.head;\r\n			}\r\n		List operator=(const List &L){\r\n			head=L.head;\r\n			return *this;\r\n			}\r\n	public:\r\n		List(){\r\n			head=NULL;\r\n			}\r\n		void push_h(const T data){\r\n			if (head==NULL){\r\n				head=new element;\r\n				head->data=data;\r\n				head->next=NULL;\r\n				}\r\n			else{\r\n				struct element* h=new element;\r\n				h->data=data;\r\n				h->next=head;\r\n				head=h;\r\n				}\r\n			}\r\n		T pop_h(){\r\n			T r;\r\n			struct element* h;\r\n			h=head;\r\n			r=h->data;\r\n			head=head->next;\r\n			delete h;\r\n			return r;\r\n			}\r\n		void push_t(T data){\r\n			if (head!=NULL){\r\n				struct element* p;\r\n				for (p=head; p->next!=NULL; p=p->next);\r\n				p->next=new element;\r\n				p->next->data=data;\r\n				p->next->next=NULL;\r\n				}\r\n			else{\r\n				head=new element;\r\n				head->data=data;\r\n				head->next=NULL;\r\n				}\r\n			}\r\n		T pop_t(){\r\n			T r;\r\n			if (head->next!=NULL){\r\n				struct element* p;\r\n				for (p=head; p->next->next!=NULL; p=p->next);\r\n				r=p->next->data;\r\n				delete p->next;\r\n				p->next=NULL;\r\n				return r;\r\n				}\r\n			r=head->data;\r\n			delete head;\r\n			head=NULL;\r\n			return r;\r\n			}\r\n		~List(){\r\n			while (head!=NULL){\r\n				pop_h();\r\n				}\r\n			}\r\n		void print(){\r\n			struct element* p;\r\n			for (p=head; p!=NULL; p=p->next){\r\n				std::cout << p->data << \" \";\r\n				}\r\n			std::cout << \"\\n\";\r\n			}\r\n		class Iterator{\r\n			private:\r\n				struct element* p;\r\n			public:\r\n				Iterator(){\r\n					p=NULL;\r\n					}\r\n				Iterator(struct element* h){\r\n					p=h;\r\n					}\r\n				struct element* operator->(){\r\n					return p;\r\n					}\r\n				T operator*(){\r\n					return p->data;\r\n					}\r\n				bool operator!=(Iterator i){\r\n					return p!=i.p;\r\n					}\r\n				Iterator operator++(){\r\n					p=p->next;\r\n					return *this;\r\n					}\r\n				Iterator operator++(int){\r\n					element *q = p;\r\n					p = p->next;\r\n					return Iterator(q);\r\n					}\r\n			};\r\n		Iterator begin() const{\r\n			Iterator i(head);\r\n			return i;\r\n			}\r\n		Iterator end() const{\r\n			Iterator i;\r\n			return i;\r\n			}\r\n	};\r\n\r\nint main(){\r\n	List<double> L;\r\n	\r\n	for (int j = 0; j < 5; j++)\r\n	{\r\n		L.push_t(j);\r\n		L.push_h(j);\r\n		List<double>::Iterator i;\r\n		for (i=L.begin(); i!=L.end(); i++){\r\n			std::cout << *i << \" \";\r\n		}\r\n		std::cout << \"\\n\";\r\n	}\r\n	\r\n	for (int j = 0; j < 5; j++)\r\n	{\r\n		L.pop_h();\r\n		L.pop_t();\r\n		List<double>::Iterator i;\r\n		for (i=L.begin(); i!=L.end(); i++){\r\n			std::cout << *i << \" \";\r\n		}\r\n		std::cout << \"\\n\";\r\n	}\r\n\r\n//	_getch();\r\n	return 0;\r\n	}','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (413,'#include <iostream>\nusing namespace std;\n\n	template <typename T> class List\n	{\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\n	\n	public:\n		List ()	\n		{	\n			head = 0;\n		}\n\n		void insert (T p) //??????? ? ??????\n		{\n			element* e;\n			e = new element;\n			e->data = p;\n			e->next = head;\n			head = e;\n		}\n\n		void del () //???????? ???????\n		{\n			element* e;\n			e = head->next;\n			delete head;\n			head = e;\n		}\n\n		~List()\n		{			\n			while(head!=0)\n				del ();\n			delete head;\n		}\n\n		void print () //?????? ??????\n		{\n			element *p;\n			p = new element;\n			p = head;\n			while (p!=NULL)\n			{\n				cout<<p->data;\n				cout<<\" \";\n				p = p->next;\n			}\n			cout<<\" \\n\";\n		}		\n		\n		/*\n		void per()\n		{\n		element *p;\n		p = \n		}	\n		*/	\n	};\n\nint main()\n{\n	int a;\n	List <int> p;\n	for (int i = 0; i < 5; i++)\n	{\n		p.insert(i);\n		p.print();\n	}\n	\n	for (int i = 0; i < 5; i++)\n	{\n		p.del();\n		p.print();\n	}\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (414,'#include <iostream>\ntemplate <typename T> class list\n{\nprivate:\n	list(const list &orig) { }\n	list& operator=(const list &orig) { }\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\n	element *tail;\npublic:\n	list()				//???????????\n	{\n		head=NULL;	\n	}\n	~list()				//??????????\n	{\n		while (head!=NULL)\n		{\n			hdelete();\n		}\n	}\n	void hinsert(T info)		//??????? ? ??????\n	{\n		element *p;\n		p=new element;\n		p->data=info;\n		p->next=head;\n		head=p;      \n	}\n	void hdelete()		//???????? ??????\n	{\n		element *p;\n		p=head->next;\n		delete head;\n		head=p;	\n	}\n	void tinsert (T info)\n	{\n		element *p,*q;\n		p=new element;\n		p->data=info;\n                p->next=NULL;\n		for (q=head;q->next;q=q->next);\n		q->next=p;\n	}\n	\n\n	void tdelete ()\n	{\n		element *p, *q;\n		for (q=head;q->next;q=q->next);\n		\n	}\n\n\n	void print()		//?????\n	{\n		element *p;\n		p=head;\n		while (p!=NULL)\n		{\n			std::cout<<(p->data)<<\" \";\n			p=p->next;\n                }\n		std::cout << \"\\n\";\n	}\n};\nint main()\n{\n	int i;\n	list <int> spisok1;\n	for (i = 0; i < 5; i++)\n	{\n		spisok1.hinsert(i);\n		spisok1.print();\n	}\n	for (i = 0; i < 5; i++)\n	{\n		spisok1.hdelete();\n		spisok1.print();\n	}\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (415,'#include <stdio.h>\nint main() \n{\n	int c,a,b;\n	scanf(\"%d\",&a);\n	printf(\"Vasa\\n\");\n	scanf(\"%d\",&b);\n	printf(\"Peta\\n\");\n	while (b>0)\n	{	printf(\"Serega\\n\");\n		c=b;\n		printf(\"Kola\\n\");\n		b=a%b;\n		a=c;\n	}	\n	printf(\"%d\\n\",a);\n	return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (416,'#include<iostream>\ntemplate <typename T> class List\n{\nprivate:\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\n\n\npublic:\n	List()\n	{\n		head=NULL;\n	}\n\n	void insert(T a)//??????? ? ?????? ??????\n	{\n		element *p=new element;\n		p->data=a;\n		p->next=head;\n		head=p;\n	}\n\n	void del()//???????? ??????? ????????\n	{\n		element *q=head->next;\n		delete head;\n		head=q;\n	}\n\n	~List()//??????????,????????????? ??? ??????\n	{\n		element *d;\n		while(head)\n		{\n			d=head;\n			head=head->next;\n			delete d;\n		}\n	}\n\n	void print()\n	{\n		for (element *p = head; p; p = p->next)\n		{\n			std::cout << p->data << \" \";\n		}\n		std::cout << \"\\n\";\n	}\n\n};\n\n\nint main()\n{\n	List<int> l;\n	\n	for (int i = 0; i < 5; i++)\n	{\n		l.insert(i);\n		l.print();\n	}\n\n	for (int i = 0; i < 5; i++)\n	{\n		l.del();\n		l.print();\n	}\n\n	return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (417,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"commandParser.h\"\n\nchar *getCommand(){\n	int len = 80;\n	int cmdLen = 0;\n	char * cmd = (char *)calloc(len, sizeof(char));\n	do{\n		if (cmdLen >= len) {\n			cmd = (char *)realloc((void *)cmd, len = len * 2);\n		}\n		cmd[cmdLen++] = getchar();\n		if((\'\\n\' == cmd[cmdLen - 1] || \' \' == cmd[cmdLen - 1]) && cmdLen == 1){\n			cmd[0] = 0;\n			cmdLen--;\n			continue;\n		}\n	}while(0 == cmdLen || \'\\n\' != cmd[cmdLen - 1]);\n	cmd[cmdLen] = 0;\n	cmdLen--;\n	while((\' \' == cmd[cmdLen] || \'\\n\' == cmd[cmdLen]) && cmdLen > 0) cmd[cmdLen--] = 0;\n	return cmd;\n}\n\n\nint substr(char *what, char *where) {\n	int whatlen = strlen(what), wherelen = strlen(where);\n	int i, j;\n	for(i = 0; i < wherelen; i++) {\n		int same = 1;\n		for(j = 0; j < whatlen; j++) {\n			if(where[i + j] != what[j]) same = 0;\n		}\n		if (same) return i;\n	}\n	return -1;\n}\n\nint getint(char * cmd, int * res) {\n	int pos = 0, len = strlen(cmd), smthread = 0;\n	*res = 0;\n	while(\' \' == cmd[pos] && pos < len) pos++;\n	while(\'0\' <= cmd[pos] && cmd[pos] <= \'9\' && pos < len) {\n		*res = *res * 10 + cmd[pos] - \'0\';\n		pos++;\n		smthread = 1;\n	}\n	return smthread ? pos : -pos;\n}\n\nList *parseList(char *cmd) {\n	List *res = NULL;\n	int stop = 0;\n	int pos = 0, len = 0, num = 0, cmdlen = strlen(cmd);\n	while (\' \' == cmd[pos] && pos < cmdlen) pos++;\n	if (0 != substr(\"\'(\", &cmd[pos])) {\n		printf(\"Error #3: Invalid argument. Use help for see example.\\n\");\n		return NULL;\n	}\n	pos += 2;\n	do {\n		while (0 < (len = getint(&cmd[pos], &num))) {\n			List * tmp = (List *)calloc(1, sizeof(List));\n			tmp->isNum = 1;\n			tmp->val.num = num;\n			if (NULL != res) {\n				res->next = tmp;\n				tmp->prev = res;\n			}	\n			res = tmp;\n			pos += len;\n		}\n		pos = pos - len;\n		/*if (0 == substr(\"\'(\", &cmd[pos])){\n			res->next = (List *)calloc(1, sizeof(List));\n			res->next->prev = res;\n			res = res->next;\n			res->val.lst = parseList(&cmd[pos]);\n			stop = 1;\n			pos += 2;\n			while (stop){\n				if (\'(\' == cmd[pos]) stop++;\n				if (\')\' == cmd[pos]) stop--;\n			}	\n			stop = 0;\n		} else {\n			stop = 1;\n		}*/\n		stop = 1;\n	}while (!stop);\n	if (NULL == res) return NULL;\n	res->next = (List *)calloc(1, sizeof(List));\n	res->next->prev = res;\n	if(\')\' != cmd[pos]) {\n		delete(res);\n		printf(\"Error #4: \')\' not found, but found \'%c\'. Use help for see example\\n\", cmd[pos]);\n		return NULL;\n	}\n	while(res && res->prev) res = res->prev;\n	return res;\n}\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (418,'#include <stdio.h>\n#include <stdlib.h>\n#include \"lispFunctions.h\"\n\nvoid delete(List *lst){\n	if (NULL == lst) return;\n	while (lst->prev) lst = lst->prev;\n	while (lst){\n		if (lst->isNum){\n			List *l = lst;\n			lst = lst->next;\n			free(l);\n		} else {\n			delete(lst->val.lst);\n			lst->isNum = 1;\n		}\n	}\n}\n\nList *copyList(List *lst){\n	List *result = NULL;\n	while (lst){\n		if (lst->isNum){\n			List *t = calloc(1, sizeof(List));\n			t->isNum = 1;\n			t->val.num = lst->val.num;\n			t->prev = result;\n			if (result) result->next = t;\n			result = t;\n		} else {\n			if (NULL == lst->val.lst){\n				List *t = calloc(1, sizeof(List));\n				t->prev = result;\n				if (NULL != result) result->next = t;\n				result = t;\n			} else {\n				if (NULL == result) result = calloc(1, sizeof(List)); else{\n					result->next = calloc(1, sizeof(List));\n					result->next->prev = result;\n					result = result->next;\n				}\n				result->val.lst = copyList(lst->val.lst);\n			}\n		}\n		lst = lst->next;\n	}\n	while (result && result->prev) result = result->prev;\n	return result;\n}\n\nList *lremove(int val, List *lst) {\n	List *ret = NULL;\n	if (NULL == lst) return NULL;\n	while (lst->prev) lst = lst->prev;\n	while (lst) {\n		if (lst->isNum && val == lst->val.num) {\n			List *tmp = lst->next;\n			if (lst->prev) {\n				lst->prev->next = lst->next;\n			}\n			if (lst->next) {\n				lst->next->prev = lst->prev;\n			}\n			free(lst);\n			lst = tmp;\n			if (NULL != tmp) ret = tmp;\n			continue;\n		} else {\n			ret = lst;\n		}\n		if (lst) lst = lst->next;\n	}\n	while(ret && ret->prev) ret = ret->prev;\n	return ret;\n}\n\nList *append(List *l1, List *l2){\n	if (NULL == l1) return l2;\n	while(l1 && l1->next) l1 = l1->next;\n	if (l1->isNum){\n		printf(\"*** - Append: A proper list must not end with %d.\\n\", l1->val.num);\n		return NULL;\n	}\n	if (l1 == l2 || NULL == l2) return l1;\n	if (NULL == l1->val.lst){\n		List *l = l1;\n		l1 = l1->prev;\n		free(l);\n		if (NULL == l1) return l2;\n		l1->next = NULL;\n	}\n	if (NULL == l1) return l2;\n	while(l2->prev) l2 = l2->prev;\n	l1->next = l2;\n	l2->prev = l1;\n	while(l1->prev) l1 = l1->prev;\n	return l1;\n}\n\nList *cons(List *src, List *lst){\n	List *l = calloc(1, sizeof(List));\n	while (src->prev) src = src->prev;\n	if (NULL == src->next) {\n		src->next = l;\n		src->next->prev = src;\n		return src;\n	}\n	if (NULL == lst) lst = calloc(1, sizeof(List));\n	l->val.lst = src;\n	l->next = lst;\n	lst->prev = l;\n	return l;\n}\n\nvoid princ(List *lst){\n	if(NULL == lst) return;\n	while (lst->prev) lst = lst->prev;\n	if(0 == lst->isNum && NULL == lst->val.lst) {\n		printf(\"NIL \");\n		return;\n	}\n	printf(\"(\");\n	while (lst) {\n		if (lst->prev && lst->next && !lst->prev->isNum) printf(\" \");\n		if (lst->isNum) {\n			if (!lst->prev && !lst->next){\n				printf(\"%d\", lst->val.num);\n				return;\n			}\n			if (!lst->next){\n				printf(\" . %d)\", lst->val.num);\n				return;\n			}\n			if (lst->prev) printf(\" %d\", lst->val.num); else printf(\"%d\", lst->val.num);\n		} else if (NULL == lst->val.lst) {\n			printf(\")\");\n		} else {	\n			princ(lst->val.lst);\n		}\n		lst = lst->next;\n	}	\n}\n\nvoid print(List *lst){\n	if (NULL == lst) return;\n	princ(lst);\n	printf(\"\\n\");\n}\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (419,'#include <unistd.h>\n#include <signal.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"lispFunctions.h\"\n#include \"commandParser.h\"\n\nList *result;\n\nvoid permut1(int sum, List *x, List *y){\n	int i;\n	List *ly = y;\n	if (0 == sum) {\n		result = append(result, cons(lremove(0, copyList(x)), NULL));\n	}else{\n		if (0 > sum) {\n			delete(x);\n			return; \n		}else{\n			for(i = ly->val.num; ly && ly->isNum; ly = ly->next, i = (NULL == ly ? 0: ly->val.num)) {\n				List *l = calloc(1, sizeof(List));\n				l->isNum = 1;\n				l->val.num = i;\n				permut1(sum - i, append(copyList(x), cons(l, NULL)), y);\n			}\n		}\n	}\n	delete(x);\n}\n\nvoid change(int v, List *x){\n	List *nulllst;\n	result = calloc(1, sizeof(List));\n	result->isNum = 1;\n	result->next = calloc(1, sizeof(List));\n	result->next->prev = result;\n	\n	nulllst = calloc(1, sizeof(List));\n	nulllst->isNum = 1;\n	nulllst->val.num = 0;\n	nulllst->next = calloc(1, sizeof(List));\n	nulllst->next->prev = nulllst;\n	\n	permut1(v, nulllst, x);\n	delete(x);\n	print(result = lremove(0, result));\n	delete(result);\n}\n\nvoid signalProcess(int sig){\n	printf(\"\\nBye.\\n\");\n	exit(0);\n}\n\nvoid printWelcomeMessage(){\n	FILE *f = fopen(\"welcome.txt\", \"r\");\n	char buf[50];\n	int len = 0;\n	if (NULL == f) return;\n	while (50 == (len = fread(&buf[0], sizeof(char), 50, f))) fwrite(buf, sizeof(char), len, stdout);\n	fwrite(buf, sizeof(char), len, stdout);\n	fclose(f);\n}\n\nint main(int argc, char * argv[]){\n	int commNum = 1;\n	char *cmd = NULL;\n	signal(SIGINT, signalProcess);\n	printWelcomeMessage();\n	while(1){\n		printf(\"[%d]> \", commNum);\n		commNum++;\n		if (NULL != cmd) free(cmd);\n		cmd = getCommand();\n		if(!strcmp(cmd, \":h\") || !strcmp(cmd, \":help\")){\n			printf(\"Available command:\\n\\tchange\\nExample:\\n\\t(change 4 \'(1 2 5))\\n\");\n		} else if (\'\\\'\' == cmd[0]) {\n			printf(\"%s\\n\", &cmd[1]);\n		} else if (0 == substr(\"(change \", &cmd[0])){\n			int num = 0, pos = 0;\n			List *lst;\n			if (0 == (pos = getint(&cmd[strlen(\"(change\")], &num))) {\n				printf(\"Error #1: Not number. Use help for see example.\\n\");\n				continue;\n			}\n			lst = parseList(&cmd[strlen(\"(change\") + ((pos > 0) ? pos : -pos)]);\n			if (NULL == lst) continue;\n			\n			change(num, lst);\n		} else if (0 == strcmp(\":exit\", cmd) || 0 == strcmp(\":e\", cmd)){\n			free(cmd);\n			signalProcess(SIGINT);\n		} else {\n			printf(\"Error #2: Unsupported command. Use help for see list of supperted commands.\\n\");\n		}\n	}\n\n	return 0;\n}\n\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (420,'#include <stdio.h>\n\nint main ()\n{\n	int a[100000] = {0};\n	int N;\n	int x=0;\n	int i=0,j=0,k=0;\n\n	FILE *f1 = fopen(\"input.txt\", \"r\");\n	FILE *f2 = fopen(\"output.txt\", \"w\");\n	\n	fscanf(f1, \"%d\", &N);\n	for (i = 0; i < N; i++)\n		fscanf(f1, \"%d\", &a[i]);\n	\n	for (i=0; i<N; i++)\n	{\n		x=a[i];\n		for (j=i-1; j>=0; j--)\n	        {\n			if (a[j]<x) \n				break;\n		        a[j+1]=a[j];\n		}\n		a[j+1]=x;\n	}\n	for (k=0;k<N;k++)\n		fprintf (f2, \"%d \",a[k]);\n	fprintf(f2, \"\\n\");\n	\n	fclose(f1);\n	fclose(f2);\n	\n	return 0;	\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (421,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nstruct passwd\n{\n	char *login;\n	char *pass ;\n	char *ch1;\n	char *realname;\n	char *ch2;\n	char *dir;\n	char *s;\n};\nvoid print (int m,struct passwd p)\n{\n	switch(m)\n	{\n		case 0: {printf(\"%s \\n\",p.login); break;}\n		case 1: {printf(\"%s \\n\",p.pass);break;}\n		case 2: {printf(\"%s \\n\",p.ch1);break;}\n		case 3: {printf(\"%s \\n\",p.ch2);break;}\n		case 4: {printf(\"%s \\n\",p.realname);break;}\n		case 5: {printf(\"%s \\n\",p.dir);break;}\n		case 6: {printf(\"%s \\n\",p.s);break;}\n	}\n}\n\nstruct passwd string1(char *s)\n{\n	struct passwd p;\n	char c,a[100]={0};\n	int i=0,t=0,k=0,l=0;\n	char **current = (char **)(&p);\n	while(l!=strlen(s)+1)\n	{\n		if(s[l]==\':\'||s[l]==0)\n		{\n			\n			a[i]=0;\n			*current = strdup(a);\n			current++;\n			k++;\n			for(t=0;t<i;t++)\n				a[t]=0;\n			i=0;\n		}\n		else\n		{\n			a[i]=s[l];\n			i++;\n		}\n		l++;\n	}\n	return  p;\n\n}\n\nstruct passwd  string(char *s)\n{\n	struct passwd p;\n	char c,a[100]={0};\n	int i=0,t=0,k=0,l=0;\n	while(l!=strlen(s)+1)\n	{\n		if(s[l]==\':\'||s[l]==0)\n		{\n			\n			a[i]=0;\n			switch(k)\n			{\n				case 0:\n					{\n						p.login=strdup(a);\n						break;\n						\n					}\n					printf(\"%s\",p.login);\n				case 1:\n					{\n						p.pass=malloc((i+1));\n						strcpy(p.pass,a);\n						break;\n					}\n				case 2: \n					{\n						p.ch1=malloc((i+1));\n						strcpy(p.ch1,a);\n						break;\n					}\n				case 3:\n					{\n						p.ch2=malloc((i+1));\n						strcpy(p.ch2,a);\n						break;\n					}\n				case 4: \n					{\n						p.realname=malloc((i+1));\n						strcpy(p.realname,a);\n						break;\n					}\n				case 5:\n					{\n						p.dir=malloc((i+1));\n						strcpy(p.dir,a);\n						break;\n					}\n				case 6: \n					{\n						p.s=malloc((i+1));\n						strcpy(p.s,a);\n						break;\n					}\n			}\n			k++;\n			for(t=0;t<i;t++)\n				a[t]=0;\n			i=0;\n		}\n		else\n		{\n			a[i]=s[l];\n			i++;\n		}\n		l++;\n	}\n	return  p;\n}\nint main()\n{\n	char s[200],t[200],c; int i=0,m;\n	struct passwd p;\n	FILE *f=fopen(\"/etc/passwd\",\"r\");\n	if(!f)\n	{\n		perror(\"/etc/passwd\");\n		return 0;\n	}\n	scanf(\"%s\",&s);\n	scanf(\"%d\",&m);\n	\n	while(fgets(t,150,f)!=0)\n	{\n		i=strlen(t);\n		t[i-1]=0;\n		p=string1(t);\n		if(strcmp(p.login,s)==0)\n		{\n			\n			\n			print(m,p);\n			return 0;\n		}\n		free(p.login);\n		free(p.ch1);\n		free(p.ch2);\n		free(p.pass);\n		free(p.dir);\n		free(p.realname);\n		free(p.s);\n	}\n	printf(\" Neverniy Login! \\n\");\n	return 0;\n	\n	\n}\n\n\n\n\n\n\n\n\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (422,'#include<stdio.h>\n#include<stdlib.h>\nvoid sort(FILE *f)\n{\n	int a;\n	struct item \n	{\n		int data;\n		struct item *next;\n	};\n	struct item *head=NULL;\n	struct item *p=malloc(sizeof(*p));\n	struct item *l;\n	p->next=NULL;\n	head=p;\n	while(fscanf(f,\"%d\",&a)==1)\n	{\n		for(p=head;p;p=p->next)\n		{\n			\n				if(p->next && a< p->next->data)\n				{\n					l=p->next;\n					p->next=malloc(sizeof(*p));\n					p->next->data=a;\n					p->next->next=l;\n					break;\n				}\n				if(p->next==NULL)\n				{\n					p->next=malloc(sizeof(*p));\n					p->next->data=a;\n					p->next->next=NULL;\n					break;\n				}\n			\n		}\n	}\n		\n	\n	\n	for(p=head->next;p;p=p->next)\n		printf(\"%d \",p->data);\n	printf(\"\\n\");\n}\nint main()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n	sort(f);\n	return 0;\n}\n\n				\n			\n		\n	\n			\n			\n			\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (423,'#include<stdio.h>\n#include<stdlib.h>\nstruct item {\n	int data;\n        struct item *next;\n};\nvoid push(struct item **phead,int a)\n{\n	struct item *p=malloc(sizeof(*p));\n	p->data=a;\n	p->next=*phead;\n	*phead=p;\n}\nvoid seat(struct item **phead, struct item *q, int a)\n{\n	struct item *p=malloc(sizeof(*p));\n	struct item *tail;\n	if(q==NULL){push(phead,a);return;}\n	if(q)\n	{\n		p->next = q->next;\n		q->next = p;\n		p->data = a;\n		return;\n	}\n}\nstruct item *search(struct item *head, int a)\n{\n	struct item *p=head;\n	struct item *q = NULL;\n	for(;p;q = p, p=p->next)\n	{\n		if(p->data>a)\n			return q;\n	}\n	return q;\n}\nvoid add (struct item **phead,int a)\n{\n	struct item *q;\n	q = search(*phead,a);\n	seat(phead,q,a);\n}\nvoid print(struct item *head)\n{\n	struct item *p=head;\n	for(;p;p=p->next)\n		printf (\"%d \",p->data);\n	printf(\"\\n\");\n}\nint main()\n{\n			\n	struct item *head=NULL;\n	FILE  *fi=fopen(\"input.txt\",\"r\");\n	int a,i,n;\n	for(i=0;fscanf(fi, \"%d\", &a) == 1;i++)\n	{\n		add(&head, a);\n	}\n	print(head);\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (424,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<ctype.h>\nchar *read_word(FILE*f)\n{\n	char *p=NULL,*tmp;\n	int allocated=0, used=0;\n	int c;\n	while((c=fgetc(f))!=EOF)\n	{\n		if(!isalpha(c))\n			break;\n		if(allocated==used)\n		{\n			tmp=realloc(p,allocated+11);\n			if(!tmp)\n				break;\n			p=tmp;\n			allocated+=11;\n		}\n		p[used]=c;\n		used++;\n	}\n	if(p)\n		p[used]=0;\n	return p;\n}	\n\nvoid count_word (FILE *f)\n{\n	char *q;\n	int fl=0,i=0;\n	struct word\n	{\n		char word[11];\n		int count ;\n		struct word *next;\n	};\n	struct word *head=NULL;\n	struct word *p;\n	p=head;\n	while((q=read_word(f))!=NULL)\n	{\n		fl = 0;\n		for(p=head;p;p=p->next)\n		{\n			if(strcmp(q,p->word)==0)\n			{\n				fl=1;\n				break;\n			}\n				\n		}\n		if(!fl)\n		{\n			struct word *n=malloc(sizeof(*p));\n			//for(i=0;i<strlen(q);i++)\n			strcpy(n->word,q);\n			n->next=head;\n			n->count = 1;\n			head = n;\n		}\n		else\n		{\n			p->count++;\n		}\n		free(q);\n	}\n	for(p=head;p;p=p->next)\n	{\n		printf(\"%s : %d \",p->word,p->count);\n		printf(\"\\n\");\n	}\n}\n\nint main()\n{\n	FILE*f=fopen(\"text.txt\",\"r\");\n	count_word(f);\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (425,'#include <iostream>\n\ntemplate <typename T>\nclass customlist\n{\npublic:\n	struct item //list node\n	{\n		T data;\n		item * next;\n	};\n\n	customlist() //list default constructor\n	{\n		head = NULL;\n	}\n\n	~customlist() //list destructor\n	{\n		while (head != NULL)\n		{\n			popf();\n		}\n	}\n\n	int putf (T const something) //add something as first item\n	{\n		item * p = new item;\n		p->data = something;\n		p->next = head;\n		head = p;\n		return 0;\n	}\n	\n	int popf() //remove first item\n	{\n		if (head) \n		{\n			item * p = head;\n			head = head->next;\n			delete p;\n		}\n		return 0;\n	}\n\n	int putl(T const something) //add something as last item\n	{\n		if (!head)\n		{\n			putf (something);\n			return 0;\n		}\n		item * p = head;\n		while (p->next != NULL)\n		{\n			p = p->next;\n		}\n		p->next = new item;\n		p = p->next;\n		p->data = something;\n		p->next = NULL;\n		return 0;\n	}\n\n	int popl() //remove last item\n	{\n		if (!head)\n		{\n			return 0;\n		}\n		if (!head->next)\n		{\n			popf();\n			return 0;\n		}\n		item * p = head;\n		while ((p->next)->next != NULL)\n		{\n			p = p->next;\n		}\n		delete p->next;\n		p->next = NULL;\n		return 0;\n	}\n	\n	int print() //show list to user\n	{\n		item * p = head;\n		while (p != NULL)\n		{\n			std::cout << p->data << \' \';\n			p = p->next;\n		}\n		std::cout << \"\\n\";\n		return 0;\n	}\n\n	class iterator\n	{\n	public:\n		iterator (item * ptr) //iterator constructor\n		{\n			itptr = ptr;\n		}\n\n//		~iterator\n//		{\n//		}\n\n		bool operator!=(iterator other) const\n		{\n			return (itptr != other.itptr);\n		}\n\n		bool operator==(iterator other) const\n		{\n			return (itptr == other.itptr);\n		}\n\n		iterator & operator++()\n		{\n			itptr = itptr->next;\n			return *this;\n		}\n\n		iterator & operator++(int)\n		{\n			iterator * old = this;\n			itptr = itptr->next;\n			return *old;\n		}\n		\n		T & operator*()\n		{\n			return itptr->data;\n		}\n\n		T * operator->()\n		{\n			return &(itptr->data);\n		}\n\n	private:\n		item * itptr;\n	};\n	//iterator description ends here \n	\n	iterator begin() const \n	{\n		iterator * a = new iterator(head);\n		return *a;\n	}\n\n	iterator end() const\n	{\n		iterator * a = new iterator(NULL);\n		return *a;	\n	}\n\nprivate:\n	customlist (customlist<T> & other) //list copy constructor\n	{\n		head = NULL;\n		item * p = other.head;\n		while (p != NULL)\n		{\n			putl(p->data);\n			p = p->next;\n		}\n	}\n\n	customlist & operator=(customlist<T> & other) //list equal operator\n	{\n		while (head != NULL)\n		{\n			popf();\n		}\n		item * p = other.head;\n		while (p != NULL)\n		{\n			putl(p->data);\n			p = p->next;\n		}\n		return *this;\n	}\n\nprivate:\n	item * head;\n};\n\nstruct b { int a, b; };\n\nint main()\n{\n	b b1;\n	b1.a = 7; b1.b = 8;\n	customlist<b> l1;\n	l1.putf(b1);\n	customlist<b>::iterator j = l1.begin();\n	std::cout << j->a << \", \" << j->b << \"\\n\";\n\n	customlist<int> a;\n\n	for (int i = 0; i < 5; i++)\n	{\n			a.putl(i);\n			a.putf(i);\n			a.print();\n	}\n\n	customlist<int>::iterator i = a.begin();\n	++i;\n	*i = 7;\n	std::cout << *( i.operator->()  );\n	std::cout << *i << \"\\n\";\n\n	for (int i = 0; i < 5; i++)\n	{\n			a.popf();\n			a.popl();\n			a.print();\n	}\n\n	return 0;\n\n	for (int i = 0; i < 6; ++i)\n	{\n		a.putf(i);\n	}\n	std::cout << \"I\'ve created the list.\\nThere are 6 items in the list now. Now you\'ll see it:\\n\";\n	for (::customlist<int>::iterator i = a.begin(); i != a.end(); i++)\n	{\n//		std:: cout << i->data << \'\\n\';\n	}\n	std::cout << \"Thanks for choosing our iterator as a service for print lists.:)\\n\";\n	std::cout << \"Now I\'ll add number 9 as a first item.\\n\";\n	a.putf(9);\n	std::cout << \"Here comes changed list!:)\\n\";\n	a.print();\n	std::cout << \"Maybe, you want to add your own number as last item of this list? Try it. Type the number.\\n\";\n	int b;\n	std::cin >> b;\n	a.putl(b);\n	std::cout << \"Here comes changed list!:)\\n\";\n	a.print();\n	std::cout << \"Now I\'ll remove 2 items from the end of list end 1 item from the beginning.\\n\";\n	a.popf();\n	a.popl();\n	a.popl();\n	std::cout << \"Here comes changed list!:)\\n\";\n	a.print();\n	std::cout << \"What else would you look at?\\n\";\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (426,'#include <iostream>\nusing namespace std;\n\n        template <typename T> class List\n        {\n        struct element\n        {\n                T data;\n                element *next;\n        };\n        element *head;\n	\n	\n	List (const List& orig)\n	{\n	}\n\n	List operator=(const List& orig)\n	{\n	}\n\n        public:\n                List ()\n                {\n                        head = 0;\n                }\n\n                void insert (T p) //??????? ? ??????\n                {\n                        element* e;\n                        e = new element;\n                        e->data = p;\n                        e->next = head;\n                        head = e;\n                }\n\n                void del () //???????? ???????\n                {\n                        element* e;\n                        e = head->next;\n                        delete head;\n                        head = e;\n                }\n\n                ~List()\n                {\n                        while(head!=0)\n                                del ();\n                        delete head;\n                }\n\n                void print () //?????? ??????\n                {\n                        element *p;\n                        p = new element;\n                        p = head;\n                        while (p)\n                        {\n                                cout<<p->data;\n                                cout<<\" \";\n                                p = p->next;\n                        }\n                        cout<<\" \\n\";\n                }\n\n\n                element*  per() //??????? ?????? (?????????? ????????????? ??????? ??????)\n                {\n                        element *p;\n                        p = new element;\n                        p = head;\n                        if (p->next)\n                           while ((p->next->next))\n                                p = p->next;\n                        return p;\n\n                }\n\n                void ins_last (T p) //??????? ? ?????\n                {\n			if (!head)\n			{\n				insert(p);\n				return;\n			}\n                        element *e;\n                        element *f;\n                        e = new element;\n                        e->next = NULL;\n                        e-> data = p;\n                        f = this->per();\n			f = f->next;\n                        if (f)\n                           f->next = e;\n                        else f = e;\n\n                }\n\n                void del_last () //???????? ??????????\n                {\n			if (!head->next)\n			{\n				del();\n				return;\n			}\n                        element *e;\n			e = new element;\n			element *f;\n			f = new element;\n			e = this->per();\n			f = e->next;\n			delete f;\n			e->next = NULL;\n                }\n        };\n\nint main()\n{\n        List <int> p;\n        for (int i = 0; i < 5; i++)\n        {\n		p.ins_last(i);\n                p.insert(i);\n                p.print();\n        }\n\n	for (int i = 0; i < 5; i++)\n	{\n		p.del();\n		p.del_last();\n		p.print();\n	}\n	return 0;\n}\n\n\n                                                 \n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (427,'#include <iostream>\r\nusing namespace std;\r\n\r\ntemplate <typename T> class List\r\n{\r\n	class Knot\r\n	{\r\n		public:\r\n			T data;\r\n			Knot *next;\r\n			Knot *prev;\r\n			Knot(T dat = 0){data=dat;next=0;prev=0;}\r\n	};\r\n	Knot *head, *tail;\r\n	public:\r\n		List(){head=0;tail=0;}\r\n		~List();\r\n		void addend(T data);\r\n		int removefirst();\r\n		int removelast();\r\n		void addbeg(T data);\r\n		int print();\r\n	private:\r\n		List(const List & other);\r\n		List & operator = (List & other);\r\n\r\n};\r\ntemplate <typename T>\r\nList<T>::~List()\r\n{\r\n	if(head!=0)\r\n	{\r\n		Knot *cu=head;\r\n		while (cu){\r\n			cu=cu->next;\r\n			delete head;\r\n			head=cu;}\r\n	}\r\n}\r\ntemplate <typename T>\r\nvoid List <T>::addend(T data)\r\n{\r\n	Knot *cu=new Knot(data);\r\n	if(head==0)\r\n		head=tail=cu;\r\n	else{\r\n		cu->prev=tail;\r\n		tail->next=cu;\r\n		tail=cu;}\r\n}\r\ntemplate <typename T>\r\nint List <T>::removefirst()\r\n{\r\n	if(head==0)\r\n	{\r\n		return 0;\r\n	}\r\n	if (head->next == 0)\r\n	{\r\n		head=head->next;\r\n		return 0;\r\n	}\r\n	else\r\n	{\r\n	head=head->next;\r\n	head->prev=0;\r\n	}\r\n}\r\ntemplate <typename T>\r\nint List <T>::removelast()\r\n{\r\n	if(head==0)\r\n	{\r\n		return 0;\r\n	}\r\n	if (head->next == 0)\r\n	{\r\n		removefirst();\r\n		return 0;\r\n	}\r\n	tail=tail->prev;\r\n	delete(tail->next);\r\n	tail->next=0;\r\n	return 0;\r\n	}\r\ntemplate <typename T>\r\nvoid List <T>::addbeg(T data)\r\n{\r\n	Knot *cu=new Knot(data);\r\n	if(tail==0)\r\n		tail=head=cu;\r\n	else\r\n	{	cu->next=head;\r\n		head->prev=cu;\r\n		head=cu;}\r\n}\r\ntemplate <typename T>\r\nint List <T>::print()\r\n{\r\n	if (!head)\r\n	{\r\n		cout << \"\";\r\n		return 0;\r\n	}\r\n	Knot *cu=head;\r\n	cout << endl << \"list\";\r\n	while(cu)\r\n	{\r\n		cout << cu->data << \' \';\r\n		cu=cu->next;\r\n	cout << endl;\r\n	}\r\n}\r\nint main()\r\n{\r\n	List<int> isp;\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		isp.addend(i);\r\n		isp.addbeg(i);\r\n		isp.print();\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		isp.removefirst();\r\n		isp.removelast();\r\n		isp.print();\r\n	}\r\n\r\n	return 0;\r\n}','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (428,'#include <iostream>\r\n#include <string.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <conio.h>\r\n\r\nusing namespace std;\r\n\r\ntemplate <class T> class List\r\n{\r\n\r\n    private:\r\n      struct element\r\n      {\r\n        T data;\r\n        element *next;\r\n        };\r\n      element *head;\r\n      element *tail;\r\n      int kolvo;\r\n\r\n    List(List& orig){//??????????? ???????????\r\n        head = orig.head;\r\n        tail = orig.tail;\r\n        kolvo = orig.kolvo;}\r\n\r\n    List& operator=(const List &orig){//???????? ????????????\r\n        head = orig.head;\r\n        tail = orig.tail;\r\n        kolvo = orig.kolvo;\r\n        return *this;\r\n        }\r\n\r\n\r\n    public:\r\n\r\n      List(){kolvo=0;\r\n      head=NULL;\r\n      tail=NULL;}\r\n\r\nvoid nachalo (T d){\r\n    if (kolvo == 0){\r\n    head = tail = new element;\r\n    head-> data = d;\r\n	head->next = 0;\r\n	}\r\n    else\r\n    {element *a = new element;\r\n    a-> data = d;\r\n    a-> next = head;\r\n    head = a;}\r\n    kolvo++;}\r\n\r\n\r\n    void attheend (T d){\r\n       if (kolvo==0)\r\n       {head = tail = new element;\r\n       head->data = d;\r\n	   head->next = 0;}\r\n        else\r\n        {\r\n       element *a;\r\n       a = head;\r\n       while (a != tail){\r\n       a = a->next;}\r\n	   a->next = new element;\r\n	   a = a->next;\r\n	   a->data = d;\r\n	   a->next = NULL;\r\n	   tail = a;\r\n       }\r\n        kolvo++;\r\n          }\r\n\r\n    void udalnach(){\r\n    if (kolvo != 0)\r\n    {element *temp = head;\r\n    head = head->next;\r\n    delete temp;\r\n    kolvo--;}\r\n    if (head == NULL) // ? ?????? ??? ???? ???????\r\n      {tail = head;}}\r\n\r\n\r\n    void delfromend(){\r\n    if (kolvo == 1){\r\n    delete tail;\r\n    head = tail = NULL;\r\n    kolvo--;}\r\n    if (kolvo > 1){\r\n    element *temp;\r\n    temp = head;\r\n    while (temp->next != tail)\r\n      temp = temp->next;\r\n    tail = temp;\r\n    delete temp->next;\r\n    tail->next = NULL;\r\n    kolvo--;}\r\n    }\r\n\r\n    ~List(){//??????????\r\n        element *delelem = head;\r\n        element *temp;\r\n        while (delelem != NULL)\r\n     {  temp = delelem->next;\r\n        delete delelem;\r\n        delelem = temp;  }}\r\n\r\n\r\n    void print(){\r\n        element *t = head;\r\n        while (t != NULL){\r\n           cout<<t->data<<\" \";\r\n           t = t->next;\r\n            }\r\n        }\r\n\r\n};\r\n\r\nint main()\r\n\r\n{List <int> a;\r\n\r\n/*a.attheend(44);\r\na.attheend(44);\r\n\r\na.nachalo(11);\r\na.nachalo(1);\r\n\r\na.delfromend();\r\n//a.udalnach();\r\na.print();\r\ngetch();\r\n*/\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		a.attheend(i);\r\n		a.nachalo(i);\r\n		a.print();\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		a.udalnach();\r\n		a.delfromend();\r\n		a.print();\r\n	}\r\n\r\n\r\n return 0;\r\n}\r\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (429,'#include <iostream>\r\nusing namespace std;\r\n\r\nclass Expression\r\n{\r\n  public:\r\n         virtual Expression* diff()=0;\r\n         virtual void print()=0;\r\n      \r\n};\r\n\r\nclass Number:public Expression\r\n{\r\n      private:\r\n              float value;\r\n      public: \r\n              Number (float v)\r\n              {value=v;}\r\n              \r\n              Expression* diff()\r\n              {return new Number(0);}  \r\n              \r\n              void print()\r\n              {cout<<value;}  \r\n                 \r\n};\r\n\r\nclass Variable:public Expression\r\n{\r\n      private:\r\n              char name;\r\n      public: \r\n              Variable (char x)\r\n              {name=x;}\r\n              \r\n              Expression* diff()\r\n              {return new Number(1);}  \r\n              \r\n              void print()\r\n              {cout<<name;}  \r\n                 \r\n};\r\n\r\n\r\nclass Add:public Expression\r\n{\r\n      private:\r\n              Expression* a1;\r\n              Expression* a2;\r\n      public: \r\n              Add(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n              Expression* diff()\r\n              {return new Add(a1->diff(),a2->diff());}  \r\n              \r\n              void print()\r\n              {\r\n				cout<<\'(\';\r\n				a1->print();\r\n				cout<<\'+\';\r\n				a2->print();\r\n				cout<<\')\';\r\n			  }  \r\n			  ~Add()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n                 \r\n};\r\n\r\nclass Sub:public Expression\r\n{\r\n      private:\r\n              Expression* a1;\r\n              Expression* a2;\r\n      public: \r\n              Sub(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n              Expression* diff()\r\n              {return new Sub(a1->diff(),a2->diff());}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'-\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  \r\n\r\n			~Sub()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n                 \r\n};\r\n\r\n\r\nclass Mul:public Expression\r\n{\r\n	private:\r\n			Expression* a1;\r\n			Expression* a2;\r\n	public:\r\n			Mul(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n            Expression* diff()\r\n            {\r\n				return new Add(new Mul(a1->diff(), a2),new Mul(a1, a2->diff()));\r\n			\r\n			}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'*\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  \r\n			~Mul()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n};\r\n\r\n\r\nclass Div:public Expression\r\n{\r\n	private:\r\n			Expression* a1;\r\n			Expression* a2;\r\n	public:\r\n			Div(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n            Expression* diff()\r\n			{return new Div(new Sub(new Mul(a1->diff(),a2),new Mul(a1,a2->diff())),new Mul(a2,a2));}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'/\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  \r\n\r\n			~Div()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n};\r\n\r\n\r\nclass Cos:public Expression\r\n{\r\n	private:\r\n			Expression* a;\r\n	public:\r\n			Cos(Expression* x)\r\n              {a=x;}\r\n              \r\n            Expression* diff();\r\n              \r\n              void print()\r\n              {\r\n				  cout<<\"Cos\";\r\n				  cout<<\'(\';\r\n				  a->print();\r\n				  cout<<\')\';\r\n			  }  \r\n};\r\n\r\n\r\nclass Sin:public Expression\r\n{\r\n	private:\r\n			Expression* a;\r\n	public:\r\n			Sin(Expression* x)\r\n              {a=x;}\r\n              \r\n            Expression* diff()\r\n			{return new Mul(new Cos(a),a->diff());}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\"Sin\";\r\n				  cout<<\'(\';\r\n				  a->print();\r\n				  cout<<\')\';\r\n			  }  \r\n};\r\n\r\nExpression *Cos::diff()\r\n{return new Mul(new Sub(new Number(0), new Sin(a)),a->diff());}  \r\n\r\n\r\nvoid main()\r\n{\r\n	Expression *e = new Add(new Number(1), new Variable(\'x\'));\r\n	e->print();\r\n	std::cout << \"\\n\";\r\n	Expression *de = e->diff();\r\n	de->print();\r\n	std::cout << \"\\n\";\r\n	delete e;\r\n	delete de;\r\n	\r\n	Expression* A= new Div(new Number(1), new Mul(new Variable(\'y\'),new Variable(\'y\')));\r\n	A->print();\r\n	cout<<endl;\r\n	Expression* A1=A->diff();\r\n	A1->print();\r\n	cout<<endl;\r\n	delete A;\r\n	delete A1;\r\n\r\n	Expression *s = new Cos(new Variable(\'x\'));\r\n	Expression *ds = s->diff();\r\n	ds->print();\r\n\r\n}','ÐÐ½Ð½Ð°','Anna','f');
INSERT INTO `bias` VALUES (430,'#include<stdio.h>\n#define N 20\nint main()\n{\n	float a, d;\n	int b, c, i=0, j[N]={0}, n, m=0;\n	printf(\"??????? ????????? ?. ?.: \");\n	scanf(\"%d\", &b);\n	printf(\"??????? ????? ?????????? ?????: \");\n	scanf(\"%f\", &a);\n	if(b==10)\n	{\n		printf(\"%f\\n\", a);\n		return 0;\n	}\n	c=(int) a;\n	d=a-c;\n	if (c==0)\n		printf(\"0\");\n	while(c!=0)\n	{\n		j[i]=c%b;\n		c=c/b;\n		i++;\n	}\n	for(i--; i>=0; i--)\n	{\n		if(j[i]>=10)\n			printf(\"%c\", j[i]-10+\'A\');\n		else\n			printf(\"%c\", j[i]+\'0\');\n	}\n	if(d==0)\n	{\n		printf(\"\\n\");\n		return 0;\n	}\n	printf(\".\");\n	while(d<1 && m<5)\n	{\n		d=d*b;\n		n=(int) d;\n		d=d-n;\n		if(n>=10)\n			printf(\"%c\", n-10+\'A\');\n		else\n			printf(\"%c\", n+\'0\');\n		m++;\n	}\n	printf(\"\\n\");\n	return 0;\n	\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (431,'#include<stdio.h>\n#include<stdlib.h>\n#define N 100000\nvoid sort(int *a, int left, int right)\n{\n	int x=left, y=right, m, n;\n	m=a[(left+right)/2];\n	do\n	{\n		while(a[x]<m)\n		{\n			x++;\n		}\n		while(a[y]>m)\n		{\n			y--;\n		}\n		if(x<=y)\n		{\n			n=a[x];\n			a[x]=a[y];\n			a[y]=n;\n			x++;\n			y--;\n		}\n	}\n	while(x<y);\n	if(left<y)\n		sort(a, left, y);\n	if(right>x)\n		sort(a, x, right);\n}\nint main()\n{\n	int *a, b, c;\n	FILE *f;\n	f=fopen(\"inputt.txt\", \"r\");\n	fscanf(f, \"%d\", &c);\n	a=(int *)malloc(c * sizeof(int));\n	for(b=0; b<c; b++)\n		fscanf(f, \"%d\", &a[b]);\n	fclose(f);\n	sort(a, 0, c-1);\n	f=fopen(\"outputt.txt\", \"w\");\n	for(b=0; b<c; b++)\n		fprintf(f, \"%d \", a[b]);\n	fprintf(f, \"\\n\");\n	fclose(f);\n	free(a);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (432,'#include<stdio.h>\n#define N 100000\nvoid Sift(int *a, int i, int n)\n{\n	int x, min, r, l;\n//	char c;\n	i++;\n	while((l=2*i)<=n)\n	{\n		r=(l+1<=n)? l+1 : i;\n		if((a[i-1]>=a[l-1])&&(a[i-1]>=a[r-1]))\n				return;\n		min=(a[l-1]>=a[r-1])? l : r;\n		x=a[i-1];\n		a[i-1]=a[min-1];\n		a[min-1]=x;\n		i=min;\n	}\n}\n\nvoid Sort(int *a, int len)\n{\n	int i;\n	int c;\n	for(i=len/2; i>=0; i--)\n		Sift(a, i, len);\n	for(i=len-1; i>0; i--)\n	{\n		c=a[0];\n		a[0]=a[i];\n		a[i]=c;\n		Sift(a, 0, i);\n	}\n	return;\n}\n\nint main()\n{\n	FILE *f;\n	int a[N];\n	int i, n;\n	f = fopen(\"inputt.txt\", \"r\");\n	fscanf(f, \"%d\", &n);	\n	for(i=0; i<n; i++)\n		fscanf(f, \"%d\", &a[i]);\n	fclose(f);\n	Sort(a, n);\n	f=fopen(\"outputt.txt\", \"w\");\n//	fscanf(f, \"%d\", &n);\n	for(i=0; i<n; i++)\n		fprintf(f, \"%d \", a[i]);\n	fclose(f);\n	\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (433,'#include <stdio.h>\n#define N 100000\n\nvoid qsort(int *a, int l, int r)\n{\n	int k,p,i,j;\n	i=l;\n	j=r;\n	k=a[(l+r)/2];\n	do\n	{\n		while(a[i]<k) i++;\n		while(k<a[j]) j--;\n		if(i<=j)\n		{\n			p=a[i];\n			a[i]=a[j];\n			a[j]=p;\n			i++;\n			j--;\n		}\n	}\n	while(i<j);\n	if(l<j) qsort(a,l,j);\n	if(i<r) qsort(a,i,r);\n}\n\nint main()\n{\n	FILE *f=fopen(\"input1\", \"r\");\n	int i,n;\n	int a[N]={0};\n	fscanf(f, \"%d\", &n);\n	for(i=0; i<n; i++)\n		fscanf(f, \"%d \", &a[i]);\n	qsort(a, 0, n-1);\n	for(i=0; i<n; i++)\n		printf(\"%d \", a[i]);\n	printf(\"\\n\");\n	fclose(f);\n	return 0;\n}\n		\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (434,'#include <stdio.h>\n#include <stdlib.h>\n\nvoid f(int *a, int *b)\n{\n	int i=0;\n	while(b[i])\n	{\n		a[i]=b[i];\n		i++;\n	}\n	a[i]=0;\n}\n\nvoid s(int *a, int *b, int kol)\n{\n	int i=0;\n	for(i=0; i< kol; i++)\n		a[i]=b[i];\n	a[i]=0;\n}\n\nvoid perestanovka(int *s1, int *s2, int n)\n{\n	int i=0, j=0, dl1, dl2;\n	int *a1, *a2;\n	a1=malloc((n+1)*sizeof(int));\n	a2=malloc((n+1)*sizeof(int));\n	for(i=0; s1[i]; i++)\n		;\n	dl1=i;\n	for(j=0; s2[j]; j++)\n		;\n	dl2=j;\n	a1[0]=0;\n	a2[0]=0;\n	if(dl2==0)\n	{\n		for(i=0; i<n; i++)\n			printf(\"%d \", s1[i]);\n		printf(\"\\n\");\n		\n	}\n	\n	else\n		for(i=0; i<dl2; i++)\n		{\n			f(a1,s1);\n			a1[dl1]=s2[i];\n			a1[dl1+1]=0;\n			s(a2, s2, i);\n			s(a2+i, s2+i+1, dl2-i-1);\n			perestanovka(a1, a2, n);\n		}\n	free(a1);\n	free(a2);\n}\n\n\nint main()\n{\n	int n, i, kol=1;\n	int *s1, *s2;\n	scanf(\"%d\",&n);\n	s1=malloc((n+1)*sizeof(int));\n	s2=malloc((n+1)*sizeof(int));\n	s1[0]=0;\n	for(i=0; i<n; i++)\n		s2[i]=i+1;\n	perestanovka(s1, s2, n);\n	for (i=1; i<=n; i++)\n		kol=kol*i;\n	printf(\"Vsego perestanovok dlya n=%d : \", n);\n	printf(\"%d\\n\", kol);\n	free(s1);\n	free(s2);\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (435,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item {\n	int data;\n	struct item *next;\n};\n\nint main()\n{\n	struct item *head=NULL;\n	struct item *p,*r;\n	int x;\n	FILE *f=fopen(\"input2\", \"r\");\n	if (fscanf(f, \"%d\", &x)==1) {\n		p=(struct item *)malloc(sizeof(*p));\n		head = p;\n		p->data=x;\n		p->next=NULL;\n	}\n	while (fscanf(f, \"%d\", &x) == 1)\n	{\n		r = (struct item *)malloc(sizeof(*r));\n		for(p=head; (p->next) && (p->data<=x); p=p->next)\n			;\n		r->next = p->next;\n		p->next = r;\n		if(x < p->data)\n		{\n			r->data = p->data;\n			p->data = x;\n		}\n	        else\n		{\n			r->data = x;\n		}\n	}\n\n	for(p=head; p; p=p->next)\n		printf(\"%d \", p->data);\n	printf(\"\\n\");	\n	\n	fclose(f);\n	\n	return 0;\n}\n			\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (436,'#include <stdio.h>\nint main()\n{\n	int i=0,j=0,h=0,l,numb,b,d=0,k=0,m=0;\n	char n[200],s[200];\n	FILE*f=fopen(\"/etc/passwd\",\"r\");\n	printf(\"Vvedite login:\\n\");\n	scanf(\"%s\",&n);\n	l=strlen(n);\n	\n      while(fgets(s,200,f)!=NULL)\n      {\n	   m++;\n	   h++;\n	   fgets(s,200,f);\n	   for (i=0; s[i]!=\':\'; i++)\n	    {\n		if (s[i]!=n[i])\n		  {\n		        k++;\n		 	break;\n		  } \n		\n	    }\n	   if (n[i] != 0)\n		   k++;\n	  if (k!=0) k=0;\n	  else\n	 {\n		\n	    m=0;\n	    i=0;\n	    while(d<4)\n            {    \n	      if (s[i]==\':\') d++;\n	      i++;\n	      numb=i;\n	    }\n	 \n	   for (j=numb; s[j]!=\':\'; j++)\n		{\n		  printf(\"%c\",s[j]);\n		}\n	  printf(\"\\n\"); \n	 }  \n      }\n	if (d=0) printf(\"Net\\n\");\n	fclose(f);\n	return 0;\n}\n		   \n			   \n			\n	\n	\n		\n	\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (437,'#include <stdio.h>\nint main()\n{\n	int a,b=0,x,y,d,r=0,i=0,j;\n	float res=0, flt=0;\n	char n[100];\n	printf(\"Vvedite osnovanie ss: \\n\");\n	scanf(\"%d\",&b);\n	printf(\"Vvedite chislo v ykazannoi ss: \\n\");\n	scanf(\"%s\",n);\n	d=strlen(n);\n	for(i=0; i<d; i++)\n	{\n		if (n[i]==\'.\')\n		{\n			i++;\n		}\n		if ((n[i]>=\'A\') && (n[i]<=\'F\'))\n		{\n			n[i]=n[i]-\'A\'+10;\n		}\n		else\n		{\n			n[i]=n[i]-\'0\';\n		}\n	}\n	r=d-1;\n	i=0;\n	\n	while ((n[i]!=\'.\') && (i<=r))\n	{\n		res=res*b+n[i];\n		i++;\n	\n	}\n	if (n[i]==\'.\')\n	{\n		while(r>i)\n		{\n			printf(\"1\\n\");\n			flt=(flt+n[r])/b;\n			r--;\n		}\n		res=res+flt;\n	}\n	printf(\"Chislo= %f\\n\",res);\n	return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (438,'#include<stdio.h>\nint main()\n{\n	int a,b,i,j,x,y,intg,lenth=0;\n	int arr[100];\n	float n,flt;\n	char s;\n	printf(\"Vvedite osnovanie ss: \\n\");\n	scanf(\"%d\", &b);\n	printf(\"Vvedite chislo v 10 ss: \\n\");\n	scanf(\"%f\", &n);\n	intg=(int)n;\n	flt=n-intg;\n	if (intg!=0)\n	{\n		for(i=0;intg!=0;i++)\n		{\n			arr[i]=intg%b;\n			intg=intg/b;\n		}\n		i--;\n		for(y=i;y>=0;y--)\n		{\n			if (arr[y]>=10)\n				s=arr[y]+\'A\'-10;\n			else\n				s=arr[y]+\'0\';\n			printf(\"%c\",s);\n		}\n	}\n	else\n		printf(\"0\");\n	\n	if (flt!=0)\n	{\n		printf(\".\");\n		\n		while(flt<1 && lenth<5)\n			{\n			\n				flt=flt*b;\n				x=(int)flt;\n				flt=flt-x;\n				if(x>=10)\n					s=x-10+\'A\';\n				else\n					s=x+\'0\';\n				lenth++;\n				printf(\"%c\",s);\n			}\n		\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (439,'#include <stdio.h>\nint a[5]={1,3,5,7,9};\nint l=0,r=4,k,m=0;\nint main()\n{\n	printf(\"??????? ??????? ?????\\n\");\n	scanf(\"%d\",&k);\n	while (l<=r)\n	{\n		m=(l+r)/2;\n		if (k==a[m]) \n		{\n			printf(\"????? ???? ? ???????\\n\");\n			exit();\n		}\n		if (k<a[m]) r=m-1;\n		else l=m+1;\n	}\n	if (l>r) printf(\"????? ? ??????? ???\\n\");\nreturn 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (440,'#include <stdio.h>\nint main(int argc, char* argv[])\n{\n       int s=0;\n       FILE* source = fopen(argv[1],\"r\");\n       FILE* destination = fopen(argv[2],\"w\");\n       while ((s = fgetc(source))!= EOF)\n       {\n	       fputc(s, destination);\n       }\n       fclose(source);\n       fclose(destination);\n       return 0;\n}\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (441,'#include <stdio.h>\nint main()\n{\n	int words=0, t=\'\\n\',symb=0,str=0,s;\n	FILE*f=fopen(\"source\",\"r\");\n	while ((s=fgetc(f))!=EOF)\n	{\n		symb++;\n		if ((t!=\'\\n\')&&(t!=\'\\t\')&&(t!=\' \'))\n		if ((s==\'\\n\')||(s==\'\\t\')||(s==\' \'))\n			words++;\n		if (s==\'\\n\') str++;\n		t=s;\n	}\n	if (symb==0) str=0;\n	fclose(f);\n	printf(\"???-?? ???? %d\\n???-?? ???????? %d\\n???-?? ????? %d\\n\",words, symb, str);\n	return 0;\n}\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (442,'#include<stdio.h>\n#include<stdlib.h>\nvoid quick_sort(int* ARR, int left, int right)\n{\n	int i = left;\n	int j = right;\n	double x, W;\n	if (right > left)\n	{\n		x = ARR[(left + right) / 2];      /*??????? ???????? ???????*/\n		while (i <= j)			  \n		{\n			while ((i < right) && (ARR[i] < x)) /* ??????? ???????, ??????? ?????? ??? ????? ??????????????? ???????? ?? ?????? ????*/\n				++i;\n			while ((j > left) && (ARR[j] > x))/* ??????? ???????, ??????? ?????? ??? ????? ??????????????? ???????? ?? ??????? ????*/\n				--j;\n			if (i <= j)\n			{              \n				W = ARR[i];\n				ARR[i] = ARR[j];\n				ARR[j] = W;\n				++i;\n				--j;\n			}\n		}\n		if (left < j) quick_sort(ARR, left, j); /* ???? ?????? ?????? ?? ?????? ????? ??????? ???????, ????? ????????? ?????????? ????? ?????.*/\n		if (i < right) quick_sort(ARR, i, right); /* ???? ????? ?????? ?? ?????? ?????? ??????? ???????, ????? ????????? ?????????? ?????? ?????.*/\n	}\n}		\nint main()		\n{\n	int i = 0, M[100000];\n	int N,n,j;\n	FILE* f=fopen(\"input.txt\",\"r\");	\n	fscanf(f,\"%d\",&N);\n	for(i=0;i<N;i++)\n	{\n		fscanf(f,\"%d\",&M[i]);\n	}\n	quick_sort(M, 0, (i-1)); \n	for(i=0;i<N;i++)\n	{\n		printf(\"%d \",M[i]);\n	}	\nreturn 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (443,'#include <stdio.h>\nint main (int argc, char* argv[])\n{\n	int i,fl=0,sl=0,b=0,c=0,sym=0,str=0;\n	char tmp=0;\n	FILE* f = fopen(argv[1],\"r\");\n	for(sym=0;(c=fgetc(f))!=EOF;sym++) \n	{\n		if(c!=\' \' && c!=\'\\n\')\n		{\n			fl = 1;\n		}\n		if(c==\'\\n\')\n		{\n			str++;\n		}\n		if((c==\' \' || c==\'\\n\') && c!=tmp && fl==1)\n		{\n			fl=0;\n			sl++;\n		}\n		tmp=c;\n	}\n	printf(\"%d %d %d \\n\",str,sl,sym);\n	fclose(f);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (444,'#include <stdio.h>\n#include <string.h>\n\n#define N 50\n#define M 100\nint ifin(char *a, char *b)\n{\n	int i,j,bzu,sa,sb;\n	sa=strlen(a);\n	sb=strlen(b);\n	if(sa>=sb)\n	for(i=0;i<=sa-sb;i++)\n	{\n		j=0;\n		bzu=1;\n		while(j<sb)\n		{	\n			if(a[i+j]==b[j])\n				j++;\n			else\n			{\n				bzu=0;\n				break;\n			}\n			if (bzu==1) return 1;\n		}	\n		\n	}\n	return 0;\n}\n\nint main()\n{\n	char str[N]={0};\n	char login[M]={0};\n	char a;\n	int count=0;\n	int flag=0;\n	int i=0;\n	FILE *f;\n	\n	f=fopen(\"/etc/passwd\",\"r\");\n	if(f==NULL)\n	{\n		perror(\"?? ??????\\n\");\n		return 1;\n	}\n	scanf(\"%s\",str);\n	while((a=fgetc(f))!=EOF)\n	{\n		if(a==\':\')\n		{\n			count++;\n			if (count==4)\n				if(strcmp(str,login)==0)\n					flag=1;\n		}\n		else if(a==\'\\n\')\n		{\n			count=0;\n			i=0;\n			if(flag)\n			{\n				printf(\"\\n\");\n				break;\n			}\n		}\n		else if(count==0)\n		{\n			login[i]=a;\n			login[i+1]=0;\n			i++;\n		}\n		else if(count==4)\n		{\n			if(flag==1)\n				printf(\"%c\",a);\n				\n		}\n			\n	}\n	fclose(f);\n\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (445,'#include <stdio.h>\n\nFILE * ctf(char a,FILE *f_out,int *i,int *j)\n{\n	if(a==\',\')\n	{\n		if(*i==1)\n			fprintf(f_out,\"%c\",a);\n		else\n			fprintf(f_out,\"</td>\\n<td>\");\n	}\n	else if(a==\'\\n\')\n	{\n		if(*i==1)\n			fprintf(f_out,\"\\n\");\n		else\n		{\n			fprintf(f_out,\"</td>\\n</tr>\\n\");\n			*j=0;\n		}\n	}\n	else \n	{\n		if(*j==0)\n		{\n			fprintf(f_out,\"<tr>\\n<td>\");\n			*j=1;\n		}\n		fprintf(f_out,\"%c\",a);\n	}\n	return f_out;\n}\n\nint main()\n{\n	char str[200]={0};\n	char a,b;\n	int i=0,j=0;\n	FILE *f_in;\n	FILE *f_out;\n	\n	f_in=fopen(\"input.csv\",\"r\");\n	f_out=fopen(\"public_html/table.html\",\"w\");\n	\n	fprintf(f_out,\"<table border=2 bordercolor=green>\\n\");\n	while((a=fgetc(f_in))!=EOF)\n	{\n		\n		if(a==\'\"\')\n		{\n			if(i==0)i=1;\n			else\n			{\n				b=fgetc(f_in);\n				if(b==\'\"\')\n					fprintf(f_out,\"%c\",b);\n				else\n				{\n					i=0;\n					f_out=ctf(b,f_out,&i,&i);\n				}\n			}\n		}\n		else\n		f_out=ctf(a,f_out,&i,&j);				\n	}\n	fprintf(f_out,\"</table>\");\n	printf(\"\\n\");\n\n	\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (446,'#include <stdio.h>\n#define N 100000\n\nvoid rek(int a[N],int b,int n,int mass[N])\n{\n	int i,j;\n	int mass1;\n	int flag;\n	\n	if(n==b)\n	{\n		for(i=0;i<b;i++)\n			printf(\"%d \",a[i]);\n		printf(\"\\n\");\n		return;\n	}	\n	for(i=0;i<n;i++)\n	{\n	\n		flag=0;\n		for(j=0;j<b;j++)\n			if(mass[i]==a[j])flag=1;\n		if(flag==0)\n		{\n			a[b]=mass[i];\n			rek(a,b+1,n,mass);\n		}\n	}\n	return;\n}\nint main()\n{\n	FILE *f;\n	int n,i;\n	int mass[N]={0};\n	int mass2[N]={0}; 	\n	\n	f=fopen(\"input.txt\",\"r\");\n	fscanf(f,\"%d\\n\",&n);\n	\n	for(i=0;i<n;i++)\n		fscanf(f,\"%d\",&mass[i]);\n\n	rek(mass2,0,n,mass);\n	\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (447,'#include <stdio.h>\n#include <stdlib.h>\nint main()\n{\n	int a,flag;\n	struct item\n	{\n		int data;\n		struct item* next;\n	};\n	struct item *tail,*qq,*curitem,*head=malloc(sizeof(*head)),*head1,*nexti,*previ;\n	//?????? ?????????\n	//-------------------------------------------\n	freopen(\"inp.txt\",\"r\",stdin);\n	scanf(\"%d\",&a);\n	head->data=a; \n	tail=head;\n	while(scanf(\"%d\",&a)==1)\n	{\n		struct item* q=malloc(sizeof(*q));\n		tail->next=q;\n		q->data=a;\n		tail=q;		\n	}\n	tail->next=NULL;\n	//--------------------------------------------\n	head1=head;\n	head=head->next;\n	head1->next=NULL;\n	while (head!=NULL)\n	{\n		flag=0;\n		nexti=head1;\n		previ=NULL;\n		curitem=head;\n		head=head->next;\n		while (nexti->data<curitem->data)\n		{\n			if (nexti->next==NULL)\n			{\n				curitem->next=NULL;\n				nexti->next=curitem;\n				flag=1;	\n			}\n			previ=nexti;\n			nexti=nexti->next;\n		}\n		if (flag==0)\n			if (previ==NULL)\n			{\n				curitem->next=head1;\n				head1=curitem;\n			}\n			else\n			{\n				curitem->next=previ->next;\n				previ->next=curitem;\n			}\n	}\n	while (head1)\n	{\n		printf(\"%d \",head1->data);\n		qq = head1;\n		head1 = head1->next;\n		free(qq);\n	}\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (448,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nvoid copy(char *from,char *in)\n{\n	        int i;\n	        for (i=0;i<11;i++) in[i]=from[i];\n}\nint readword(char *s)\n{\n	int i;\n	char c;\n	for (i=0;i<11;i++) s[i]=0;\n	i=0;\n	while(((c=getchar())<\'a\' && c>\'z\') ||(c<\'A\' && c>\'Z\'))  if (c==EOF) return -1;\n	while ((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\'))\n	{\n		s[i]=c;\n		i++;\n		c=getchar();\n	}\n	s[i]=0;\n	if (c==EOF) return -1;\n	return 0;\n}\nint main()\n{\n	int flag;\n	char s[11];\n	struct item\n	{\n		char word[11];\n		int count;\n		struct item *next;\n	} *head,*p,*q;\n	freopen(\"iput.txt\",\"r\",stdin);\n	readword(s);\n	head=malloc(sizeof(*head));\n	copy(s,head->word);\n	head->count=1;\n	head->next=NULL;\n	while (readword(s)!=-1)\n	{\n		if (s[0] == 0) continue;\n		printf(\"%s\\n\",s);\n		flag=0;\n		p=head;\n		while(1)\n		{\n			if (strcmp(s,p->word)==0)\n			{\n				(p->count)++;\n				flag=1;\n			}\n			if (p->next==NULL) break;\n			p=p->next;\n		}\n		if (flag==0)\n		{\n			q=malloc(sizeof(*q));\n			copy(s,q->word);\n			q->count=1;\n			q->next=NULL;\n			p->next=q;\n		}\n	}\n	for(p=head;p;)\n	{\n		printf(\"%s %d\\n\",p->word, p->count);\n		p=p->next;\n	}\n	return 0;\n}                        			                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (449,'#include <stdio.h>\n\nint main (int argc, char *argv[]) {\n\n  char buff[128];\n\n  FILE *input  = fopen (argv[1], \"rb\");\n  FILE *output = fopen (argv[2], \"wb\");\n\n  int k;\n\n  while ((k = fread (buff, 1, 128, input)) > 0) {\n    fwrite (buff, 1, k, output);\n  }\n\n  fclose(input);\n  fclose(output);  \n  \n  return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (450,'#include <stdio.h>\n#include \"safe.h\"\n\n#define null 0\n\nint isSeparator(char c) {\n  return !((c > \'0\' && c < \'9\' ) || ( c > \'A\' && c < \'Z\' ) || (c > \'a\' && c<\'z\'));\n}\n\ntypedef struct {\n  FILE *file;\n  char buff[1024];\n  int bytesAvailable;\n  int eof;\n  int index;\n} file_t;\n\n\nfile_t *init(char* fname) {\n  file_t *f = (file_t*) __safe_calloc (sizeof(file_t), 1);\n  f->file = fopen (fname, \"rb\");\nf->bytesAvailable = fread (f->buff, 1, 1024, f->file);\n  return f;\n}\n\nchar getNewChar(file_t *f) {\n  if (f->eof) return 0;\n  if (f->index >= f->bytesAvailable) {\n    if (f->bytesAvailable != 1024) {\n      f->eof = 1;\n      return 0;\n    }\n    else {\n      f->index = 0;\n      f->bytesAvailable = fread (f->buff, 1, 1024, f->file);\n      if (f->bytesAvailable == 0) {\n	f->eof = 1;\n	return 0;\n      }\n    }\n  }\n  return f->buff[f->index++];\n}\n\nvoid deinit(file_t *f) {\n  fclose(f->file);\n  free(f);\n}\n\nint main (int argc, char* argv[]) {\n\n  file_t *file = init(argv[1]);\n\n  char c;\n  long chars = 0, words = 0, lines = 0;\n  char prv = 1;\n  while (c = getNewChar (file)) {\n    chars++;\n    if (c==\'\\n\') lines++;\n    if (isSeparator(c)) {\n      if (!prv) {\n        words++;\n	prv = 1;\n      }\n    } \n    else \n      prv = 0;\n  }\n\n  printf (\"%5d lines %5d words %5d chars  file %s  \\n\", lines, words, chars, argv[1]);\n\n  deinit (file);\n\n  return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (451,'#include <stdio.h>\n\n\n#define MAX_STRING_LENGTH 1024\n\n\n#define __sep(c) !((c>\'A\'-1 && c<\'Z\'+1) || (c>\'a\'-1 && c<\'z\'+1) || (c>\'0\'-1 && c<\'9\'+1))\n\n\nint main () {\n  char buff[MAX_STRING_LENGTH];\n  int i = 0,j =  strlen(buff)-1;\n  \n  fgets(buff, MAX_STRING_LENGTH, stdin);\n    \n  while (i < j) {\n		while (__sep(buff[i]) && i <MAX_STRING_LENGTH) i++;\n		while (__sep(buff[j]) && j >= 0) j--;\n\n		if (buff[i]!=buff[j]) {\n			printf(\"NO\\n\");\n			return (1);\n		}\n	i++; j--;	\n	}\n\n  printf(\"YES\\n\");\n  return (0);\n\n};\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (452,'#include <stdio.h>\n#include \"safe.h\"\n\n\nvoid print(int* A, int N) {\n	int i;\n	for (i = 0; i < N; i++) \n	printf(\"%2d \",A[i]+1);\n	printf(\"\\n\");\n}\n\n\n\n\n\nvoid generate(int *B, int N, int I, long available) {\n	int i=0;\n\n	if (I==N) {\n		print(B,N);\n		return;\n	}\n\n	for (i = 0; i < N; i++)\n		if (available & (2<<i)) {\n			B[I]=i;\n			generate(B,N,I+1, available ^ (2<<i));\n		}\n\n}\n\n\n\n\n\nint main() {\n        int N =0;\n	int *A = (int*) __safe_calloc(N,sizeof(int));\n	\n\n	while (1) {\n		printf(\"N [1-31]: \");\n		scanf(\"%d\", &N);\n		if (N>0 && N<32) break;\n		printf(\"Incorrect value for N. try again:\\n\");\n	       \n	}\n\n\n\n	generate(A,N,0,-1);\n\n	free (A);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (453,'#include <stdio.h>\n#include \"safe.h\"\n\n\nvoid swap (int *A, int i, int j) {\n	int temp = A[i];\n	A[i] = A[j];\n	A[j] = temp;\n}\n\n\nvoid quicksort(int *A, int l, int r)  {\n\n	int i=l, j=r;\n	float x = ((float)(A[l]+A[r]))/2;\n	if (l+1==r) {\n		if (A[l]>A[r]) swap(A,l,r);\n		return;\n	}\n	while (i<j) {\n		while (A[i]<=x) i++;\n		while (A[j]>=x) j--;\n		if (i<j) { swap(A,i,j); i++; j--; }\n	}\n	if (i<r) quicksort(A, i,r);\n	if (j>l) quicksort(A, l,j);\n}\n\nint main () {\n	int N;\n	int *A;\n	int i;\n\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n\n        scanf(\"%d\", &N);\n	A = (int*) __safe_calloc(N, sizeof(int));\n\n        for (i = 0; i < N; i++) scanf(\"%d\", &A[i]);\n//	for (i = 0; i < N; i++) printf(\"%d \", A[i]);\n//	printf(\"\\n\");\n        \n	quicksort(A,0,N-1);\n\n	for (i = 0; i < N; i++) printf(\"%d \", A[i]);\n\n	free(A);\n	fclose(stdin);\n	fclose(stdout);\n\n	return (0);\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (454,'#include<stdio.h>\n#include<math.h>\nint main()\n{\n\n	char s[20];\n	int ce;\n	float dr;\n	float a;\n	int b;\n	int i=-1;\n 	int t;\n	int k;\n	int m,n;\n	int dr1;\n	int u;\n	printf(\"vvedite chislo\\n\");\n	scanf(\"%f\",&a);\n      	printf(\"vvedite systemy schislenia\\n\");\n	scanf(\"%d\",&b);\n	ce=a;\n	dr=a-ce;\n	printf(\"celoe= %d\\n\",dr); \n	printf(\"drobnoe= %f\\n\",dr); \n	t=ce*b;\n	printf(\"t nach= %d\\n\",t); \n	while(t>=b)\n	{\n	t=t/b;\n	i++;\n	printf(\"i= %d\\n\",i);\n	k=t%b;\n	printf(\"k= %d\\n\",k);\n	if(k<10)\n	{\n		s[i]=k+\'0\';\n	}\n	else\n	     s[i]=55+k;	\n	printf(\"t konech= %d\\n\",t); \n	}\n       	printf(\"i= %d\\n\",i);\n	for (m=0;m<=(i/2);m++)\n	{\n		n=s[m];\n		s[m]=s[i-m];\n	        s[i-m]=n;\n	}\n	s[i+1]=\'.\';\n	for(u=i+2;u<i+20;u++)\n	{\n		dr=dr*b;\n		printf(\"dr= %d\\n\",dr);\n		dr1=dr;\n	        printf(\"dr1= %d\\n\",dr1); \n	if(dr1<10)	\n		s[u]=dr1+\'0\';\n	else\n	     s[u]=55+dr1;	\n	dr=dr-dr1;\n	}\n	s[u]=0;\n	printf(\"REZULTAT %s\\n\",s);\n	return 0;\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (455,'#include<stdio.h>\n#include<math.h>\nint main()\n{\n	float rez=0;\n	float pro=0;\n	int d=0;\n	int i,t;\n	int b;\n	int g=0;\n	int z=0;\n	int fan=0; \n        char s[100];\n        int k=0;\n	int q=0;\n	int e=0;\n	float  v=0;\n	FILE*f1=fopen(\"zxc.c\",\"r\");  \n	printf(\"vvod chisla\\n\");\n	scanf(\"%s\",s);\n	\n	for (k=0;s[k];k++)\n	;\n	printf(\"k= %d\\n\",k);\n\n	printf(\"vvod systemy schislenia\\n\");\n	scanf(\"%d\",&b);\n	for (i=0;i<k;i++)\n		if (s[i]==\'.\')\n		{\n			g++;\n			q=i;\n		}\n	if (g==0)\n	{	\n		for (z=k-1;z>=0;z--)\n		{          \n			if (s[z]<=\'9\')\n				fan=fan+(s[z]-\'0\')*pow(b,k-z-1);\n			else \n				fan=fan+(s[z]-\'A\'+10)*pow(b,k-z-1);\n		 }\n	}\n	else \n	{\n		for (e=q-1;e>=0;e--)\n		{\n			if (s[e]<=\'9\')\n				fan=fan+(s[e]-\'0\')*pow(b,q-e-1);\n			else \n				fan=fan+(s[e]-\'A\'+10)*pow(b,q-e-1);\n		}\n		printf(\"promez rezult= %d\\n\",fan);\n		for (d=q+1;d<=(k-1);d++)\n		{\n			if (s[d]<=\'9\')\n				pro=pro+(s[d]-\'0\')*pow(b,q-d);\n			else\n				pro=pro+(s[d]-\'A\'+10)*pow(b,q-d);\n			printf(\"stepen= %f\\n\",pow(b,q-d));\n			printf(\"pro= %f\\n\",pro);\n		}			\n	}\n	rez=fan+pro;	\n	printf(\"rezultat %f\\n\",rez);\n	fclose(f1);\n	return 0;\n}\n		\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (456,'#include <iostream>\n\ntemplate <typename T> class List\n{\n	private:\n		struct element\n		{\n			T data;\n			element *next;\n			element *prev;\n		};\n		element *head;\n		element *tail;\n		int len;\n	List(const List &p);\n	List& operator=(const List& other); \n	public:\n		List()\n		{\n			head=0;\n			tail=0;\n			len=0;\n		}\n		void pst1(const T c)\n		{\n			struct element *q;\n			q=new struct element[1];\n			if (len)\n				{\n					head->prev=q;\n					q->next=head;\n					q->prev=0;\n					head=q;\n					q->data=c;\n				}\n				else\n				{\n					head=q;\n					tail=q;\n					q->next=0;\n					q->prev=0;\n					q->data=c;\n				}\n			len++;\n		}\n\n		void del1()\n		{\n			if (len==0)\n				return;\n			if (len==1)\n			{\n				struct element *t;\n				t=head;\n				head=0;\n				tail=0;\n				len=0;\n				delete t;\n			}\n			else\n			{\n				struct element *t;\n				t=head;\n				head=head->next;\n				head->prev=0;\n				len--;\n				delete t;\n			}\n		}\n\n		~List()\n		{\n			struct element *p,*q;\n			p=head;\n			q=0;\n			for (p=head;p;p=p->next)\n			{\n				if (q) \n					delete q;\n				q=p;\n			}\n			delete p;\n			len=0;\n		}\n\n\n\n		void pst2(const T c)\n		{\n			struct element *p;\n			p = new struct element[1];\n			if (len)\n				{\n					tail->next=p;\n					p->next=0;\n					p->prev=tail;\n					tail=p;\n					p->data=c;\n				}\n				else\n				{\n					head=p;\n					tail=p;\n					p->next=0;\n					p->prev=0;\n					p->data=c;\n				}\n		len++;\n		}\n\n\n		void del2()\n		{\n			if (len==0)\n				return;\n			if (len==1)\n			{\n				struct element *t;\n				t=head;\n				head=0;\n				tail=0;\n				len=0;\n				delete t;\n			}\n			else\n			{\n				struct element *t;\n				t=tail;\n				tail=tail->prev;\n				tail->next=0;\n				len--;\n				delete t;\n			}\n		}\n		\n		void pr()\n		{\n		std::cout << \"\\n  \";\n		struct element *p;\n		for (p=head;p;p=p->next)\n			std::cout << p->data << \"| \";\n		std::cout <<\"\\n \" <<len<<\"\\n\";\n		}\n\n\n};\nint main()\n{\n	List<int> qqq;\n\n	for (int i = 0; i < 5; i++)\n	{\n		qqq.pst2(i);\n		qqq.pst1(i);\n		qqq.pr();\n	}\n\n	for (int i = 0; i < 5; i++)\n	{\n		qqq.del1();\n		qqq.del2();\n		qqq.pr();\n	}\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (457,'\n#include <stdio.h>\n#include <string.h>\n\nclass Expression\n{\n	public:\n	virtual Expression* diff() = 0;\n	virtual void print() = 0;\n};\n\nclass Number: public Expression\n{\n	private:\n	int num;\n	Expression *retDiff;\n	public:\n	Number (int n)\n	{\n		 num=n;\n		 retDiff=NULL;\n	}\n	~Number()\n	{\n		 if(retDiff) delete retDiff;\n	}\n\n	Expression* diff()\n	{\n		 if(retDiff == NULL) retDiff=new Number(0);\n		 return retDiff;\n	}\n	void print()\n	{\n		 printf(\"%d\",num);\n	}\n};\nclass Variable: public Expression\n{\n	private:\n	char var;\n	Expression *retDiff;\n	public:\n	Variable(char v)\n	{\n			var=v;\n			retDiff=NULL;\n	}\n	~Variable()\n	{\n		 if (retDiff) delete retDiff;\n	}\n	Expression* diff()\n	{\n		 if (retDiff==NULL) retDiff = new Number(1);\n		 return retDiff;\n	}\n	void print()\n	{\n		 printf(\"%c\",var);\n	}\n};\n\nclass Add: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff;\n	public:\n	Add (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 retDiff=NULL;\n	};\n	~Add()\n	{\n		 if (retDiff) delete retDiff;\n	}\n	\n	Expression* diff()\n	{\n		 if (retDiff==NULL) retDiff=new Add (exp1->diff(),exp2->diff());\n		 return retDiff;\n	}\n	void print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"+\");\n		exp2->print();\n		printf(\")\");\n	}\n};\nclass Sub: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff;\n	public:\n\n	Sub (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 retDiff=NULL;\n	};\n	~Sub()\n	{\n		 if(retDiff) delete retDiff;\n	}\n	Expression* diff()\n	{\n		 if(retDiff==NULL) retDiff=new Sub (exp1->diff(),exp2->diff());\n		 return retDiff;\n	}\n	void print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"-\");\n		exp2->print();\n		printf(\")\");\n	}\n};\n\nclass Mul: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff, *mul1, *mul2;\n	\n	public:\n	Mul (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 mul1=NULL;\n		 mul2=NULL;\n		 retDiff=NULL;\n	};\n	~Mul()\n	{\n		 if (mul1) delete mul1;\n		 if (mul2) delete mul2;\n		 if (retDiff) delete retDiff;\n	}\n	\n	Expression* diff()\n	{\n		 if (mul1==NULL) mul1=new Mul (exp1->diff(),exp2);\n		 if (mul2==NULL) mul2=new Mul (exp1,exp2->diff());\n		 if (retDiff==NULL) retDiff=new Add (mul1,mul2);\n		 return retDiff;\n	\n	}\n	void\n	print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"*\");\n		exp2->print();\n		printf(\")\");\n	}\n};\nclass Div: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff, *mul1, *mul2, *mul3, *sub;\n	\n	public:\n	Div (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 mul1=NULL;\n		 mul2=NULL;\n		 mul3=NULL;\n		 sub=NULL;\n		 retDiff=NULL;\n	}\n	~Div()\n	{\n		 if(mul1) delete mul1;\n		 if(mul2) delete mul2;\n		 if(mul3) delete mul3;\n		 if(sub)  delete sub;\n		 if(retDiff) delete retDiff;\n	}\n\n	Expression* diff()\n	{\n		 if (mul1==NULL) mul1=new Mul (exp1->diff(),exp2);\n		 if (mul2==NULL) mul2=new Mul (exp1,exp2->diff());\n		 if (sub==NULL) sub=new Sub (mul1,mul2);\n		 if (mul3==NULL) mul3=new Mul (exp2,exp2);\n		 if (retDiff==NULL) retDiff=new Div (sub,mul3);\n		 return retDiff;\n	}\n	void print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"/\");\n		exp2->print();\n		printf(\")\");\n	}\n};\n\nExpression* read(char*x)\n{\n	char*y,*z;\n	if(strlen(x)==1)\n	{\n		if((x[0]<=\'9\')&&(x[0]>=\'0\'))\n		return new Number(x[0]-\'0\');\n		else\n		return new Variable(x[0]);\n	}\n	y=new char[strlen(x)];\n	z=new char[strlen(x)];\n	int i,j=0,k;\n	for (i=1;(j>0)||(i==1);i++)\n	{\n		if(*x==\'(\')\n		j++;\n		if(*x==\')\')\n		j--;\n		y[i-1]=*x;\n	}\n	y[i-1]=0;\n	k=i;\n	for(i=k+1;x[i+1];i++)\n	{\n		z[i-k-1]=*x;\n	}\n	z[i-k-1]=0;\n	if(x[k]==\'+\')\n	return new Add(read(y),read(z));\n	if(x[k]==\'-\')\n	return new Sub(read(y),read(z));\n	if(x[k]==\'*\')\n	return new Mul(read(y),read(z));\n	if(x[k]==\'/\')\n	return new Div(read(y),read(z));\n}\n\nint main()\n{\n	Expression *e=new Div(new Number(1), new Add(new Variable(\'x\'), new Number(1)));\n	printf(\"\\n\");\n	e->print();\n	printf(\"\\n\");\n	\n	printf(\"\\n\");\n	\n	Expression *de = e->diff();\n	de->print();\n	printf(\"\\n\");\n	delete e;\n	delete de;\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (458,'#include <iostream>\ntemplate <typename T> class list\n{\nprivate:\n	list(const list &orig) { }\n	list& operator=(const list &orig) { }\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\npublic:\n	list()				//???????????\n	{\n		head=NULL;	\n	}\n	~list()				//??????????\n	{\n		while (head!=NULL)\n		{\n			hdelete();\n		}\n	}\n	void hinsert(T info)		//??????? ? ??????\n	{\n		element *p;\n		p=new element;\n		p->data=info;\n		p->next=head;\n		head=p;      \n	}\n	void hdelete()		//???????? ??????\n	{\n		element *p;\n		p=head->next;\n		delete head;\n		head=p;	\n	}\n	void tinsert (T info)	//?????? ? ?????\n	{\n		element *p,*q;\n		p=new element;\n		p->data=info;\n                p->next=NULL;\n		if (head==NULL)\n		{\n			head=p;			\n			return;\n		}\n		if (head!=NULL)	\n		{\n			for (q=head;q->next;q=q->next);	\n			q->next=p;\n			return;\n		}\n	}\n	\n\n	void tdelete ()		//???????? ??????\n	{\n		element *p,*q,*r;\n		p=head;\n		for (q=head;q->next;q=q->next)\n		{\n			p=q;\n		}\n		p->next=NULL;\n		if (q == head)\n		{\n			delete head;\n			head = NULL;\n		}\n		else\n			delete q->next;\n	}\n\n\n	void print()		//?????\n	{\n		element *p;\n		p=head;\n		while (p!=NULL)\n		{\n			std::cout<<(p->data)<<\" \";\n			p=p->next;\n                }\n		std::cout << \"\\n\";\n	}\n};\nint main()\n{\n	int i;\n	list <int> spisok1;\n	for (i = 0; i < 5; i++)\n        {\n                spisok1.tinsert(i);\n		spisok1.hinsert(i);\n                spisok1.print();\n        }\n	\n	for (i = 0; i < 5; i++)\n	{\n		spisok1.hdelete();\n		spisok1.tdelete();\n		spisok1.print();\n	}\n	\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (459,'#include <iostream>\n\ntemplate <typename T> class List\n{\nprivate:\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\n	List(const List& a){};\n	List& operator= (const List& a){};	\npublic:\n	List()\n	{\n		head=0;\n	}	\n        ~List()\n        {\n                struct element* p=head;\n                while(head)\n                {\n                           p=head->next;\n                           delete[] head;\n                           head=p;\n                }           \n                delete[] head;\n        }\n	void put(T a)\n	{\n		struct element *p=new(struct element);\n		p->data=a;\n		p->next=head;\n		head=p;\n	}\n	void del()\n	{\n		struct element*p=head;\n		if(!p)\n			throw \"don\'t have elements\";\n		else\n		{\n			head=head->next;\n			delete [] p;\n		}\n				\n	}\n	void put_end(T a)\n	{\n		struct element*p=head;\n                struct element*q;\n\n		if(!p)\n			put(a);\n		else\n		{\n			while(p)\n	                {\n                       		q=p;\n                       		p=p->next;\n        	        }\n			p=new(struct element);\n			q->next=p;\n			p->next=0;\n			p->data=a;\n		}\n	}\n	void del_end()\n	{\n		struct element*p=head;\n		struct element*q;\n		if(!p)\n			throw \"don\'t have elements\";\n\n		if (!head->next)\n		{\n			delete head;\n			head = NULL;\n			return;\n		}\n\n		while(p->next)\n		{\n			q=p;\n			p=p->next;\n		}\n		q->next=0;\n		delete []p;\n	}\n	class iterator\n        {\n        private:\n		element* iter;\n	public:   		\n		iterator(element* a)\n		{\n			iter=a;\n		}\n                iterator(const iterator& a)\n                {\n			iter=a.iter;\n                }\n                ~iterator()\n		{\n		}\n                bool operator!= (const iterator&a)\n                {\n                        if(iter==a.iter)\n                                return false;\n                        return true;\n                }\n                void operator++ ()\n                {\n                        if(iter!=0)\n                                iter=iter->next;\n                        else\n                                throw \"don\'t have elements\";\n                        return;\n                }\n                T& operator* () const\n                {\n                         if(iter)\n                                 return iter->data;\n                         else\n                                 throw \"don\'t have elements\";\n                }\n                element* operator-> () const\n                {\n                         if(iter)\n                                 return iter;\n                         else\n                                 throw \"don\'t have elements\";\n                }\n        };\n        iterator begin() const\n        {\n                return iterator(head);\n        }\n        iterator end() const\n        {\n                return iterator(0);\n        }\n};\n\nint main()\n{\n        List<int> sp;\n\n	for (int i = 0; i < 5; i++)\n	{\n		sp.put_end(i);\n		sp.put(i);\n        	for(List<int>::iterator i=sp.begin(); i!=sp.end(); ++i)\n	        {\n	                 std::cout<<*i<<\" \";        \n	        }\n	        std::cout<<\"\\n\";\n	}\n\n	for (int i = 0; i < 5; i++)\n	{\n		sp.del();\n		sp.del_end();\n        	for(List<int>::iterator i=sp.begin(); i!=sp.end(); ++i)\n	        {\n	                 std::cout<<*i<<\" \";        \n	        }\n	        std::cout<<\"\\n\";\n	}\n\n        return 0;\n}\n\n','Ð›Ð¸Ð´Ð¸Ñ','Lidiya','f');
INSERT INTO `bias` VALUES (460,'//??????\n#include<iostream>\ntemplate <typename T> class List\n{\nprivate:\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\n\n	List(const List &orig){};//?????? ????????????? ???????????? ???????????\n	List& operator=(const List &orig){};//?????? ????????????? ????????? ????????????\n\n\npublic:\n	List()\n	{\n		head=NULL;\n	}\n\n	void insert(T a)//??????? ? ?????? ??????\n	{\n		element *p=new element;\n		p->data=a;\n		p->next=head;\n		head=p;\n	}\n\n	void del()//???????? ??????? ????????\n	{\n		element *q=head->next;\n		delete head;\n		head=q;\n	}\n\n	~List()//??????????,????????????? ??? ??????\n	{\n		element *d;\n		while(head)\n		{\n			d=head;\n			head=head->next;\n			delete d;\n		}\n	}\n\n	void insertend(T x)//???????? ??????? ???????? ? ????? ??????\n	{\n		element *q=new element;\n		element *p=head;\n\n		if (!p)\n		{\n			insert(x);\n			return;\n		}\n\n		while(p->next!=NULL)\n		{\n			p=p->next;\n		}\n		q->data=x;\n		p->next=q;\n		q->next=NULL;\n		\n	}\n	\n	void delend()//???????? ???????? ?????????? ????????\n	{\n		element *p=head;\n		element *q=head->next;\n\n		if (!q)\n		{\n			delete head;\n			head = NULL;\n			return;\n		}\n\n		while(q->next!=NULL)\n		{\n			p=q;\n			q=q->next;\n		}\n		p->next=NULL;\n		delete q;\n	}\n\n	class Iterator//?????-????????\n	{\n	private:\n		element *p;\n	public:\n\n		Iterator(element *where)\n		{\n			p = where;\n		}\n	\n		T operator*() const//???????? ???????? ??????\n		{\n			return p->data;\n		}\n\n		T* operator->() const//????? ????????\n		{\n			return &(p->data);\n		}\n\n		Iterator& operator++()//????????? ????????\n		{\n			if(p!=NULL)\n				p=p->next;\n			return *this;\n		}\n\n		bool operator!=(const Iterator other)\n		{\n			return (p != other.p);\n		}\n	\n	};\n	void print()\n	{\n		for (element *p = head; p; p = p->next)\n		{\n			std::cout << p->data << \" \";\n		}\n		std::cout << \"\\n\";\n	}\n\n	Iterator begin() const \n	{\n		Iterator i(head);\n		return i;\n	}\n\n	Iterator end() const \n	{\n		Iterator i(NULL);\n		return i;\n	}\n\n};\n\n\nint main()\n{\n	List<int> l;\n	\n	for (int i = 0; i < 5; i++)\n	{\n		l.insertend(i);\n		l.insert(i);\n		l.print();\n	}\n\n	for (List<int>::Iterator i = l.begin(); i != l.end(); ++i)\n	{\n		std::cout << *i << \"\\n\";\n	}\n\n	for (int i = 0; i < 5; i++)\n	{\n		l.del();\n		l.delend();\n		l.print();\n	}\n\n	return 0;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (461,'#include <iostream>\r\n\r\nstruct s\r\n{\r\n	int a,b;\r\n};\r\n\r\n\r\ntemplate <typename T> class List // ?????? ?????? ?????? ? ????? ?????? T\r\n{\r\nprivate:\r\n	struct item // ?????????, ?????????? ?????????? ???? T (data), ????????? ?? ????????? ? ?????????? ????????\r\n	{\r\n		T data;\r\n		item *next;\r\n		item *prev;\r\n	};\r\n	item* tail; //????????? ?? ?????\r\n	item* head; //????????? ?? ??????\r\n	int len; //????? ??????\r\n	List(const List &t); //?????? ???????????? ???????????\r\n	List& operator=(const List& other); //?????? ????????? ????????????\r\npublic:\r\n	class Iterator\r\n	{\r\n	private:\r\n		item* i;\r\n	public:\r\n		Iterator()\r\n		{\r\n			i = 0;\r\n		}\r\n		Iterator(item*a)\r\n		{\r\n			i = a;\r\n		}\r\n		Iterator(const Iterator &other)\r\n		{\r\n			i = other.i;\r\n		}\r\n		~Iterator()	{}\r\n		Iterator& operator++()\r\n		{\r\n			i = i->next;\r\n			return *this;\r\n		}\r\n		Iterator& operator--()\r\n		{\r\n			i = i->prev;\r\n			return i;\r\n		}\r\n		T* operator->()\r\n		{\r\n			return &(i->data);\r\n		}\r\n		T& operator*()\r\n		{\r\n			return i->data;\r\n		}\r\n		bool operator==(const Iterator other)\r\n		{\r\n			if (other.i == i)\r\n				return 1;\r\n			else \r\n				return 0;\r\n		}\r\n		bool operator!=(const Iterator other)\r\n		{\r\n			if (other.i == i)\r\n				return 0;\r\n			else \r\n				return 1;\r\n		}\r\n		Iterator& operator=(const Iterator &other)\r\n		{\r\n			i = other.i;\r\n			return *this;\r\n		}\r\n	};\r\n	Iterator begin() const\r\n	{\r\n		return Iterator(head);\r\n	}\r\n	Iterator end() const\r\n	{\r\n		return Iterator(0);\r\n	}\r\n	List() //???????????, ???????? ??????? ?????? (????????? ???)\r\n	{\r\n		head = 0;\r\n		tail = 0;\r\n		len = 0;\r\n	}\r\n	~List() //??????????, ???????????? ???????? ??????\r\n	{\r\n		struct item *p,*q;\r\n		std::cout << \"\\n?????? ?????? ????? \" << len;\r\n		p=head;\r\n		q=0;\r\n		for (p=head;p;p=p->next)\r\n		{\r\n			if (q) \r\n				delete q;\r\n			q = p;\r\n		}\r\n		delete p;\r\n	}\r\n	int length() const //???????, ????????????? ????? ??????\r\n	{\r\n		return len;\r\n	}\r\n	void paste_H(const T a) //??????? ? ?????? ??????\r\n	{\r\n		struct item *p;\r\n		p = new struct item[1]; //????????? ?????? ??? ???????\r\n		if (len) //???? ?????? ?? ????\r\n		{\r\n			head->prev = p;\r\n			p->next = head;\r\n			p->prev = 0;\r\n			head = p;\r\n			p->data = a;\r\n		}\r\n		else //???? ?????? ????\r\n		{\r\n			head = p;\r\n			tail = p;\r\n			p->next = 0;\r\n			p->prev = 0;\r\n			p->data = a;\r\n		}\r\n//		std::cout << \"\\n??????? ? ??????: \" << p->data;\r\n		len++; //?????????? ????? ?? ???????\r\n	}\r\n	void paste_T(const T a) //??????? ? ????? ??????\r\n	{\r\n		struct item *p;\r\n		p = new struct item[1]; //????????? ?????? ??? ???????\r\n		if (len) //???? ?????? ?? ????\r\n		{\r\n			tail->next = p;\r\n			p->next = 0;\r\n			p->prev = tail;\r\n			tail = p;\r\n			p->data = a;\r\n		}\r\n		else //???? ?????? ????\r\n		{\r\n			head = p;\r\n			tail = p;\r\n			p->next = p;\r\n			p->prev = p;\r\n			p->data = a;\r\n		}\r\n//		std::cout << \"\\n??????? ? ?????: \" << p->data;\r\n		len++; //?????????? ????? ?? ???????\r\n	}\r\n	void remove_H() //???????? ????????? ????????\r\n	{\r\n		if (!len) return; //???? ?????? ????, ? ??????? ??????\r\n		if (len==1) //???? ? ?????? 1 ???????\r\n		{\r\n			struct item *p;\r\n			p = head;\r\n			head = 0;\r\n			tail = 0;\r\n			len--; //?????????? ?????\r\n			std::cout << \"\\n?????? ?????? \" << p->data;\r\n			delete p; //???????????? ??????\r\n		}\r\n		else //???? ? ?????? ?????? ?????? ????????\r\n		{\r\n			struct item *p;\r\n			p = head;\r\n			head = head->next;\r\n			head->prev=0;\r\n			len--; //?????????? ?????\r\n			std::cout << \"\\n?????? ?????? \" << p->data;\r\n			delete p; //???????????? ??????\r\n		}\r\n	}\r\n	void remove_T() //???????? ?????????? ????????\r\n	{\r\n		if (!len) return; //???? ?????? ????, ? ??????? ??????\r\n		if (len==1) //???? ? ?????? 1 ???????\r\n		{\r\n			struct item *p;\r\n			p = tail;\r\n			head = 0;\r\n			tail = 0;\r\n			len--; //?????????? ?????\r\n			std::cout << \"\\n?????? ????? \" << p->data;\r\n			delete p; //???????????? ??????\r\n		}\r\n		else //???? ? ?????? ?????? ?????? ????????\r\n		{\r\n			struct item *p;\r\n			p = tail;\r\n			tail = tail->prev;\r\n			tail->next=0;\r\n			len--; //?????????? ?????\r\n			std::cout << \"\\n?????? ????? \" << p->data;\r\n			delete p; //???????????? ??????\r\n		}\r\n	}\r\n	void go() //?????? ??????\r\n	{\r\n		struct item *p;\r\n		std::cout << \"\\n ????? \" << len << \"; ??????: \";\r\n		for (p=head;p;p=p->next)\r\n			std::cout << p->data << \"; \";\r\n	}\r\n};\r\n\r\nint main() //???????? ?????????\r\n{\r\n	setlocale(LC_ALL, \"Russian\");\r\n	int *q;\r\n	List<int> li; //???????? ?????? ? ????? ?????? int\r\n	List<s> ls;\r\n	for (int i = 1; i <= 2; i++)\r\n	{\r\n		li.paste_T(i); //??????? ? ????? i\r\n		li.paste_H(i); //??????? ? ?????? i\r\n	}\r\n	li.go(); //??????\r\n	for (List<int>::Iterator i = li.begin(); i != li.end(); ++i)\r\n	{\r\n		(*i) ++;\r\n		q = i.operator->();\r\n		(*q) --;\r\n		std::cout << \" \" << *q;\r\n	}\r\n\r\n	while (li.length() > 0)\r\n	{\r\n		li.remove_H(); //???????? ??????\r\n		li.remove_T(); //???????? ??????\r\n		li.go(); //??????\r\n	}\r\n\r\n	s w;\r\n	s* p;\r\n	w.a = 1;\r\n	w.b = 2;\r\n	ls.paste_H(w);\r\n	List<s>::Iterator i = ls.begin();\r\n//	p = i.operator->();\r\n	std::cout << \"\\n \" << i->a;\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n/*#include <iostream>\r\ntemplate <typename T> class list\r\n{\r\nprivate:\r\n        list(const list &orig) { }\r\n        list& operator=(const list &orig) { }\r\n        struct element\r\n        {\r\n                T data;\r\n                element *next;\r\n        };\r\n        element *head;\r\n        element *tail;\r\npublic:\r\n        list()                          //???????????\r\n        {\r\n                head=NULL;\r\n        }\r\n        ~list()                         //??????????\r\n        {\r\n                while (head!=NULL)\r\n                {\r\n                        hdelete();\r\n                }\r\n        }\r\n        void hinsert(T info)            //??????? ? ??????\r\n        {\r\n                element *p;\r\n                p=new element;\r\n                p->data=info;\r\n                p->next=head;\r\n                head=p;\r\n        }\r\n        void hdelete()          //???????? ??????\r\n        {\r\n                element *p;\r\n                p=head->next;\r\n                delete head;\r\n                head=p;\r\n        }\r\n        void tinsert (T info)   //?????? ? ?????\r\n        {\r\n                element *p,*q;\r\n                p=new element;\r\n                p->data=info;\r\n                p->next=NULL;\r\n                if (head==NULL)\r\n				{\r\n                        head=p;\r\n						return ;\r\n				}\r\n                if (head!=NULL)\r\n                {\r\n                        for (q=head;q->next;q=q->next);\r\n                        q->next=p;\r\n						return ;\r\n                }\r\n        }\r\n        void tdelete ()         //???????? ??????\r\n        {\r\n                element *p,*q,*r;\r\n                p=head;\r\n                for (q=head;q->next;q=q->next)\r\n                {\r\n                        p=q;\r\n                }\r\n                p->next=NULL;\r\n                delete q->next;\r\n        }\r\n\r\n\r\n        void print()            //?????\r\n        {\r\n                element *p;\r\n                p=head;\r\n                while (p!=NULL)\r\n                {\r\n                        std::cout<<(p->data)<<\" \";\r\n                        p=p->next;\r\n                }\r\n                std::cout << \"\\n\";\r\n        }\r\n};\r\nint main()\r\n{\r\n        int i;\r\n        list <int> spisok1;\r\n        spisok1.tinsert(123);\r\n\r\n        spisok1.print();\r\n        /*for (i = 0; i < 5; i++)\r\n        {\r\n                spisok1.tinsert(i);\r\n                spisok1.print();\r\n        }\r\n\r\n        for (i = 0; i < 5; i++)\r\n        {\r\n                spisok1.tdelete();\r\n                spisok1.print();\r\n        }\r\n\r\n}*/','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (462,'#include <iostream>\r\n\r\nclass Expression\r\n{\r\npublic:\r\n	virtual Expression* diff(char x) = 0;\r\n	virtual void print() = 0;\r\n};\r\n\r\nclass Number: public Expression\r\n{\r\nprivate:\r\n	int x;\r\npublic:\r\n	Number (int y)\r\n	{\r\n		x = y;\r\n	}\r\n	Expression* diff(char x)\r\n	{\r\n		return new Number(0);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<x;\r\n	}\r\n};\r\nclass Variable: public Expression\r\n{\r\nprivate:\r\n	char y;\r\npublic:\r\n	Variable(char a)\r\n	{\r\n		y = a;\r\n	}\r\n	Expression* diff(char x)\r\n	{\r\n		if (x == y)\r\n			return new Number(1);\r\n		return new Number(0);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<y;\r\n	}\r\n};\r\nclass Add: public Expression\r\n{\r\nprivate:\r\n	Expression *xx, *y;\r\npublic:\r\n	Add (Expression *a, Expression *b):xx(a), y(b) {};\r\n	Expression* diff(char x)\r\n	{\r\n		return new Add (xx->diff(x),y->diff(x));\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<\"(\";\r\n		xx->print();\r\n		std::cout<<\"+\";\r\n		y->print();\r\n		std::cout<<\")\";  \r\n	}\r\n};\r\nclass Sub: public Expression\r\n{\r\nprivate:\r\n	Expression *xx, *y;\r\npublic:\r\n	Sub (Expression *a, Expression *b):xx(a), y(b) {};\r\n	Expression* diff(char x)\r\n	{\r\n		return new Sub (xx->diff(x),y->diff(x));\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<\"(\";\r\n		xx->print();\r\n		std::cout<<\"-\";\r\n		y->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nclass Mul: public Expression\r\n{\r\nprivate:\r\n	Expression *xx, *y;\r\npublic:\r\n	Mul (Expression *a, Expression *b):xx(a), y(b) {};\r\n	Expression* diff(char x)\r\n	{\r\n		return new Add (new Mul(xx->diff(x),y),new Mul(xx,y->diff(x)));\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<\"(\";\r\n		xx->print();\r\n		std::cout<<\"*\";\r\n		y->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nclass Div: public Expression\r\n{\r\nprivate:\r\n	Expression *xx, *y;\r\npublic:\r\n	Div (Expression *a, Expression *b):xx(a), y(b) {};\r\n	Expression* diff(char x)\r\n	{\r\n		return new Div (new Sub(new Mul(xx->diff(x),y),new Mul(xx,y->diff(x))),new Mul(y,y));\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<\"(\";\r\n		xx->print();\r\n		std::cout<<\"/\";\r\n		y->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\n\r\nExpression* read(char*a)\r\n{\r\n	char*b,*c;\r\n	if (strlen(a) == 1)\r\n	{\r\n		if ((a[0]<=\'9\')&&(a[0]>=\'0\'))\r\n			return new Number(a[0]-\'0\');\r\n		else\r\n			return new Variable(a[0]);\r\n	}\r\n	b = new char[strlen(a)];\r\n	c = new char[strlen(a)];\r\n	int i,j=0,k;\r\n	for (i=1;(j>0)||(i==1);i++)\r\n	{\r\n		if (a[i]==\'(\')\r\n			j++;\r\n		if (a[i]==\')\')\r\n			j--;\r\n		b[i-1] = a[i];\r\n	}\r\n	b[i-1]=0;\r\n	k = i;\r\n	for (i=k+1;a[i+1];i++)\r\n	{\r\n		c[i-k-1] = a[i];\r\n	}\r\n	c[i-k-1]=0;\r\n	if (a[k] == \'+\')\r\n		return new Add (read(b),read(c));\r\n	if (a[k] == \'-\')\r\n		return new Sub (read(b),read(c));\r\n	if (a[k] == \'*\')\r\n		return new Mul (read(b),read(c));\r\n	if (a[k] == \'/\')\r\n		return new Div (read(b),read(c));\r\n}\r\n\r\nint main()\r\n{\r\n	Expression *e = new Div(new Number(1), new Variable(\'x\'));\r\n	std::cout << \"\\n\";\r\n	Expression *de = e->diff(\'x\');\r\n	de->print();\r\n	std::cout << \"\\n\";\r\n	delete e;\r\n	delete de;\r\n\r\n	Expression *t;\r\n	t = read(\"(((z*z)+(2*z))+1)\");\r\n	t->print();\r\n	std::cout << \"\\n\";\r\n	Expression *dt = t->diff(\'z\');\r\n	dt->print();\r\n	std::cout << \"\\n\";\r\n	delete t;\r\n	delete dt;\r\n	return 0;\r\n}','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (463,'#include <list>\r\n#include <iostream>\r\n#include <string>\r\n#include <fstream>\r\n\r\nusing namespace std;\r\n\r\nclass opnum\r\n{\r\npublic:\r\n	bool isOp;\r\n	int op;\r\n	float num;\r\n	opnum(bool isOp, int op, float num):isOp(isOp),op(op),num(num){}\r\n};\r\nlist<list<opnum> > sublists(list<opnum> l, int size, int pos, list<opnum> res);\r\nvoid moveOps(list<opnum> l, int offset, int opsCount);\r\nint getMaxOffset(list<opnum> l, int opsToMove);\r\nvoid moveEvery(int opsToMove);\r\nlist<list<opnum> > generateOpsPlaces(list<opnum> l);\r\nlist<opnum> addOps(list<opnum> x);\r\nlist<opnum> changeToOps(list<opnum> x);\r\nlist<opnum> toOplistBase1(int x, list<opnum> l);\r\nlist<opnum> toOplistBase(int x);\r\nlist<list<opnum> > generateOplists(int n);\r\nvoid printList(list<opnum> l);\r\nvoid printListsList(list<list<opnum> > l);\r\nlist<list<opnum> > insertops(list<opnum> l, int len);\r\nlist<opnum> insertops1(list<opnum> l, list<opnum> result, list<opnum> ops);\r\n\r\nlist<list<opnum> > sublists(list<opnum> l, int size, int pos, list<opnum> res)\r\n{\r\n	if(pos == size)\r\n	{\r\n		list<list<opnum> > lst;\r\n		lst.push_back(res);\r\n		lst.push_back(l);\r\n		return lst;\r\n	}\r\n	else\r\n	{\r\n		res.push_back(*(l.begin()));\r\n		l.pop_front();\r\n		return sublists(l, size, pos+1, res);\r\n	}\r\n}\r\n\r\nlist<list<opnum> > lists;\r\n\r\nvoid moveOps(list<opnum> l, int offset, int opsCount)\r\n{\r\n	int var1 = 0;\r\n	for(list<opnum>::iterator iter = l.begin(); l.end() != iter && !((*iter).isOp); ++ iter)\r\n	{\r\n		if(iter->isOp)\r\n		{\r\n			break;\r\n		}\r\n		++var1;\r\n	}\r\n	int size = var1 - offset;\r\n	list<list<opnum> > diff = sublists(l, size, 0, list<opnum>());\r\n	list<list<opnum> >::iterator it = diff.begin();\r\n	list<opnum> tmpHead(*it);\r\n	++it;\r\n	list<opnum> tmpRest(*it);\r\n	for(int i = 0; i < opsCount; ++i)\r\n	{\r\n		tmpHead.push_back(opnum(true, \'o\', 0));\r\n	}\r\n	int i = 0;\r\n	for(list<opnum>::iterator iter = tmpRest.begin(); (tmpRest.end() != iter && !(*iter).isOp); ++iter)\r\n	{\r\n		tmpHead.push_back(*iter);\r\n		++i;\r\n	}\r\n	for(int j = 0; j < i+opsCount; ++j)\r\n	{\r\n		tmpRest.pop_front();\r\n	}\r\n	for(list<opnum>::iterator iter = tmpRest.begin(); tmpRest.end() != iter; ++iter)\r\n	{\r\n		tmpHead.push_back(*iter);\r\n	}\r\n	lists.push_back(tmpHead);\r\n}\r\n\r\nint getMaxOffset(list<opnum> l, int opsToMove)\r\n{\r\n	int offset = 0;\r\n	for(list<opnum>::iterator iter = l.begin(); (l.end() != iter && !(*iter).isOp); ++iter)\r\n	{\r\n		++offset;\r\n	}\r\n	return offset-opsToMove-1;\r\n}\r\n\r\nvoid moveEvery(int opsToMove)\r\n{\r\n	if(0 >= opsToMove)\r\n	{\r\n		return;\r\n	}\r\n	list<list<opnum> > l(lists);\r\n	for(list<list<opnum> >::iterator iter = l.begin(); l.end() != iter; ++iter)\r\n	{\r\n		int maxOffset = getMaxOffset(*iter, opsToMove);\r\n		for(int j = 1; j <= maxOffset; ++j)\r\n		{\r\n			moveOps(*iter, j, opsToMove);\r\n		}\r\n	}\r\n	moveEvery(opsToMove-1);\r\n}\r\n\r\nlist<list<opnum> > generateOpsPlaces(list<opnum> l)\r\n{\r\n	int ops = l.size() - 1;\r\n	for(int i = 0; i < ops; ++i)\r\n	{\r\n		l.push_back(opnum(true, \'o\', 0));\r\n	}\r\n	lists.clear();\r\n	lists.push_back(l);\r\n	moveEvery(ops-1);\r\n	return lists;\r\n}\r\n\r\nchar oplist[] = { \'/\',\'*\',\'+\',\'-\' };\r\nint opsCount = 4;\r\nint mainLength = 0;\r\n\r\nlist<opnum> addOps(list<opnum> x)\r\n{\r\n	int len = x.size();\r\n	if(len != mainLength)\r\n	{\r\n		for(int i = 0; i < (mainLength - len); ++i)\r\n		{\r\n			x.push_front(opnum(true, oplist[0], 0));\r\n		}\r\n	}\r\n	return x;\r\n}\r\n\r\nlist<opnum> changeToOps(list<opnum> x)\r\n{\r\n	list<opnum> y;\r\n	for(list<opnum>::iterator iter = x.begin(); x.end() != iter; ++iter)\r\n	{\r\n		y.push_back(opnum(true, oplist[iter->op], 0));\r\n	}\r\n	return addOps(y);\r\n}\r\n\r\nlist<opnum> toOplistBase1(int x, list<opnum> l)\r\n{\r\n	if(1 > x / opsCount)\r\n	{\r\n		l.push_front(opnum(true, x % opsCount, 0));\r\n		return l;\r\n	}\r\n	l.push_front(opnum(true, x % opsCount, 0));\r\n	return toOplistBase1(((x - x % opsCount) / opsCount), l);\r\n}\r\n\r\nlist<opnum> toOplistBase(int x)\r\n{\r\n	return toOplistBase1(x, list<opnum>());\r\n}\r\n\r\nint pow(int x, int y)\r\n{\r\n	return (1 >= y) ? x : x*pow(x, y-1);\r\n}\r\n\r\nlist<list<opnum> > generateOplists(int n)\r\n{\r\n	mainLength = n;\r\n	int m = (pow(opsCount, n)-1);\r\n	list<opnum> op;\r\n	for(int i = 0; i <= m; ++i)\r\n	{\r\n		op.push_back(opnum(true, i, 0));\r\n	}\r\n	list<list<opnum> > tmp;\r\n	for(list<opnum>::iterator iter = op.begin(); op.end() != iter; ++iter)\r\n	{\r\n		tmp.push_back(toOplistBase(iter->op));\r\n	}\r\n	list<list<opnum> > tmp1;\r\n	for(list<list<opnum> >::iterator iter = tmp.begin(); tmp.end() != iter; ++iter)\r\n	{\r\n		tmp1.push_back(changeToOps(*iter));\r\n	}\r\n	return tmp1;\r\n}\r\n\r\nvoid printList(list<opnum> l)\r\n{\r\n	cout << \"( \";\r\n	for(list<opnum>::iterator iter = l.begin(); l.end() != iter; ++iter)\r\n	{\r\n		if((*iter).isOp)\r\n		{\r\n			cout << (char)((*iter).op) << \' \';\r\n		}\r\n		else\r\n		{\r\n			cout << (*iter).num << \' \';\r\n		}\r\n	}\r\n	cout << \')\';\r\n}\r\nvoid printList(list<list<opnum> > l)\r\n{\r\n	cout << \'(\' << endl;\r\n	for(list<list<opnum> >::iterator iter = l.begin(); l.end() != iter; ++iter)\r\n	{\r\n		printList(*iter);\r\n		cout << endl;\r\n	}\r\n	cout << endl << \')\';\r\n}\r\nlist<list<opnum> > insertops(list<opnum> l, int len)\r\n{\r\n	list<list<opnum> > oplists(generateOplists(len));\r\n	list<list<opnum> > result;\r\n	for(list<list<opnum> >::iterator iter = oplists.begin(); oplists.end() != iter; ++iter)\r\n	{\r\n		result.push_back(insertops1(l, list<opnum>(), *iter));\r\n	}\r\n	return result;\r\n}\r\n\r\nlist<opnum> insertops1(list<opnum> l, list<opnum> result, list<opnum> ops)\r\n{\r\n	if(l.empty())\r\n	{\r\n		return result;\r\n	}\r\n	opnum op = *(l.begin());\r\n	if(op.isOp)\r\n	{\r\n		l.pop_front();\r\n		op = *(ops.begin());\r\n		ops.pop_front();\r\n		result.push_back(op);\r\n		return insertops1(l, result, ops);\r\n	}\r\n	op = *(l.begin());\r\n	l.pop_front();\r\n	result.push_back(op);\r\n	return insertops1(l, result, ops);\r\n\r\n}\r\n\r\nclass Exception\r\n{\r\n	const std::string message;\r\npublic:\r\n	Exception(const std::string& message):message(message){}\r\n	const std::string& getMessage(){ return message; }\r\n\r\n};\r\n\r\nopnum funcall(opnum fn, opnum first, opnum second) throw (Exception)\r\n{\r\n	switch(fn.op)\r\n	{\r\n	case \'/\':\r\n		if(0 == second.num)\r\n		{\r\n			throw Exception(\"Division by zero\");\r\n		}\r\n		return opnum(false, 0, first.num / second.num);\r\n	case \'*\':\r\n		return opnum(false, 0, first.num * second.num);\r\n	case \'+\':\r\n		return opnum(false, 0, first.num + second.num);\r\n	case \'-\':\r\n		return opnum(false, 0, first.num - second.num);\r\n	default:\r\n		break;\r\n	}\r\n	return opnum(false, 0, 0);\r\n}\r\n\r\nopnum calc1(list<opnum> stack, list<opnum> l) throw (Exception)\r\n{\r\n	if(l.empty())\r\n	{\r\n		return *(stack.begin());\r\n	}\r\n	opnum op = *(l.begin());\r\n	l.pop_front();\r\n	if(!op.isOp)\r\n	{\r\n		stack.push_front(op);\r\n		return calc1(stack, l);\r\n	}\r\n	opnum second = *(stack.begin());\r\n	stack.pop_front();\r\n	opnum first = *(stack.begin());\r\n	stack.pop_front();\r\n	stack.push_front(funcall(op, first, second));\r\n	return calc1(stack, l);\r\n}\r\n\r\n\r\nopnum calc(list<opnum> l) throw (Exception)\r\n{\r\n	return calc1(list<opnum>(), l);\r\n}\r\n\r\nlist<list<opnum> > ticket(list<opnum> l, float num)\r\n{\r\n	list<list<opnum> > result;\r\n	list<list<opnum> > opsplaces(generateOpsPlaces(l));\r\n	int len = l.size() - 1;\r\n	for(list<list<opnum> >::iterator i = opsplaces.begin(); opsplaces.end() != i; ++i)\r\n	{\r\n		list<list<opnum> > tmp = insertops(*i, len);\r\n		for(list<list<opnum> >::iterator j = tmp.begin(); tmp.end() != j; ++j)\r\n		{\r\n			try\r\n			{\r\n				if(num == (calc(*j)).num)\r\n				{\r\n					result.push_back(*j);\r\n				}\r\n			}\r\n			catch(Exception& e)\r\n			{\r\n\r\n			}\r\n		}\r\n	}\r\n	return result;\r\n}\r\n\r\nint main(int argc, char** argv)\r\n{\r\n	ifstream file(\"input.txt\");\r\n	if(file.fail())\r\n	{\r\n		cerr << \"input.txt: open error\" << endl;\r\n		return -1;\r\n	}\r\n	list<opnum> l;\r\n	float num;\r\n	file >> num;\r\n	while(!file.eof())\r\n	{\r\n		float tmpNum;\r\n		file >> tmpNum;\r\n		l.push_back(opnum(false, 0, tmpNum));\r\n	}\r\n	l.pop_back();\r\n	file.close();\r\n	if(!l.empty())\r\n	{\r\n		printList(ticket(l, num));\r\n		cout << endl;\r\n	}\r\n	return 0;\r\n}\r\n','ÐšÐ¾Ð½ÑÑ‚Ð°Ð½Ñ‚Ð¸Ð½','Konstantin','m');
INSERT INTO `bias` VALUES (464,'#include <cstdio>\n#include <list>\n#include <iterator>\n#include <iostream>\n\nusing std::list;\n\nlist<list<int> > globalList;\n\nvoid counting(list<int> elem, list<int> lst)\n{\n	if(lst.size() == 0)\n	{\n		elem.sort();\n		globalList.push_back(elem);\n	}\n	else\n	{\n		int lst_result = 1;\n		int elem_result = 1;\n		for(list<int>::const_iterator iter = lst.begin(); iter != lst.end(); ++iter)\n		{\n			lst_result *= (*iter);\n		}\n		for(list<int>::const_iterator iter2 = elem.begin(); iter2 != lst.end(); ++iter2)\n		{\n		    elem_result *= (*iter2);\n		}\n		lst.push_back(elem_result);\n		lst.sort();\n		elem.push_back(lst_result);\n		elem.sort();\n		cout << \"Start push back\" << endl;\n		globalList.push_back(lst);\n		globalList.push_back(elem);\n		cout << \"End push back\" << endl;\n	}\n}\n\nbool checking(int y, int z)\n{\n	if(z == 1)\n	{\n		return true;\n	}\n	else if(y%z == 0)\n	{\n		return false;\n	}\n	else\n	{\n		checking(y, z-1);\n	}\n}\n\nlist<int> getPrimes(int number)\n{\n	list<int> primes;\n	if(number != 2)\n	{\n		for(int i = 2; i < number; i++)\n		{\n			if(checking(i, i-1))\n			{\n				primes.push_back(i);\n			}\n		}\n	}\n	else{\n	primes.push_back(2);}\n	return primes;\n}\n\nvoid remove(list<int> lst, int pos, list<int> new_lst, int iter,list<int> elem)\n{\n	if(lst.size() == 0)\n	{\n		counting(elem, new_lst);\n	}\n	else if(iter == pos)\n	{\n		elem.push_front(*(lst.begin()));\n		lst.pop_front();\n		remove(lst, pos, new_lst, iter+1, elem);\n	}\n	else\n	{\n		new_lst.push_front(*(lst.begin()));\n		lst.pop_front();\n		remove(lst, pos, new_lst, iter+1, elem);\n	}\n}\n\nvoid setAnswer(list<int> lst, int it, list<int> elem)\n{\n	if(lst.size() == 0)\n	{\n		return;\n	}\n	else if(lst.size() != it)\n	{\n		remove(lst, it, list<int>(), 0, elem);\n		setAnswer(lst, it+1, elem);\n	}\n	else\n	{\n		list<int>::const_iterator iter = lst.begin();\n		elem.push_front(*iter);\n		lst.pop_front();\n		setAnswer(lst, 0, elem);\n	}\n}\n\nvoid factors(int number, list<int> primes, list<int> lst)\n{\n	if(number == 1 || primes.empty())\n	{\n		setAnswer(lst, 0, list<int>());\n	}\n	else if(number%(*(primes.begin())) == 0)\n	{\n		lst.push_back(*(primes.begin()));\n		factors((number/(*(primes.begin()))), primes, lst);\n	}\n	else\n	{\n		primes.pop_front();\n		factors(number, primes, lst);\n	}\n}\n\nint main(int argc, char** argv)\n{\n	if(2 != argc)\n	{\n		cout << \"Please enter number\" << endl;\n		return 0;\n	}\n	int number = atoi(argv[1]);\n	factors(number, getPrimes(number), list<int>());\n	globalList.unique();\n	for(list<list<int> >::iterator iter2 = globalList.begin(); iter2 != globalList.end(); iter2++)\n	{\n		cout << \"( \";\n		for(list<int>::iterator iter = iter2->begin(); iter != iter2->end(); iter++)\n		{\n			cout << *iter << \' \';\n		}\n		cout << \')\' << endl;\n	   // cout << *iter2 << endl;\n	}\n	cout << \"( \" << number << \" )\" << endl;\n	\n	\n	return 0;\n}\n','Ð•ÐºÐ°Ñ‚ÐµÑ€Ð¸Ð½Ð°','Ekaterina','f');
INSERT INTO `bias` VALUES (465,'#include <stdio.h>\nint main()\n{\n	char cur,next;\n	int ed=1,er=1,inq=0,cont=0;\n	freopen(\"csv.txt\",\"r\",stdin);\n	freopen(\"public_html/output.html\",\"w\",stdout);\n	printf(\"<table border=1>\");\n	next=getchar();\n	while(next!=EOF)\n	{\n		cur=next;\n		next=getchar();\n		if (cont==1)\n		{\n			cont=0;\n			continue;\n		}\n		if (er==1)\n		{\n			printf(\"<tr>\");\n			er=0;\n		}\n		if (ed==1) \n		{\n			printf(\"<td>\");\n			ed=0;\n		}\n		if (inq==0 && cur==\'\"\')\n		{\n			inq=1;\n			continue;\n		}\n		if (inq==0)\n		{\n			if (cur!=\'\\n\' && cur!=\',\')\n			{\n				printf(\"%c\",cur);\n			}\n			if (cur==\'\\n\')\n			{\n				printf(\"</td></tr>\");\n				er=1;\n				ed=1;\n			}\n			if (cur==\',\')\n			{\n				printf(\"</td>\");\n				ed=1;\n			}\n		}\n		if (inq==1)\n		{\n			if (cur==\'\"\')\n			{\n				if (next==EOF || next==\'\\n\')\n				{\n					printf(\"</td></tr>\");\n					ed=1;\n					er=1;\n					inq=0;\n					cont=1;\n				}\n				if (next==\',\')\n				{\n					printf(\"</td>\");\n					ed=1;\n					inq=0;\n					cont=1;\n				}\n				if (next==\'\"\') \n				{\n					printf(\"\\\"\");\n					cont=1;\n				}\n			}\n			if (cur==\'\\n\') printf(\"<br/>\");\n			if (cur!=\'\\n\' && cur!=\'\"\')\n			{\n				printf(\"%c\",cur);\n			}\n		}		\n	}\n	printf(\"</table>\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (466,'#include <stdio.h>\n#include <stdlib.h>\nstruct item\n{\n	int data;\n	struct item *left, *right;\n};\n\nvoid infix(struct item *root)\n{\n	if (!root) return;\n	infix(root->left);\n	printf(\"%d \",root->data);\n	infix(root->right);\n}\n\nvoid insert(struct item **root, int a)\n{\n	struct item *q, *p;\n	if (!*root)\n	{\n		*root=malloc(sizeof(**root));\n		(*root)->data=a;\n		(*root)->left=NULL;\n		(*root)->right=NULL;\n		return;\n	}\n	q=*root;\n	while(q!=NULL)\n	{\n		if (a>q->data) \n		{\n			if (q->right==NULL) \n			{\n				q->right=malloc(sizeof(*p));\n				q->right->data=a;\n				q->right->left=NULL;\n				q->right->right=NULL;\n				break;\n			}\n			q=q->right;\n		}\n		else \n		{\n			if (q->left==NULL)\n			{\n				q->left=malloc(sizeof(*p));\n				q->left->data=a;\n				q->left->left=NULL;\n				q->left->right=NULL;\n				break;\n			}\n			q=q->left;\n		}\n	}\n}\n\nint main(int argc,char ** argv)\n{ \n	struct item *root=NULL;\n	int a;\n	freopen(argv[1],\"r\",stdin);\n	while(scanf(\"%d\",&a)==1)\n	{\n		insert(&root, a);\n	}\n	infix(root);\n	printf(\"\\n\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (467,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n\nvoid dfs(int cur,int* visited,int** graf)\n{\n	int i;\n	visited[cur]=1;\n	printf(\"%d \", cur);\n	for (i=0;i<N;i++)\n		if (graf[cur][i]==1 && !visited[i])\n			dfs(i,visited,graf);\n	\n}\n\nint main(int argc,char **argv)\n{\n	int **A,i,j,a,b,visited[N];\n\n	A = malloc(N * sizeof(int *));\n	for (i = 0; i < N; i++)\n	{\n		A[i] = malloc(N * sizeof(int));\n	}\n	\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++) A[i][j]=0;\n	for (i=0;i<N;i++) visited[i]=0;\n	freopen(argv[1],\"r\",stdin);\n	while(scanf(\"%d%d\",&a,&b)==2)\n	{\n		A[a][b]=1;\n		A[b][a]=1;\n	}\n	dfs(1,visited,A);\n//	for (i=0;i<N;i++)\n//		if (visited[i]==1) printf(\"%d \",i+1);\n\n\n	printf(\"\\n\");\n	for (i = 0; i < N; i++)\n	{\n		free(A[i]);\n	}\n	free(A[i]);\n	\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (468,'#include <stdio.h>\n#define N 100\nint ALL[N],w=0,r=0;\nvoid enqueue(int a)\n{\n	ALL[w++]=a;\n}\nint dequeue(void)\n{\n	return ALL[r++];	\n}\nint empty(void)\n{\n	return (r==w);\n}\nint main(int argc,char **argv)\n{\n	int A [N][N],i,j,a,b,visited[N],cur;\n	for (i=0;i<N;i++)\n		for (j=0;j<N;j++) A[i][j]=0;\n	for (i=0;i<N;i++) visited[i]=0;\n	freopen(argv[1],\"r\",stdin);\n	while(scanf(\"%d%d\",&a,&b)==2)\n	{\n		A[a-1][b-1]=1;\n		A[b-1][a-1]=1;\n	}\n	enqueue(1);\n	while(!empty())\n	{\n		cur=dequeue();\n		for (i=0;i<N;i++)\n			if (A[cur][i]==1 && !visited[i])\n			{\n				enqueue(i);\n				visited[i]=1;\n			}\n	}\n	for (i=0;i<N;i++) if (visited[i]==1) printf(\"%d \",i+1);\n	return 0;\n}\n\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (469,'#include <stdio.h>\n#define N 100\nint way[N];\n\nvoid copy(int* in,int *from)\n{\n	int i;\n	for (i=0;i<N;i++) in[i]=from[i];\n}\nint deikstr(int* wcur,int* graf,int* flag)\n{\n	int i,min=1000000,j,indmin=-1;\n	for (i=0;i<N;i++)\n		if (wcur[i]<min && flag[i]==0)\n		{\n			min=wcur[i];\n			indmin=i;\n		}\n	if (indmin==-1) return 0;\n	flag[indmin]=1;\n	for (i=0;i<N;i++)\n	{\n		if (graf[indmin*N+i]!=-1)\n		{\n			if (wcur[i]>wcur[indmin]+graf[indmin*N+i])\n			{\n				wcur[i]=wcur[indmin]+graf[indmin*N+i];\n				way[i] = indmin;\n			}\n		}\n	}\n	return 1;\n}\nint main(int argc,char **argv)\n{\n	int graf[N][N],i,j,a,b,weight,wcur[N],flag[N],max=0,mV;\n        for (i=0;i<N;i++)\n		for (j=0;j<N;j++) \n		{\n			graf[i][j]=-1;\n		}\n	for (i=0;i<N;i++)\n	{\n		wcur[i]=1000;\n		flag[i]=0;\n		way[i] = -1;\n	}\n	freopen(argv[1],\"r\",stdin);\n	scanf(\"%d\",&mV);\n	while(scanf(\"%d%d%d\",&a,&b,&weight)==3)\n	{\n		if (a>max) max=a;\n		if (b>max) max=b;\n		graf[a-1][b-1]=weight;\n		graf[b-1][a-1]=weight;\n	}\n	wcur[mV-1]=0;\n	while(deikstr(wcur,&graf[0][0],flag)==1)\n		;\n	for (i=0;i<max;i++)\n	{\n		int tmp[N];\n		int idx = 0;\n		int j = i;\n		printf(\"vertex %d:\",i+1);\n		if (wcur[i]==1000) \n		{\n			printf(\"	Not reachable\\n\");\n			continue;\n		}\n		printf(\"	short way:%d	\",wcur[i]);\n		while (way[j] != -1)\n		{\n			tmp[idx++] = j;\n			j = way[j];\n		}\n		tmp[idx++] = j;\n		for (j = idx - 1; j >= 0; j--)\n		{\n			printf(\"%d \", tmp[j] + 1);\n		}\n		printf(\"\\n\");\n	}\n	return 0;\n}\n\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (470,'#include<stdio.h>\n#include<ctype.h>\n#include<stdlib.h>\n#include<string.h>\nunsigned int kod(char *w)\n{\n	unsigned int K=0,i, t=\'a\'-\'A\';\n	for(i=0; w[i]; i++)\n	{\n		if(w[i]<\'a\')\n			w[i]+=t;\n		K+=(int)w[i]*(i+1); //??????? ??? ?????, ????????? ? ???????? ????? ????? ?????? ???\n	}\n	return K%100;\n}\nchar *read_word(FILE*f)//?????? ????? ?? ????? \n{\n	char *p=NULL,*tmp;\n	int allocated=0, used=0;\n	int c;\n	while((c=fgetc(f))!=EOF)\n	{\n		if(!isalpha(c))\n		{\n			if(p)\n				break;\n			continue;\n		}\n		if(allocated==used)\n		{\n			tmp=realloc(p,allocated+11);\n			if(!tmp)\n				break;\n			p=tmp;\n			allocated+=11;\n		}\n		p[used]=c;\n		used++;\n	}\n	if(p)\n		p[used]=0;\n	return p;\n}\nstruct Word{\n	char word[100];\n	int count;\n	struct Word *next;\n};\nvoid hash(char *w, struct Word **H)\n{\n	int K,fl=0;\n	struct Word *p;//?-????????? ?? ?????? ??????, ??????? ????? \"??????\" ?? ??????\n	K=kod(w);\n	p=H[K];\n	for(;p;p=p->next)\n	{\n		fl=0;\n		if(strcmp(p->word,w)==0)//????? ??? ???? ? ???????\n		{\n			fl=1;\n			break;\n		}\n	}\n	if(!fl)//????? ? ??????? ???\n	{\n		\n		p=malloc(sizeof(*p));\n		strcpy(p->word,w);\n		p->count =1;\n		p->next=H[K];\n		H[K]=p;\n	}\n	else\n	{\n		p->count++;\n	}\n	free(w);\n}\nint main()\n{\n	FILE *f;\n	char *w;\n	int i;\n	struct Word *H[100]={NULL},*p;\n	f=fopen(\"TEKST.txt\",\"r\");\n	if(!f)\n	{\n		perror(\"TEKST.txt \\n\");\n		return 0;\n	}\n        while((w=read_word(f))!=NULL)	\n	{\n		hash(w,&H[0]);\n	}\n	for(i=0;i<100;i++)\n	{\n		for(p=H[i];p;p=p->next)\n			printf (\"%s : %d \\n\",p->word,p->count);\n	}\n		\n	for(i=0;i<100;i++)\n	{\n		while (H[i])\n		{\n			p = H[i];\n			H[i] = H[i]->next;\n			free(p);\n		}\n	}\n	\n	return 0;\n}\n	\n	\n\n	\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (471,'#include<stdio.h>\nvoid dfs(int a[][100],int N,int v,int *vis)\n{\n	int i;\n	vis[v]=1;\n	printf(\"%d \",v);\n	for(i=1;i<=N;i++)\n		if(a[v][i]&&!vis[i])\n		{\n			dfs(a,N,i,vis);\n		}\n}\nint main()\n{\n	FILE *f=fopen(\"Input.txt\",\"r\");\n	int A[100][100]={0},k,i,j,M,N,v,visited[100]={0};\n	if(!f)\n	{\n		perror(\"Input.txt\");\n		return 0;\n	}\n	fscanf(f,\"%d %d\",&N,&M);\n	for(k=0;k<M;k++)\n	{\n		fscanf(f,\"%d %d\",&i,&j);\n		A[i][j]=1;\n		A[j][i]=1;\n	}\n	fscanf(f,\"%d\",&v);//??????? .1\n	dfs(A,N,v,visited);\n	printf(\"\\n\");\n	return 0;\n}\n\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (472,'#include <stdio.h>\n#include <string.h>\nvoid reverse(char *s,int l, int r)\n{\n	int i;\n	while (l<=r)\n	{\n		i=s[l];\n		s[l]=s[r];\n		s[r]=i;\n		l++;\n		r--;\n	}\n}\nint main ()\n{\n	int i = 0, j, m, b, z = 0, h, t;\n	char c[100]={0}, g[100];\n	float k = 0, l;\n	scanf(\"%f %d\",&l,&b);\n	h = (int)l;\n	k = l - (float)h;\n//	printf(\"celaya chast\' = %d, drobnaya chast\' %f\\n \",h,k);\n	for(i=0;h!=0;i++)\n	{\n		t = h % b;\n		h /= b;\n		printf(\"h = %d\",h);\n		if(t<10)\n		{\n			c[i] = t + \'0\';\n		}\n		if (t>=10)\n		{\n			c[i] = t + \'A\' - 10;\n			printf (\"perevod = %c\",c[i]);\n		}\n		printf(\"c[%d] = %c\\n\",i,c[i]);\n	}\n	printf (\"i = %d\\n\",i);\n	reverse(c,0,i);\n//	printf(\"h/b =  %d\",h/b);\n	for(j=1;j<=i;j++)\n		printf(\"c[%d] = %c\\n\",j,c[j]);\n	for(j=0;j<5;j++)\n	{\n		t = (int)(k*b);\n		k = k*b - (float)(int)(k*b);\n		printf(\"k = %f , t = %d \",k,t);\n		if(t<10)\n		{\n			g[j] = t + \'0\';\n		}\n		if (t>=10)\n		{\n			g[j] = t + \'A\' - 10;\n		}\n		printf(\"g[%d] = %c\\n\",j,g[j]);\n	}\n	if(h==0)\n		printf(\"0\");\n	for(m=1;m<=i;m++)\n		printf (\"%c\",c[m]);\n	printf (\".\");\n	for(m=0;m<j;m++)\n		printf (\"%c\",g[m]);\n	printf (\"\\n\");\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (473,'#include <stdio.h>\r\n#include <string.h>\r\n#define N 200\r\n#define START 0\r\n#define oCoQ 1\r\n#define iCoQ 2\r\n#define iCiQ 3\r\n#define iCiQpQ 4\r\n#define iC_WaitingForNext 5\r\n\r\nint main(int agrc, char** agrv)\r\n{\r\n	FILE* I;\r\n	FILE* O;\r\n	int state = START;\r\n	char s[N] = {0};\r\n	int c = \' \';\r\n	int flag = 0;\r\n	\r\n	if(agrc == 3)\r\n	{\r\n		I = fopen(agrv[1], \"r\");\r\n		O = fopen(agrv[2], \"w\");\r\n	}\r\n	else\r\n	{\r\n		printf(\"Invalid parameters\\n\");\r\n		return 0;\r\n	}\r\n\r\n	fputs(\"<html>\\n<body>\\n<table border=\\\"1\\\">\\n\", O);\r\n\r\n\r\n	while((fgets(s, N, I)) != NULL)\r\n	{\r\n		if (state != iCiQ)\r\n		{\r\n			fprintf(O, \"<tr>\\n\");\r\n			flag = 1;\r\n		}\r\n		for(int i = 0; i < strlen(s); i++)\r\n		{\r\n			if(((state == oCoQ) || (state == iC_WaitingForNext)) && s[i] == \' \')\r\n				continue;\r\n			switch(state)\r\n			{\r\n			case iCoQ:			//\r\n				switch(s[i])\r\n				{\r\n				case \',\':\r\n					fputs(\"</td>\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				case \'\\n\':\r\n					fputs(\"</td></tr>\\n\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				default:\r\n					fputc(s[i], O);\r\n				}\r\n				break;\r\n			case iCiQ:\r\n				switch(s[i])\r\n				{\r\n				case \'\\n\':\r\n					fputs(\"<br/>\\n\", O);\r\n					break;\r\n				case \'\"\':\r\n					state = iCiQpQ;\r\n					break;\r\n				default:\r\n					fputc(s[i], O);\r\n				}\r\n				break;\r\n			case iCiQpQ:\r\n				switch(s[i])\r\n				{\r\n				case \'\"\':\r\n					state = iCiQ;\r\n					fputc(s[i], O);\r\n					break;\r\n				default:\r\n					state = oCoQ;\r\n					break;\r\n				}\r\n			case oCoQ:\r\n				switch(s[i])\r\n				{\r\n				case \',\':\r\n					fputs(\"</td>\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				case \'\\n\':\r\n					fputs(\"</td></tr>\\n\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				case \'\"\':\r\n					state = iCiQ;\r\n//					fputs(\"<td>\", O);\r\n				}\r\n				break;\r\n			case iC_WaitingForNext:\r\n				switch(s[i])\r\n				{\r\n				case \'\"\':\r\n					state = iCiQ;\r\n					fputs(\"<td>\", O);\r\n					break;\r\n				case \',\':\r\n					fputs(\"<td>\", O);\r\n					break;\r\n				case \'\\n\': \r\n					fputs(\"<td></td></tr>\\n\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				default:\r\n					fputs(\"<td>\", O);\r\n					fputc(s[i], O);\r\n					state = iCoQ;\r\n				}\r\n				break;\r\n			case START:\r\n				switch(s[i])\r\n				{\r\n				case \'\"\':\r\n					state = iCiQ;\r\n					fputs(\"<td>\", O);\r\n					break;\r\n				case \'\\n\':\r\n					fputs(\"</td></tr>\\n\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				case \',\':\r\n					fputs(\"</td>\", O);\r\n					state = iC_WaitingForNext;\r\n					break;\r\n				default:\r\n					fputs(\"<td>\", O);\r\n					fputc(s[i], O);\r\n					state = iCoQ;\r\n				}\r\n			}\r\n		}\r\n	}\r\n	\r\n	if (flag)\r\n	{\r\n		fprintf(O, \"</tr>\\n\");\r\n	}\r\n	fputs(\"</table>\\n</body>\\n</html>\", O);\r\n\r\n	fclose(I);\r\n	fclose(O);\r\n	return 0;\r\n}\r\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (474,'#include <stdio.h>\n#include <ctype.h>\n\nint pow(int a, int p)\n{\n	int res = 1;\n	for(int i = 0; i < p; i++)\n	{\n		res *= a;\n	}\n	return res;\n}\n\n#define DOT -1\n#define INVALID -2\n#define W -3\n\nint convert(char a)\n{\n	if(a >= \'0\' && a <= \'9\')\n		return a - \'0\';\n	else if(a >= \'A\' && a <= \'Z\')\n		return a - \'A\' + 10;\n	else if(a >= \'a\' && a <= \'z\')\n		return a - \'a\' + 10;\n	else if(a == \'.\' || a == \',\')\n		return DOT;\n	else if(a == \' \' || a == \'\\n\')\n		return W;\n	else\n	{\n//		printf(\"[%c]\", a);\n		return INVALID;\n	}\n}\n\nint main(int argc, char** argv)\n{\n	int base = 0;\n	\n	float result = 0.0;\n\n	char c = 0;\n	int f = false;\n	int tmp = 0;\n	\n	FILE* I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE* O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n\n	fscanf(I, \"%d\", &base);\n\n	do \n	{\n		c = fgetc(I);\n	} while (isspace(c));\n	ungetc(c, I);\n\n	for(int i = 0; (c = fgetc(I)) != EOF && !isspace(c); i++)\n	{\n		tmp = convert(c);\n//		printf(\"---------------------------------[ %d ]\\n\", tmp);\n		if(tmp == DOT)\n		{\n			f = true;\n			i = 0;\n		}\n		else if(tmp == W)\n		{\n//			printf(\"#\");\n		}\n		else if(tmp == INVALID)\n		{\n			printf(\"Invalid symbol!\\n[%c]\\n\", c);\n			exit(0);\n		}\n		else if(tmp >= 0)\n		{\n			if(tmp < base)\n			{\n				if(!f)\n					result = result * (float)base + tmp;\n				else\n				{\n//					printf(\"[( %f )]\\n\", tmp / pow(base, i));\n//					getchar();\n					result = result + (float)tmp / pow(base, i);\n				}\n			}\n			else\n			{\n				printf(\"Invalid digit!\\n[%d](digit) >= [%d](base)\\n\", tmp, base);\n				return 0;\n			}\n		}\n	}\n	fprintf(O, \"%f\\n\", result);\n\n	fclose(O);\n	fclose(I);\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (475,'#include <iostream>\r\n\r\ntemplate <typename T> class List\r\n{\r\nprivate:\r\n	struct element\r\n	{\r\n		T data;\r\n		element *next;\r\n	};\r\n	element *head;\r\n	List& operator= (const List& s1);\r\n	List (const List& s1);\r\npublic:\r\n	List () // ??????????? ??????? ??????\r\n	{\r\n		head = NULL;\r\n	};\r\n\r\n	~List() //??????????\r\n	{\r\n		if (!empty())\r\n		{\r\n		element *p;\r\n		element *q;\r\n		p = head;\r\n		do\r\n		{\r\n			q = p->next;\r\n			delete p;\r\n			p=q;\r\n		} while (p != NULL); } else {}\r\n		std::cout <<\"Destructer\" <<\"\\n\";\r\n	}\r\n	\r\n	void push_front (T d) //??????? ? ??????\r\n	{\r\n		element *p = new element;\r\n		p->data = d;\r\n		p->next = head;\r\n		head = p;\r\n	};\r\n\r\n	void output()  //?????\r\n	{\r\n	if (!empty())\r\n	{ element *p;\r\n	p = head;\r\n	do \r\n	{\r\n		std::cout << p->data <<\"\\n\";\r\n		p = p->next;\r\n	} \r\n	while (p != NULL); } else {std::cout <<\"empty\\n\";}\r\n\r\n	};\r\n\r\n	void pop_last() //???????? ? ?????\r\n	{	\r\n	if (!once()) \r\n	{\r\n	if (!empty())\r\n		{\r\n			element *p;\r\n			element *q;\r\n			p = head;\r\n			q = head;\r\n			while (p->next)\r\n				{ \r\n					q = p;		\r\n					p = p->next;\r\n				}\r\n				delete p;\r\n				q->next = NULL;\r\n			} else {\r\n					std::cout <<\"List is already empty!\\n\";\r\n					}\r\n	} else \r\n			{\r\n			delete head;\r\n			head = NULL;\r\n			};\r\n	};\r\n\r\n	void pop_front() //???????? ???????\r\n	{\r\n		if (!empty())\r\n		{\r\n			element *q;\r\n			q = head;\r\n			head = q->next;\r\n			delete q;\r\n			} else {std::cout <<\"List is already empty!\\n\";}\r\n	};\r\n\r\n	void push_last(T d)  //??????? ? ????? \r\n	{\r\n		element *p;\r\n		element *s;\r\n		p = head;\r\n		s = head;\r\n		if (!empty())\r\n		{\r\n			while(p)\r\n			{	\r\n				s = p;	\r\n				p = p->next;\r\n			}\r\n		element *q = new element;\r\n		q->data = d;\r\n		q->next = NULL;\r\n		s->next = q;\r\n		} else { element *q1= new element; q1->data=d; q1->next=NULL; head=q1; }\r\n	}\r\n\r\n	bool empty()\r\n	{\r\n	return (head == NULL);\r\n	}\r\n\r\n	bool once()\r\n	{\r\n	if (!empty()) {return (head->next == NULL);} else {return false;}\r\n	};\r\n\r\n	class Iterator\r\n	{\r\n	friend class List<T>;\r\n	private:\r\n		element *t;\r\n	public:\r\n		Iterator(element *x)\r\n		{\r\n			t = x;\r\n		}\r\n		T& operator*() const\r\n		{\r\n			return t->data;\r\n		}\r\n		T* operator->()\r\n		{\r\n			return &t->data;\r\n		}\r\n		Iterator operator++()\r\n		{\r\n			t = t->next;	\r\n			return t;	\r\n		}\r\n		bool operator !=(const Iterator& x)\r\n		{\r\n			return x.t != t;\r\n		}\r\n	};\r\n	Iterator begin() const \r\n	{\r\n		return Iterator(head);\r\n	};\r\n	Iterator end() const\r\n	{	\r\n		return Iterator(NULL);\r\n	};\r\n\r\n};\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	List<double> s1;\r\n	//List<double> s2=s1; ?? ???? ????????? ?????? ???????????\r\n	//List<double> s3; s3=s1; ?????????? ? ?????????????\r\n	//s1.push_front(2);\r\n	//s1.push_front(3);\r\n	s1.push_front(5.7);\r\n	s1.push_last(10333.2);\r\n	s1.push_last(1.5345);\r\n	s1.push_front(4);\r\n	s1.pop_last();\r\n	s1.pop_front(); // ??? ??? ???????? ???????? ????????/??????? ? ??????/?????\r\n	//s1.output();\r\n	for (List<double>::Iterator i = s1.begin(); i != s1.end(); ++i) // ???????? ?????????\r\n	{\r\n		std::cout << *i <<\"\\n\";\r\n	}\r\n	struct s\r\n	{\r\n		int a,b;\r\n	};\r\n	s k,l;\r\n	k.a = 3;\r\n	k.b = 4;\r\n	l.a = 100500;\r\n	l.b = 9001;\r\n	List<s> s2;\r\n	s2.push_front(k);\r\n	s2.push_last(l);\r\n	s2.push_last(l);\r\n	s2.push_last(l);\r\n	s2.push_last(l);\r\n	s2.push_last(l);\r\n	for (List<s>::Iterator i = s2.begin(); i != s2.end(); ++i)\r\n	{\r\n		i->a = 55;\r\n		std::cout << i->a <<\" \" <<i->b <<\"\\n\";\r\n	}\r\n	return 0;\r\n}\r\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (476,'#include <iostream>\r\n#include <string>\r\n\r\nclass Expression\r\n{\r\npublic:\r\n	virtual Expression *diff() = 0;\r\n	virtual void print() = 0;\r\n	//Expression(double a):Number(a) {}\r\n	//Expression(char c):Variable(c) {}\r\n	virtual ~Expression() { }\r\n};\r\n\r\nclass Number: public Expression\r\n{\r\nprivate:\r\n	double s;\r\npublic:\r\n	Number(double a)\r\n	{\r\n		//char* c = new char[100];\r\n		//_//gcvt(a,10,c);\r\n		this->s = a;	\r\n	}\r\n	~Number()\r\n	{\r\n\r\n	}\r\n	Expression *diff()\r\n	{\r\n		//this->s = 0;\r\n		return new Number(0);\r\n	}\r\n	void print()\r\n	{\r\n		//std::cout <<\"(\";\r\n		std::cout <<this->s;\r\n		//std::cout <<\")\";\r\n	}\r\n		\r\n};\r\n\r\nclass Variable: public Expression\r\n{\r\nprivate:\r\n	char s;\r\npublic:\r\n	Variable(char c)\r\n	{\r\n		this->s = c;\r\n	}\r\n	Expression *diff()\r\n	{\r\n		//this->s = \'1\';\r\n		return new Number(1);\r\n	}\r\n	void print()\r\n	{\r\n		//std::cout <<\"(\";\r\n		std::cout <<this->s;\r\n		//std::cout <<\")\";\r\n	}\r\n\r\n};\r\n\r\nclass Sum :public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Sum(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n	Expression *diff()\r\n	{\r\n		//this->e1 = e1->diff();\r\n		//this->e2 = e2->diff();\r\n		return new Sum(e1->diff(), e2->diff());\r\n	}\r\n	void print()\r\n	{\r\n		//std::cout <<*this->e1 <<\"+\"<< *this->e2 <<\"\\n\";\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"+\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	\r\n	~Sum()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n\r\n\r\n};\r\n\r\nclass Sub :public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Sub(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n	Expression *diff()\r\n	{\r\n		//this->e1 = e1->diff();\r\n		//this->e2 = e2->diff();\r\n		return new Sub(e1->diff(), e2->diff());\r\n	}\r\n	void print()\r\n	{\r\n		//std::cout <<*this->e1 <<\"+\"<< *this->e2 <<\"\\n\";\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"-\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n\r\n	~Sub()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n\r\n};\r\n\r\nclass Mul:public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Mul(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n	Expression *diff()\r\n	{\r\n		//this->e1 = e1->diff();\r\n		//this->e2 = e2->diff();\r\n		return new Sum(new Mul(e1->diff(),e2),new Mul(e1,e2->diff()));\r\n	}\r\n	void print()\r\n	{\r\n		//std::cout <<*this->e1 <<\"+\"<< *this->e2 <<\"\\n\";\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"*\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n\r\n	~Mul()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n\r\n};\r\n\r\nclass Div:public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Div(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n	Expression *diff()\r\n	{\r\n		//this->e1 = e1->diff();\r\n		//this->e2 = e2->diff();\r\n		Expression *tmp = e2;\r\n		return new Div(new Sub(new Mul(e1->diff(),e2),new Mul(e1,e2->diff())),new Mul(e2,e2));\r\n	}\r\n	void print()\r\n	{\r\n		//std::cout <<*this->e1 <<\"+\"<< *this->e2 <<\"\\n\";\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\")\";\r\n		std::cout <<\"/\";\r\n		std::cout <<\"(\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n\r\n	~Div()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n	\r\n};\r\n\r\nbool main()\r\n{\r\n	Expression *s1 = new Div(new Number(1),new Mul(new Variable(\'x\'), new Variable(\'x\')));\r\n	//Expression *s1 = new Mul(new Sum(new Variable(\'x\'),new Number(1)),new Variable(\'x\'));\r\n	//Expression *s1 = new Number(1);\r\n	Expression *s2 = s1->diff();\r\n	s2->print();\r\n	//Number *s2 = s1->diff();\r\n	//s2->print();\r\n	delete s1;\r\n	delete s2;\r\n	std::cout <<\"\\n\";\r\n	return true;\r\n}','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (477,'#include<iostream>\r\ntemplate <typename T>\r\nclass List\r\n{\r\nprivate:\r\n	struct element\r\n	{\r\n		T data;\r\n		element *next;\r\n	};\r\n	element *head;\r\n\r\npublic:\r\n	void insert (T data)\r\n	{\r\n		element *p;\r\n		p = new element;\r\n		p->data = data;\r\n		p->next = head;\r\n		head = p;\r\n	}\r\n\r\n	void deletefirst ()\r\n	{\r\n		element *p;\r\n		if (head)\r\n		{\r\n			p = head->next;\r\n			delete(head);\r\n			head = p;\r\n		}\r\n	}\r\n\r\n	~List (void)\r\n	{\r\n		element* p;\r\n		while (head!=NULL)\r\n		{\r\n			deletefirst();\r\n		}\r\n	}\r\n\r\n	List (void)\r\n	{\r\n		head=NULL;\r\n	}\r\n\r\n	void print ()\r\n	{\r\n		element *p;\r\n		p=head;\r\n		while(p)\r\n		{\r\n			std::cout<<p->data<<\' \';\r\n			p=p->next;\r\n		}\r\n		std::cout<<\"\\n\";\r\n	}\r\n\r\n	void append (T data)\r\n	{\r\n		if (!head)\r\n		{\r\n			insert(data);\r\n			return;\r\n		}\r\n\r\n		element *p,*m;\r\n		p=head;\r\n		while(p->next)\r\n		{\r\n			p=p->next;\r\n		}\r\n		m = new element;\r\n		m->data = data;\r\n		m->next = NULL;\r\n		p->next = m;\r\n	}\r\n\r\n	void deletelast ()\r\n	{\r\n		element *p,*m;\r\n		p=head;\r\n		m=NULL;\r\n		if(head->next==NULL)	\r\n		{\r\n			head=NULL;\r\n		}\r\n		else\r\n		{\r\n			while(p->next)\r\n			{\r\n				m=p;\r\n				p=p->next;\r\n			}\r\n			delete(p);\r\n			m->next=NULL;\r\n		}\r\n	}\r\n};\r\n\r\nvoid main()\r\n{\r\n	List <int> a;\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		a.append(i);\r\n		a.insert(i);\r\n		a.print();\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		a.deletefirst();\r\n		a.deletelast();\r\n		a.print();\r\n	}\r\n\r\n}\r\n','ÐžÐ»ÑŒÐ³Ð°','Olga','f');
INSERT INTO `bias` VALUES (478,'#include <conio.h>\r\n#include <stdio.h>\r\n#include <iostream>\r\n\r\n	template <typename T> class List\r\n	{\r\n		private:\r\n			struct element\r\n			{\r\n				T data;\r\n				element *next;\r\n			};\r\n			List & operator=(List & other){}\r\n			List (const List & orig){}\r\n\r\n			element *head;\r\n		public :\r\n			List() { head = NULL; }\r\n			~List()\r\n			{\r\n				while (head)\r\n				{\r\n					delfirst();\r\n				}\r\n			}\r\n\r\n			void print ()\r\n			{\r\n				element *r;\r\n				r = head;\r\n				while (r)\r\n				{\r\n					std::cout << r->data << \" \";\r\n					r = r->next;\r\n				}\r\n				std::cout << \"\\n\";\r\n			}\r\n			void addfirst ( T znach)\r\n			{\r\n				element *d;\r\n				d = new element;\r\n				d->data = znach;\r\n				d->next = head;\r\n				head = d;\r\n			}\r\n			void addlast ( T znach)\r\n			{\r\n				if (!head)\r\n				{\r\n					addfirst(znach);\r\n					return;\r\n				}\r\n\r\n				element *d,*r;\r\n				d = new element;\r\n				d->data = znach;\r\n				r = head;\r\n				while (r->next)\r\n					r = r->next;\r\n				r->next = d;\r\n				d->next = NULL;\r\n				//head = d;\r\n			}\r\n			void delfirst()\r\n			{\r\n				element *d;\r\n\r\n				d = head->next;\r\n				delete head;\r\n				head = d;\r\n			}\r\n\r\n			void dellast()\r\n			{\r\n				element *r,*d;\r\n				r = head;\r\n\r\n				if (!head->next)\r\n				{\r\n					delfirst();\r\n					return;\r\n				}\r\n\r\n				while (r->next->next)\r\n					r = r->next;\r\n				d = r;\r\n				r = r->next;\r\n				delete r;\r\n				d->next = NULL;\r\n			}\r\n	\r\n	};\r\n	int main ()\r\n	{\r\n		List<int> l;\r\n		\r\n		for (int i = 0; i < 5; i++)\r\n		{\r\n			l.addlast(i);\r\n			l.addfirst(i);\r\n\r\n			l.print();\r\n		}\r\n\r\n		for (int i = 0; i < 5; i++)\r\n		{\r\n			l.delfirst();\r\n			l.dellast();\r\n\r\n			l.print();\r\n		}\r\n\r\n		return 0;\r\n	}','ÐÐ½Ñ‚Ð¾Ð½Ð¸Ð½Ð°','Antonina','f');
INSERT INTO `bias` VALUES (479,'#include <iostream>\r\n#include <string>\r\n#include <math.h>\r\n#include <ctype.h>\r\nclass Expression\r\n{\r\npublic:\r\n\r\n	virtual void print() = 0;\r\n	virtual Expression * diff() = 0;\r\n	virtual ~Expression() { }\r\n};\r\nclass Number : public Expression\r\n{\r\nprivate:\r\n	int x;\r\npublic: \r\n	Number()\r\n	{\r\n		x = 1;\r\n	}\r\n	Number(int znah)\r\n	{\r\n		x = znah;\r\n	}\r\n	~Number() { } \r\n	void print()\r\n		{\r\n			printf (\"%i\",x);\r\n		}\r\n	Expression * diff()\r\n	{\r\n		//Number d(0);\r\n		//return &d;//?????? ??? ???????\r\n\r\n\r\n		return new Number( 0 );\r\n	}\r\n};\r\nclass Variable : public Expression\r\n{\r\nprivate:\r\n	char var;\r\n	Variable();\r\npublic: \r\n	\r\n	Variable(char name)\r\n	{\r\n		var = name;\r\n	}\r\n	void print()\r\n		{\r\n			printf (\"%c\",var);\r\n		}\r\n	~Variable() { } \r\n	Expression * diff()\r\n	{\r\n		return new Number( 1 );\r\n	}\r\n\r\n};\r\nclass Add : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Add();\r\npublic:\r\n	Add(Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n	~Add()\r\n	{\r\n		delete f;\r\n		delete s;\r\n	}\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"+\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n\r\n	Expression * diff()\r\n	{\r\n		return new Add(f->diff(),s->diff());\r\n	}\r\n};\r\nclass Sub : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Sub ();\r\npublic:\r\n	Sub(Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n\r\n	\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"-\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n	~Sub ()\r\n	{\r\n		delete f;\r\n		delete s;\r\n	}\r\n\r\n	Expression * diff()\r\n	{\r\n		return new Sub(f->diff(),s->diff());\r\n	}\r\n};\r\nclass Mul : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Mul ();\r\npublic:\r\n	Mul(Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n\r\n	\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"*\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n	Expression * diff()\r\n	{\r\n		Expression *a = new Mul(f->diff(),s);\r\n		Expression *b = new Mul(s->diff(),f);\r\n		return new Add(a, b);\r\n	}\r\n	~Mul ()\r\n	{\r\n		delete f;\r\n		delete s;\r\n		//delete a;\r\n		//delete b;\r\n	}\r\n	\r\n};\r\nclass Div : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Div ();\r\npublic:\r\n	Div (Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n	\r\n	\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"/\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n\r\n	Expression * diff()\r\n	{\r\n		Expression * a, *b, *c, *d;\r\n		a = new Mul(f->diff(),s);\r\n		b = new Mul(s->diff(),f);\r\n		c = new Sub(a, b);\r\n		d = new Mul(s,s);\r\n		return new Div (c,d);\r\n	}\r\n	~Div ()\r\n	{\r\n		delete f;\r\n		delete s;\r\n	}\r\n};\r\n\r\nclass Cos : public Expression\r\n{\r\nprivate:\r\n	Expression *var;\r\n\r\npublic: \r\n	\r\n	Cos(Expression *znah)\r\n	{\r\n		var = znah;\r\n	}\r\n	~Cos() \r\n	{\r\n		delete var;\r\n	} \r\n	void print()\r\n		{\r\n			printf (\"cos\");\r\n			printf(\"(\");\r\n			var->print();\r\n			printf(\")\");\r\n		}\r\n	Expression *diff();\r\n};\r\nclass Sin : public Expression\r\n{\r\nprivate:\r\n	Expression *var;\r\n\r\npublic: \r\n	\r\n	Sin(Expression *znah)\r\n	{\r\n		var = znah;\r\n	}\r\n	~Sin() \r\n	{\r\n		delete var;\r\n	} \r\n	void print()\r\n		{\r\n			printf (\"sin\");\r\n			printf(\"(\");\r\n			var->print();\r\n			printf(\")\");\r\n		}\r\n	Expression * diff()\r\n	{\r\n		return new Cos(var);\r\n	}\r\n};\r\n\r\nExpression *Cos::diff()\r\n{\r\n	return new Mul(new Number(-1), new Sin(var));\r\n}\r\n\r\nint main ()\r\n{\r\n	//Number n(2);\r\n	//n.print();\r\n	//n.diff();\r\n	//n.print();\r\n	//Variable m;\r\n	//Variable p(\'k\');\r\n	//Variable(\'k\').print();\r\n	//m.print();\r\n	//Expression *e = new Number();\r\n\r\n	Expression *e = new Div(new Number(1), new Variable(\'x\'));\r\n	std::cout << \"\\n\";\r\n	Expression *de = e->diff();\r\n	de->print();\r\n	std::cout << \"\\n\";\r\n	Expression *zz = new Sin(e);\r\n	delete e;\r\n	//delete de;\r\n\r\n	return 0;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*Expression *readExpression()\r\n{\r\n  char c;\r\n  std::cin >> c;\r\n\r\n  if (isdigit(c))\r\n  {\r\n  std::cin.unget();\r\n  int a;\r\n  std::cin >> a;\r\n  return new Number(a);\r\n  }\r\n\r\n  if (c == \'x\'\r\n  {\r\n  return new Variable();\r\n  }\r\n\r\n  Expression *e1 = readExpression();\r\n\r\n  char oper;\r\n  std::cin >> oper;\r\n\r\n  Expression *e2 = readExpression();\r\n\r\n  std::cin >> c; // ??????? ??????????? ??????\r\n\r\n  if (oper == \'+\'\r\n  return new Add(e1, e2);\r\n  if (oper == \'-\'\r\n  return new Sub(e1, e2);\r\n  ...\r\n\r\n}*/','ÐÐ½Ñ‚Ð¾Ð½Ð¸Ð½Ð°','Antonina','f');
INSERT INTO `bias` VALUES (480,'#include <iostream>\r\nclass Expression \r\n{					\r\npublic:								\r\n	virtual Expression* diff()=0;	\r\n	virtual void print()=0;		\r\n};\r\nclass Number:public Expression \r\n{	\r\nprivate:				\r\n	int chislo;						\r\npublic: \r\n	Number(int a):chislo(a)\r\n	{\r\n	}\r\n	Expression *diff() \r\n	{	\r\n		return new Number(0);\r\n	}\r\n	void print() \r\n	{\r\n		std::cout<<chislo;\r\n	}\r\n};\r\nclass Variable:public Expression\r\n{\r\nprivate:\r\n	char nepeMeHHa9I;\r\npublic :\r\n	Variable(char a):nepeMeHHa9I(a)\r\n	{\r\n	}\r\n	Expression *diff()\r\n	{\r\n		if (nepeMeHHa9I==\'x\')return new Number(1); \r\n		else return new Number(0);\r\n	}\r\n	void print() \r\n	{\r\n		std::cout<<nepeMeHHa9I;\r\n	}\r\n};\r\nclass Add:public Expression\r\n{\r\nprivate: \r\n	Expression *BbIpazheHue1,*BbIpazheHue2;\r\npublic: \r\n	Add(Expression *a1,Expression *a2):BbIpazheHue1(a1),BbIpazheHue2(a2)\r\n	{\r\n	}\r\n	Expression *diff() \r\n	{\r\n		return new Add(BbIpazheHue1->diff(),BbIpazheHue2->diff());\r\n	}\r\n	void print()\r\n	{	std::cout<<\"(\";\r\n		BbIpazheHue1->print();\r\n		std::cout<<\"+\";\r\n		BbIpazheHue2->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nclass Sub:public Expression\r\n{\r\nprivate: \r\n	Expression *BbIpazheHue1,*BbIpazheHue2;\r\npublic: \r\n	Sub(Expression *a1,Expression *a2):BbIpazheHue1(a1),BbIpazheHue2(a2)\r\n	{\r\n	}\r\n	Expression *diff() \r\n	{\r\n		return new Sub(BbIpazheHue1->diff(),BbIpazheHue2->diff());\r\n	}\r\n	void print() \r\n	{	std::cout<<\"(\";\r\n		BbIpazheHue1->print();\r\n		std::cout<<\"-\";\r\n		BbIpazheHue2->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nclass Mul:public Expression\r\n{\r\nprivate: \r\n	Expression *BbIpazheHue1,*BbIpazheHue2;\r\npublic: \r\n	Mul(Expression *a1,Expression *a2):BbIpazheHue1(a1),BbIpazheHue2(a2)\r\n	{\r\n	}\r\n	Expression *diff() \r\n	{\r\n		return new Add(new Mul(BbIpazheHue1->diff(),BbIpazheHue2),new Mul(BbIpazheHue2,BbIpazheHue1->diff()));\r\n	}\r\n	void print() \r\n	{	std::cout<<\"(\";\r\n		BbIpazheHue1->print();\r\n		std::cout<<\"*\";\r\n		BbIpazheHue2->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nclass Div:public Expression\r\n{\r\nprivate: \r\n	Expression *BbIpazheHue1,*BbIpazheHue2;\r\npublic: \r\n	Div(Expression *a1,Expression *a2):BbIpazheHue1(a1),BbIpazheHue2(a2)\r\n	{\r\n	}\r\n	Expression *diff() \r\n	{\r\n		return new Div(new Sub(new Mul(BbIpazheHue1->diff(),BbIpazheHue2),new Mul(BbIpazheHue1,BbIpazheHue2->diff())),new Mul(BbIpazheHue2, BbIpazheHue2));	\r\n	}\r\n	void print() \r\n	{\r\n		std::cout<<\"(\";\r\n		BbIpazheHue1->print();\r\n		std::cout<<\"/\";\r\n		BbIpazheHue2->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nvoid main()\r\n{\r\n	Expression *zz = new Mul(new Add(new Number(1), new Number(2)), new Add(new Number(3), new Number(4)));\r\n	zz->print();\r\n	std::cout << \"\\n\";\r\n\r\n	return;\r\n\r\n	Expression *e=new Add(new Number(1),new Variable(\'x\'));\r\n	e->print();\r\n	std::cout<<\"\\n\";\r\n	Expression *de=e->diff();\r\n	de->print();\r\n	std::cout<<\"\\n\";\r\n	delete e;\r\n	delete de;\r\n	Expression *ee=new Sub(new Number(1),new Variable(\'x\'));\r\n	ee->print();\r\n	std::cout<<\"\\n\";\r\n	Expression *dede=ee->diff();\r\n	dede->print();\r\n	std::cout<<\"\\n\";\r\n	delete ee;\r\n	delete dede;              \r\n	Expression *eee=new Mul(new Number(1),new Variable(\'x\'));\r\n	eee->print();\r\n	std::cout<<\"\\n\";\r\n	Expression *dedede=eee->diff();\r\n	dedede->print();\r\n	std::cout<<\"\\n\";\r\n	delete eee;\r\n	delete dedede;\r\n	Expression *eeee=new Div(new Number(1),new Variable(\'x\'));\r\n	eeee->print();\r\n	std::cout<<\"\\n\";\r\n	Expression *dededede=eeee->diff();\r\n	dededede->print();\r\n	std::cout<<\"\\n\";\r\n	delete eeee;\r\n	delete dededede;\r\n}','ÐžÐ»ÑŒÐ³Ð°','Olga','f');
INSERT INTO `bias` VALUES (481,'#include <iostream>\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#include <string.h>\r\n\r\ntemplate <typename T> \r\nclass List\r\n{private:\r\n	struct element\r\n	{T data;\r\n	element *next;\r\n	};\r\n	element *head;\r\n	\r\n	\r\n	\r\n\r\npublic:\r\n\r\n	void NewFirst(T NewData)//?????????? ??????? ???????? ? ??????\r\n	{	struct element *p;\r\n	    p = new element;\r\n		p->data=NewData;\r\n		p->next=head;\r\n		head=p;\r\n		\r\n	}\r\n	List(const List &a)\r\n	{std::cout<<\"ERROR! Don\'t use = and copy\"<<\'\\n\';\r\n	}\r\n	List &operator=(const List &a)\r\n	{std::cout<<\"ERROR! Don\'t use = and copy\"<<\'\\n\';\r\n	return *this;\r\n	}\r\n	void DeleteFirst (void)//???????? ??????? ?? ??????\r\n	{if (head != NULL)\r\n	\r\n	{struct element *p;\r\n     p = head->next;\r\n     delete head;\r\n     head = p;\r\n	};\r\n	}\r\n	~List ()\r\n	{if (head != NULL)\r\n	{struct element *p;\r\n	struct element *q;\r\n	p = head;\r\n	while (p != NULL)\r\n	{\r\n		q = p->next;\r\n		delete p;\r\n		p=q;};\r\n	}\r\n	}\r\n	List ()\r\n	{head = NULL;\r\n	}\r\n	\r\n	void Vivod(void)\r\n	{\r\n		struct element *p;\r\n		p = head;\r\n		while (p != NULL)\r\n		{\r\n			std::cout<<p->data<<\" \";\r\n			p = p->next;\r\n		}\r\n		std::cout <<\"\\n\";\r\n	}\r\n\r\n	void NewLast(T NewData)\r\n	{\r\n	element *p;\r\n	if (!head)\r\n	{\r\n	    p = new element;\r\n	    p->next = NULL;\r\n	    p->data = NewData;\r\n	    head = p;\r\n	    return;\r\n	}\r\n	p = head;\r\n	while (p->next != NULL)\r\n	{\r\n	    p = p->next;\r\n	}\r\n        element *q = new element;\r\n        q->data=NewData;\r\n        q->next=NULL;\r\n        p->next = q;\r\n	}\r\n\r\n	void DeleteLast(void)\r\n	{if (head != NULL)\r\n	{\r\n\r\n		if (head->next == NULL)\r\n		{\r\n			DeleteFirst();\r\n			return;\r\n		}\r\n\r\n		struct element *p;\r\n		struct element *q;\r\n		p = head;\r\n		while (p->next != NULL)\r\n		{\r\n			q = p;\r\n			p = p->next;\r\n		}\r\n		delete p;\r\n		q->next = NULL;\r\n\r\n	\r\n	};};\r\n\r\n	\r\n//-----------------------------------------\r\n class Iterator\r\n {\r\n private:\r\n	 element *IterElement;\r\n public:\r\n	 Iterator(element *anyelement)\r\n	 {\r\n		 IterElement = anyelement;\r\n	 }\r\n	 bool operator!=(const Iterator &iter)\r\n	 {\r\n		 return IterElement != iter.IterElement;\r\n	 }\r\n	 bool operator==(const Iterator &iter)\r\n	 {\r\n		 return IterElement == iter.IterElement;\r\n	 }\r\n	 T &operator*()\r\n	 {\r\n		 return IterElement->data;\r\n	 }\r\n	 T *operator->()\r\n	 {\r\n		 return &(IterElement->data);\r\n	 }\r\n	 Iterator &operator++()\r\n	 {\r\n		 IterElement = IterElement->next;\r\n		 return *this;\r\n	 }\r\n\r\n	 };\r\n Iterator begin() const\r\n	{\r\n		return Iterator(head);\r\n	}\r\n\r\n	\r\n	Iterator end()const\r\n	{\r\n		return Iterator(NULL);\r\n	}\r\n\r\n};\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n	List<float> L;\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		L.NewLast(i);\r\n		L.NewFirst(i);\r\n		L.Vivod();\r\n	}\r\n\r\n	for (List<float>::Iterator i = L.begin(); i != L.end(); ++i)\r\n	{\r\n		std::cout << *i << \" \" << \"\\n\";\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		L.DeleteFirst();\r\n		L.DeleteLast();\r\n		L.Vivod();\r\n	}\r\n\r\n	return 0;\r\n}','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (482,'\r\n#include <iostream>\r\n#include <ctype.h>\r\nusing namespace std;\r\n\r\nclass Expression\r\n{\r\n  public:\r\n         virtual Expression* diff(char p)=0;\r\n         virtual void print()=0;\r\n		 virtual ~Expression() { }\r\n};\r\n\r\nclass Number:public Expression\r\n{\r\n      private:\r\n              float value;\r\n      public: \r\n              Number (float v)\r\n              {value=v;}\r\n              \r\n              Expression* diff(char p)\r\n              {return new Number(0);}  \r\n              \r\n              void print()\r\n              {cout<<value;}  \r\n                 \r\n};\r\n\r\nclass Variable:public Expression\r\n{\r\n      private:\r\n              char name;\r\n      public: \r\n              Variable (char x)\r\n              {name=x;}\r\n              \r\n              Expression* diff(char p)\r\n              {\r\n              if (name==p)\r\n              return new Number(1);\r\n              return new Number(0);}  \r\n              \r\n              void print()\r\n              {cout<<name;}  \r\n              \r\n};\r\n\r\n\r\nclass Add:public Expression\r\n{\r\n      private:\r\n              Expression* a1;\r\n              Expression* a2;\r\n      public: \r\n              Add(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n              Expression* diff(char p)\r\n              {return new Add(a1->diff(p),a2->diff(p));}  \r\n              \r\n              void print()\r\n              {\r\n				cout<<\'(\';\r\n				a1->print();\r\n				cout<<\'+\';\r\n				a2->print();\r\n				cout<<\')\';\r\n			  }  \r\n			  ~Add()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			       \r\n};\r\n\r\nclass Sub:public Expression\r\n{\r\n      private:\r\n              Expression* a1;\r\n              Expression* a2;\r\n      public: \r\n              Sub(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n              Expression* diff(char p)\r\n              {return new Sub(a1->diff(p),a2->diff(p));}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'-\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  \r\n\r\n			~Sub()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			         \r\n};\r\n\r\n\r\nclass Mul:public Expression\r\n{\r\n	private:\r\n			Expression* a1;\r\n			Expression* a2;\r\n	public:\r\n			Mul(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n            Expression* diff(char p)\r\n            {\r\n				return new Add(new Mul(a1->diff(p), a2),new Mul(a1, a2->diff(p)));\r\n			\r\n			}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'*\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  \r\n			~Mul()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			   \r\n};\r\n\r\n\r\nclass Div:public Expression\r\n{\r\n	private:\r\n			Expression* a1;\r\n			Expression* a2;\r\n	public:\r\n			Div(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n            Expression* diff(char p)\r\n			{return new Div(new Sub(new Mul(a1->diff(p),a2),new Mul(a1,a2->diff(p))),new Mul(a2,a2));}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'/\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  \r\n\r\n			~Div()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			  \r\n};\r\n\r\n\r\nclass Cos:public Expression\r\n{\r\n	private:\r\n			Expression* a;\r\n	public:\r\n			Cos(Expression* x)\r\n              {a=x;}\r\n              \r\n            Expression* diff(char p);\r\n              \r\n              void print()\r\n              {\r\n				  cout<<\"Cos\";\r\n				  cout<<\'(\';\r\n				  a->print();\r\n				  cout<<\')\';\r\n			  }  \r\n			  \r\n};\r\n\r\n\r\nclass Sin:public Expression\r\n{\r\n	private:\r\n			Expression* a;\r\n	public:\r\n			Sin(Expression* x)\r\n              {a=x;}\r\n              \r\n            Expression* diff(char p)\r\n			{return new Mul(new Cos(a),a->diff(p));}  \r\n              \r\n              void print()\r\n              {\r\n				  cout<<\"Sin\";\r\n				  cout<<\'(\';\r\n				  a->print();\r\n				  cout<<\')\';\r\n			  }  \r\n			  \r\n};\r\n\r\n\r\nExpression* read()\r\n{\r\n			char c;\r\n\r\n			\r\n			cin>>c;\r\n			if (isdigit(c)) \r\n			{\r\n				cin.unget();\r\n				int a;\r\n				cin>>a;\r\n				return new Number(a);\r\n		\r\n			/*  int a;\r\n			  a=c;\r\n			  return new Number(a);\r\n			  */\r\n	\r\n            }\r\n			if ((c!=\'(\')&&(c!=\')\')&&(c!=\'+\')&&(c!=\'-\')&&(c!=\'/\')&&(c!=\'*\')&&(c!=\'S\')&&(c!=\'C\'))\r\n			{\r\n				return new Variable(c);\r\n			}\r\n			if (c==\'(\')\r\n			{\r\n				char ch;\r\n				\r\n				Expression* a;\r\n				Expression* b;\r\n				a=read();\r\n				cin>>c;\r\n				b=read();\r\n				cin>>ch;\r\n				if (c==\'+\')\r\n					return new Add(a,b);\r\n				if (c==\'-\')\r\n					return new Sub(a,b);\r\n				if (c==\'*\')\r\n					return new Mul(a,b);\r\n				if (c==\'/\')\r\n					return new Div(a,b);\r\n			}\r\n			if (c==\'C\')\r\n			{\r\n				Expression* d;\r\n				cin>>c;\r\n				cin>>c;\r\n				cin>>c;\r\n				d=read();\r\n				cin>>c;\r\n				return new Cos(d);\r\n			}\r\n\r\n			if (c==\'S\')\r\n			{\r\n				Expression* e;\r\n				cin>>c;\r\n				cin>>c;\r\n				cin>>c;\r\n				e=read();\r\n				cin>>c;\r\n				return new Sin(e);\r\n			}\r\n\r\n		 }\r\n		 \r\n		 \r\n/*Expression* read(char* s)\r\n{\r\n            int n=0,i;\r\n            while(*s!=\'\\0\')\r\n            {cout<<*s;\r\n            s++;\r\n			n++;}\r\n            for (i=1; i<=n; i++)\r\n            cin.unget();\r\n            return read1();\r\n             \r\n}\r\n*/\r\n\r\nExpression *Cos::diff(char p)\r\n{return new Mul(new Sub(new Number(0), new Sin(a)),a->diff(p));}  \r\n\r\n\r\nvoid main()\r\n{\r\n	Expression *f;\r\n	f=read();\r\n	std::cout << \"\\n\";\r\n	Expression *df = f->diff(\'x\');\r\n	df->print();\r\n	std::cout << \"\\n\";\r\n//	delete f;\r\n//	delete df;\r\n	\r\n	//Expression *e = new Add(new Number(1), new Variable(\'x\'));\r\n	//e->print();\r\n	//std::cout << \"\\n\";\r\n	//Expression *de = e->diff(\'x\');\r\n	//de->print();\r\n	//std::cout << \"\\n\";\r\n	//delete e;\r\n	//delete de;\r\n	//\r\n	//Expression* A= new Div(new Number(1), new Mul(new Variable(\'y\'),new Variable(\'y\')));\r\n	//A->print();\r\n	//cout<<endl;\r\n	//Expression* A1=A->diff(\'y\');\r\n	//A1->print();\r\n	//cout<<endl;\r\n	//delete A;\r\n	//delete A1;\r\n\r\n	//Expression *s = new Cos(new Variable(\'x\'));\r\n	//Expression *ds = s->diff(\'x\');\r\n	//ds->print();\r\n\r\n}','ÐÐ½Ð½Ð°','Anna','f');
INSERT INTO `bias` VALUES (483,'#include <iostream>\r\n\r\ntemplate <typename T> class List\r\n{\r\nprivate:\r\n	struct element\r\n	{\r\n		T data;\r\n		element *next;\r\n	};\r\n	//fields\r\n	element *head;\r\n	element *tail;\r\n	//copy constructor\r\n	List (List&){}\r\n	//operator=\r\n	List operator=(List&){}\r\npublic:\r\n	//default constructor\r\n	List ()\r\n	{\r\n		head = NULL;\r\n		tail = NULL;\r\n	};\r\n	//add at the beginning\r\n	void push_it(T n)\r\n	{\r\n		element *item;\r\n		item = new element;\r\n		item->data = n;\r\n		item->next = head;\r\n		head = item;\r\n		if (tail == NULL)\r\n		{\r\n			tail = item;\r\n		}\r\n	}\r\n	//delete from the beginning\r\n	void pop_it()\r\n	{\r\n		if (head == NULL)\r\n		{\r\n		}\r\n		else if (head->next == NULL)\r\n		{\r\n			delete head;\r\n			tail = NULL;\r\n			head = NULL;\r\n		}\r\n		else\r\n		{\r\n			element *p;\r\n			p = head->next;\r\n			delete head;\r\n			head = p;\r\n		}\r\n	}\r\n	//add at the end\r\n	void push_end(T n)\r\n	{\r\n		if (head == NULL)\r\n		{\r\n			push_it (n);\r\n		}\r\n		else\r\n		{\r\n			element *item;\r\n			item = new element;\r\n			item->data = n;\r\n			item->next = NULL;\r\n			tail->next = item;\r\n			tail = item;\r\n		}\r\n	}\r\n	//delete from the end\r\n	void pop_end ()\r\n	{\r\n		if (head == NULL)\r\n		{\r\n		}\r\n		else if (head->next == NULL)\r\n		{\r\n			pop_it();\r\n		}\r\n		else\r\n		{\r\n			element *p = head;\r\n			for (p = head; p->next != tail; p = p->next) {}\r\n			delete tail;\r\n			tail = p;\r\n			p->next = NULL;\r\n		}\r\n	}\r\n	//print\r\n	void print()\r\n	{\r\n		element * p = head;\r\n		while (p != NULL)\r\n		{\r\n//			std::cout << p->data << \"\\n\";\r\n			std::cout << p->data << \" \";\r\n			p = p->next;\r\n		}\r\n		std::cout << \"\\n\";\r\n	}\r\n	//destructor\r\n	~List()\r\n	{\r\n		while (head != NULL)\r\n		{\r\n			pop_end();\r\n		}\r\n	}\r\n};\r\n\r\nint main()\r\n{	List<int> A;\r\n	\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		A.push_end(i);\r\n		A.push_it(i);\r\n\r\n		A.print();\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		A.pop_it();\r\n		A.pop_end();\r\n\r\n		A.print();\r\n	}\r\n\r\n	return 0;\r\n}\r\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (484,'// spis.cpp : Defines the entry point for the console application.\r\n//\r\n\r\n#include \"stdafx.h\"\r\n\r\n\r\nint _tmain(int argc, _TCHAR* argv[])\r\n{\r\n	return 0;\r\n}\r\n\r\n#include<iostream>\r\ntemplate <typename T> class List\r\n{\r\nprivate:\r\n	struct element\r\n	{\r\n		T data;\r\n		element *next;\r\n	};\r\n	element *head;\r\n	public:\r\n	List(void)\r\n	{\r\n\r\n		head=NULL;\r\n		//head->next=NULL;\r\n		//head->data=0;\r\n\r\n\r\n	}\r\n	~List(void)//??????????!!!\r\n	{\r\n		element *fun;\r\n\r\n		while (head != NULL)\r\n		{\r\n			fun=head->next;\r\n			delete head;\r\n			head=fun;\r\n\r\n		}\r\n	\r\n\r\n	}\r\n	void Add_first (T x)\r\n	{\r\n			element *fun = new element;\r\n			if (!fun)\r\n			{\r\n				std::cout << \"?????? ????????? ??????\";\r\n				exit (1);\r\n			}\r\n\r\n			fun->data = x;\r\n			fun->next = head;\r\n			head = fun;\r\n\r\n		std::cout<<\"head = \"<< head->data<<\"\\n\";\r\n	}\r\n	void del_first(void)\r\n	{\r\n	\r\n		if(head != NULL)\r\n		{\r\n			element *fun;\r\n			std::cout<<\"head = \"<< head->data<<\"\\n\";\r\n	\r\n			fun=head->next;\r\n			delete head;\r\n			head = fun;\r\n		}\r\n		else\r\n		{\r\n			std::cout << \"you can\'t remove what is not \\n\";\r\n		}\r\n\r\n	}\r\n};\r\nvoid main()\r\n{\r\n	List<int>qwer;\r\n	\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		qwer.Add_first(i);\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		qwer.del_first();\r\n	}\r\n\r\n\r\n	//qwer.del_first();\r\n	//qwer.del_first();\r\n\r\n}','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (485,'#include<stdio.h>\n#include<stdlib.h>\nstruct node{\n	int data;\n	struct node *left,*right;\n};\nvoid print(struct node *root)\n{\n	if(!root)\n		return;\n	print(root->left);\n	printf(\"%d \",root->data);\n	print(root->right);\n\n}\nstruct node *search(struct node *p, int a)\n{\n	struct node *q=p;\n	while(q)\n	{\n		if(a>=q->data)\n		{\n			p=q;					\n			q=q->right;		\n		}\n		else \n		{\n			p=q;\n			q=q->left;\n			\n		}\n	}\n	return p;	 \n}	\n	\nvoid add(struct node **proot, int a)\n{\n	struct node *p, *q;\n	p=malloc(sizeof(*p));\n	p->data=a;\n	p->left=NULL;\n	p->right=NULL;\n	if(!*proot)\n	{\n		*proot=p;\n		return;\n	}\n	q=search(*proot,a);\n	if(a<q->data)\n		q->left=p;\n	else q->right=p;\n}\nvoid Free(struct node *root)\n{\n	if(!root)\n		return;\n	Free(root->left);\n	Free(root->right);\n	free(root);\n}\nint main()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n	int a; struct node *root=NULL,*q,*p;\n	if(!f)\n	{\n		perror(\"input.txt\");\n		return 0;\n	}\n	while((fscanf(f,\"%d\",&a))==1)\n	{\n		add(&root,a);\n	}\n	print(root);\n	Free(root);		\n	printf(\"\\n\");	\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (486,'#include<stdio.h>\nvoid  Dijkstra(int a[][100],int N,int *prev,int *D)\n{\n	int used[100]={0},i,cur;\n	for(;;)\n	{       cur=N+1;\n		for(i=1;i<=N;i++)\n			if(D[i]<D[cur]&&!used[i])\n				cur=i;\n		if(cur==N+1)break;\n		for(i=1;i<=N;i++)\n			if(D[i]>D[cur]+a[cur][i])\n				{\n					D[i]=D[cur]+a[cur][i];\n					prev[i]=cur;\n				}\n		used[cur]=1;\n	}\n	\n}\nvoid print(int *prev,int s,int *D)\n{\n	int a[100]={0},j,k;\n	a[0]=s;\n	k=a[0];\n	j=1;\n	while(prev[k]!=0)\n	{\n		a[j]=prev[k];\n		k=a[j];\n		j++;\n	}\n	for(k=j-1;k>=0;k--)\n		printf(\"%d \",a[k]);\n	printf(\"D=%d \",D[s]);\n	printf(\"\\n\");\n}\nint main()\n{\n	FILE *f=fopen(\"Input.txt\",\"r\");\n	int A[100][100]={0},i,j,N,v,k,M,d, prev[100]={-1},D[100],a[100]={0};\n	if(!f)\n	{\n		perror(\"Input.txt\");\n		return 0;\n	}\n	fscanf(f,\"%d %d\",&N,&M);\n	for(i=1;i<=N+1;i++)\n		D[i]=1000000;\n	for(v=0;v<M;v++)\n	{\n		fscanf(f,\"%d %d\",&i,&j);\n		fscanf(f,\"%d\",&d);\n		A[i][j]=d;\n		A[j][i]=d;\n	}\n	for(i=1;i<=N;i++)\n		for(j=1;j<=N;j++)\n			if(i!=j&&A[i][j]==0)\n				A[i][j]=1000000;\n		\n	fscanf(f,\"%d\",&v);\n	D[v]=0;\n	Dijkstra(A,N,prev,D);\n	for(i=1;i<=N;i++)\n		print(prev,i,D);\n	return 0;\n}\n\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (487,'#include <stdio.h>\n#define N 100\nvoid permut(int *a, int *clear,int l, int r)\n{\n	int i,t,j;\n\n	if (l==r)\n	{\n		for(i=0;i<r;i++)\n			printf(\"%d \",clear[i]);\n		printf(\"\\n\");\n		return;\n	}\n	else\n	{\n		for(i=0;i<r;i++)\n		{\n			if (a[i]==0) continue;\n			t=a[i];\n			a[i]=0;\n			clear[l]=t;\n			permut(a,clear,l+1,r);\n			a[i]=clear[l];\n		}\n	}\n}\n\nint main()\n{\n	int n, i;\n	int a[N];\n	int clear[N]={0};\n	scanf(\"%d\", &n);\n	for (i = 0; i < n; i++)\n	{\n		a[i] = i + 1;\n	}\n	permut(a,clear,0,n);\n	return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (488,'#include <stdio.h>\n\nvoid sift(int a[], int i, int n)\n{\n	int l,r,k,t;\n	while ((2*i)<n)\n	{\n		r=2*i;\n		if ((r+1<n) && (a[r]<a[r+1]))\n			r++;\n		\n		if (a[i]<a[r])\n		{\n			t=a[i];\n			a[i]=a[r];\n			a[r]=t;\n			i=r;\n		}\n		else return;\n		\n	}\n}\n\nint main()\n{\n	int i,N,c,t;\n	int a[100000];\n	FILE*f=fopen(\"input.txt\",\"r\");\n	fscanf(f,\"%d\",&N);\n	for (i=0; i<N; i++) \n		fscanf(f,\"%d\",&a[i]);\n	i=N/2;\n	while (i>=0)\n	{\n		sift(a,i,N);\n		i--;\n	}\n	i=N-1;\n	while(i>1)\n	{\n	      c=a[0];\n	      a[0]=a[i];\n	      a[i]=c;\n	      i--;\n  	      sift(a,0,i);\n	}\n	for(i=0; i<N; i++)\n		printf(\"%d \",a[i]);\n	printf(\"\\n\");\n	return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (489,'#include<stdio.h>\n#include<ctype.h>\n#define N 20\nint main()\n{\n	float t, z=0;\n	char a[20];\n	int k, d, arr[20], i=0, n, v, j;\n	printf(\"??????? ????????? ?.?.: \");\n	scanf(\"%d\", &d);\n	printf(\"??????? ????? ????? ? ??????????????? ?.?.: \");\n	scanf(\"%s\", &a);\n	while(a[i]!=0)\n	{\n		if(isdigit(a[i]))\n			arr[i]=(int)a[i]-\'0\';\n		else\n		{\n			if(isalpha(a[i]))\n				arr[i]=(int)a[i]-\'A\'+10;\n		}\n		if(a[i]==\'.\')\n		{\n			k=i+1;\n		}\n		i++;\n	}\n	v=i;\n	i=k-2;\n	t=1;\n	while(i>=0)\n	{\n		z=z+arr[i]*t;\n		t=t*d;\n		i--;\n	}\n	i=k;\n	t=1/(float)d;\n	while(i!=v)\n	{\n		z=z+arr[i]*t;\n		t=t/d;\n		i++;\n	}\n	printf(\"%f\\n\", z);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (490,'#include \"17.h\"\n\nvoid sift(int *x, int i, int n) {\n	int l, r, m, z;\n\n	i++;\n	while ((l=2*i) <= n) {\n		r = (l+1 <= n) ? l+1 : i;\n		\n		if ((x[i-1] >= x[l-1]) && (x[i-1] >= x[r-1]))\n			return;\n		\n		m = (x[l-1] >= x[r-1]) ? l : r;\n		\n		z = x[m-1];\n		x[m-1] = x[i-1];\n		x[i-1] = z;\n		\n		i = m;\n	}\n}\n\nvoid sort(int *x, int n)\n{\n	int i;\n	\n	for (i=n/2; i>=0; i--)\n		sift(x, i, n);\n\n	for (i=n-1; i>0; i--)\n	{\n		int z;\n		z = x[0];\n		x[0] = x[i];\n		x[i] = z;\n		sift(x, 0, i);\n	}\n}\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (491,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#define N 10\r\n\r\ntypedef struct item hash;\r\n\r\nstruct item {\r\n	int code, count;\r\n	char *word;\r\n	struct item *next;\r\n};\r\n\r\nunsigned int f_hash(char *s, int n)\r\n{\r\n	int i, x=0, k=2;\r\n	for (i=0; i<n; i++) {\r\n		x += s[i]*(k+1);\r\n		k *= 2;\r\n	}\r\n	return x;\r\n}\r\n\r\nint add_hash(hash **x, unsigned char *s, unsigned int hashcode, int f) {\r\n	unsigned int i = hashcode % N, n = strlen(s);\r\n	hash *p, *q;\r\n	\r\n	for (p=x[i]; p; p=p->next)\r\n		if (p->code == hashcode) {\r\n			//if f == 0, not increment\r\n			if (f)\r\n				p->count++;\r\n			return p->count;\r\n		}\r\n	if (f) {\r\n		p = x[i];\r\n		q = (hash *) malloc(sizeof(*p));\r\n		x[i] = q;\r\n		q->code = hashcode;\r\n		q->count = 1;\r\n		q->word = (char *) malloc(n+1);\r\n		strcpy(q->word, s);\r\n		q->next = p;\r\n	}\r\n\r\n	return 0;\r\n}\r\n\r\nvoid free_hash(hash **x) {\r\n	int i;\r\n	hash *p, *q;\r\n	for (i=0; i<N; i++) {\r\n		for (p=x[i]; p; p=q) {\r\n			q = p->next;\r\n			free(p->word);\r\n			free(p);\r\n		}\r\n	}\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n	int i=0, c, z=0, y=0, u=0, b=0, a;\r\n	unsigned char word[50]={\'\\0\'}, s[50];\r\n	hash *x[N], *p;\r\n	FILE *f = fopen(\"word.txt\", \"r\");\r\n	if (!f) {\r\n		perror(\"fopen\");\r\n		return 0;\r\n	}\r\n	\r\n	for (i=1; i<argc; i++) {\r\n		//print hash table in the terminal\r\n		if (!strcmp(argv[i], \"-p\"))\r\n			z = 1;\r\n		//big and small letters - different\r\n		if (!strcmp(argv[i], \"-b\"))\r\n			b = 1;\r\n		//finf the word-parameter\r\n		if (!strcmp(argv[i], \"-i\")) {\r\n			y = i + 1;\r\n			if ( y >= argc || !strcmp(argv[y], \"-p\") || !strcmp(argv[y], \"-b\")) {\r\n				printf(\"wrong parameters\\n\");\r\n				return 0;\r\n			}\r\n		}\r\n	}\r\n	\r\n	for (i=0; i<N; i++)\r\n		x[i] = NULL;\r\n	\r\n	i = 0;\r\n	while ((c = fgetc(f)) != EOF) {\r\n		if (!isalpha(c)) {\r\n			word[i] = 0;\r\n			if (word[0] != 0)\r\n				add_hash(x, word, f_hash(word, i), 1);\r\n			i = 0;\r\n			word[0] = 0;\r\n		}else {\r\n			if (!b)\r\n				c = tolower(c);\r\n			word[i] = c;\r\n			i++;\r\n		}\r\n	}\r\n	word[i] = 0;\r\n	add_hash(x, word, f_hash(word, i), i);\r\n	fclose(f);\r\n	\r\n	//print hash table in the \"output.txt\"\r\n	f = fopen(\"output.txt\", \"w\");\r\n	if (!f) {\r\n		perror(\"fopen\");\r\n		return 0;\r\n	}\r\n	fprintf(f, \"Hash table\\n\");\r\n	fprintf(f, \"Word - Count - Code\\n\");\r\n	for (i=0; i<N; i++)\r\n		for (p=x[i]; p; p=p->next)\r\n			fprintf(f, \"%s %d %d\\n\", p->word, p->count, p->code);\r\n	fclose(f);\r\n	\r\n	if (y) {\r\n		c = strlen(argv[y]);\r\n		strcpy(word, argv[y]);\r\n		for (i=0; i<c; i++)\r\n			if (!b)\r\n				word[i] = tolower(word[i]);\r\n		word[i] = 0;\r\n		a = add_hash(x, word, f_hash(word, c), 0);\r\n		printf(\"The word \\\"%s\\\" is found in the text %d times\\n\", word, a);\r\n	}\r\n	\r\n	if (z) {\r\n		printf(\"Number of occurrences of all words in the text\\n\");\r\n		for (i=0; i<N; i++) \r\n			for (p=x[i]; p; p=p->next)\r\n				printf(\"%s %d\\n\", p->word, p->count);\r\n	}\r\n	\r\n	free_hash(x);\r\n\r\n	return 0;\r\n}\r\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (492,'#include <stdio.h>\n#include <stdlib.h>\n#define N 101\n\nint A[N][N]={0};\n\nvoid dfs(int c, int *visited) {\n	int i;\n	\n	printf(\"%d \", c);\n	visited[c] = 1;\n	for (i=1; i<N; i++)\n		if (A[c][i] && !visited[i]) {\n			dfs(i, visited);\n		}\n}\n\nint main()\n{\n	int i=0, j=0, visited[N]={0};\n	FILE *f = fopen(\"input22.txt\", \"r\");\n	while (fscanf(f, \"%d %d\", &i, &j) == 2) {\n		A[i][j] = 1;\n		A[j][i] = 1;\n		i++;\n	}\n	fclose(f);\n	printf(\"Iz vershiny 1 dostigimy: \");\n	dfs(1, visited);\n	printf(\"\\n\");\n	\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (493,'#include <stdio.h>\n#define N 101\n\nstruct queue\n{\n	int Q[N];\n	int r, w;\n};\n\nint A[N][N]={0};\n\nvoid init(struct queue *q)\n{\n	q->r = 0;\n	q->w = 0;\n}\n\nvoid enqueue(struct queue *q, int a) {\n	q->Q[q->w++] = a;\n}\n\nint dequeue(struct queue *q) {\n	return q->Q[q->r++];\n}\n\nint empty(struct queue *q) {\n	return (q->r == q->w);\n}\n\nvoid bfs(int c, int *visited) {\n	int i;\n	struct queue q;\n	init(&q);\n	\n	enqueue(&q, c);\n	visited[c] = 1;\n	while (!empty(&q)) {\n		c = dequeue(&q);\n		for (i=1; i<N; i++)\n			if (A[c][i] && !visited[i]) {\n				enqueue(&q, i);\n				visited[i] = 1;\n			}\n	}\n}\n\nint main()\n{\n	int i=0, j=0, visited[N]={0};\n	FILE *f = fopen(\"input22.txt\", \"r\");\n	while (fscanf(f, \"%d %d\", &i, &j) == 2) {\n		A[i][j] = 1;\n		A[j][i] = 1;\n		i++;\n	}\n	fclose(f);\n	printf(\"Iz vershiny 1 dostigimy: \");\n	bfs(1, visited);\n\n	for (i=2; i<N; i++)\n		if (visited[i])\n			printf(\"%d \", i);\n	printf(\"\\n\");\n	\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (494,'#include <iostream>\nusing namespace std;\n	class exp\n	{\n		public:\n			virtual exp* diff()=0;\n			virtual void print()=0;\n\n	};\n	\n	class numb:public exp\n		{\n			int val;\n		public:	numb(int a){val=a;}\n			exp* diff()\n			{\n				exp* A=new numb(0);\n				return A;\n			}\n		void print(){cout<<val;}\n		};\n\n	class var:public exp\n	{\n		char x;\n	public:	var(char c){x=c;}\n		exp* diff()\n		{\n			exp* A=new numb(1);\n			return A;\n		}\n		void print(){cout<<x;}\n	};\n	\n	class add:public exp\n	{\n		exp* val1;exp* val2;\n	public:	add(exp* a,exp* b){val1=a;val2=b;}\n		exp* diff()\n		{\n			exp* A=new add (val1->diff(),val2->diff());\n			return A;\n		}\n		void print(){\n			cout<<\"(\";\n			val1->print();\n			cout<<\")+(\";\n			val2->print();\n			cout<<\")\";\n		}\n	};\n\n	class sub:public exp\n	{\n		exp* val1;exp* val2;\n	public:	sub(exp* a,exp* b){val1=a;val2=b;}\n		exp* diff()\n		{\n			exp* A=new sub (val1->diff(),val2->diff());\n			return A;\n		}\n		void print()\n		{\n			cout<<\"(\";\n			val1->print();\n			cout<<\")-(\";\n			val2->print();\n			cout<<\")\";\n		}\n	};\n\n	class mul:public exp\n	{\n		exp* val1;exp* val2;\n	public:	mul(exp* a,exp* b){val1=a;val2=b;}\n		exp* diff()\n		{\n			exp* A=new add (new mul(val1->diff(),val2),new mul(val2->diff(),val1));\n			return A;\n		}\n		void print()\n		{\n			cout<<\"(\";\n			val1->print();	\n			cout<<\")*(\";\n			val2->print();\n			cout<<\")\";\n		}\n	};\n\n	class div:public exp\n	{\n		exp* val1;exp* val2;\n	public:	div(exp* a,exp* b){val1=a;val2=b;}\n		exp* diff()\n		{\n			exp* A=new div( new div( new sub(new mul (val1->diff(),val2),new mul(val2->diff(),val1) ), val2 ) , val2);\n			return A;\n		}\n		void print()\n		{\n			cout<<\"(\";\n			val1->print();	\n			cout<<\")/(\";\n			val2->print();\n			cout<<\")\";\n		}\n\n	};\n\n/////// \n	\n	\n\n\n		int main()\n		{\n			exp *e = new div(new numb(1), new var(\'x\'));\n			std::cout << \"\\n\";\n			exp *de = e->diff();\n			de->print();\n			cout << \"\\n\";\n			delete e;\n			delete de;\n			\n				\n		}		\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (495,'//?????????? ?????????????????\n#include <iostream>\n\nclass Expression\n{\npublic:\n	virtual void print()=0;	\n	virtual Expression *diff()=0;\n};\n\nclass Number: public Expression //????????????, ?????? ????? int\n{\nprivate:\n	int value;\npublic:\n	Number(int v) { value=v; }\n	Expression *diff()\n	{\n		Expression *p=new Number(0);\n		return p;\n	}\n	void print()\n	{\n		std::cout<<value;\n	}\n};\n\nclass Variable: public Expression //?????? ??? ?????????? char\n{\nprivate:\n	char Name;\npublic:\n	Variable(char name)\n	{\n		Name=name;\n	}\n	Expression *diff()\n	{\n		Expression *p;\n		p=new Number(1);\n		return p;\n	}\n	void print()\n	{\n		std::cout<<Name;\n	}\n};\n\nclass Add: public Expression //????????\n{\nprivate:\n	Expression *first,*second;\npublic:\n	Add(Expression *a, Expression *b)	//???????? a+b\n	{\n		first=a;\n		second=b;\n	}\n	Expression *diff()\n	{\n		Expression *p=new Add(first->diff(), second->diff());//?????????????? first+second\n		return p;\n	}\n	void print()\n	{\n		std::cout<<\"(\";\n		first->print();\n		std::cout<<\"+\";\n		second->print();\n		std::cout<<\")\";\n	}\n};\n\nclass Sub: public Expression //????????\n{\nprivate:\n	Expression *first,*second;\npublic:\n	Sub(Expression *a, Expression *b)\n	{\n		first=a;\n		second=b;\n	}\n	Expression *diff()\n	{\n		Expression *p=new Sub(first->diff(), second->diff());\n		return p;\n	}\n	void print()\n	{\n		std::cout<<\"(\";\n		first->print();\n		std::cout<<\"-\";\n		second->print();\n		std::cout<<\")\";\n	}\n};\n\nclass Mul: public Expression //????????????\n{\nprivate:\n	Expression *first,*second;\npublic:\n	Mul(Expression *a, Expression *b)\n	{\n		first=a;\n		second=b;\n	}\n	Expression *diff()\n	{\n		Expression *p=new Add(new Mul(first->diff(),second),new Mul(first,second->diff()));\n		return p;\n	}\n	void print()\n	{\n		std::cout<<\"(\";\n		first->print();\n		std::cout<<\"*\";\n		second->print();\n		std::cout<<\")\";\n	}\n};\n\nclass Div: public Expression//???????\n{\nprivate:\n	Expression *first,*second;\npublic:\n	Div(Expression *a, Expression *b)\n	{\n		first=a;\n		second=b;\n	}\n	Expression *diff()\n	{\n		Expression *p=new Div(new Sub(new Mul(first->diff(),second),new Mul(first,second->diff())),new Mul(second,second));\n		return p;\n	}\n	void print()\n	{\n		std::cout<<\"(\";\n		first->print();\n		std::cout<<\"/\";\n		second->print();\n		std::cout<<\")\";\n	}\n};\n\n\n\nint main()\n{\n	Expression *e = new Div(new Number(1), new Variable(\'x\'));\n//	std::cout << \"\\n\";\n	Expression *de = e->diff();\n	de->print();\n	std::cout << \"\\n\";\n	delete e;\n	delete de;\n}\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (496,'//??????\n#include <iostream>\nclass String\n{\nprivate:\n	char* data;//?????????? ??????\n	int length;//????? ??????\npublic:\n	String() //??????????? ?? ?????????(??? ??????????)\n	{\n		data=new char[1];\n		data[0]=0;\n		length=0;\n	}\n\n	String(const char* str) //??????????? ? ?????????? char*\n	{\n		for(length=0;str[length];length++);\n		data=new char[length+1];\n		for(int i=0;i<=length;i++)\n		{\n			data[i]=str[i];\n		}\n	}\n	\n	String(const String& str) //??????????? ???????????\n	{\n		length=str.length;\n		data=new char[length+1];\n		for(int i=0;i<length;i++)\n		{\n			data[i]=str.data[i];\n		}\n	}\n	\n	~String() //??????????\n	{\n		delete[]data;\n	}\n	\n	String& operator= (const String& str)//????????=\n	{\n		if (&str == this)\n			return *this;\n\n		delete []data;\n		length=str.length;\n		char *p=new char[length+1];\n		for(int i=0;i<=length;i++)\n		{\n			p[i]=str[i];\n		}\n\n		data = p;\n		return *this;\n	}\n\n	operator const char *() const //???????? ?????????? ? const char *\n	{\n		return data;\n	}\n\n	String operator+ (const String str)//????????+\n        {\n                char *q=new char[length+str.length+1];\n                for(int i=0;i<length;i++)\n                {\n                        q[i]=data[i];\n                }\n                for(int i=0;i<=str.length;i++)\n                {\n                        q[i+length]=str[i];\n                }\n                String result(q);\n                delete[] q;\n                return result;\n        }\n\n	\n\n	String& operator+= (const String str)//???????? +=\n	{\n		*this = *this + str;\n		return *this;\n	}\n	\n	\n	char& operator[] (int i)// ???????? [] ??? ?????????\n	{\n		return data[i];\n	}\n\n	char operator[] (int i) const// ???????? [] ??? ??????\n	{\n		return data[i];\n	}\n};\n\n\nint main()\n{\n	String b(\"parametr\");\n	std::cout << b << \"\\n\";\n	b += \"vasya\";\n	//b = \"vasya\";\n	std::cout << b << \"\\n\";\n\n	return 0;\n}\n\n','Ð•Ð»ÐµÐ½Ð°','Elena','f');
INSERT INTO `bias` VALUES (497,'#include <iostream>\n#include <string.h>\nclass xstring\n{\nprivate:\n	char *data;\n	int length;\npublic:\n	xstring()\n	{\n		length=0;\n		data=new char[length+1];\n		data[length]=0;\n	}\n	xstring(const char *s)\n	{\n		int i;\n		length=strlen(s);\n		data=new char[length+1];\n		for (i=0; i<length; i++)\n			data[i]=s[i];	\n	}\n	xstring(const xstring &orig)\n	{\n		int i;\n		length=orig.length;\n		data=new char [length+1];\n		for (i=0;i<length;i++)\n			data[i]=orig.data[i];\n	}\n	~xstring()\n	{\n		delete [] data;\n	}\n\n	xstring operator+(const xstring &second) const\n	{\n		\n		char *p = new char[strlen(data)+strlen(second.data)+1];\n		strcpy(p,data);\n		strcat(p,second.data);\n		p[strlen(data)+strlen(second.data)]=0;\n		xstring result(p);\n		delete p;\n		return (result);\n\n	}\n	xstring& operator+=(const xstring &other)\n	{	\n		*this = *this + other;\n		return *this;	\n	}\n	xstring& operator=(const xstring &orig)\n	{\n		int i;\n		length=orig.length;\n		if(&orig!=this)\n		{\n			delete [] data;\n			data=new char [length+1];\n			for (i=0;i<length;i++)\n			data[i]=orig.data[i];\n		}\n		return *this;\n	}\n	operator const char*() const\n	{\n		return(data);\n	}\n	void print()\n	{\n		std::cout<<data<<\"\\n\";\n	}	\n};\nint main()\n{\n	xstring s0;\n	xstring s1(\"?????? ? ??????? \");\n	xstring s2(\"? ?? ??? ??????? ?? ??????? ????????\");\n	xstring s3(\"???? ????? ??????? ??????, ?????, ??????? ? ???? \");\n	xstring s4(\"? ??? ????-???? ?????? - ????? ??????? ??? ??????\");\n	s0=s1+s2;\n	s3+=s4;\n	s1.print();\n	s2.print();\n	s0.print();\n	s3.print();\n	s1+=s1;\n	s1.print();\n	\nreturn 0;\n}\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (498,'\r\n// ChildView.cpp : ?????????? ?????? CChildView\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"4th_f.h\"\r\n#include \"ChildView.h\"\r\n#include \"Expression.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// ??????????? ????????? CChildView\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\n\r\nvoid CChildView::OnPaint() \r\n{\r\n	CPaintDC dc(this); // ???????? ?????????? ??? ?????????\r\n	int a,x0,y0,t,x1,y1,px,py;\r\n	double k,z;\r\n	Expression* y,* dy;\r\n\r\n	// ????????\r\n	t = 5;\r\n	// ???\r\n	k = 0.01;\r\n	//???????\r\n	\r\n	y = read (\"(((x*x)*x)/3)\");\r\n	dy = y->diff(\'x\');\r\n\r\n	RECT rect;\r\n	dc.GetWindow()->GetWindowRect(&rect);\r\n	rect.right -= rect.left;\r\n	rect.bottom -= rect.top;\r\n	x0 = rect.right/2;\r\n	y0 = rect.bottom/2;\r\n\r\n	CPen p(PS_SOLID, 1, RGB(220,220,220));\r\n	dc.SelectObject(p);\r\n\r\n	for (int i=0;i<(2*t);i++)\r\n	{\r\n		a = (i*rect.bottom)/(2*t);\r\n		dc.MoveTo(0, a);\r\n		dc.LineTo(rect.right, a);\r\n\r\n	}\r\n\r\n	for (int i=0;i<(2*t);i++)\r\n	{\r\n		a = (i*rect.right)/(2*t);\r\n		dc.MoveTo(a, 0);\r\n		dc.LineTo(a, rect.bottom);\r\n\r\n	}\r\n\r\n	CPen p1(PS_SOLID, 1, RGB(0,0,0));\r\n	dc.SelectObject(p1);\r\n\r\n	dc.MoveTo(x0, 0);\r\n	dc.LineTo(x0, rect.bottom);\r\n	dc.MoveTo(0, y0);\r\n	dc.LineTo(rect.right, y0);\r\n\r\n	px = (rect.right/2)/t;\r\n	py = (rect.bottom/2)/t;\r\n\r\n	CPen p2(PS_SOLID, 1, RGB(0,0,255));\r\n	dc.SelectObject(p2);\r\n\r\n	x0 = -t*px;\r\n	y0 = (y->evaluate(-t))*py;\r\n	dc.MoveTo(x0+rect.right/2, -y0+rect.bottom/2);\r\n\r\n	for (z = -t; z<t; z+=k)\r\n	{\r\n		x1 = (z+k)*px;\r\n		y1 = (y->evaluate(z+k))*py;\r\n		dc.LineTo(x1+rect.right/2, -y1+rect.bottom/2);\r\n	}\r\n\r\n	CPen p3(PS_SOLID, 1, RGB(255,99,71));\r\n	dc.SelectObject(p3);\r\n\r\n	x0 = -t*px;\r\n	y0 = (dy->evaluate(-t))*py;\r\n	dc.MoveTo(x0+rect.right/2, -y0+rect.bottom/2);\r\n\r\n	for (z = -t; z<t; z+=k)\r\n	{\r\n		x1 = (z+k)*px;\r\n		y1 = (dy->evaluate(z+k))*py;\r\n		dc.LineTo(x1+rect.right/2, -y1+rect.bottom/2);\r\n	}\r\n\r\n	//Left, Top, Right, Bottom\r\n	// TODO: ???????? ??? ????????? ?????????\r\n	\r\n	// ?? ????????? CWnd::OnPaint() ??? ????????? ?????????\r\n}\r\n\r\n','Ð”ÐµÐ½Ð¸Ñ','Denis','m');
INSERT INTO `bias` VALUES (499,'#include <iostream>\nclass expression \n{\npublic:\n        virtual expression* diff()=0;\n        virtual void print()=0;\n//	virtual ~expression(){}\n//	virtual expression *clone()=0;\n};\nclass number: public expression\n{\nprivate:\n	float num;\npublic:\n	number(float n)\n	{\n		num=n;\n	}\n	~number(){}\n	\n	expression* diff()\n	{\n		return new number(0);\n	}\n	void print()\n        {\n        	std::cout<<num;\n        }\n};\nclass variable: public expression\n{\nprivate:\n	char var;	\npublic:	\n	variable(char x)\n	{\n		var=x;	\n	}\n	~variable(){}\n	\n	expression* diff()\n	{\n		return new number(1);\n	}\n	void print()\n	{\n		std::cout<<var;\n	}\n};\nclass add: public expression\n{\nprivate:\n	expression *A, *B;\npublic:\n	add(expression* x, expression* y):A(x),B(y){}\n	\n	~add()\n	{\n                delete A;\n                delete B;\n        }\n\n        expression* diff()\n	{\n		return new add(A->diff(),B->diff());\n	}\n	void print()\n	{\n		std::cout<<\"(\";\n		A->print();\n		std::cout<<\"+\";\n		B->print();\n		std::cout<<\")\";\n	}\n};\nclass sub: public expression\n{\nprivate:\n        expression *A, *B;\npublic:\n        sub(expression* x, expression* y):A(x),B(y){}\n	\n	~sub()\n        {\n                delete A;\n                delete B;\n        }\n        expression* diff()\n        {\n                return new sub(A->diff(),B->diff());\n        }\n        void print()\n        {\n        	std::cout<<\"(\";\n	        A->print();\n                std::cout<<\"-\";\n                B->print();\n		std::cout<<\")\";\n	}\n};\nclass mul: public expression\n{\nprivate:\n	expression *A, *B;\npublic:\n	mul(expression *x, expression *y):A(x),B(y){}\n\n	expression* diff()\n        {\n                return new add(new mul(A->diff(),B), new mul(A,B->diff()));\n        }\n	\n	void print()\n        {\n                std::cout<<\"(\";\n		A->print();\n                std::cout<<\"*\";\n                B->print();\n        	std::cout<<\")\";\n	}\n};\nclass div: public expression\n{\nprivate:\n        expression *A, *B;\npublic:\n        div(expression *x, expression *y):A(x),B(y){}\n\n	 expression* diff()\n        {\n                return new div(new sub(new mul(A->diff(),B),new mul(A,B->diff())),new mul(B,B));\n        }\n	void print()\n        {\n		std::cout<<\"(\";\n                A->print();\n                std::cout<<\"/\";\n                B->print();\n		std::cout<<\")\";\n        }\n};\nint main()\n{\n	expression *e=new div(new variable(\'x\'),new number(2));\n	e->print();\n	std::cout<<\"\\n\";\n	expression *de=e->diff();\n	de->print();\n	delete e;\n	delete de;\nreturn(0);\n}	\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (500,'\n#include <stdio.h>\n#include <string.h>\n#include <string.h>\n#include <ctype.h>\n#include <iostream>\n#include <string>\nclass Expression\n{\n	public:\n	virtual Expression* diff() = 0;\n	virtual void print() = 0;\n};\n\nclass Number: public Expression\n{\n	private:\n	int num;\n	Expression *retDiff;\n	public:\n	Number (int n)\n	{\n		 num=n;\n		 retDiff=NULL;\n	}\n	~Number()\n	{\n		 if(retDiff) delete retDiff;\n	}\n\n	Expression* diff()\n	{\n		 if(retDiff == NULL) retDiff=new Number(0);\n		 return retDiff;\n	}\n	void print()\n	{\n		 printf(\"%d\",num);\n	}\n};\nclass Variable: public Expression\n{\n	private:\n	char var;\n	Expression *retDiff;\n	public:\n	Variable(char v)\n	{\n			var=v;\n			retDiff=NULL;\n	}\n	~Variable()\n	{\n		 if (retDiff) delete retDiff;\n	}\n	Expression* diff()\n	{\n		 if (retDiff==NULL) retDiff = new Number(1);\n		 return retDiff;\n	}\n	void print()\n	{\n		 printf(\"%c\",var);\n	}\n};\n\nclass Add: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff;\n	public:\n	Add (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 retDiff=NULL;\n	};\n	~Add()\n	{\n		 if (retDiff) delete retDiff;\n	}\n	\n	Expression* diff()\n	{\n		 if (retDiff==NULL) retDiff=new Add (exp1->diff(),exp2->diff());\n		 return retDiff;\n	}\n	void print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"+\");\n		exp2->print();\n		printf(\")\");\n	}\n};\nclass Sub: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff;\n	public:\n\n	Sub (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 retDiff=NULL;\n	};\n	~Sub()\n	{\n		 if(retDiff) delete retDiff;\n	}\n	Expression* diff()\n	{\n		 if(retDiff==NULL) retDiff=new Sub (exp1->diff(),exp2->diff());\n		 return retDiff;\n	}\n	void print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"-\");\n		exp2->print();\n		printf(\")\");\n	}\n};\n\nclass Mul: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff, *mul1, *mul2;\n	\n	public:\n	Mul (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 mul1=NULL;\n		 mul2=NULL;\n		 retDiff=NULL;\n	};\n	~Mul()\n	{\n		 if (mul1) delete mul1;\n		 if (mul2) delete mul2;\n		 if (retDiff) delete retDiff;\n	}\n	\n	Expression* diff()\n	{\n		 if (mul1==NULL) mul1=new Mul (exp1->diff(),exp2);\n		 if (mul2==NULL) mul2=new Mul (exp1,exp2->diff());\n		 if (retDiff==NULL) retDiff=new Add (mul1,mul2);\n		 return retDiff;\n	\n	}\n	void\n	print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"*\");\n		exp2->print();\n		printf(\")\");\n	}\n};\nclass Div: public Expression\n{\n	private:\n	Expression *exp1, *exp2;\n	Expression *retDiff, *mul1, *mul2, *mul3, *sub;\n	\n	public:\n	Div (Expression *e1, Expression *e2)\n	{\n		 exp1=e1;\n		 exp2=e2;\n		 mul1=NULL;\n		 mul2=NULL;\n		 mul3=NULL;\n		 sub=NULL;\n		 retDiff=NULL;\n	}\n	~Div()\n	{\n		 if(mul1) delete mul1;\n		 if(mul2) delete mul2;\n		 if(mul3) delete mul3;\n		 if(sub)  delete sub;\n		 if(retDiff) delete retDiff;\n	}\n\n	Expression* diff()\n	{\n		 if (mul1==NULL) mul1=new Mul (exp1->diff(),exp2);\n		 if (mul2==NULL) mul2=new Mul (exp1,exp2->diff());\n		 if (sub==NULL) sub=new Sub (mul1,mul2);\n		 if (mul3==NULL) mul3=new Mul (exp2,exp2);\n		 if (retDiff==NULL) retDiff=new Div (sub,mul3);\n		 return retDiff;\n	}\n	void print()\n	{\n		printf(\"(\");\n		exp1->print();\n		printf(\"/\");\n		exp2->print();\n		printf(\")\");\n	}\n};\n/*\nExpression* read(char*x)\n{\n	char*y,*z;\n	if(strlen(x)==1)\n	{\n		if((x[0]<=\'9\')&&(x[0]>=\'0\'))\n		return new Number(x[0]-\'0\');\n		else\n		return new Variable(x[0]);\n	}\n	y=new char[strlen(x)];\n	z=new char[strlen(x)];\n	int i,j=0,k;\n	for (i=1;(j>0)||(i==1);i++)\n	{\n		if(*x==\'(\')\n		j++;\n		if(*x==\')\')\n		j--;\n		y[i-1]=*x;\n	}\n	y[i-1]=0;\n	k=i;\n	for(i=k+1;x[i+1];i++)\n	{\n		z[i-k-1]=*x;\n	}\n	z[i-k-1]=0;\n	if(x[k]==\'+\')\n	return new Add(read(y),read(z));\n	if(x[k]==\'-\')\n	return new Sub(read(y),read(z));\n	if(x[k]==\'*\')\n	return new Mul(read(y),read(z));\n	if(x[k]==\'/\')\n	return new Div(read(y),read(z));\n}\n*/\nExpression*\nmakeExp(Expression *e1, char op, Expression *e2)\n{ switch(op)\n	{case \'+\': return new Add(e1,e2);\n	 case \'-\': return new Sub(e1,e2);\n	 case \'*\': return new Mul(e1,e2);\n	 case \'/\': return new Div(e1,e2);\n	}\n return new Number(0);\n}\n\nchar* getOper(char *str)\n{char *ret = NULL;\n if (ret = strchr(str, \'+\')) return ret;\n if (ret = strchr(str, \'-\')) return ret;\n if (ret = strchr(str, \'*\')) return ret;\n if (ret = strchr(str, \'/\')) return ret;\n return ret;\n}\nchar* getClose(char *str)\n{ int i;\n  int len = strlen(str);\n  int num = 0;\n  for (i = 0; i < len; i++)\n	{if (str[i] == \'(\') num++;\n	 else if (str[i] == \')\') num--;\n	 if (num <= 0) break;\n	}\n  return  &str[i];\n}\n\nExpression* Read(char *str)\n{\n	Expression *exp1, *exp2;\n	char oper;\n	char *chr;\n\n	int i, j = 0;\n	int len = strlen(str);\n	for (i = 0; i < len ; i++)\n		{\n		if (str[i] == \' \') continue;\n		str[j] = str[i];\n		j++;\n		}\n	 str[j] = 0;\n	 len = j;\n\n	 if (str[0] == \'(\')\n	{\n		chr = getClose(str);\n		 if (chr - str < len-1)\n		{\n			chr[0] = 0;\n			 exp1 = Read(&str[1]);\n			 oper = chr[1];\n			 exp2 = Read(&chr[2]);\n			 return makeExp(exp1,oper,exp2);\n		}\n	 	else\n		{\n			chr[0] = 0;\n			return Read(&str[1]);\n		}\n	}\n else\n	{\n		chr = getOper(str);\n		if (chr)\n		{\n			oper = chr[0];\n			 chr[0] = 0;\n			 exp1 = Read(str);\n			 exp2 = Read(&chr[1]);\n			 return makeExp(exp1,oper,exp2);\n		}\n	 else \n		{if (isalpha(str[0])) return new Variable(str[0]);\n		 else {\n			int num;\n			sscanf(str, \"%d\", &num);\n			return new Number(num);\n		  }\n		}\n	}\n}\n\nint main()\n{\n	Expression *e=new Div(new Number(1), new Add(new Variable(\'x\'), new Number(1)));\n	printf(\"\\n\");\n	e->print();\n	printf(\"\\n\");\n	printf(\"\\n\");\n	\n	Expression *de = e->diff();\n	de->print();\n	printf(\"\\n\");\n	delete e;\n	delete de;\n\n	std::string s;\n	std::cin >> s;\n	char *str = new char[s.size() + 1];\n	strcpy(str, s.c_str());\n	e = Read(str);\n	e->print();\n	std::cout << \"\\n\";\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (501,'#include <iostream>\n\ntemplate <typename T> class List\n{\n	private:\n		struct element\n		{\n			T data;\n			element *next;\n			element *prev;\n		};\n		element *head;\n		element *tail;\n		int len;\n	List(const List &p);\n	List& operator=(const List& other); \n	public:\n		class Iterator\n		{\n		private:\n			element* i;\n		public:\n			Iterator()\n				{\n					i=0;\n				}\n			Iterator(element *a)\n				{\n					i=a;\n				}\n			Iterator(const Iterator &other)\n				{\n					i=other.i;\n				}\n			~Iterator()\n				{\n				}\n			Iterator& operator++()\n				{\n					i=i->next;\n					return *this;\n				}\n			Iterator& operator--()\n				{\n					i=i->prev;\n					return i;\n				}\n			T* operator->()\n			{\n				return &(i->data);\n			}\n			T& operator*()\n			{\n				return i->data;\n			}\n			int operator==(const Iterator other)\n			{\n				if (other.i==i)\n					return 1;\n				else \n					return 0;\n			}\n			int operator!=(const Iterator other)\n			{\n				if (other.i==i)\n					return 0;\n				else \n					return 1;\n			}\n			Iterator& operator=(const Iterator &other)\n			{\n				i=other.i;\n				return *this;\n			}\n		};\n	Iterator begin() const\n	{\n		return Iterator(head);\n	}\n	Iterator end() const\n	{\n		return Iterator(0);\n	}\n		List()\n		{\n			head=0;\n			tail=0;\n			len=0;\n		}\n		void pst1(const T c)\n		{\n			struct element *q;\n			q=new struct element[1];\n			if (len)\n				{\n					head->prev=q;\n					q->next=head;\n					q->prev=0;\n					head=q;\n					q->data=c;\n				}\n				else\n				{\n					head=q;\n					tail=q;\n					q->next=0;\n					q->prev=0;\n					q->data=c;\n				}\n			len++;\n		}\n\n		void del1()\n		{\n			if (len==0)\n				return;\n			if (len==1)\n			{\n				struct element *t;\n				t=head;\n				head=0;\n				tail=0;\n				len=0;\n				delete t;\n			}\n			else\n			{\n				struct element *t;\n				t=head;\n				head=head->next;\n				head->prev=0;\n				len--;\n				delete t;\n			}\n		}\n\n		~List()\n		{\n			struct element *p,*q;\n			p=head;\n			q=0;\n			for (p=head;p;p=p->next)\n			{\n				if (q) \n					delete q;\n				q=p;\n			}\n			delete p;\n			len=0;\n		}\n\n\n\n		void pst2(const T c)\n		{\n			struct element *p;\n			p = new struct element[1];\n			if (len)\n				{\n					tail->next=p;\n					p->next=0;\n					p->prev=tail;\n					tail=p;\n					p->data=c;\n				}\n				else\n				{\n					head=p;\n					tail=p;\n					p->next=0;\n					p->prev=0;\n					p->data=c;\n				}\n		len++;\n		}\n\n\n		void del2()\n		{\n			if (len==0)\n				return;\n			if (len==1)\n			{\n				struct element *t;\n				t=head;\n				head=0;\n				tail=0;\n				len=0;\n				delete t;\n			}\n			else\n			{\n				struct element *t;\n				t=tail;\n				tail=tail->prev;\n				tail->next=0;\n				len--;\n				delete t;\n			}\n		}\n		\n		void pr()\n		{\n		std::cout << \"\\n  \";\n		struct element *p;\n		for (p=head;p;p=p->next)\n			std::cout << p->data << \"| \";\n		std::cout <<\"\\n \" <<len<<\"\\n\";\n		}\n\n\n};\nint main()\n{\n	List<int> qqq;\n\n	for (int i = 0; i < 5; i++)\n	{\n		qqq.pst2(i);\n		qqq.pst1(i);\n		qqq.pr();\n	}\n\n	for (List<int>::Iterator i = qqq.begin(); i != qqq.end(); ++i)\n	{\n		std::cout << *i << \"\\n\";\n	}\n\n	for (int i = 0; i < 5; i++)\n	{\n		qqq.del1();\n		qqq.del2();\n		qqq.pr();\n	}\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (502,'#include <iostream>\nusing namespace std;\n\n        template <typename T> class List\n        {\n        struct element\n        {\n                T data;\n                element *next;\n        };\n        element *head;\n	\n	\n	List (const List& orig)\n	{\n	}\n\n	List operator=(const List& orig)\n	{\n	}\n\n        public:\n                List ()\n                {\n                        head = 0;\n                }\n\n                void insert (T p) //??????? ? ??????\n                {\n                        element* e;\n                        e = new element;\n                        e->data = p;\n                        e->next = head;\n                        head = e;\n                }\n\n                void del () //???????? ???????\n                {\n                        element* e;\n                        e = head->next;\n                        delete head;\n                        head = e;\n                }\n\n                ~List()\n                {\n                        while(head!=0)\n                                del ();\n                        delete head;\n                }\n\n                void print () //?????? ??????\n                {\n                        element *p;\n                        p = head;\n                        while (p)\n                        {\n                                cout<<p->data;\n                                cout<<\" \";\n                                p = p->next;\n                        }\n                        cout<<\" \\n\";\n                }\n\n\n                element*  per() //??????? ?????? (?????????? ????????????? ??????? ??????)\n                {\n                        element *p;\n                        p = new element;\n                        p = head;\n                        if (p->next)\n                           while ((p->next->next))\n                                p = p->next;\n                        return p;\n\n                }\n\n                void ins_last (T p) //??????? ? ?????\n                {\n			if (!head)\n			{\n				insert(p);\n				return;\n			}\n                        element *e;\n                        element *f;\n                        e = new element;\n                        e->next = NULL;\n                        e-> data = p;\n                        f = this->per();\n			f = f->next;\n                        if (f)\n                           f->next = e;\n                        else f = e;\n\n                }\n\n                void del_last () //???????? ??????????\n                {\n			if (!head->next)\n			{\n				del();\n				return;\n			}\n                        element *e;\n			e = new element;\n			element *f;\n			f = new element;\n			e = this->per();\n			f = e->next;\n			delete f;\n			e->next = NULL;\n                }\n	class Iterator\n	{\n	private:\n		element *p;\n\n	public:\n		Iterator(element *q)\n		{\n			p = q;\n		}	\n		\n		T operator* () const\n		{\n			return p->data;\n		}\n\n		T* operator-> () const\n		{\n			return &p->data;\n		}\n\n		Iterator& operator++ ()\n		{\n			p = p->next;\n			return *this;\n		}\n\n		int  operator!= (const Iterator &other) const\n		{\n			if(p!=other.p)\n\n				return (1);\n			else\n				return (0);\n		}	\n		\n	};\n\n	Iterator begin() const {  return Iterator(head); }\n	Iterator end() const { return Iterator(NULL); }\n        };\n\nint main()\n{\n        List <int> p;\n        for (int i = 0; i < 5; i++)\n        {\n		p.ins_last(i);\n                p.insert(i);\n                p.print();\n        }\n\n	for (List<int>::Iterator i = p.begin(); i != p.end(); ++i)\n	{\n		std::cout << *i << \"\\n\";\n	}\n\n	for (int i = 0; i < 5; i++)\n	{\n		p.del();\n		p.del_last();\n		p.print();\n	}\n	return 0;\n}\n\n\n                                                 \n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (503,'#include <iostream>\r\n\r\nclass Expression{\r\n	public:\r\n		virtual Expression *diff()=0;\r\n		virtual void print()=0;\r\n	};\r\nclass Number: public Expression{\r\n		double data;\r\n	public:\r\n		Number(double dat){\r\n			data=dat;\r\n			}\r\n		Expression *diff(){\r\n			Number *n=new Number(0);\r\n			return n;\r\n			}\r\n		void print(){\r\n			std::cout << data;\r\n			}\r\n	};\r\nclass Variable: public Expression{\r\n		char data;\r\n	public:\r\n		Variable(char dat){\r\n			data=dat;\r\n			}\r\n		Expression *diff(){\r\n			Number *n=new Number(1);\r\n			return n;\r\n			}\r\n		void print(){\r\n			std::cout << data;\r\n			}\r\n	};\r\nclass Add: public Expression{\r\n		Expression *item1, *item2;\r\n	public:\r\n		Add(Expression *it1,Expression *it2){\r\n			item1=it1;\r\n			item2=it2;\r\n			}\r\n		~Add(){\r\n			delete item1;\r\n			delete item2;\r\n			}\r\n		Expression *diff(){\r\n			Add *a= new Add(item1->diff(),item2->diff());\r\n			return a;\r\n			}\r\n		void print(){\r\n			std::cout << \"(\";\r\n			item1->print();\r\n			std::cout << \"+\";\r\n			item2->print();\r\n			std::cout << \")\";\r\n			}\r\n	};\r\nclass Sub: public Expression{\r\n		Expression *item1, *item2;\r\n	public:\r\n		Sub(Expression *it1,Expression *it2){\r\n			item1=it1;\r\n			item2=it2;\r\n			}\r\n		~Sub(){\r\n			delete item1;\r\n			delete item2;\r\n			}\r\n		Expression *diff(){\r\n			Sub *a= new Sub(item1->diff(),item2->diff());\r\n			return a;\r\n			}\r\n		void print(){\r\n			std::cout << \"(\";\r\n			item1->print();\r\n			std::cout << \"-\";\r\n			item2->print();\r\n			std::cout << \")\";\r\n			}\r\n	};\r\nclass Mul: public Expression{\r\n		Expression *item1, *item2;\r\n	public:\r\n		Mul(Expression *it1,Expression *it2){\r\n			item1=it1;\r\n			item2=it2;\r\n			}\r\n		~Mul(){\r\n			delete item1;\r\n			delete item2;\r\n			}\r\n		Expression *diff(){\r\n			Add *a= new Add(new Mul(item1->diff(),item2),new Mul(item1,item2->diff()));\r\n			return a;\r\n			}\r\n		void print(){\r\n			std::cout << \"(\";\r\n			item1->print();\r\n			std::cout << \"*\";\r\n			item2->print();\r\n			std::cout << \")\";\r\n			}\r\n	};\r\nclass Div: public Expression{\r\n		Expression *item1, *item2;\r\n	public:\r\n		Div(Expression *it1,Expression *it2){\r\n			item1=it1;\r\n			item2=it2;\r\n			}\r\n		~Div(){\r\n			delete item1;\r\n			delete item2;\r\n			}\r\n		Expression *diff(){\r\n			Div *a= new Div(new Sub(new Mul(item1->diff(),item2),\r\n					new Mul(item1,item2->diff())),new Mul(item2,item2));\r\n			return a;\r\n			}\r\n		void print(){\r\n			std::cout << \"(\";\r\n			item1->print();\r\n			std::cout << \"/\";\r\n			item2->print();\r\n			std::cout << \")\";\r\n			}\r\n	};\r\n\r\nclass Sin: public Expression{\r\n		Expression *p;\r\n	public:\r\n		Sin(Expression *v){\r\n			p=v;\r\n			}\r\n		Expression *diff();\r\n		void print(){\r\n			std::cout << \"sin(\";\r\n			p->print();\r\n			std::cout << \")\";\r\n			}\r\n	};\r\nclass Cos: public Expression{\r\n		Expression *p;\r\n	public:\r\n		Cos(Expression *v){\r\n			p=v;\r\n			}\r\n		Expression *diff(){\r\n			Expression *d=new Sub(new Number(0),new Mul(new Sin(p),p->diff()));\r\n			return d;\r\n			}\r\n		void print(){\r\n			std::cout << \"cos(\";\r\n			p->print();\r\n			std::cout << \")\";\r\n			}\r\n	};\r\n\r\nExpression *Sin::diff()\r\n{\r\n	Expression *d=new Mul(new Cos(p), p->diff());\r\n	return d;\r\n}\r\n\r\nint main(){\r\n	Expression *e =new Div(new Number(1),new Add(new Variable(\'x\'),new Number(3)));\r\n	Expression *de = e->diff();\r\n	e->print();\r\n	std::cout << \"\\n\";\r\n	de->print();\r\n	return 0;\r\n	}','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (504,'#include <iostream>\r\n#include <cmath>\r\nclass expression\r\n{\r\npublic:\r\n	virtual expression* diff()=0;\r\n	virtual void print()=0;\r\n};\r\nclass number: public expression\r\n{\r\n	int x;\r\npublic:\r\n	number(int a)\r\n	{\r\n		x=a;\r\n	}\r\n	expression* diff()\r\n	{\r\n		return new number(0);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<x;\r\n	}\r\n};\r\nclass variable: public expression\r\n{\r\n	char x;\r\npublic:\r\n	variable(char a)\r\n	{\r\n		x=a;\r\n	}\r\n	expression *diff()\r\n	{\r\n		return new number(1);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<x;\r\n	}\r\n};\r\nclass add: public expression\r\n{\r\n	expression *s;\r\n	expression *t;\r\npublic:\r\n	add(expression*a,expression*b)\r\n	{\r\n		s=a;\r\n		t=b;\r\n	}\r\n	expression* diff()\r\n	{\r\n		return new add(s->diff(),t->diff());\r\n	}\r\n	void print()\r\n	{\r\n		s->print();\r\n		std::cout<<\"+\";\r\n		t->print();\r\n	}\r\n		\r\n};\r\nclass sub: public expression\r\n{\r\n	expression *s;\r\n	expression *t;\r\npublic:\r\n	sub(expression*a,expression*b)\r\n	{\r\n		s=a;\r\n		t=b;\r\n	}\r\n	expression* diff()\r\n	{\r\n		return new sub(s->diff(),t->diff());\r\n	}\r\n	void print()\r\n	{\r\n		s->print();\r\n		std::cout<<\"-\";\r\n		t->print();\r\n	}\r\n};\r\nclass mul: public expression\r\n{\r\n	expression *s;\r\n	expression *t;\r\npublic:\r\n	mul(expression *a ,expression *b): s(a),t(b){}\r\n	expression* diff()\r\n	{\r\n		return new add(new mul(s->diff(),t),new mul(s,t->diff()));	\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<\"(\";\r\n		s->print();\r\n		std::cout<<\"*\";\r\n		t->print();\r\n		std::cout<<\")\";\r\n	}\r\n};\r\nclass Div: public expression\r\n{\r\n	expression *s;\r\n	expression *t;\r\npublic:\r\n	Div(expression *a ,expression *b): s(a),t(b){}\r\n	expression* diff()\r\n	{\r\n		return new Div(new sub(new mul(s->diff(),t),new mul(s,t->diff())),new mul(t,t));	\r\n	}\r\n	void print()\r\n	{\r\n		std::cout<<\"(\";\r\n		s->print();\r\n		std::cout<<\")\";\r\n		std::cout<<\"/\";\r\n		t->print();\r\n	}\r\n};\r\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (505,'#include <iostream>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\n//calculates number of digits\nint length (int const i_n)\n{\n	int buf = i_n, i;\n	for (i =  1; (buf /= 10) >= 1; ++i) {};	\n	return i;\n}\n\n//checks two strings by chars\nbool areEqual (char const * i_first, char const * i_second)\n{\n	int len = strlen (i_first);\n	if (len != strlen (i_second))\n	{\n		return false;\n	}\n	for (int i = 0; i < len; ++i)\n	{\n		if (i_first[i] != i_second[i])\n		{\n			return false;\n		}\n	}\n	return true;\n}\n\n//checks char by comparing it with digits\nbool isNumber (char const i_ch)\n{\n	char base[] = \"1234567890\";\n	int rightCh = 0;\n	for (int i = 0; i < 10; ++i)\n	{\n		if (i_ch == base[i])\n		{\n			++rightCh;\n		}\n	}\n	if (rightCh)\n	{\n		return true;\n	}\n	return false;\n}\n\n\n//checks string by chars by comparing with digits\nbool isNumber (char const * i_str)\n{\n	char base[] = \"1234567890\";\n	int rightCh;\n	int j = 0;\n	if (i_str[0] == \'-\')\n	{\n		j = 1;\n	}\n	while (i_str[j])\n	{\n		rightCh = 0;\n		for (int i = 0; i < 10 ; ++i)\n		{\n			if (base[i] == i_str[j])\n			{\n				++rightCh;\n			}\n		}\n		if (!rightCh)\n		{\n			return false;\n		}\n		++j;\n	}\n	return true;\n}\n\nbool isSign(char i_ch)\n{\n	char base[] = \"()+-/*^ \\n\";\n	int len = strlen (base);\n	int rightCh = 0;\n	for (int i = 0; i < len; ++i)\n	{\n		if (i_ch == base[i])\n		{\n			++rightCh;\n		}\n	}\n	if (rightCh)\n	{\n		return true;\n	}\n	return false;\n}\n\nclass expression\n{\npublic:\n	virtual expression * diff (char const * i_var) const = 0;\n	virtual char const * getData () const {return \"\";};\n	virtual void print() const = 0;\n	virtual char getType() const = 0;\n	virtual expression * getCopy() = 0;\n	virtual expression * simplify() {return this;};\n	virtual ~expression () {};\n};\n\nclass number : public expression\n{\npublic:\n	//constructor from char\n	number (char const i_ch)\n	{\n		if (!isNumber (i_ch))\n		{\n			std::cout << \"\\nIt is not a number!\\n\";\n			throw (\"It is not number!\");\n		}\n		data = new char [1];\n		data[0] = i_ch;\n	}	\n\n	//constructor from int\n	number (int i_n)\n	{\n		data = new char [length (i_n) + 1];\n		sprintf (data, \"%i\", i_n);\n	}\n\n	//constructor from string\n	number (char const * i_str)\n	{\n		if (!isNumber (i_str))\n		{\n			std::cout << \"\\nIt is not a number!\\n\";\n			throw (\"It is not number!\");\n		}\n		int len = strlen (i_str) + 1;\n		data = new char [len];\n		strcpy (data, i_str);\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new number (data);\n	}\n\n	//destructor\n	~number()\n	{\n		delete data;\n	}\n\n	//returns value of object\n	char const * getData () const\n	{\n		return data;\n	}\n\n	//simplifies the expression\n	expression * simplify() const\n	{\n		return new number (data);\n	}\n\n	//\n	expression * diff (char const * i_var) const\n	{\n		return new number (\'0\');\n	}\n\n	//returns type of the object\n	char getType () const\n	{\n		return \'n\';\n	}\n\n	//print\n	void print () const\n	{\n		if (atoi (data) < 0)\n		{\n			std::cout << \"(\" << data << \")\";\n			return;\n		}\n		std::cout << data;\n	}\n\nprivate:\n	char * data;\n};\n\nclass variable : public expression \n{\npublic:\n	//constructor from char\n	variable (char const i_ch)\n	{\n		data = new char [1];\n		data[0] = i_ch;\n	}	\n\n	//constructor from string\n	variable (char const * i_str)\n	{\n		int len = strlen (i_str) + 1;\n		data = new char [len];\n		strcpy (data, i_str);\n	}\n\n	//destructor\n	~variable()\n	{\n		delete data;\n	}\n\n	//returns copy of the object\n	expression * getCopy() \n	{\n		return new variable (data);\n	}\n\n	//returns value of object\n	char const * getData () const\n	{\n		return data;\n	}\n\n	//simplifies the expression\n	expression * simplify() const\n	{\n		return new variable (data);\n	}\n\n	//\n	expression * diff (char const * i_var) const\n	{\n		if (areEqual (i_var, data))\n		{\n			return new number (\'1\');\n		}\n		return new number (\'0\');\n	}\n	\n	//returns type of the object\n	char getType () const\n	{\n		return \'v\';\n	}\n\n	//print\n	void print() const\n	{	\n		std::cout << data;\n	}\n\nprivate:\n	char * data;\n};\n\nclass add : public expression\n{\npublic:\n	//constructor\n	add (expression * i_first, expression * i_second)\n	{\n		first = i_first->getCopy();\n		second = i_second->getCopy();\n	}\n\n	//destructor\n	~add()\n	{\n		delete first;\n		delete second;\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new add (first, second);\n	}\n\n	//simplifies the expression\n	expression * simplify() const\n	{\n		if (first->getType() == \'n\')\n		{\n			if (second->getType() == \'n\')\n			{\n				return new number (atoi (first->getData()) + atoi (second->getData() )); \n			}\n		}\n		return new add (first, second);\n	}\n\n	//\n	expression * diff (char const * i_var) const\n	{\n		return new add (first->diff(i_var), second->diff(i_var));\n	}\n\n	//returns type of the object\n	char getType() const\n	{\n		return \'+\';\n	}\n\n	//print\n	void print() const\n	{\n		std::cout << \"(\";\n		first->print();\n		std::cout << \" + \";\n		second->print();\n		std::cout << \")\";\n	}\nprivate:\n	expression * first;\n	expression * second;	\n};\n\nclass sub : public expression\n{\npublic:\n	//constructor\n	sub (expression * i_first, expression * i_second)\n	{\n		first = i_first->getCopy();\n		second = i_second->getCopy();\n	}\n\n	//destructor\n	~sub()\n	{\n		delete first;\n		delete second;\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new sub (first, second);\n	}\n\n	//\n	expression * diff (char const * i_var) const\n	{\n		return new sub (first->diff(i_var), second->diff(i_var));\n	}\n\n	//returns type of the object\n	char getType() const\n	{\n		return \'-\';\n	}\n\n	//print\n	void print() const\n	{\n		std::cout << \"(\";\n		first->print();\n		std::cout << \" - \";\n		second->print();\n		std::cout << \")\";\n	}\nprivate:\n	expression * first;\n	expression * second;	\n};\n\nclass mul : public expression\n{\npublic:\n	//constructor\n	mul (expression * i_first, expression * i_second)\n	{\n		first = i_first->getCopy();\n		second = i_second->getCopy();\n	}\n\n	//destructor\n	~mul()\n	{\n		delete first;\n		delete second;\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new mul (first, second);\n	}\n\n	//\n	expression * diff (char const * i_var) const\n	{\n		return new add (new mul ( first->diff(i_var), second ), new mul ( first, second->diff (i_var) ));\n	}\n\n	//returns type of the object\n	char getType() const\n	{\n		return \'*\';\n	}\n\n	//print\n	void print() const\n	{\n	//	std::cout << \"(\";\n		first->print();\n		std::cout << \"*\";\n		second->print();\n	//	std::cout << \")\";\n	}\nprivate:\n	expression * first;\n	expression * second;	\n};\n\nclass powr : public expression\n{\npublic:\n	//constructor\n	powr (expression * i_base, expression * i_power)\n	{\n		base = i_base->getCopy();\n		power = i_power->getCopy();\n	}\n\n	//destructor)\n	~powr()\n	{\n		delete base;\n		delete power;\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new powr (base, power);\n	}\n\n	//\n	expression * diff (char const * i_var) const\n	{\n\n		if (power->getType() != \'n\')\n		{\n			std::cout << \"\\nSorry, I cannot differentiate this shit. Power is not a number.\\n\";\n			throw (\"Sorry, I cannot differentiate this shit. Power is not a number.\");\n		}\n		return new mul (new mul (power, new powr (base, new sub (power, new number (\'1\')))), base->diff(i_var) );\n	}\n\n	//returns type of the object\n	char getType() const\n	{\n		return \'^\';\n	}\n\n	void print() const\n	{\n		std::cout << \"(\";\n		base->print();\n		std::cout << \")\";\n		std::cout << \"^\";\n		std::cout << \"(\";\n		power->print();\n		std::cout << \")\";\n	}\nprivate:\n	expression * base;\n	expression * power;\n};\n\nclass divs : public expression //first is a nominator, second is a denominator\n{\npublic:\n	//constructor\n	divs (expression * i_first, expression * i_second)\n	{\n		first = i_first->getCopy();\n		second = i_second->getCopy();\n	}\n\n	//destructor\n	~divs()\n	{\n		delete first;\n		delete second;\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new divs (first, second);\n	}\n	\n	//\n	expression * diff (char const * i_var) const\n	{\n		return new divs (new sub (new mul( first->diff(i_var), second ), new mul ( first, second->diff (i_var) )), new powr (second, new number (\'2\')) );\n	}\n\n	//returns type of the object\n	char getType() const\n	{\n		return \'/\';\n	}\n\n	//print\n	void print() const\n	{\n//		std::cout << \"(\";\n		first->print();\n		std::cout << \"/\";\n		second->print();\n//		std::cout << \")\";\n	}\nprivate:\n	expression * first;\n	expression * second;	\n};\n\nclass c_sin : public expression\n{\npublic:\n	//constructor\n	c_sin (expression * i_exp)\n	{\n		data = i_exp->getCopy();\n	}\n\n	//destructor\n	~c_sin()\n	{\n		delete data;\n	}\n\n	//returns copy of the object\n	expression * getCopy ()\n	{\n		return new c_sin (data);\n	}\n\n	//\n	expression * diff (char const * i_var) const; \n\n	char getType () const\n	{\n		return \'s\';\n	}\n\n	//print\n	void print() const\n	{\n		std::cout << \"sin(\";\n		data->print();\n		std::cout << \")\";\n	}\nprivate:\n	expression * data;\n};\n\nclass c_cos : public expression\n{\npublic:\n	//constructor\n	c_cos (expression * i_exp)\n	{\n		data = i_exp->getCopy();\n	}\n\n	//destructor\n	~c_cos()\n	{\n		delete data;\n	}\n\n	//returns copy of the object\n	expression * getCopy()\n	{\n		return new c_cos (data);\n	}\n\n	//\n	expression * diff (char const * i_var) const	\n	{\n		return new mul (new mul (new number (\"-1\"), new c_sin (data)), data->diff(i_var));\n	}\n\n	char getType () const\n	{\n		return \'c\';\n	}\n\n	//print\n	void print() const\n	{\n		std::cout << \"cos(\";\n		data->print();\n		std::cout << \")\";\n	}\nprivate:\n	expression * data;\n};\n\n//diff for c_sin\nexpression * c_sin::diff(char const * i_var) const\n{\n	return new mul (new c_cos (data), data->diff(i_var));\n}\n\n//buffer string\nclass bufstr\n{\npublic:\n	bufstr ()\n	{\n		length = 0;\n		data = new char[1];\n		*data = 0;\n	}\n\n	bufstr (char i_ch)\n	{\n		length = 1;\n		data = new char[1];\n		*data = i_ch;\n	}\n\n	bufstr (char const * i_other)\n	{\n		length = strlen (i_other) + 1;\n		data = new char [length];\n		strcpy (data, i_other);\n	}\n\n	~bufstr()\n	{\n		delete data;\n	}\n\n	bufstr & operator+= (char const i_ch)\n	{	\n		if (length == 0)\n		{\n			length = 1;\n			*data = i_ch;\n			return *this;\n		}\n		char * buf = new char [length];\n		strcpy (buf, data);\n		delete data;\n		data = new char [length + 1];\n		strcpy (data, buf);\n		data [length] = i_ch;\n		++length;\n		data [length] = 0;\n		delete buf;\n		return *this;\n	}\n\n	char & operator[] (int index)\n	{\n		return data [index];\n	}\n\n	char const * getData()\n	{\n		return data;\n	}\n\n	bool isNotEmpty()\n	{\n		return (length > 0);\n	}\n\n	int getLen()\n	{\n		return length;\n	}\nprivate:\n	char * data;\n	int length;\n};\n\n//forward definition\nexpression * getBrackets();\n\n//returns a number or a variable\nexpression * getBasic()\n{\n	bufstr buf_s;\n	char buf_c = std::cin.get();\n	while (buf_c == \' \') {buf_c = std::cin.get();} //ignoring spaces\n	while (buf_c >= \'0\' && buf_c <= \'9\')\n	{\n		buf_s += buf_c;\n		buf_c = std::cin.get();\n	}\n	if (buf_s.isNotEmpty())\n	{\n		std::cin.putback (buf_c);\n		return new number (buf_s.getData());\n	}\n	if (buf_c == \'s\')\n	{\n		buf_c = std::cin.get();\n		if (buf_c == \'i\')\n		{\n			buf_c = std::cin.get();\n			if (buf_c == \'n\')\n			{\n				return new c_sin (getBrackets());\n			}\n			std::cin.putback (buf_c);\n			std::cin.putback (\'i\');\n			buf_c = \'s\';\n		}\n		else\n		{\n			std::cin.putback (buf_c);\n			buf_c = \'s\';\n		}\n	}\n	if (buf_c == \'c\')\n	{\n		buf_c = std::cin.get();\n		if (buf_c == \'o\')\n		{\n			buf_c = std::cin.get();\n			if (buf_c == \'s\')\n			{\n				return new c_cos (getBrackets());\n			}\n			std::cin.putback (buf_c);\n			std::cin.putback (\'o\');\n			buf_c = \'c\';\n		}\n		else\n		{\n			std::cin.putback (buf_c);\n			buf_c = \'c\';\n		}\n	}\n	while (!isSign(buf_c))\n	{\n		buf_s += buf_c;\n		buf_c = std::cin.get();\n	}\n	std::cin.putback (buf_c);\n	return new variable (buf_s.getData());\n}\n\n//forward definition\nexpression * getSum();\n\n//returns expression in brackets\nexpression * getBrackets()\n{\n	char buf_c = std::cin.get();\n	while (buf_c == \' \') {buf_c = std::cin.get();} //ignoring spaces\n	if (buf_c == \'(\')\n	{\n		expression * buf = getSum();\n		std::cin.get(); //reads the \')\'\n		return buf;\n	}	\n	std::cin.putback(buf_c);\n	return getBasic();\n}\n\n//returns an expression like * or /\nexpression * getFactor()\n{\n	expression * buf = getBrackets();\n	expression * result;\n	result = buf;\n	char buf_c = std::cin.get();\n	while (buf_c == \' \') {buf_c = std::cin.get();} //ignoring spaces\n	while (true)\n	{\n		switch (buf_c)\n		{\n			case \'*\':\n				buf =  new mul (buf, getBrackets());\n				break;\n			case \'/\':\n				buf =  new divs (buf, getBrackets());\n				break;\n			case \'^\':\n				buf =  new powr (buf, getBrackets());\n				break;\n			default:\n				std::cin.putback (buf_c);\n				return buf;\n		}\n		buf_c = std::cin.get();\n		while (buf_c == \' \') {buf_c = std::cin.get();} //ignoring spaces\n	}\n}\n\n//returns an expression like + or -\nexpression * getSum()\n{\n	expression * buf = getFactor();\n	char buf_c = std::cin.get();\n	while (buf_c == \' \') {buf_c = std::cin.get();} //ignoring spaces\n	while (true)\n	{\n		switch (buf_c)\n		{\n			case \'+\':\n				buf = new add (buf, getFactor());\n				break;\n			case \'-\':\n				buf = new sub (buf, getFactor());\n				break;\n			default:\n				std::cin.putback (buf_c);\n				return buf;\n		}\n		buf_c = std::cin.get();\n		while (buf_c == \' \') {buf_c = std::cin.get();} //ignoring spaces\n	}\n}\n\nint main()\n{\n	expression * a = getSum();\n	std::cout << \"\\n\";\n	a->print();\n	std::cout << \"\\n\\nEnter a variable\\n\";\n	char * buf = new char [100];\n	std::cin >> buf;\n	(a->diff(buf))->print();\n	std::cout << \"\\n\\n\";\n	delete a;\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (506,'#include <iostream>\r\n#include <string>\r\n#include <stack>\r\n#include <cstdio>\r\n#include <cctype>\r\n\r\nclass Expression\r\n{\r\npublic:\r\n	virtual Expression *diff() = 0;\r\n	virtual void print() = 0;\r\n	virtual ~Expression() {};\r\n	virtual Expression* clone() = 0; /*return new Expression();*/\r\n};\r\n\r\nclass Number: public Expression\r\n{\r\nprivate:\r\n	double s;\r\npublic:\r\n	Number(double a)\r\n	{\r\n		this->s = a;	\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Number(this->s);\r\n	} \r\n\r\n	Expression *diff()\r\n	{\r\n		return new Number(0);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<this->s;\r\n	}\r\n		\r\n};\r\n\r\nclass Variable: public Expression\r\n{\r\nprivate:\r\n	std::string s;\r\npublic:\r\n	Variable(std::string c)\r\n	{\r\n		this->s = c;\r\n	}\r\n	\r\n	Expression* clone()\r\n	{\r\n		return new Variable(this->s);\r\n	}\r\n\r\n	Expression *diff()\r\n	{\r\n		return new Number(1);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<this->s;\r\n	}\r\n\r\n};\r\n\r\nclass Sum :public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Sum(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Sum(e1->clone(), e2->clone());\r\n	}\r\n\r\n	Expression *diff()\r\n	{\r\n		return new Sum(e1->diff(), e2->diff());\r\n	}\r\n\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"+\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Sum()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n		//std::cout <<\"DestrSum\\n\";\r\n	}\r\n};\r\n\r\nclass Sub :public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Sub(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Sub(e1->clone(), e2->clone());\r\n	}\r\n\r\n	Expression *diff()\r\n	{\r\n		return new Sub(e1->diff(), e2->diff());\r\n	}\r\n\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"-\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n\r\n	~Sub()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n		//std::cout <<\"DestrSub\\n\";\r\n	}\r\n};\r\n\r\nclass Mul:public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Mul(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Mul(e1->clone(), e2->clone());\r\n	}\r\n\r\n	Expression *diff()\r\n	{\r\n		Expression *tmp2 = e2->clone();\r\n		Expression *tmp1 = e1->clone();\r\n		return new Sum(new Mul(e1->diff(),tmp2),new Mul(tmp1,e2->diff()));\r\n	}\r\n\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"*\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Mul()\r\n	{\r\n		delete e1;\r\n//		std::cout <<\"DestrMul\\n\";\r\n		delete e2;\r\n//		std::cout <<\"DestrMulfdssfgfsdgfgfdgj\\n\";\r\n	}\r\n};\r\n\r\nclass Div:public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Div(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone() \r\n	{\r\n		return new Div(e1->clone(), e2->clone());\r\n	}\r\n\r\n	Expression *diff()\r\n	{\r\n		Expression *tmp2 = e2->clone();\r\n		Expression *tmp1 = e1->clone();\r\n		Expression *tmp22 = e2->clone();\r\n		Expression *tmp222 = e2->clone();\r\n		return new Div(new Sub(new Mul(e1->diff(),tmp2),new Mul(tmp1,e2->diff())),new Mul(tmp22,tmp222));\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"/\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Div()\r\n	{\r\n		delete e1;\r\n//		std::cout <<\"DestrDiv\" << \"\\n\";\r\n		delete e2;\r\n//		std::cout <<\"DestrDivagfdggfgmdklfgf\" << \"\\n\";\r\n	}\r\n};\r\n\r\nExpression* razbor()\r\n{\r\n	char y;\r\n	Expression *e1;\r\n	Expression *e2;\r\n	Expression *temp;\r\n	std::stack<Expression*> stack2;\r\n	std::stack<char> stack1;\r\n	std::stack<char> stack3;\r\n	std::cout <<\"Input expression:\";\r\n	char c;	\r\n	std::string s = \"\";\r\n	bool flag = false;\r\n	for ( ; ; )\r\n	{\r\n		c = getchar();\r\n\r\n		if (!isalpha(c) && flag)\r\n		{\r\n			Expression *q = new Variable(s);\r\n			stack2.push(q);\r\n			flag = false;\r\n			s = \"\";\r\n		}\r\n\r\n		if (c == \'\\n\' || c == EOF)\r\n			break;\r\n\r\n		if (isspace(c))\r\n		{\r\n			continue;\r\n		}\r\n		else if (isdigit(c))\r\n		{\r\n			ungetc(c, stdin);\r\n			int n;\r\n			scanf(\"%d\", &n);\r\n			Expression *t = new Number(n);\r\n			stack2.push(t);\r\n		}\r\n		else if (isalpha(c))\r\n		{\r\n			s += c;\r\n			flag = true;\r\n		}\r\n		else \r\n		{\r\n			if (c == \'(\') {stack1.push(c);}\r\n			if (c == \')\') \r\n			{\r\n				char x;\r\n				while ((x = stack1.top()) != \'(\')\r\n				{	\r\n					e1 = stack2.top();\r\n					stack2.pop();\r\n					e2 = stack2.top();\r\n					stack2.pop();\r\n					if (x == \'+\') { temp = new Sum(e2,e1); stack2.push(temp); };\r\n					if (x == \'-\') {temp = new Sub(e2,e1); stack2.push(temp); };\r\n					if (x == \'*\') {temp = new Mul(e2,e1); stack2.push(temp); };\r\n					if (x == \'/\') {temp = new Div(e2,e1); stack2.push(temp); };\r\n					stack1.pop();\r\n				}\r\n				\r\n			}\r\n			if ((c == \'+\')||(c == \'-\')) \r\n			{\r\n				while (!stack1.empty())\r\n				{\r\n					y = stack1.top();\r\n					if (y != \'(\') {\r\n					if (y == \'+\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sum(e2,e1); stack2.push(temp);} else\r\n					if (y == \'-\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sub(e2,e1); stack2.push(temp);} else\r\n					if (y == \'*\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Mul(e2,e1); stack2.push(temp);} else\r\n					if (y == \'/\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Div(e2,e1); stack2.push(temp);} \r\n					stack1.pop(); } else { break;}\r\n				}\r\n\r\n			stack1.push(c);\r\n			}\r\n\r\n			if ((c == \'*\')||(c == \'/\')) \r\n			{\r\n				while (!stack1.empty())\r\n				{\r\n				y = stack1.top();\r\n				if ((y != \'(\')&&(y != \'+\')&&(y != \'-\')) {\r\n				if (y == \'*\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Mul(e2,e1); stack2.push(temp);} else\r\n				if (y == \'/\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Div(e2,e1); stack2.push(temp);} \r\n				stack1.pop(); } else { break;}\r\n				\r\n				}\r\n				stack1.push(c);\r\n			}\r\n		}\r\n	}\r\n		while (!stack1.empty())\r\n		{\r\n			y = stack1.top();\r\n			if (y == \'+\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sum(e2,e1); stack2.push(temp);} else\r\n			if (y == \'-\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sub(e2,e1); stack2.push(temp);} else\r\n			if (y == \'*\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Mul(e2,e1); stack2.push(temp);} else\r\n			if (y == \'/\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Div(e2,e1); stack2.push(temp);}\r\n			stack1.pop();\r\n		}\r\nstack2.top()->print();\r\nstd::cout <<\"\\n\";\r\nreturn stack2.top();\r\n};\r\n\r\nint main()\r\n\r\n\r\n{\r\n	Expression *s1 = razbor(); \r\n	Expression *s2 = s1->diff();\r\n	s2->print();\r\n	delete s1;\r\n	delete s2;\r\n	std::cout <<\"\\n\";\r\n	return 0;\r\n}','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (507,'// ChildView.cpp : implementation of the CChildView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"44.h\"\r\n#include \"ChildView.h\"\r\n#include <math.h>\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CChildView message handlers\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\n\r\ndouble f(double x)\r\n{\r\n	return sin(x);\r\n}\r\n\r\nvoid CChildView::OnPaint() \r\n{\r\n	CPaintDC dc(this); // device context for painting\r\n	CRect rect;\r\n	dc.GetWindow()->GetWindowRect(&rect);\r\n	int width=rect.Width();\r\n	int height=rect.Height();\r\n	int x0=width/2;\r\n	int y0=height/2;\r\n	dc.MoveTo(x0,0);\r\n	dc.LineTo(x0,height);\r\n	dc.MoveTo(0,y0);\r\n	dc.LineTo(width,y0);\r\n	dc.MoveTo(x0,y0);\r\n\r\n	int mx = 100;\r\n	int my = 100;\r\n\r\n	for(int i=0;i<width;i++)\r\n		{\r\n			double x = (double)(i - x0) / mx;\r\n			double y = f(x);\r\n			int j = y0 - y * my;\r\n			if (i == 0)\r\n				dc.MoveTo(i, j);\r\n			dc.LineTo(i, j);\r\n		}\r\n	// TODO: Add your message handler code here\r\n	\r\n	// Do not call CWnd::OnPaint() for painting messages\r\n}\r\n\r\n','ÐžÐ»ÑŒÐ³Ð°','Olga','f');
INSERT INTO `bias` VALUES (508,'// grafView.cpp : implementation of the CgrafView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"graf.h\"\r\n\r\n#include \"grafDoc.h\"\r\n#include \"grafView.h\"\r\n\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CgrafView\r\n\r\nIMPLEMENT_DYNCREATE(CgrafView, CView)\r\n\r\nBEGIN_MESSAGE_MAP(CgrafView, CView)\r\nEND_MESSAGE_MAP()\r\n\r\n// CgrafView construction/destruction\r\n\r\nCgrafView::CgrafView()\r\n{\r\n	// TODO: add construction code here\r\n\r\n\r\n}\r\n\r\nCgrafView::~CgrafView()\r\n{\r\n}\r\n\r\nBOOL CgrafView::PreCreateWindow(CREATESTRUCT& cs)\r\n{\r\n	// TODO: Modify the Window class or styles here by modifying\r\n	//  the CREATESTRUCT cs\r\n\r\n	return CView::PreCreateWindow(cs);\r\n}\r\n\r\n// CgrafView drawing\r\n\r\n#include <math.h>\r\nclass Expression\r\n{\r\n  public:\r\n         virtual Expression* diff(char p)=0;\r\n		 virtual float val(float x)=0;\r\n       //  virtual void print()=0;\r\n};\r\n\r\nclass Number:public Expression\r\n{\r\n      private:\r\n              float value;\r\n      public: \r\n              Number (float v)\r\n              {value=v;}\r\n              \r\n              Expression* diff(char p)\r\n              {return new Number(0);}  \r\n\r\n			  float val(float x)\r\n			  {return value;}\r\n              \r\n          /*    void print()\r\n              {cout<<value;}  */\r\n                 \r\n};\r\n\r\nclass Variable:public Expression\r\n{\r\n      private:\r\n              char name;\r\n      public: \r\n              Variable (char x)\r\n              {name=x;}\r\n              \r\n              Expression* diff(char p)\r\n              {\r\n              if (name==p)\r\n              return new Number(1);\r\n              return new Number(0);}  \r\n\r\n			  float val(float x)\r\n			  {return x;}\r\n              \r\n           /*   void print()\r\n              {cout<<name;}  */\r\n              \r\n};\r\n\r\n\r\nclass Add:public Expression\r\n{\r\n      private:\r\n              Expression* a1;\r\n              Expression* a2;\r\n      public: \r\n              Add(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n              Expression* diff(char p)\r\n              {return new Add(a1->diff(p),a2->diff(p));}  \r\n              \r\n         /*     void print()\r\n              {\r\n				cout<<\'(\';\r\n				a1->print();\r\n				cout<<\'+\';\r\n				a2->print();\r\n				cout<<\')\';\r\n			  }  */\r\n\r\n			  float val(float x)\r\n			  {return (a1->val(x)+a2->val(x));}\r\n			  ~Add()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			       \r\n};\r\n\r\nclass Sub:public Expression\r\n{\r\n      private:\r\n              Expression* a1;\r\n              Expression* a2;\r\n      public: \r\n              Sub(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n              Expression* diff(char p)\r\n              {return new Sub(a1->diff(p),a2->diff(p));}  \r\n              \r\n       /*       void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'-\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  */\r\n\r\n				float val(float x)\r\n			  {return (a1->val(x)-a2->val(x));}\r\n			~Sub()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			         \r\n};\r\n\r\n\r\nclass Mul:public Expression\r\n{\r\n	private:\r\n			Expression* a1;\r\n			Expression* a2;\r\n	public:\r\n			Mul(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n            Expression* diff(char p)\r\n            {\r\n				return new Add(new Mul(a1->diff(p), a2),new Mul(a1, a2->diff(p)));\r\n			\r\n			}  \r\n              \r\n         /*     void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'*\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  */\r\n				float val(float x)\r\n			  {return (a1->val(x)*a2->val(x));}\r\n\r\n			~Mul()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			   \r\n};\r\n\r\n\r\nclass Div:public Expression\r\n{\r\n	private:\r\n			Expression* a1;\r\n			Expression* a2;\r\n	public:\r\n			Div(Expression* x1, Expression* x2)\r\n              {a1=x1; a2=x2;}\r\n              \r\n            Expression* diff(char p)\r\n			{return new Div(new Sub(new Mul(a1->diff(p),a2),new Mul(a1,a2->diff(p))),new Mul(a2,a2));}  \r\n              \r\n       /*       void print()\r\n              {\r\n				  cout<<\'(\';\r\n				  a1->print();\r\n				  cout<<\'/\';\r\n				  a2->print();\r\n				  cout<<\')\';\r\n			  }  */\r\n\r\n			float val(float x)\r\n			  {return (a1->val(x)/a2->val(x));}\r\n\r\n			~Div()\r\n			  {\r\n				delete a1;\r\n				delete a2;\r\n			  }\r\n			  \r\n};\r\n\r\n\r\nclass Cos:public Expression\r\n{\r\n	private:\r\n			Expression* a;\r\n	public:\r\n			Cos(Expression* x)\r\n              {a=x;}\r\n              \r\n            Expression* diff(char p);\r\n\r\n		float val(float x)\r\n			  {return cos(x);}\r\n              \r\n         /*     void print()\r\n              {\r\n				  cout<<\"Cos\";\r\n				  cout<<\'(\';\r\n				  a->print();\r\n				  cout<<\')\';\r\n			  }  */\r\n			  \r\n};\r\n\r\n\r\nclass Sin:public Expression\r\n{\r\n	private:\r\n			Expression* a;\r\n	public:\r\n			Sin(Expression* x)\r\n              {a=x;}\r\n              \r\n            Expression* diff(char p)\r\n			{return new Mul(new Cos(a),a->diff(p));}  \r\n              \r\n		float val(float x)\r\n			  {return sin(x);}\r\n\r\n         /*     void print()\r\n              {\r\n				  cout<<\"Sin\";\r\n				  cout<<\'(\';\r\n				  a->print();\r\n				  cout<<\')\';\r\n			  }  */\r\n			  \r\n};\r\n\r\n\r\nExpression* read1(char *s)\r\n{\r\n			char c=s[0];\r\n\r\n			while(c!=\'\\0\')\r\n			{\r\n			c=s[0];\r\n			s++;\r\n			if ((\'0\'<=c)&(c<=\'9\') )\r\n			{\r\n				//cin.unget();\r\n				int a;\r\n				//cin>>a;\r\n				switch (c)\r\n				{\r\n				case\'0\': a=0;\r\n				case\'1\': a=1;\r\n				case\'2\': a=2;\r\n				case\'3\': a=3;\r\n				case\'4\': a=4;\r\n				case\'5\': a=5;\r\n				case\'6\': a=6;\r\n				case\'7\': a=7;\r\n				case\'8\': a=8;\r\n				case\'9\': a=9;\r\n				};\r\n\r\n				return new Number(a);\r\n		\r\n			/*  int a;\r\n			  a=c;\r\n			  return new Number(a);\r\n			  */\r\n	\r\n            }\r\n			if ((c!=\'(\')&&(c!=\')\')&&(c!=\'+\')&&(c!=\'-\')&&(c!=\'/\')&&(c!=\'*\')&&(c!=\'S\')&&(c!=\'C\'))\r\n			{\r\n				return new Variable(c);\r\n			}\r\n			if (c==\'(\')\r\n			{\r\n				char ch;\r\n				\r\n				Expression* a;\r\n				Expression* b;\r\n				a=read1(s);\r\n				s++;\r\n				c=s[0];\r\n				b=read1(s);\r\n			//	cin>>ch;\r\n				if (c==\'+\')\r\n					return new Add(a,b);\r\n				if (c==\'-\')\r\n					return new Sub(a,b);\r\n				if (c==\'*\')\r\n					return new Mul(a,b);\r\n				if (c==\'/\')\r\n					return new Div(a,b);\r\n			}\r\n			if (c==\'C\')\r\n			{\r\n				Expression* d;\r\n				//cin>>c;\r\n				//cin>>c;\r\n				//cin>>c;\r\n				d=read1(s+4);\r\n			//	cin>>c;\r\n				s=s+1;\r\n				return new Cos(d);\r\n			}\r\n\r\n			if (c==\'S\')\r\n			{\r\n				Expression* e;\r\n				//cin>>c;\r\n				//cin>>c;\r\n			//	cin>>c;\r\n				e=read1(s+4);\r\n			//	cin>>c;\r\n				s=s+1;\r\n				return new Sin(e);\r\n			}\r\n			s++;\r\n			}\r\n\r\n		 }\r\n		 \r\n		 \r\n/*Expression* read(char* s)\r\n{\r\n            int n=0,i;\r\n            while(*s!=\'\\0\')\r\n            {cout<<*s;\r\n            n++;}\r\n            for (i=1; i<=n; i++)\r\n            cin.unget();\r\n            return read1();\r\n             \r\n}\r\n*/\r\n\r\nExpression *Cos::diff(char p)\r\n{return new Mul(new Sub(new Number(0), new Sin(a)),a->diff(p));}  \r\n\r\n\r\n\r\n\r\n	\r\n\r\n\r\ndouble func(double x)\r\n	{\r\n\r\n	Expression *f;\r\n	f=read1(\"(x*x)\");\r\n//	std::cout << \"\\n\";\r\n	Expression *df = f->diff(\'x\');\r\n//	df->print();\r\n//	std::cout << \"\\n\"\r\n		return f->val(x);}\r\n\r\n\r\n//delete f;\r\n//	delete df;\r\n\r\nvoid CgrafView::OnDraw(CDC* pDC)\r\n{\r\n	CgrafDoc* pDoc = GetDocument();\r\n	ASSERT_VALID(pDoc);\r\n	\r\n	if (!pDoc)\r\n		return;\r\n\r\n	\r\n	// TODO: add draw code for native data here\r\n\r\n	\r\n\r\n\r\n//#include <iostream>\r\n//#include <ctype.h>\r\n//using namespace std;\r\n\r\n\r\n\r\n	\r\n	\r\n	\r\n\r\n\r\n	int xmax,ymax,cx,cy,i,j;\r\n	float n;\r\n	double x, y;\r\n\r\n	RECT rect;\r\n	pDC->GetWindow()->GetWindowRect(&rect);\r\n	\r\n	xmax=abs(rect.right-rect.left);\r\n	ymax=abs(rect.bottom-rect.top);\r\n	\r\n	cx=xmax/2;\r\n	cy=ymax/2;\r\n\r\n	pDC->MoveTo(cx,0);\r\n	pDC->LineTo(cx,ymax);\r\n	pDC->MoveTo(0,cy);\r\n	pDC->LineTo(xmax,cy);\r\n\r\n	n=0.01;\r\n\r\n	int mx = 100;\r\n	int my = 100;\r\n\r\n	for (i = 0; i < xmax; i++)\r\n	{\r\n		x = (double)(i-cx) / mx;\r\n		y = func(x);\r\n		j = -y*my+cy;\r\n		if (i==0) {pDC->MoveTo(i,j);} \r\n		else \r\n		{pDC->LineTo(i, j);}\r\n	}\r\n\r\n\r\n\r\n\r\n\r\n/*	for(i=0; i*n<xmax; i++)\r\n	{\r\n	x=i*n;\r\n	y=func(x-cx)*n;\r\n	if (x==0)\r\n		pDC->MoveTo(0,y);\r\n	else pDC->LineTo(x,y);\r\n\r\n	}\r\n*/\r\n}\r\n\r\n\r\n\r\n// CgrafView diagnostics\r\n\r\n#ifdef _DEBUG\r\nvoid CgrafView::AssertValid() const\r\n{\r\n	CView::AssertValid();\r\n}\r\n\r\nvoid CgrafView::Dump(CDumpContext& dc) const\r\n{\r\n	CView::Dump(dc);\r\n\r\n}\r\n\r\nCgrafDoc* CgrafView::GetDocument() const // non-debug version is inline\r\n{\r\n	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CgrafDoc)));\r\n	return (CgrafDoc*)m_pDocument;\r\n}\r\n#endif //_DEBUG\r\n\r\n\r\n// CgrafView message handlers\r\n','ÐÐ½Ð½Ð°','Anna','f');
INSERT INTO `bias` VALUES (509,'#include <stdio.h>\n#define N 101\n\nint n;\nint A[N][N];\nint visited[N] = { 0 };\nint dist[N];\nint path[N];\nint INF = 10000000;\n\nvoid dijkstra(int s) {\n	int i,it;\n	for (i = 1; i <= n; i++) {\n		visited[i] = 0;\n		dist[i] = INF;\n	}\n\n	dist[s] = 0;\n	path[s] = 0;\n	for (it = 0; it < n; it++) {\n		int mn = INF;\n		int v = -1;\n		for (i = 1; i <= n; i++)\n			if (!visited[i] && mn > dist[i]) {\n				mn = dist[i];\n				v = i;\n			}\n	                \n		if (v == -1)\n			break;\n		visited[v] = 1;\n		for (i = 1; i <= n; i++)\n			if (!visited[i] && A[v][i] != -1 && dist[i] > dist[v] + A[v][i]) {\n				dist[i] = dist[v] + A[v][i];\n				path[i] = v;\n			}\n	}\n}\n\nvoid print(int a) {\n	if (a == 0)\n		return;\n	print(path[a]);\n	printf(\"%d \", a);\n}\n\nint main() {\n	FILE *f = fopen(\"input20.txt\", \"r\");\n	int i,j,m,s;\n	printf(\"Kolichestvo reber: \");\n	fscanf(f, \"%d %d %d\", &n, &m, &s);\n	printf(\"%d\\n\", m);\n	printf(\"Nachalnaya vershina: %d\\n\", s);\n	for (i = 1; i<=n; i++)\n		for (j =1; j<=n; j++)\n			A[i][j] = -1;\n	for (i = 1; i <= m; i++) {\n		int a,b,c;\n		fscanf(f, \"%d %d %d\", &a, &b, &c);\n		printf(\"edge: %d %d %d\\n\", a, b, c);\n		A[a][b] = c;\n		A[b][a] = c;\n	}\n	fclose(f);\n	dijkstra(s);\n	for (i = 1; i <= n; i++) {\n		printf(\"%d: \", i);\n		if (dist[i] == INF) {\n		printf(\"no path\\n\");\n		} else {\n			printf(\" dist = %d, path = \", dist[i]);\n			print(i);\n			printf(\"\\n\");\n		}\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (510,'#include <stdio.h>\n#define N 101\n\nint A[N][N];\nint visited[N] = {0};\n\nvoid dfs(int c)\n{\n	int i;\n	printf(\"%d \", c);\n	visited[c] = 1;\n	for(i=1; i<=N; i++)\n	{\n		if(A[c][i] && !visited[i])\n		{\n			dfs(i);\n		}\n	}\n}\n\nint main ()\n{\n	int i,j,n,k;\n	FILE *f = fopen(\"input1.txt\", \"r\");\n	printf (\"Kolichestvo reber: \");\n	fscanf (f, \"%d\", &n);\n	printf (\"%d\\n\", n);\n	for(k=1; k<=n; k++)\n	{\n		fscanf(f, \"%d\", &i);\n		fscanf(f, \"%d\", &j);\n		A[i][j] = 1;\n		A[j][i] = 1;\n	}\n	printf(\"Dostigimy: \");\n	fclose(f);\n	dfs(1);\n	printf(\"\\n\");\n	return 0;\n}\n		\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (511,'#include <stdio.h>\n#define N 101\n\nstruct queue\n{\n	int E[N];\n	int r;\n	int w;\n};\n\nvoid init(struct queue *q)\n{\n	q->r = q->w = 0;\n}\n\nvoid e(struct queue *q, int a)\n{\n	q->E[q->w++] = a;\n}\n\nint d(struct queue *q)\n{\n	return q->E[q->r++];\n}\n\nint empty(struct queue *q)\n{\n	return (q->r == q->w);\n}\n\nvoid bfs(int A[N][N], int c)\n{\n	int i;\n	int visited[N] = {0};\n	struct queue q;\n	init(&q);\n	e(&q, c);\n	visited[c] = 1;\n	while (!empty(&q))\n	{\n		c = d(&q);\n		printf(\"%d \", c);\n		for (i=1; i<N; i++)\n		{\n			if (A[c][i] && !visited[i])\n			{\n				e(&q, i);\n				//printf(\"%d \", i);\n				visited[i] = 1;\n			}\n		}\n	}\n}\n\nint main ()\n{\n	int A[N][N] = {0};\n	int i,j,n,k;\n	FILE *f = fopen(\"input1.txt\", \"r\");\n	printf (\"Kolichestvo reber: \");\n	fscanf (f, \"%d\", &n);\n	printf (\"%d\\n\", n);\n	for(k=1; k<=n; k++)\n	{\n		fscanf(f, \"%d\", &i);\n		fscanf(f, \"%d\", &j);\n		A[i][j] = 1;\n		A[j][i] = 1;\n	}\n	printf(\"Dostigimy: \");\n	fclose(f);\n	bfs(A, 1);\n	\n	printf(\"\\n\");\n	\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (512,'#include<stdio.h>\nvoid enqueue(int a,int *w,int *Q)\n{\n	Q[(*w)++]=a;\n}\nint dequeue(int *r,int *Q)\n{\n	return (Q[(*r)++]);\n}\nint empty(int r,int w)\n{\n	return(r==w);\n}\n\nvoid poisk(int A[][100], int v, int *vis, int N)\n{\n	int c,i,w=0,r=0,Q[100]={0};\n	enqueue(v,&w,Q);\n	vis[v]=1;\n	while(!empty(r,w))\n	{\n		c=dequeue(&r,Q);\n		printf(\"%d \",c);\n		for(i=1;i<=N;i++)\n		{\n			if(A[c][i]&&!vis[i])\n			{\n				enqueue(i,&w,Q);\n				vis[i]=1;\n			}\n		}\n	}\n}	\nint main()\n{\n	 FILE *f=fopen(\"INP.txt\",\"r\");\n	 int A[100][100],N, M,vis[100]={0},i,j,k,v;\n	 if(!f)\n	 {\n		 perror(\"INP.txt\");\n		 return 0;\n	 }\n	 fscanf(f,\"%d %d\",&N,&M);\n	 for(k=0;k<M;k++)\n	 {\n		 fscanf(f,\"%d %d\",&i,&j);\n		 A[i][j]=1;\n		 A[j][i]=1;\n	 }\n	 fscanf(f,\"%d\",&v);\n	 poisk(A,v,vis,N);\n	 printf(\"\\n\");\n	return 0;\n}\n	 \n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (513,'#include<stdio.h>\n#include<ctype.h>\nvoid CSV(FILE *fi,FILE *fo)\n{\n	int c, state=0,fl=0;\n	fprintf(fo,\"<table border=\\\"1\\\">\");\n	while((c=getc(fi))!=EOF)\n	{\n		if(state==0)\n		{\n			fprintf(fo,\"<tr>\");\n			state=1;//????????? ? ??????\n		}\n		if(state==1)\n		{\n			fprintf(fo,\"<td>\");\n			state=2;//????????? ? ??????\n		}\n		if(state==2)\n		{\n			/*if(isalpha(c)||c==\' \')\n			{\n				fprintf(fo,\"%c\",c);\n				continue;\n			}*/\n			if(c==\'\\n\')\n			{\n				fprintf(fo,\"</td></tr></br>\");		\n				state=0;\n				continue;\n			}\n			else\n			{\n				if(c==\',\')\n				{\n					fprintf(fo,\"</td>\");\n					state=1;\n					continue;\n				}\n				else\n				{\n					if(c==\'\"\')\n					{\n						state=3;\n						continue;\n					}\n					else\n					{\n						fprintf(fo,\"%c\",c);\n						continue;\n					}\n				}\n			}\n		}\n		if(state==3)\n		{\n			/*if(isalpha(c)||c==\' \')\n			{\n				fprintf(fo,\"%c\",c);\n				fl=1;\n				continue;\n			}*/\n			if(c==\',\')\n			{\n				fprintf(fo,\",\");\n				fl=1;\n				continue;\n			}\n			else\n			{\n				if(c==\'\\n\')\n				{\n					fprintf(fo,\"<br/>\\n\");\n					fl=1;\n					continue;\n				}\n				else\n				{\n					if(c==\'\"\')\n					{\n						state=4;\n						fl=0;\n						continue;\n					}\n					else\n					{\n						fprintf(fo,\"%c\",c);\n						continue;\n					}\n				}\n			}\n		}\n		if(state==4)\n		{\n			if(c==\'\"\'&!fl)\n			{\n				fprintf(fo,\"%c\",c);\n				state=3;\n				fl=0;\n				continue;\n			}\n			else\n			{\n				if(isalpha(c)||c==\' \')\n				{\n					fprintf(fo,\"%c\",c);\n					continue;\n				}\n				if(c==\'\\n\')\n				{\n					fprintf(fo,\"</td></tr>\");\n					state=0;\n					continue;\n				}\n				if(c==\',\')\n				{\n					fprintf(fo,\"</td>\");\n					state=1;\n					continue;\n				}\n			}\n			\n		}\n		\n	}\n\n	fprintf(fo,\"</table>\");\n}\nint main()\n{\n	FILE*fi=fopen(\"csvinput.txt\",\"r\"),*fo=fopen(\"public_html/csvoutput.htm\",\"w\");\n	CSV(fi,fo);\n	return 0;\n}\n\n							\n\n\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (514,'#include<stdio.h>\n#include<math.h>\nint emp(int *vis,int N)\n{		\n	int i;	\n	for(i=1;i<=N;i++)\n		if(vis[i]==0)\n			return 1;\n	return 0;\n}\nvoid dfs(float D[][100],int cur,int N,int *vis,int*prev,float *min,int *pr,float *MIN)\n{\n	int i;float min1=0;\n	vis[cur]=1;	\n	for(i=1;i<=N;i++)		\n		if(!vis[i]&&cur!=i)\n		{ min1=*min;\n			*min+=D[cur][i];\n			\n			prev[i]=cur;\n			\n			dfs(D,i,N,vis,prev,min,pr,MIN);\n			(*min)=min1;\n		}\n	\n	if(!emp(vis,N))\n	{\n		*min+=D[cur][pr[0]];\n		if((*min)<(*MIN))\n		{\n			(*MIN)=(*min);\n			\n			for(i=1;i<=N;i++)\n				pr[i]=prev[i];\n					\n		}\n	}\n	vis[cur]=0;					              \n	\n}\nstruct point{\n	float x;\n	float y;\n};\nvoid dlina(struct point *a,float D[][100],int N)\n{\n	int i,j;\n	float d;\n	for(i=1;i<=N;i++)\n		for(j=1;j<=N;j++)\n		{\n			D[i][j]=sqrt((a[i].x-a[j].x)*(a[i].x-a[j].x)+(a[i].y-a[j].y)*(a[i].y-a[j].y));\n		}\n}\n\nint main()\n{\n	FILE *f=fopen(\"fulldfsin.txt\",\"r\");\n	int p,q,N,v,k, vis[100]={0},prev[100]={0}, i,pr[100]={0};\n	struct point a[100];\n	float d,D[100][100]={0},min=0,MIN;\n	if(!f)\n	{\n		perror(\"Input.txt\");\n		return 0;\n	}\n	fscanf(f,\"%d \",&N);\n	for(v=1;v<=N;v++)\n		fscanf(f,\"%f%f\",&a[v].x,&a[v].y);       \n	dlina(a,D,N);\n	fscanf(f,\"%d \",&v);\n	pr[0]=v;\n	k=v;\n	MIN=N*N*D[2][1];\n	dfs(D,v,N,vis,prev,&min,pr,&MIN);\n	for(i=1;i<N+1;i++)\n	{\n		if(pr[i]==v)\n		{\n			printf(\"%d \",v);\n			v=i;\n			i=1;\n		}\n	}\n	printf(\"%d \",v);\n	printf(\"%d \",k);\n	printf(\"D=%.2f\\n \",MIN);\n	return 0;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (515,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct list \n{\n	int a;\n	struct list * next;\n};\n\nvoid l_insert(struct list * head, int n)\n{\n	if(n<head->a)\n	{\n		struct list * p=malloc(sizeof(struct list));\n		p->a=head->a;\n		head->a=n;\n		p->next=head->next;\n		head->next=p;		\n	}\n	else if(head->next==NULL)\n	{	\n		struct list *p=malloc(sizeof(struct list));\n		p->a=n;\n		p->next=NULL;\n		head-> next=p;\n	}\n	else l_insert(head-> next,n);\n}\n\nint main()\n{\n	FILE *f_in,*f_out;\n	struct list * head=malloc(sizeof(struct list));\n	struct list * p;\n	struct list * q;\n	int n;\n\n	f_in=fopen(\"input1.txt\",\"r\");\n	f_out=fopen(\"output1.txt\",\"w\");\n	\n	if(fscanf(f_in,\"%d\",&n)==1)\n	{	\n		head->a=n;\n		head->next=NULL;\n		while(fscanf(f_in,\"%d\",&n)==1)\n			l_insert(head,n);\n	}\n	p=head;\n	while(p!=NULL)\n	{	\n		fprintf(f_out,\"%d \",p->a);\n		q = p;\n		p=p->next;\n		free(q);\n	}\n	\n	fclose(f_in);\n	fclose(f_out);\n\n	return 0;\n												\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (516,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct tree \n{\n	int a;\n	struct tree * left;\n	struct tree * right;\n};\n\nvoid l_insert(struct tree * root, int n)\n{\n	if(root->a>n)\n		if(root->left==NULL)\n		{\n			struct tree * p=malloc(sizeof(struct tree));\n			p->a=n;\n			p->left=NULL;\n			p->right=NULL;\n			root->left=p;\n		}\n		else\n			l_insert(root->left,n);\n	else \n		if(root->right==NULL)\n		{	\n			struct tree * p=malloc(sizeof(struct tree));\n			p->a=n;\n			p->left=NULL;\n			p->right=NULL;\n			root->right=p;\n		}\n		else \n			l_insert(root->right,n);\n}\n\nvoid ret(struct tree * root, FILE * f_out)\n{\n	if(root->left)\n		ret(root->left,f_out);\n	fprintf(f_out,\"%d \",root->a);\n	if(root->right)\n		ret(root->right,f_out);\n}\n\nint main()\n{\n	FILE *f_in,*f_out;\n	struct tree * root=malloc(sizeof(struct tree));\n	int n;\n\n	f_in=fopen(\"input1.txt\",\"r\");\n	f_out=fopen(\"output1.txt\",\"w\");\n	\n	if(fscanf(f_in,\"%d\",&n)==1)\n	{	\n		root->a=n;\n		root->left=NULL;\n		root->right=NULL;\n		while(fscanf(f_in,\"%d\",&n)==1)\n			l_insert(root,n);\n	}\n	ret(root,f_out);\n\n	free(root); // !!!\n	\n	fclose(f_in);\n	fclose(f_out);\n	\n	return 0;\n											\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (517,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 30\nstruct list \n{\n	char a[N];\n	int count;\n	struct list * next;\n};\n\nvoid l_insert(struct list * head , char a[N])\n{\n	if(strcmp(head->a,a)==0)\n		head->count++;\n	else if(head->next)\n		l_insert(head->next, a);\n	else\n	{\n		struct list * p=malloc(sizeof(struct list));\n		strcpy(p->a,a);\n		p->count=1;\n		p->next=NULL;\n		head->next=p;\n	}\n}\n\nint main()\n{\n	FILE *f_in;\n	struct list * head=malloc(sizeof(struct list));\n	struct list * p;\n	char a[N];\n	char b;\n	int i=0;\n\n	f_in=fopen(\"input19.txt\",\"r\");\n	\n	while(fscanf(f_in,\"%c\",&b)==1)\n	{	\n		if( ((b>=\'a\')&&(b<=\'z\'))||((b>=\'A\')&&(b<=\'Z\')) )\n		{\n			a[i]=b;\n			i++;\n			a[i]=0;\n		}\n		else\n		{\n			if(i) l_insert(head,a);\n			i=0;	\n		}\n	}\n\n	p=head;\n\n	while(p)\n	{\n		printf(\"%s -- %d \\n\",p->a,p->count);\n		p=p->next;\n	}\n	\n	fclose(f_in);\n	\n	return 0;\n	\n}	\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (518,'#include <stdio.h>\n\nvoid sort(int* mass, int n)\n{\n	int i,j;\n	int min,tmp;\n	for(i=0;i<n;i++)\n	{\n		min=i;\n		for(j=i;j<n;j++)\n			if(mass[j]<mass[min])\n				min=j;\n		tmp=mass[i];\n		mass[i]=mass[min];\n		mass[min]=tmp;\n	}\n		\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (519,'#include <stdio.h>\n#include <stdlib.h>\n#define N 100\nunsigned int hcode(char *s)\n{\n	int i=0,sum=0;\n	while(s[i]!=0) sum = sum * 37 + s[i++];\n	return (sum%N);\n}\nint readword(char *s)\n{\n	char c;\n	int i=0;\n	while (1)\n	{\n		c=getchar();\n		if ((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\'))\n		{\n			s[i]=c;	\n			i++;\n		}\n		else break;\n	}\n	s[i]=0;\n	if (c==EOF) return -1;\n	if (s[0]==0) return readword(s);\n	return 0;\n}\nint main(int argc,char** argv)\n{\n	int j=0;\n	unsigned int curc;\n	char s[100];\n	struct item\n	{\n		char word[100];\n		int count;\n		struct item *next;\n	};\n	struct item *root[N],*p;\n	freopen(argv[1],\"r\",stdin);\n	for (j=0;j<N;j++) root[j]=NULL;\n	while(readword(s)!=-1)\n	{\n		curc=hcode(s);\n		if (root[curc]!=NULL)\n		{\n			p=root[curc];\n			while(p->next!=NULL)\n			{\n				if (strcmp(p->word,s)==0)\n				{\n					p->count++;\n					break;\n				}\n				p=p->next;\n			}\n			if (p->next==NULL)\n			{\n				if (strcmp(p->word,s)==0) p->count++;\n				else\n				{\n					p->next=malloc(sizeof(*p));\n					p->next->word[0]=0;\n					strcpy(p->next->word,s);\n					p->next->next=NULL;\n					p->next->count=1;\n				}\n			}\n		}\n		else\n		{\n			root[curc]=malloc(sizeof(*p));\n			root[curc]->word[0]=0;\n			strcpy(root[curc]->word,s);\n			root[curc]->next=NULL;\n			root[curc]->count=1;\n		}\n		\n	}\n	for (j=0;j<N;j++)\n	{\n		int c = 0;\n		p=root[j];\n		while (p!=NULL)\n		{\n			struct item *q;\n			c++;\n//			printf(\"%s %d\\n\",p->word,p->count);\n			q = p;\n			p=p->next;\n			free(q);\n		}\n		printf(\"%d => %d\\n\", j, c);\n	}\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (520,'#include <stdio.h>\n#include <math.h>\n#define N 100\ndouble min=10000;\nint cur_way[N],best_way[N],n;\nstruct koor\n{\n	double x,y;\n} k[N];\ndouble r(struct koor a,struct koor b)\n{\n	return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nvoid dfs(int cur,int* visited,double weight,int length)\n{\n	int i,flag=0;\n	visited[cur]=1;\n	cur_way[length]=cur;\n	for (i=0;i<n;i++)\n		if (visited[i]==0) \n		{\n			flag=1;	\n			dfs(i,visited,weight+r(k[cur],k[i]),length+1);\n		}\n	if (flag==0 && length==n-1) \n	{\n		weight+=r(k[0],k[cur]);\n		if (weight<min) \n		{\n			min=weight;\n			for (i=0;i<n;i++) best_way[i]=cur_way[i];\n		}\n	}\n	visited[cur]=0;\n}\nint main(int argc, char** argv)\n{\n	int i,visited[N]={0};\n	freopen(argv[1],\"r\",stdin);\n	scanf(\"%d\",&n);\n	for (i=0;i<n;i++) scanf(\"%lf%lf\",&k[i].x,&k[i].y);\n	dfs(0,visited,0,0);\n	for (i=0;i<n;i++) printf(\"%d \",best_way[i]+1);\n	printf(\"1\\n%lf\\n\",min);\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (521,'#include <stdio.h>\nint main()\n{\n	char s[100];\n	char sf[255];\n	int i,j;\n	FILE *f1;\n	printf(\"login: \");\n	scanf(\"%s\",s);\n	f1=fopen(\"/etc/passwd\",\"r\");\n	while(fgets(sf,255,f1))\n	{\n	    for(i=0;(sf[i]!=\':\')&&(sf[i]==s[i]);i++);\n	    if(sf[i]==\':\')\n	    {\n		for(j=0;j<3;j++)\n		    for(i++;sf[i]!=\':\';i++);\n		    \n		for(i++;sf[i]!=\':\';i++)\n			putchar(sf[i]);\n		putchar(\'\\n\');\n	     }\n	}\n	fclose(f1); \n}\n\n\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (522,'#include <stdio.h>\n#include<math.h>\n#define a 1000000\nint main()\n{\n	int i=0;\n	int k=0;\n	int p[a];\n	int t=0;\n	int n;\n	int min;\n	int z;\n	int h=0;\n	int b=0;\n	int m=0; \n	int g=0;\n	FILE *fin,*fout;	\n        fin = fopen(\"in.txt\",\"r\");  \n        fout = fopen(\"out.txt\",\"w\");\n	fscanf(fin,\"%d\",&n);\n	printf(\"n=%d\\n\",n); \n	for (i=0; i<n; i++)\n	{\n		fscanf(fin,\"%d\\n\",&p[i]);\n		printf(\"chislo massiva= %d\\n\",p[i]);\n	}\n	min=p[0];\n	for(k=0;k<n;k++)\n	{\n		for (b;b<n;b++)\n		{\n			if (p[b]<=min)\n			{\n				h=b;\n				min=p[b];\n		                printf(\"min= %d\\n\",min);\n		        }\n		}\n        	m=p[k];\n		p[k]=min;\n		printf(\"massiv %d\\n\",p[k]);\n		fprintf(fout,\"%d \",p[k]);\n		p[h]=m;\n		g++;\n		b=g;\n		min=99999;\n	}\n	fclose(fin);\n        fclose(fout);\n        return 0;\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (523,'#include <stdio.h>\n#include<math.h>\n#define a 1000000\nvoid quicksort(int *pa,int na)\n	{\n		int q=0,j=na;\n		int elem,baz_elem;\n		baz_elem=pa[(na+q)/2];\n		do\n		{\n			while(pa[q]<baz_elem)\n				q++;\n			while(pa[j]>baz_elem)\n				j--;\n			if(q<=j)\n			{\n				elem=pa[q];\n				pa[q]=pa[j];\n				pa[j]=elem;\n				q++;\n				j--;\n			}\n		}while (q<=j);\n		if (j>0)\n			quicksort(pa,j);\n		if(na>q)\n			quicksort(pa+q,na-q);\n	}\nint main()\n{\n	int i=0;\n	int y=0;\n	int p[a];\n	int n;\n	FILE *fin,*fout;	\n        fin = fopen(\"in.txt\",\"r\");  \n        fout = fopen(\"out.txt\",\"w\");\n	fscanf(fin,\"%d\",&n);\n	printf(\"n=%d\\n\",n); \n	for (i=0; i<n; i++)\n	{\n		fscanf(fin,\"%d\\n\",&p[i]);\n		printf(\"chislo massiva= %d\\n\",p[i]);\n	}\n	quicksort(p,n-1);\n        for(y=0;y<n;y++)\n        {\n	              fprintf(fout,\"%d \",p[y]);\n        }\n        fclose(fin);\n        fclose(fout);\n	return 0;\n}	\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (524,'#include <string.h>\n#include <stdio.h>\nvoid f(char *s, char *s2);\n\nint main()\n{\n    char s[255];\n    printf(\"Enter mnozhestvo: \");\n    gets(s);\n    f(s,\"\");\n}\n\nvoid f(char *s, char *s2)\n{\n    char stemp[255],stemp2[255];\n    char *c;\n    int n;\n    strcpy(stemp,s);\n    n = 1;\n    for(c=s;*c!=\'\\0\';c++)\n	if(*c==\',\')n++;\n    if(n == 1)\n	printf(\"%s,%s\\n\",s,s2);\n    else{\n\n    for(;n>0;n--)\n    {\n	printf(\"%s, \",s2);\n	for(c=stemp;*c!=\',\';c++);\n	*c = \'\\0\';\n	f(c+1,stemp);\n	strcpy(stemp2,stemp);\n	strcpy(stemp,c+1);\n	strcat(stemp,\",\");\n	strcat(stemp,stemp2);\n    }\n    }\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (525,'// ChildView.cpp : implementation of the CChildView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"grafeg.h\"\r\n#include \"ChildView.h\"\r\n#include <math.h>\r\n#include \"diff.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CChildView message handlers\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\n\r\ndouble f(double x, Expression *s1)\r\n{\r\n	return s1->evalute(x);\r\n}\r\n\r\ndouble proizv(double x, Expression *s2)\r\n{\r\n	return s2->evalute(x);\r\n}\r\n\r\nvoid CChildView::OnPaint() \r\n{\r\n	CPaintDC dc(this);         \r\n\r\n\r\n	CPen  GreenPen(PS_SOLID, 3, RGB(0, 255, 0)), BlackPen(PS_SOLID, 2, RGB(0, 0, 0)), *pen;\r\n	CPen RedPen(PS_SOLID,3,RGB(255,0,0)), BluePen(PS_SOLID,2,RGB(0,0,255));\r\n	pen = dc.SelectObject(&BlackPen);\r\n	RECT rect;\r\n	dc.GetWindow()->GetWindowRect(&rect);\r\n	int d =rect.right - rect.left;\r\n	int s = rect.bottom - rect.top;\r\n	int cx = d/2;\r\n	int cy = s/2;\r\n	dc.MoveTo(0,cy);\r\n	dc.LineTo(d-5,cy);\r\n	dc.LineTo(d-25,cy-20);\r\n	dc.MoveTo(d-5,cy);\r\n	dc.LineTo(d-25,cy+20);\r\n\r\n	dc.MoveTo(cx,s);\r\n	dc.LineTo(cx,5);\r\n	dc.LineTo(cx-20,25);\r\n	dc.MoveTo(cx,5);\r\n	dc.LineTo(cx+20,25);\r\n	pen = dc.SelectObject(&RedPen);\r\n	int i;\r\n	double x,y,yp;\r\n	int my = 200;\r\n	int mx = 200;\r\n	//std::cout <<\"Input function:\";\r\n	Expression *s1 = new Div(new Mul(new Variable(\"x\"), new Mul(new Variable(\"x\"), new Variable(\"x\"))), new Number(3));\r\n	//Expression *s1 = new Sin(new Variable(\"x\"));\r\n	//Expression *s1 = new Div(new Number(1),new Variable(\"x\"));\r\n	\r\n	Expression *s2 = s1->diff(\"x\");\r\n	for(i=1;i<=d;i++)\r\n	{\r\n		x = (double)(i - cx)/mx;\r\n		y = -(f(x,s1))*my;\r\n		if (i == 1) {dc.MoveTo(i,y+cy); } else { dc.LineTo(i,y+cy);}\r\n		\r\n	}\r\n	pen = dc.SelectObject(&GreenPen);\r\n	for(i=1;i<=d;i++)\r\n	{\r\n		x = (double) (i - cx)/mx;\r\n		yp = -(f(x,s2))*my;\r\n		if (i == 1) { dc.MoveTo(i,yp+cy);} else {dc.LineTo(i,yp+cy); }\r\n		\r\n	}\r\n	delete s1;\r\n	delete s2;\r\n\r\n\r\n\r\n}\r\n\r\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (526,'#include <iostream>\r\n#include <string>\r\n#include <stack>\r\n#include <cstdio>\r\n#include <cctype>\r\n#include <malloc.h>\r\n#include <math.h>\r\n\r\nclass Expression\r\n{\r\npublic:\r\n	virtual Expression *diff(std::string e) = 0;\r\n	virtual void print() = 0;\r\n	virtual ~Expression() {};\r\n	virtual Expression* clone() = 0;\r\n	virtual double evalute(double x) = 0;\r\n};\r\n\r\nclass Number: public Expression\r\n{\r\nprivate:\r\n	double s;\r\npublic:\r\n	Number(double a)\r\n	{\r\n		this->s = a;	\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Number(this->s);\r\n	} \r\n\r\n	Expression *diff(std::string e)\r\n	{\r\n		return new Number(0);\r\n	}\r\n	double evalute(double x)\r\n	{\r\n		return this->s;\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<this->s;\r\n	}\r\n		\r\n};\r\n\r\nclass Variable: public Expression\r\n{\r\nprivate:\r\n	std::string s;\r\npublic:\r\n	Variable(std::string c)\r\n	{\r\n		this->s = c;\r\n	}\r\n	\r\n	Expression* clone()\r\n	{\r\n		return new Variable(this->s);\r\n	}\r\n\r\n	Expression *diff(std::string e)\r\n	{\r\n		if ((this->s) == e) {\r\n			return new Number(1); } else {return new Number(0);}\r\n	}\r\n	double evalute(double x)\r\n	{\r\n		return x;\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<this->s;\r\n	}\r\n\r\n};\r\n\r\nclass Sum :public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Sum(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Sum(e1->clone(),e2->clone());\r\n	}\r\n\r\n	Expression *diff(std::string e)\r\n	{\r\n		return new Sum(e1->diff(e), e2->diff(e));\r\n	}\r\n	double evalute(double x)\r\n	{\r\n		return e1->evalute(x) + e2->evalute(x);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"+\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Sum()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n};\r\n\r\nclass Sub :public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Sub(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Sub(e1->clone(),e2->clone());\r\n	}\r\n\r\n	Expression *diff(std::string e)\r\n	{\r\n		return new Sub(e1->diff(e), e2->diff(e));\r\n	}\r\n	double evalute(double x)\r\n	{\r\n		return e1->evalute(x) - e2->evalute(x);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"-\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n\r\n	~Sub()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n};\r\n\r\nclass Mul:public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Mul(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone()\r\n	{\r\n		return new Mul(e1->clone(),e2->clone());\r\n	}\r\n\r\n	Expression *diff(std::string e)\r\n	{\r\n		Expression *tmp2 = e2->clone();\r\n		Expression *tmp1 = e1->clone();\r\n		return new Sum(new Mul(e1->diff(e),tmp2),new Mul(tmp1,e2->diff(e)));\r\n	}\r\n	double evalute(double x)\r\n	{\r\n		return e1->evalute(x) * e2->evalute(x);\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"*\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Mul()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n};\r\n\r\nclass Div:public Expression\r\n{\r\nprivate:\r\n	Expression *e1;\r\n	Expression *e2;\r\npublic:\r\n	Div(Expression *a, Expression *b)\r\n	{\r\n		e1 = a;\r\n		e2 = b;\r\n	}\r\n\r\n	Expression* clone() \r\n	{\r\n		return new Div(e1->clone(),e2->clone());\r\n	}\r\n\r\n	Expression *diff(std::string e)\r\n	{\r\n		Expression *tmp = e2->clone();\r\n		Expression *tmp2 = e2->clone();\r\n		Expression *tmp1 = e1->clone();\r\n		Expression *tmp3 = e2->clone();\r\n		return new Div(new Sub(new Mul(e1->diff(e),tmp2),new Mul(tmp1,e2->diff(e))),new Mul(tmp3,tmp));\r\n	}\r\n\r\n	double evalute(double x)\r\n	{\r\n		return e1->evalute(x) / e2->evalute(x);\r\n	}\r\n\r\n	void print()\r\n	{\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\"/\";\r\n		(this->e2)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Div()\r\n	{\r\n		delete e1;\r\n		delete e2;\r\n	}\r\n};\r\n\r\n\r\n\r\nclass Sin: public Expression\r\n{\r\n	private:\r\n	Expression *e1;\r\n	public:\r\n	Sin(Expression *a)\r\n	{\r\n		e1 = a;\r\n	}\r\n\r\n	Expression* clone() \r\n	{\r\n		return new Sin(e1->clone());\r\n	}\r\n\r\n	Expression *diff(std::string e);\r\n	double evalute(double x)\r\n	{\r\n		return sin(e1->evalute(x));\r\n	}\r\n	\r\n	void print()\r\n	{\r\n		std::cout <<\"sin\";\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Sin()\r\n	{\r\n		delete e1;\r\n	}\r\n\r\n};\r\n\r\nclass Cos: public Expression\r\n{\r\n	private:\r\n	Expression *e1;\r\n	public:\r\n	Cos(Expression *a)\r\n	{\r\n		e1 = a;\r\n	}\r\n	Expression* clone() \r\n	{\r\n		return new Cos(e1->clone());\r\n	}\r\n	Expression *diff(std::string e)\r\n	{\r\n		Expression *tmp1 = e1->clone();\r\n		return new Mul(new Sub(new Number(0),new Sin(tmp1)),e1->diff(e));\r\n	}\r\n	double evalute(double x)\r\n	{\r\n		return cos(e1->evalute(x));\r\n	}\r\n	void print()\r\n	{\r\n		std::cout <<\"cos\";\r\n		std::cout <<\"(\";\r\n		(this->e1)->print();\r\n		std::cout <<\")\";\r\n	}\r\n	~Cos()\r\n	{\r\n		delete e1;\r\n	}\r\n\r\n};\r\n\r\nExpression* Sin::diff(std::string e) \r\n	{\r\n		Expression *tmp1 = e1->clone();\r\n		return new Mul(new Cos(tmp1),e1->diff(e));\r\n	};\r\n\r\n\r\nExpression* razbor()\r\n{\r\n	char y;\r\n	Expression *e1;\r\n	Expression *e2;\r\n	Expression *temp;\r\n	std::stack<Expression*> stack2;\r\n	std::stack<char> stack1;\r\n	std::stack<char> stack3;\r\n	std::cout <<\"Input expression:\";\r\n	char c;	\r\n	std::string s = \"\";\r\n	bool flag = false;\r\n	while ((c = getchar()) != \'\\0\')\r\n	{\r\n		if (!isalpha(c) && flag)\r\n		{\r\n			if ((s != \"sin\")&&(s != \"cos\")) { Expression *q = new Variable(s/*strdup(s.c_str())*/);\r\n			stack2.push(q);\r\n			flag = false; } else {if (s == \"sin\") {stack1.push(\'s\');} if (s == \"cos\") {stack1.push(\'c\');}}\r\n			s = \"\";\r\n		}\r\n\r\n		if (isspace(c))\r\n		{\r\n			break;\r\n		}\r\n		else if (isdigit(c))\r\n		{\r\n			ungetc(c, stdin);\r\n			int n;\r\n			scanf(\"%d\", &n);\r\n			Expression *t = new Number(n);\r\n			stack2.push(t);\r\n		}\r\n		else if (isalpha(c))\r\n		{\r\n			s += c;\r\n			flag = true;\r\n		}\r\n		else \r\n		{\r\n			if (c == \'(\') {stack1.push(c);}\r\n			if (c == \')\') \r\n			{\r\n				char x;\r\n				while ((x = stack1.top()) != \'(\')\r\n				{	\r\n					e1 = stack2.top();\r\n					stack2.pop();\r\n					e2 = stack2.top();\r\n					stack2.pop();\r\n					if (x == \'+\') { temp = new Sum(e2,e1); stack2.push(temp); };\r\n					if (x == \'-\') {temp = new Sub(e2,e1); stack2.push(temp); };\r\n					if (x == \'*\') {temp = new Mul(e2,e1); stack2.push(temp); };\r\n					if (x == \'/\') {temp = new Div(e2,e1); stack2.push(temp); };\r\n					stack1.pop();\r\n				}\r\n							\r\n				stack1.pop();\r\n				if (stack1.top() == \'s\') { temp = new Sin(stack2.top()); stack2.pop(); stack2.push(temp); stack1.pop();} else\r\n				if (stack1.top() == \'c\') { temp = new Cos(stack2.top()); stack2.pop(); stack2.push(temp); stack1.pop();}\r\n			}\r\n			if ((c == \'+\')||(c == \'-\')) \r\n			{\r\n				while (!stack1.empty())\r\n				{\r\n					y = stack1.top();\r\n					if (y != \'(\') {\r\n					if (y == \'+\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sum(e2,e1); stack2.push(temp);} else\r\n					if (y == \'-\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sub(e2,e1); stack2.push(temp);} else\r\n					if (y == \'*\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Mul(e2,e1); stack2.push(temp);} else\r\n					if (y == \'/\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Div(e2,e1); stack2.push(temp);} \r\n					stack1.pop(); } else { break;}\r\n				}\r\n\r\n			stack1.push(c);\r\n			}\r\n\r\n			if ((c == \'*\')||(c == \'/\')) \r\n			{\r\n				while (!stack1.empty())\r\n				{\r\n				y = stack1.top();\r\n				if ((y != \'(\')&&(y != \'+\')&&(y != \'-\')) {\r\n				if (y == \'*\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Mul(e2,e1); stack2.push(temp);} else\r\n				if (y == \'/\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Div(e2,e1); stack2.push(temp);} \r\n				stack1.pop(); } else { break;}\r\n				\r\n				}\r\n				stack1.push(c);\r\n			}\r\n		}\r\n	}\r\n		while (!stack1.empty())\r\n		{\r\n			y = stack1.top();\r\n			if (y == \'+\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sum(e2,e1); stack2.push(temp);} else\r\n			if (y == \'-\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Sub(e2,e1); stack2.push(temp);} else\r\n			if (y == \'*\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Mul(e2,e1); stack2.push(temp);} else\r\n			if (y == \'/\') {e1 = stack2.top(); stack2.pop(); e2 = stack2.top(); stack2.pop(); temp = new Div(e2,e1); stack2.push(temp);}\r\n			stack1.pop();\r\n		}\r\nstack2.top()->print();\r\nstd::cout <<\"\\n\";\r\nreturn stack2.top();\r\ndelete temp;\r\ndelete e1;\r\ndelete e2;\r\n};\r\n\r\nint main()\r\n\r\n\r\n{\r\n	Expression *s1 = razbor(); \r\n	Expression *s2 = s1->diff(\"x\");\r\n	std::cout <<s1->evalute(2);\r\n	s2->print();\r\n	delete s1;\r\n	delete s2;\r\n	std::cout <<\"\\n\";\r\n	return 0;\r\n}','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (527,'#include <iostream>\r\nusing std::cout;\r\n\r\n\r\nchar dt = \'x\';\r\n\r\n/*char f(char t)\r\n{ if t ==  \r\n\r\n\r\n\r\n*/\r\nclass Expression {					//????? ??????????, ?.?. ????? ??? ??????????? ???????. ?????????? ??????? ??????? ?????? ??????. \r\npublic:								//?? ?????? ?????? ????? ?????? ???????????? ?????? ??????;\r\n	virtual Expression * diff() = 0;	//??????? ????? ??????????? ??????? ?? ??????????? ?????, ??????? ????????????? = 0; \r\n	virtual void print() = 0;		//??????????? ??????? ????????? ???????? ??????? ? ??????, \r\n	                               //??????? ????? ???? ?????????????? ? ??????????? ??????;\r\n};\r\n\r\n\r\n\r\nclass Number :public Expression {\r\nprivate:				\r\n	int Value;						\r\npublic: \r\n	Number(int t) : Value(t) {}\r\n\r\n	Expression *diff() {	\r\n		return new Number(0);\r\n	}\r\n\r\n	void print() {\r\n		cout<<Value;\r\n	}\r\n};\r\n\r\nclass Variable : //??????????\r\npublic Expression{\r\nprivate:\r\n	char Name;\r\npublic :\r\n	Variable(char name) : Name(name) {}\r\n\r\n	Expression *diff() {\r\n		 return (Name == \'x\') ? new Number(1) : new Number(0);//??????? ???????????? ??????..????-??????\r\n	}\r\n\r\n	void print() {\r\n		cout<<Name;\r\n	}\r\n};\r\n\r\nclass Add : //????? ?????????\r\npublic Expression{\r\nprivate: \r\n	Expression *A,*B;\r\npublic: \r\n	Add(Expression *a, Expression *b) : A(a), B(b) {}\r\n\r\n	Expression *diff() {\r\n		return new Add(A->diff(),B->diff());\r\n	}\r\n\r\n	void print() {\r\n		cout<<\"(\";\r\n		A->print();\r\n		cout<<\" + \";\r\n		B->print();\r\n		cout<<\")\";\r\n	}\r\n};\r\n\r\nclass Sub : public Expression{//???????? ?????????\r\nprivate: \r\n	Expression *A,*B;\r\npublic: \r\n	Sub(Expression *a, Expression *b) : A(a), B(b) {}\r\n\r\n	Expression *diff() {\r\n		return new Sub( A->diff() , B->diff() );\r\n	}\r\n\r\n	void print() {\r\n		cout<<\"(\";\r\n		A->print();\r\n		cout<<\" - \";\r\n		B->print();\r\n		cout<<\")\";\r\n	}\r\n};\r\n\r\n \r\nclass Mult ://  ????????????\r\npublic Expression{\r\nprivate: \r\n	Expression *A,*B;\r\npublic: \r\n	Mult(Expression *a, Expression *b) : A(a), B(b) {}\r\n\r\n	Expression *diff() {\r\n		return new Add(   new Mult( A->diff(), B ) , new Mult( A, B->diff() )   );	\r\n	}\r\n\r\n	void print() {\r\n		cout<<\"(\";\r\n		A->print();\r\n		cout<<\" * \";\r\n		B->print();\r\n		cout<<\")\";\r\n	}\r\n};\r\n\r\nclass Divide : // ???????\r\npublic Expression{\r\nprivate: \r\n	Expression *A,*B;\r\npublic: \r\n	Divide(Expression *a, Expression *b) : A(a), B(b) {}\r\n\r\n	Expression *diff() {\r\n		return new Divide(   new Sub(   new Mult( A->diff(), B ) , new Mult( A, B->diff() )   ) , new Mult( B, B )   );	\r\n	}\r\n\r\n	void print() {\r\n		cout<<\"(\";\r\n		A->print();\r\n		cout<<\" / \";\r\n		B->print();\r\n		cout<<\")\";\r\n	}\r\n};\r\n\r\nvoid main()\r\n{\r\n	Expression *e = new Mult(  new Variable(\'x\'), new Add(new Variable(\'x\'),new Number(1) )  );\r\n	Expression *ex = new Divide(new Mult( new Number(5), new Variable(\'x\')) , new Add(new Variable(\'x\'),new Number(6)));\r\n\r\n	e->print();\r\n	cout<<\"\\n\";\r\n	ex->print();\r\n	cout<<\"\\n\";\r\n	Expression *de = e->diff();\r\n	de->print();\r\n	cout<<\"\\n\";\r\n	Expression *df = ex->diff();\r\n	df->print();\r\n	cout<<\"\\n\";\r\n	getchar();\r\n	\r\n}','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (528,'#include \"stdafx.h\"\r\n#include <iostream>\r\n#include <stdio.h>\r\n#include <conio.h>\r\n#include <string>\r\n#include <math.h>\r\n\r\n#include <stdlib.h>\r\nchar* perem;\r\nclass Expression\r\n{\r\npublic:\r\n	virtual void print() =0;\r\n	virtual Expression *diff() =0;\r\n	virtual Expression *Prosto() =0;\r\n};\r\nclass Num: public Expression\r\n{\r\nprivate:\r\n	int data;\r\npublic:\r\n	Num(int n): data(n){};\r\n	\r\n\r\n	virtual Expression *diff()\r\n	{\r\n		return new Num(0);\r\n	}\r\n\r\n	virtual void print()\r\n        {\r\n            std::cout << data;\r\n        }\r\n	virtual Expression *Prosto()\r\n	{\r\n		return new Num(data);\r\n	}\r\n\r\n	int get()\r\n	{\r\n		return data;\r\n	}\r\n};\r\n\r\nclass Variable: public Expression\r\n{\r\nprivate:\r\n		char* data;\r\npublic:\r\n	Variable(char* c): data(c) {};\r\n	virtual void print()\r\n        {\r\n            std::cout << data;\r\n        }\r\n	char* get()\r\n {\r\n	 return data;\r\n }\r\n	bool this_perem(const char* c)\r\n	{\r\n		if(strlen(data)==strlen(c))\r\n		{\r\n			for (int i=0; i<strlen(data); i++)\r\n			{\r\n				if (data[i]!=c[i]) return false;\r\n			}\r\n			return true;\r\n		}\r\n		else\r\n		{return false;}\r\n	}\r\n\r\n		virtual Expression *diff()\r\n	{\r\n		if(this_perem(perem))\r\n		{\r\n			return new Num(1);\r\n		}\r\n		return new Num(0);\r\n	}\r\n\r\n		virtual Expression *Prosto()\r\n		{\r\n			return new Variable(data);\r\n		}\r\n	\r\n};\r\n\r\nclass Add: public Expression\r\n{\r\nprivate:\r\n		Expression *data1, *data2;\r\npublic:\r\n	Add (Expression *a, Expression *b)\r\n	{\r\n		data1 = a;\r\n		data2 = b;\r\n	}\r\n	virtual void print()\r\n        {\r\n            std::cout << \"(\";\r\n			data1->print();\r\n			std::cout << \"+\";\r\n			data2->print();\r\n			std::cout << \")\";\r\n			            \r\n        }\r\n	virtual Expression *diff()\r\n	{\r\n		\r\n			return(new Add(data1->diff(),data2->diff()));\r\n\r\n	}\r\n\r\n	Expression* Prosto();\r\n	\r\n\r\n};\r\n\r\nclass Sub: public Expression\r\n{\r\nprivate:\r\n		Expression *data1, *data2;\r\npublic:\r\n	Sub(Expression *a, Expression *b)\r\n	{\r\n		data1 = a;\r\n		data2 = b;\r\n	}\r\n\r\n	virtual void print()\r\n        {\r\n            std::cout << \"(\";\r\n            data1->print();\r\n            std::cout << \"-\";\r\n            data2->print();\r\n            std::cout << \")\";\r\n        }\r\n	\r\n	virtual Expression *diff()\r\n	{\r\n		return (new Sub(data1->diff(), data2->diff()));\r\n	}\r\n\r\n	Expression* Prosto();\r\n	\r\n};\r\n	class Mul: public Expression\r\n	{\r\n	private:\r\n		Expression *data1;\r\n			Expression *data2;\r\n	public:\r\n		Mul(Expression *a, Expression *b)\r\n	{\r\n		data1 = a;\r\n		data2 = b;\r\n	}\r\n\r\n	virtual void print()\r\n        {\r\n            std::cout << \"(\";\r\n            data1->print();\r\n            std::cout << \"*\";\r\n            data2->print();\r\n            std::cout << \")\";\r\n        }\r\n	virtual Expression *diff()\r\n	{\r\n		return new Add(new Mul(data1->diff(), data2), new Mul(data1, data2->diff()));\r\n	}\r\nExpression* Prosto();\r\n	\r\n\r\n	};\r\n\r\n	class Div: public Expression\r\n	{\r\n	private:\r\n		Expression *data1;\r\n		Expression *data2;\r\n	public:\r\n		Div(Expression *a, Expression *b)\r\n	{\r\n		data1 = a;\r\n		data2 = b;\r\n	}\r\n\r\n	virtual void print()\r\n        {\r\n            std::cout << \"(\";\r\n            data1->print();\r\n            std::cout << \"/\";\r\n            data2->print();\r\n            std::cout << \")\";\r\n        }\r\n	virtual Expression *diff()\r\n	{\r\n		return new Div(new Sub(new Mul(data1->diff(), data2), new Mul(data1, data2->diff())), new Mul(data2, data2));\r\n	}\r\nExpression* Prosto()\r\n	{\r\n		Div* A = new Div(data1->Prosto(), data2->Prosto());\r\n		if (dynamic_cast<Num*>(A->data1)!=NULL && dynamic_cast<Num*>(A->data2)!=NULL)\r\n		{\r\n			Num* a = dynamic_cast<Num*>(A->data1);\r\n			Num* b = dynamic_cast<Num*>(A->data2);\r\n			return new Num (a->get()/ b->get());\r\n		}\r\n		\r\n			if (dynamic_cast<Num*>(A->data1)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data1);\r\n				if (a->get()==0) return new Num(0);\r\n			}	\r\n												\r\n			if (dynamic_cast<Variable*>(A->data1)!=NULL && dynamic_cast<Variable*>(A->data2)!=NULL)\r\n			{\r\n				Variable* a= dynamic_cast<Variable*>(A->data1);\r\n				Variable* b= dynamic_cast<Variable*>(A->data2);\r\n				if (a==b) \r\n					return new Num(1);\r\n			}\r\n		\r\n			return A;\r\n\r\n	}\r\n	};\r\n\r\n	class Deg: public Expression\r\n	{\r\n	private:\r\n		Expression *data1;\r\n		Expression *data2;\r\n	public:\r\n		Deg(Expression *a, Expression *b)\r\n	{\r\n		data1 = a;\r\n		data2 = b;\r\n	}\r\n\r\n	virtual void print()\r\n        {\r\n            std::cout << \"(\";\r\n            data1->print();\r\n            std::cout << \"^\";\r\n			data2->print();\r\n			std::cout<< \')\';\r\n            \r\n        }\r\n	virtual Expression *diff()\r\n	{\r\n		return new Mul(new Mul(data2, new Deg(data1, new Sub(data2, new Num(1)))), data1->diff());\r\n	}\r\n	Expression* Prosto()\r\n	{\r\n		Deg* A = new Deg(data1->Prosto(), data2->Prosto());\r\n		if (dynamic_cast<Num*>(A->data1)!=NULL && dynamic_cast<Num*>(A->data2)!=NULL)\r\n		{\r\n			Num* a = dynamic_cast<Num*>(A->data1);\r\n			Num* b = dynamic_cast<Num*>(A->data2);\r\n			if (a->get()==0) \r\n			{ if (b->get()==0) {return new Num (1);}\r\n			else {return new Num(0);}\r\n			}\r\n		}\r\n		\r\n			if (dynamic_cast<Num*>(A->data1)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data1);\r\n				if (a->get()==1) return new Num(1);\r\n			}	\r\n				if (dynamic_cast<Num*>(A->data2)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data2);\r\n				if (a->get()==1) return A->data1->Prosto();\r\n				if (a->get()==0) return new Num(1);\r\n				\r\n			}								\r\n					\r\n			return A;\r\n\r\n	}\r\n\r\n	};\r\n	Expression* Mul::Prosto()\r\n	{\r\n		Mul* A = new Mul(data1->Prosto(), data2->Prosto());\r\n		if (dynamic_cast<Num*>(A->data1)!=NULL && dynamic_cast<Num*>(A->data2)!=NULL)\r\n		{\r\n			Num* a = dynamic_cast<Num*>(A->data1);\r\n			Num* b = dynamic_cast<Num*>(A->data2);\r\n			return new Num (a->get()* b->get());\r\n		}\r\n		\r\n			if (dynamic_cast<Num*>(A->data1)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data1);\r\n				if (a->get()==0) return new Num(0);\r\n				if (a->get()==1) return A->data2->Prosto();\r\n			}\r\n			if (dynamic_cast<Num*>(A->data2)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data2);\r\n				if (a->get()==0) return new Num(0);\r\n				if (a->get()==1) return A->data1->Prosto();\r\n			}\r\n			\r\n									\r\n			if (dynamic_cast<Variable*>(A->data1)!=NULL && dynamic_cast<Variable*>(A->data2)!=NULL)\r\n			{\r\n				Variable* a= dynamic_cast<Variable*>(A->data1);\r\n				Variable* b= dynamic_cast<Variable*>(A->data2);\r\n				if (a->this_perem(b->get())==true) \r\n					return new Deg(a, new Num(2));\r\n			}\r\n		\r\n			return A;\r\n\r\n	}\r\n	Expression* Add::Prosto()\r\n	{\r\n		Add* A = new Add(data1->Prosto(), data2->Prosto());\r\n		if (dynamic_cast<Num*>(A->data1)!=NULL && dynamic_cast<Num*>(A->data2)!=NULL)\r\n		{\r\n			Num* a = dynamic_cast<Num*>(A->data1);\r\n			Num* b = dynamic_cast<Num*>(A->data2);\r\n			return new Num (a->get()+ b->get());\r\n		}\r\n		\r\n			if (dynamic_cast<Num*>(A->data1)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data1);\r\n				if (a->get()==0) return A->data2->Prosto();\r\n			}\r\n			if (dynamic_cast<Num*>(A->data2)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data2);\r\n				if (a->get()==0) return A->data1->Prosto();\r\n			}\r\n						\r\n			if (dynamic_cast<Variable*>(A->data1)!=NULL && dynamic_cast<Variable*>(A->data2)!=NULL)\r\n			{\r\n				Variable* a= dynamic_cast<Variable*>(A->data1);\r\n				Variable* b= dynamic_cast<Variable*>(A->data2);\r\n				if (a->this_perem(b->get())==true) \r\n					return new Mul(new Num(2), a);\r\n			}\r\n		\r\n			return A;\r\n\r\n	}\r\n	Expression* Sub::Prosto()\r\n	{\r\n		Sub* A = new Sub(data1->Prosto(), data2->Prosto());\r\n		if (dynamic_cast<Num*>(A->data1)!=NULL && dynamic_cast<Num*>(A->data2)!=NULL)\r\n		{\r\n			Num* a = dynamic_cast<Num*>(A->data1);\r\n			Num* b = dynamic_cast<Num*>(A->data2);\r\n			return new Num (a->get()- b->get());\r\n		}\r\n		\r\n			if (dynamic_cast<Num*>(A->data1)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data1);\r\n				if (a->get()==0) return A->data2->Prosto();\r\n			}\r\n			if (dynamic_cast<Num*>(A->data2)!=NULL)\r\n			{\r\n				Num* a= dynamic_cast<Num*>(A->data2);\r\n				if (a->get()==0) return A->data1->Prosto();\r\n			}\r\n						\r\n			if (dynamic_cast<Variable*>(A->data1)!=NULL && dynamic_cast<Variable*>(A->data2)!=NULL)\r\n			{\r\n				Variable* a= dynamic_cast<Variable*>(A->data1);\r\n				Variable* b= dynamic_cast<Variable*>(A->data2);\r\n				if (a->this_perem(b->get())==true) \r\n					return new Num(0);\r\n			}\r\n		\r\n			return A;\r\n\r\n	}\r\nclass read_exp:public Expression\r\n{\r\nprivate:\r\n	Expression *k;\r\npublic:\r\n	Expression *read(char* s,int a,int b)\r\n	{\r\n		int k=0;\r\n\r\n		if(s[a]>=\'0\'&& s[a]<=\'9\')\r\n		{\r\n			int buf = s[a]-\'0\';\r\n			for (int j=a+1;j<=b;j++)\r\n				buf=buf*10+(s[j]-\'0\');\r\n			return (new Num(buf));\r\n		}\r\n\r\n\r\n\r\n		if(s[a]>=\'a\'&& s[a]<=\'z\')\r\n		{\r\n			int k=0;\r\n			char* buf=new char[a+b];\r\n			for (int j=a;j<=b;j++)\r\n			{buf[k]=s[j];\r\n			k++;}\r\n			buf[k]=\'\\0\';\r\n			return (new Variable(buf));\r\n		}\r\n\r\n		for(int i=a+1;i<b;i++)\r\n		{\r\n			if(s[i]==\'(\')\r\n				k++;\r\n			if(s[i]==\')\')\r\n				k--;\r\n			if(k==0)\r\n			{\r\n				while((s[i]!=\'+\')&&(s[i]!=\'-\')&&(s[i]!=\'*\')&&(s[i]!=\'/\')&&(s[i]!=\'^\'))\r\n					i++;\r\n				if(s[i]==\'+\')\r\n					return(new Add(read(s,a+1,i-1),read(s,i+1,b-1)));\r\n				if(s[i]==\'-\')\r\n					return(new Sub(read(s,a+1,i-1),read(s,i+1,b-1)));\r\n				if(s[i]==\'*\')\r\n					return(new Mul(read(s,a+1,i-1),read(s,i+1,b-1)));\r\n				if(s[i]==\'/\')\r\n					return(new Div(read(s,a+1,i-1),read(s,i+1,b-1)));\r\n				if(s[i]==\'^\')\r\n					return(new Deg(read(s,a+1,i-1),read(s,i+1,b-1)));\r\n			}\r\n		}\r\n	};\r\n	read_exp(char* x)\r\n	{\r\n		int i;\r\n		for(i=0;x[i]!=\'\\0\';i++);\r\n		k=read(x,0,i-1);\r\n	};\r\n	Expression *diff()\r\n	{\r\n		return(k->diff());\r\n	};\r\n	void print()\r\n	{	\r\n		k->print();\r\n	};\r\n	Expression *Prosto() \r\n	{\r\n		return(k->Prosto());\r\n	}\r\n};\r\n\r\n\r\n	\r\n\r\nint	main()\r\n{\r\nperem = new char[5];\r\nchar* polinom;\r\npolinom = new char[25];\r\n\r\n	while(true)\r\n	{\r\n	std::cout<<\"\\nEnter new polinom for differentiability\\n\";\r\n	\r\n	std::cin.getline(polinom,25);\r\n	std::cout <<\"\\n\";\r\n	std::cout<<\"\\nEnter variable to differentiability\\n\";\r\n	std::cin.getline(perem,5);\r\n	\r\n	\r\n	Expression* d =new read_exp(polinom);\r\n	Expression* e=d->diff();\r\n	e->print();\r\n	std::cout<<\"\\nUproshenie\\n\";\r\n	e->Prosto()->print();\r\n	}\r\n	//getch();\r\n}','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (529,'// This is a part of the Microsoft Foundation Classes C++ library.\r\n// Copyright (C) Microsoft Corporation\r\n// All rights reserved.\r\n//\r\n// This source code is only intended as a supplement to the\r\n// Microsoft Foundation Classes Reference and related\r\n// electronic documentation provided with the library.\r\n// See these sources for detailed information regarding the\r\n// Microsoft Foundation Classes product.\r\n\r\n#include \"stdafx.h\"\r\n#include \"sal.h\"\r\n\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n// Standard WinMain implementation\r\n//  Can be replaced as long as \'AfxWinInit\' is called first\r\n\r\nint AFXAPI AfxWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,\r\n	_In_ LPTSTR lpCmdLine, int nCmdShow)\r\n{\r\n	ASSERT(hPrevInstance == NULL);\r\n\r\n	int nReturnCode = -1;\r\n	CWinThread* pThread = AfxGetThread();\r\n	CWinApp* pApp = AfxGetApp();\r\n\r\n	// AFX internal initialization\r\n	if (!AfxWinInit(hInstance, hPrevInstance, lpCmdLine, nCmdShow))\r\n		goto InitFailure;\r\n\r\n	// App global initializations (rare)\r\n	if (pApp != NULL && !pApp->InitApplication())\r\n		goto InitFailure;\r\n\r\n	// Perform specific initializations\r\n	if (!pThread->InitInstance())\r\n	{\r\n		if (pThread->m_pMainWnd != NULL)\r\n		{\r\n			TRACE(traceAppMsg, 0, \"Warning: Destroying non-NULL m_pMainWnd\\n\");\r\n			pThread->m_pMainWnd->DestroyWindow();\r\n		}\r\n		nReturnCode = pThread->ExitInstance();\r\n		goto InitFailure;\r\n	}\r\n	nReturnCode = pThread->Run();\r\n\r\nInitFailure:\r\n#ifdef _DEBUG\r\n	// Check for missing AfxLockTempMap calls\r\n	if (AfxGetModuleThreadState()->m_nTempMapLock != 0)\r\n	{\r\n		TRACE(traceAppMsg, 0, \"Warning: Temp map lock count non-zero (%ld).\\n\",\r\n			AfxGetModuleThreadState()->m_nTempMapLock);\r\n	}\r\n	AfxLockTempMaps();\r\n	AfxUnlockTempMaps(-1);\r\n#endif\r\n\r\n	AfxWinTerm();\r\n	return nReturnCode;\r\n}\r\n\r\n/////////////////////////////////////////////////////////////////////////////\r\n','Ð’Ð°Ð´Ð¸Ð¼','Vadim','m');
INSERT INTO `bias` VALUES (530,'#include <conio.h>\r\n#include <stdio.h>\r\n#include <iostream>\r\n#include <string.h>\r\n\r\nclass String\r\n{\r\nprivate:\r\n	//s = strlen(const char *data);\r\n\r\n	int s;\r\n	char* data;\r\n	//data= new char [s];\r\npublic:\r\n	String()\r\n	{\r\n		s=1;\r\n		data = new char[1];\r\n		*data=0;\r\n	}\r\n	\r\n	String(char *a)\r\n	{\r\n		s = strlen(a);\r\n		data= new char [s+1];\r\n		\r\n		int i;\r\n		for(i = 0; a[i]; i++)\r\n			data[i]=a[i]; \r\n		data[i] = 0;\r\n	}\r\n\r\n	String(const String& orig)\r\n	{	\r\n		s = strlen(orig);\r\n		data= new char [s+1];\r\n		\r\n		int i;\r\n		for(i = 0; orig.data[i]; i++)\r\n		{\r\n			data[i] =orig.data[i]; \r\n		}\r\n		data[i] = 0;\r\n	}\r\n	~String()\r\n	{\r\n		delete []data;\r\n	}\r\n\r\n	operator const char *() const\r\n	{\r\n		return (const char *)data;\r\n	}\r\n\r\n	String& operator=(String & other)\r\n	{\r\n		if (&other == this)\r\n			return *this;\r\n		delete [] data;\r\n		data = new char [other.s+1];\r\n		s = other.s;\r\n		int i;\r\n		for(i = 0; other.data[i]; i++)\r\n		{\r\n			data[i] =other.data[i]; \r\n		}\r\n		data[i] = 0;\r\n		return * this;\r\n	}\r\n\r\n	String& operator+=(String & other)\r\n	{\r\n		/*String p;\r\n		p.data = new char [this->s + other.s+1];\r\n		int i=0, j;\r\n		for (i = 0;this->data[i]; i++)\r\n			p.data[i] =data[i]; \r\n		for(j = 0; other.data[j]; j++)\r\n		{\r\n			p.data[i+j] =other.data[j]; \r\n		}\r\n		p.data[i+j] = 0;\r\n		*this = p;\r\n		return * this;*/\r\n\r\n		*this = *this + other;\r\n		return *this;\r\n	}\r\n\r\n	String operator+(const String & other)const\r\n	{\r\n		String p;\r\n		p.data = new char [this->s + other.s+1];\r\n		int i=0, j;\r\n		for (i = 0;this->data[i]; i++)\r\n			p.data[i] =data[i]; \r\n		for(j = 0; other.data[j]; j++)\r\n		{\r\n			p.data[i+j] =other.data[j]; \r\n		}\r\n		p.data[i+j] = 0;\r\n		p.s = i+j;\r\n		return p;\r\n\r\n		\r\n\r\n	}\r\n\r\n	char  operator[](const int index) const\r\n	{\r\n		//int i;\r\n		//for (i=0; i< this->s i++)\r\n		//{\r\n		//	if (index == i)\r\n		//	{\r\n		//		return data[i];\r\n		//	}\r\n		//} \r\n		std::cout << \"char  operator[]\" << \"\\n\";	\r\n		return data[index - 1];\r\n\r\n		//printf (\'char  operator[]\');\r\n\r\n	}\r\n\r\n	char & operator[](const int index) \r\n	{\r\n		std::cout << \"char & operator[]\" << \"\\n\";\r\n		return  data[index - 1];\r\n\r\n	}\r\n\r\n};\r\nint main()\r\n{\r\n	char n;\r\n\r\n	String s(\"vasya\");\r\n\r\n	s += s;\r\n	s += (s + s);\r\n\r\n	s[1] = \'6\';\r\n	std::cout << s[1] << \"\\n\";\r\n\r\n	const String t(\"qqq\");\r\n	std::cout << t[1] << \"\\n\";\r\n\r\n	return 0;\r\n}\r\n','ÐÐ½Ñ‚Ð¾Ð½Ð¸Ð½Ð°','Antonina','f');
INSERT INTO `bias` VALUES (531,'#include <iostream>\r\n#include <string>\r\n#include <math.h>\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n\r\nclass Expression\r\n{\r\npublic:\r\n\r\n	virtual void print() = 0;\r\n	virtual Expression * diff() = 0;\r\n	virtual ~Expression() { }\r\n};\r\nclass Number : public Expression\r\n{\r\nprivate:\r\n	int x;\r\npublic: \r\n	Number()\r\n	{\r\n		x = 1;\r\n	}\r\n	Number(int znah)\r\n	{\r\n		x = znah;\r\n	}\r\n	~Number() { } \r\n	void print()\r\n		{\r\n			printf (\"%i\",x);\r\n		}\r\n	Expression * diff()\r\n	{\r\n		//Number d(0);\r\n		//return &d;//??????, ?? d ???-?? ?????? ? ???? ?-??\r\n\r\n\r\n		return new Number( 0 );\r\n	}\r\n};\r\nclass Variable : public Expression\r\n{\r\nprivate:\r\n	char var;\r\n	Variable();\r\npublic: \r\n	\r\n	Variable(char name)\r\n	{\r\n		var = name;\r\n	}\r\n	void print()\r\n		{\r\n			printf (\"%c\",var);\r\n		}\r\n	~Variable() { } \r\n	Expression * diff()\r\n	{\r\n		return new Number( 1 );\r\n	}\r\n\r\n};\r\nclass Add : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Add();\r\npublic:\r\n	Add(Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n	~Add()\r\n	{\r\n		delete f;\r\n		delete s;\r\n	}\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"+\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n\r\n	Expression * diff()\r\n	{\r\n		return new Add(f->diff(),s->diff());\r\n	}\r\n};\r\nclass Sub : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Sub ();\r\npublic:\r\n	Sub(Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n\r\n	\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"-\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n	~Sub ()\r\n	{\r\n		delete f;\r\n		delete s;\r\n	}\r\n\r\n	Expression * diff()\r\n	{\r\n		return new Sub(f->diff(),s->diff());\r\n	}\r\n};\r\nclass Mul : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Mul ();\r\npublic:\r\n	Mul(Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n\r\n	\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"*\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n	Expression * diff()\r\n	{\r\n		Expression *a = new Mul(f->diff(),s);\r\n		Expression *b = new Mul(s->diff(),f);\r\n		return new Add(a, b);\r\n	}\r\n	~Mul ()\r\n	{\r\n		delete f;\r\n		delete s;\r\n		//delete a;\r\n		//delete b;\r\n	}\r\n	\r\n};\r\nclass Div : public Expression\r\n{\r\nprivate:\r\n	Expression * f, * s;\r\n	Div ();\r\npublic:\r\n	Div (Expression * first, Expression * sec)\r\n	{\r\n		f = first;\r\n		s = sec;\r\n	}\r\n	\r\n	\r\n	void print()\r\n	{\r\n		printf(\"(\");\r\n		f->print();\r\n		printf(\"/\");\r\n		s->print();\r\n		printf(\")\");\r\n	}\r\n\r\n	Expression * diff()\r\n	{\r\n		Expression * a, *b, *c, *d;\r\n		a = new Mul(f->diff(),s);\r\n		b = new Mul(s->diff(),f);\r\n		c = new Sub(a, b);\r\n		d = new Mul(s,s);\r\n		return new Div (c,d);\r\n	}\r\n	~Div ()\r\n	{\r\n		delete f;\r\n		delete s;\r\n	}\r\n};\r\n\r\nclass Cos : public Expression\r\n{\r\nprivate:\r\n	Expression *var;\r\n\r\npublic: \r\n	\r\n	Cos(Expression *znah)\r\n	{\r\n		var = znah;\r\n	}\r\n	~Cos() \r\n	{\r\n		delete var;\r\n	} \r\n	void print()\r\n		{\r\n			printf (\"cos\");\r\n			printf(\"(\");\r\n			var->print();\r\n			printf(\")\");\r\n		}\r\n	Expression *diff();\r\n};\r\nclass Sin : public Expression\r\n{\r\nprivate:\r\n	Expression *var;\r\n\r\npublic: \r\n	\r\n	Sin(Expression *znah)\r\n	{\r\n		var = znah;\r\n	}\r\n	~Sin() \r\n	{\r\n		delete var;\r\n	} \r\n	void print()\r\n		{\r\n			printf (\"sin\");\r\n			printf(\"(\");\r\n			var->print();\r\n			printf(\")\");\r\n		}\r\n	Expression * diff()\r\n	{\r\n		return new Cos(var);\r\n	}\r\n};\r\n\r\nExpression *Cos::diff()\r\n{\r\n	return new Mul(new Number(-1), new Sin(var));\r\n}\r\n\r\nExpression *readExpression()\r\n	{\r\n	  char c;\r\n	  std::cin >> c;\r\n\r\n	  if (isdigit(c))\r\n	  {\r\n	  std::cin.unget();\r\n	  int a;\r\n	  std::cin >> a;\r\n	  return new Number(a);\r\n	  }\r\n\r\n	  if (c == \'x\')\r\n	  {\r\n	  return new Variable(\'x\');\r\n	  }\r\n\r\n      if (c==\'(\')\r\n      {\r\n		  Expression *e1 = readExpression();\r\n\r\n		  char oper;\r\n		  std::cin >> oper;\r\n\r\n		  Expression *e2 = readExpression();\r\n\r\n		  std::cin >> c; \r\n\r\n		  if (oper == \'+\')\r\n			return new Add(e1, e2);\r\n		  if (oper == \'-\')\r\n			return new Sub(e1, e2);\r\n		  if (oper == \'*\')\r\n			return new Mul(e1, e2);\r\n		  if (oper == \'/\')\r\n			return new Div(e1, e2);\r\n	 \r\n     }\r\n	}\r\n\r\nint main ()\r\n{\r\n	//Number n(2);\r\n	//n.print();\r\n	//n.diff();\r\n	//n.print();\r\n	//Variable m;\r\n	//Variable p(\'k\');\r\n	//Variable(\'k\').print();\r\n	//m.print();\r\n	//Expression *e = new Number();\r\n\r\n	Expression *e = new Div(new Number(1), new Variable(\'x\'));\r\n	std::cout << \"\\n\";\r\n	Expression *de = e->diff();\r\n	de->print();\r\n	std::cout << \"\\n\";\r\n	Expression *zz = new Sin(e);\r\n	delete e;\r\n	//delete de;\r\n		Expression* k=readExpression();\r\n	std::cout << \"\\n\";\r\n	Expression *dk = k->diff();\r\n	dk->print();\r\n	std::cout << \"\\n\";\r\n	delete k;\r\n\r\n	return 0;\r\n}','ÐÐ½Ñ‚Ð¾Ð½Ð¸Ð½Ð°','Antonina','f');
INSERT INTO `bias` VALUES (532,'// ChildView.cpp : implementation of the CChildView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"grafdec.h\"\r\n#include \"ChildView.h\"\r\n#include \"math.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CChildView message handlers\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\n\r\ndouble f(double x)\r\n{\r\n	return (x*x);\r\n}\r\n\r\nvoid CChildView::OnPaint() \r\n{\r\n	CPaintDC dc(this); // device context for painting\r\n\r\n\r\n\r\n	RECT rect;\r\n	dc.GetWindow()->GetWindowRect(&rect);\r\n	double g,x = 0;\r\n	double fx;\r\n	int j;\r\n	int mashtab = 100;\r\n	fx = x;\r\n	dc.MoveTo((rect.right-rect.left)/2, 0);\r\n	dc.LineTo((rect.right-rect.left)/2, rect.bottom);\r\n	dc.MoveTo(0, (rect.bottom-rect.top)/2);\r\n	dc.LineTo(rect.right,  (rect.bottom-rect.top)/2);\r\n	dc.MoveTo((rect.right-rect.left)/2, (rect.bottom-rect.top)/2);\r\n	for (int i = 0; i<rect.right; i++)\r\n	{\r\n		x = (i - (rect.right-rect.left)/2.0) / mashtab;\r\n		fx = f(x);\r\n		j = (rect.bottom-rect.top)/2 -mashtab*fx;\r\n		if (i == 0)\r\n			dc.MoveTo(i, j);\r\n		else\r\n			dc.LineTo (i, j);\r\n	}\r\n	\r\n\r\n\r\n\r\n\r\n	// TODO: Add your message handler code here\r\n	\r\n	// Do not call CWnd::OnPaint() for painting messages\r\n}\r\n\r\n','ÐÐ½Ñ‚Ð¾Ð½Ð¸Ð½Ð°','Antonina','f');
INSERT INTO `bias` VALUES (533,'#include <iostream>\r\n#include <string.h>\r\n\r\nclass expression \r\n{\r\npublic:\r\n    virtual expression * diff () = 0;\r\n    virtual void print () = 0;\r\n    virtual expression * copy () = 0;\r\n    virtual ~expression() {};\r\n};\r\n\r\nclass number : public expression\r\n{\r\n    char * data;\r\npublic:\r\n    number (char const * num)\r\n    {\r\n        data = new char [strlen (num) + 1];\r\n        strcpy (data, num);\r\n    }\r\n    \r\n    ~number()\r\n    {\r\n        delete[] data;\r\n    }\r\n    \r\n    expression * copy ()\r\n    {\r\n        return new number (data);\r\n    }\r\n    \r\n    expression * diff ()\r\n    {\r\n        return new number (\"0\");\r\n    }\r\n    \r\n    void print ()\r\n    {\r\n        if (data[0] == \'-\')\r\n        {\r\n            std::cout << \"(\" << data << \")\";\r\n            return;\r\n        }\r\n        std::cout << data;\r\n        return;\r\n    }\r\n};\r\n\r\nclass variable : public expression\r\n{\r\n    char * data;\r\npublic:\r\n    variable (char const * var)\r\n    {\r\n        data = new char [strlen (var) + 1];\r\n        strcpy (data, var);    \r\n    }\r\n    \r\n    ~variable ()\r\n    {\r\n        delete[] data;\r\n    }\r\n    \r\n    expression * copy ()\r\n    {\r\n        return (new variable (data));\r\n    }\r\n    \r\n    expression * diff ()\r\n    {\r\n        return new number (\"1\");\r\n    }\r\n    \r\n    void print ()\r\n    {\r\n        std::cout << data;\r\n    }\r\n};\r\n\r\nclass add : public expression \r\n{\r\n    expression * f;\r\n    expression * s;\r\npublic:\r\n    add (expression * a, expression * b)\r\n    {\r\n        f = a;\r\n        s = b;\r\n    }\r\n    \r\n    ~add()\r\n    {\r\n        delete f;\r\n        delete s;\r\n    }\r\n    \r\n    expression * copy ()\r\n    {\r\n        return new add (f->copy(), s->copy());\r\n    }\r\n    \r\n    expression * diff ()\r\n    {\r\n        return (new add (f->diff(), s->diff()));\r\n    }\r\n    \r\n    void print ()\r\n    {\r\n        std::cout << \"(\";\r\n        f->print();\r\n        std::cout << \" + \";\r\n        s->print();\r\n        std::cout << \")\";\r\n    }\r\n};\r\n\r\nclass sub : public expression \r\n{\r\n    expression * f;\r\n    expression * s;\r\npublic:\r\n    sub (expression * a, expression * b)\r\n    {\r\n        f = a;\r\n        s = b;\r\n    }\r\n    \r\n    ~sub()\r\n    {\r\n        delete f;\r\n        delete s;\r\n    }\r\n    \r\n    expression * copy ()\r\n    {\r\n        return new sub (f->copy(), s->copy());\r\n    }\r\n    \r\n    expression * diff ()\r\n    {\r\n        return (new sub (f->diff(), s->diff()));\r\n    }\r\n    \r\n    void print ()\r\n    {\r\n        std::cout << \"(\";\r\n        f->print();\r\n        std::cout << \" - \";\r\n        s->print();\r\n        std::cout << \")\";\r\n    }\r\n};\r\n\r\nclass mul : public expression\r\n{\r\n    expression * f;\r\n    expression * s;\r\npublic:\r\n    mul (expression * a, expression * b)\r\n    {\r\n        f = a;\r\n        s = b;\r\n    }\r\n    \r\n    ~mul()\r\n    {\r\n        delete f;\r\n        delete s;\r\n    }\r\n    \r\n    expression * copy ()\r\n    {\r\n        return new mul (f->copy(), s->copy());\r\n    }\r\n    \r\n    expression * diff()\r\n    {\r\n        return new add (new mul (f->diff(), s->copy()), new mul (f->copy(), s->diff()));\r\n    }\r\n    \r\n    void print()\r\n    {\r\n        f->print();\r\n        std::cout << \"*\";\r\n        s->print();\r\n    }\r\n};\r\n\r\nclass divs : public expression\r\n{\r\n    expression * f;\r\n    expression * s;\r\npublic:\r\n    divs (expression * a, expression * b)\r\n    {\r\n        f = a;\r\n        s = b;\r\n    }\r\n    \r\n    ~divs()\r\n    {\r\n        delete f;\r\n        delete s;\r\n    }\r\n    \r\n    expression * copy ()\r\n    {\r\n        return new divs (f->copy(), s->copy());\r\n    }\r\n    \r\n    expression * diff()\r\n    {\r\n        return new divs (new sub (new mul (f->diff(), s->copy()), new mul(f->copy(), s->diff())), new mul (s->copy(), s->copy()) );\r\n    }\r\n    \r\n    void print()\r\n    {\r\n        f->print();\r\n        std::cout << \"/\";\r\n        s->print();\r\n    }\r\n};\r\n\r\nint main ()\r\n{\r\n    expression * a = new divs (new add (new number (\"1\"), new variable (\"x\")), new sub (new number (\"-3\"), new variable (\"x\")));\r\n    expression * da;\r\n    a->print();\r\n    std::cout << \"\\n\\n\";\r\n    (da = a->diff())->print();\r\n    delete a;\r\n    delete da;\r\n    std::cout << \"\\n\\n Press enter \\n\";\r\n    std::cin.get();\r\n    return 0;\r\n}\r\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (534,'// godView.cpp : implementation of the CgodView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"god.h\"\r\n#include \"math.h\"\r\n#include \"godDoc.h\"\r\n#include \"godView.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CgodView\r\n\r\nIMPLEMENT_DYNCREATE(CgodView, CView)\r\n\r\nBEGIN_MESSAGE_MAP(CgodView, CView)\r\n	// Standard printing commands\r\n	ON_COMMAND(ID_FILE_PRINT, &CView::OnFilePrint)\r\n	ON_COMMAND(ID_FILE_PRINT_DIRECT, &CView::OnFilePrint)\r\n	ON_COMMAND(ID_FILE_PRINT_PREVIEW, &CView::OnFilePrintPreview)\r\nEND_MESSAGE_MAP()\r\n\r\n// CgodView construction/destruction\r\n\r\nCgodView::CgodView()\r\n{\r\n	// TODO: add construction code here\r\n\r\n}\r\n\r\nCgodView::~CgodView()\r\n{\r\n}\r\n\r\nBOOL CgodView::PreCreateWindow(CREATESTRUCT& cs)\r\n{\r\n	// TODO: Modify the Window class or styles here by modifying\r\n	//  the CREATESTRUCT cs\r\n\r\n	return CView::PreCreateWindow(cs);\r\n}\r\n\r\ndouble f(double x)\r\n{\r\n	if (x == 0) return 0;\r\n	return sin(1/x);\r\n}\r\n\r\n// CgodView drawing\r\n\r\nvoid CgodView::OnDraw(CDC* pDC)\r\n{\r\n	CgodDoc* pDoc = GetDocument();\r\n	ASSERT_VALID(pDoc);\r\n	if (!pDoc)\r\n		return;\r\nRECT rect;\r\n	pDC->GetWindow()->GetWindowRect(&rect);\r\n	int width=rect.right-rect.left;\r\n	int height=rect.bottom-rect.top;\r\n\r\n	int center_x=width/2;\r\n	int center_y=height/2;\r\n\r\n	double kx=200;\r\n	double ky=200;\r\n	pDC->MoveTo(center_x,0);\r\n	pDC->LineTo(center_x,height);\r\n	pDC->MoveTo(0,center_y);\r\n	pDC->LineTo(width,center_y);\r\n\r\n	int px=0;\r\n	double x=(px-center_x)/kx;\r\n	double y=f(x);\r\n	\r\n	int py=center_y-y*ky;\r\n	\r\n	\r\n	pDC->MoveTo(0,py);\r\n\r\n	for(int px=1;px<width;px++)\r\n	{	\r\n		x=(px-center_x)/kx;\r\n		y=f(x);\r\n		py=center_y-y*ky;\r\n		pDC->LineTo(px,py);\r\n\r\n	};\r\n	// TODO: add draw code for native data here\r\n}\r\n\r\n\r\n// CgodView printing\r\n\r\nBOOL CgodView::OnPreparePrinting(CPrintInfo* pInfo)\r\n{\r\n	// default preparation\r\n	return DoPreparePrinting(pInfo);\r\n}\r\n\r\nvoid CgodView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)\r\n{\r\n	// TODO: add extra initialization before printing\r\n}\r\n\r\nvoid CgodView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)\r\n{\r\n	// TODO: add cleanup after printing\r\n}\r\n\r\n\r\n// CgodView diagnostics\r\n\r\n#ifdef _DEBUG\r\nvoid CgodView::AssertValid() const\r\n{\r\n	CView::AssertValid();\r\n}\r\n\r\nvoid CgodView::Dump(CDumpContext& dc) const\r\n{\r\n	CView::Dump(dc);\r\n}\r\n\r\nCgodDoc* CgodView::GetDocument() const // non-debug version is inline\r\n{\r\n	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CgodDoc)));\r\n	return (CgodDoc*)m_pDocument;\r\n}\r\n#endif //_DEBUG\r\n\r\n\r\n// CgodView message handlers\r\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (535,'#include <QApplication>\n#include <QWidget>\n#include <QPainter>\n#include <math.h>\n#include <QString>\n#include <QPoint>\n\n#define scr_w 800\n#define scr_h 500\n#define scr_cx (scr_w/2)\n#define scr_cy (scr_h/2)\n#define scale_x (scr_w/6)\n#define scale_y (scr_h/6)\n#define e 0.1\n\nvoid draw (QPainter & p, double x1, double y1, double x2, double y2)\n{\n    p.drawLine(scr_cx + x1 * scale_x, scr_cy - y1 * scale_y, scr_cx + x2 * scale_x, scr_cy - y2 * scale_y);\n}\n\n//function\ndouble f (double x)\n{\n//    return (x * x);\n    if (x == 0) return 0;\n    return (sin(1/x));\n}\n\nvoid paintf (QPainter & p)\n{\n    p.setRenderHint(QPainter::Antialiasing, true);\n    //coordinates\n    p.drawLine(scr_w/2, 0, scr_w/2, scr_h);\n    p.drawLine(0, scr_h/2, scr_w, scr_h/2);\n    p.drawText(QPoint (scr_cx - 10, scr_cy + 12), QString (\"0\"));\n    p.drawText(QPoint (scr_cx + scr_w/6, scr_cy + 12), QString (\"1\"));\n    p.drawText(QPoint (scr_cx + scr_w/3, scr_cy + 12), QString (\"2\"));\n    p.drawText(QPoint (scr_cx + scr_w/2 - 10, scr_cy + 12), QString (\"3\"));\n    p.drawText(QPoint (scr_cx - scr_w/6, scr_cy + 12), QString (\"-1\"));\n    p.drawText(QPoint (scr_cx - scr_w/3, scr_cy + 12), QString (\"-2\"));\n    p.drawText(QPoint (scr_cx - scr_w/2, scr_cy + 12), QString (\"-3\"));\n    p.drawText(QPoint (scr_cx, scr_cy - scr_h/6), QString (\"1\"));\n    p.drawText(QPoint (scr_cx, scr_cy - scr_h/3), QString (\"2\"));\n    p.drawText(QPoint (scr_cx, scr_cy - scr_h/2 + 12), QString (\"3\"));\n    p.drawText(QPoint (scr_cx, scr_cy + scr_h/6), QString (\"-1\"));\n    p.drawText(QPoint (scr_cx, scr_cy + scr_h/3), QString (\"-2\"));\n    p.drawText(QPoint (scr_cx, scr_cy + scr_h/2), QString (\"-3\"));\n    //ends here\n    p.setPen(QPen (Qt::blue, 2, Qt::SolidLine, Qt::RoundCap));\n   /* for (double i = -3; i < 3; i += e)\n    {\n        draw (p, i, f (i), i + e, f (i + e));\n    }*/\n    int previ, prevj;\n    for (int i = 0; i < scr_w; i++)\n    {\n        double x = (i - scr_cx) / scale_x;\n        double y = f(x);\n        int j = scr_cy - y * scale_y;\n        if (i != 0)\n        {\n            p.drawLine(previ, prevj, i, j);\n        }\n        previ = i;\n        prevj = j;\n    }\n}\n\nclass paintspace : public QWidget\n{\npublic:\n    paintspace (QWidget * parent = 0) : QWidget (parent)\n    {}\n\n    void paintEvent (QPaintEvent *)\n    {\n        QPainter p (this);\n        paintf (p);\n    }\n};\n\n\nint main(int agrc, char ** agrv)\n{\n    QApplication app (agrc, agrv);\n    paintspace m;\n    m.resize(scr_w, scr_h);\n    m.show();\n    return app.exec();\n}\n\n\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (536,'#include <iostream>\r\n\r\nclass Expression\r\n{\r\npublic :\r\n\r\nvirtual Expression *diff() = 0;\r\n\r\nvirtual void print() = 0;\r\n};\r\nclass Number: public Expression\r\n{\r\ndouble a;\r\n\r\npublic :\r\n\r\nNumber(double b)\r\n{\r\n	a = b;\r\n}\r\n\r\nExpression *diff()\r\n{\r\n	Expression *e;\r\n	a = 0;\r\n	return e = new Number(0);\r\n}\r\n\r\nvoid print()\r\n{\r\n	std::cout << this->a;\r\n}\r\n};\r\n\r\nclass Variable: public Expression\r\n{\r\nchar a;\r\n\r\npublic :\r\n\r\nVariable(char b)\r\n{\r\n	a = b;\r\n}\r\n\r\nvoid print()\r\n{\r\n	std::cout << this->a;\r\n}\r\n\r\nExpression *diff()\r\n{\r\n	Expression *e;\r\n	return e = new Number(1);\r\n}\r\n};\r\n\r\nclass Add: public Expression\r\n{\r\nExpression *a;\r\nExpression *b;\r\n\r\npublic :\r\n\r\nAdd(Expression *c, Expression *d)\r\n{\r\n	a = c;\r\n	b = d;\r\n}\r\n\r\nvoid print()\r\n{\r\n	a->print(); std::cout << \"+\"; b->print();\r\n}\r\n\r\nExpression *diff()\r\n{\r\n	Expression *e;\r\n	a = a->diff();\r\n	b = b->diff();\r\n	return e = new Add(a, b);\r\n}\r\n};\r\n\r\nclass Sub: public Expression\r\n{\r\nExpression *a;\r\nExpression *b;\r\n\r\npublic :\r\n\r\nSub(Expression *c, Expression *d)\r\n{\r\n	a = c;\r\n	b = d;\r\n}\r\n\r\nvoid print()\r\n{\r\n	a->print(); std::cout << \"-\"; b->print();\r\n}\r\n\r\nExpression *diff()\r\n{\r\n	Expression *e;\r\n	a = a->diff();\r\n	b = b->diff();\r\n	return e = new Sub(a, b);\r\n}\r\n};\r\n\r\nint main()\r\n{\r\nExpression *e = new Add(new Number(1), new Variable(\'x\'));\r\nstd::cout << \"\\n\";\r\ne->print();\r\nExpression *de = e->diff();\r\nde->print();\r\nstd::cout << \"\\n\";\r\ndelete e;\r\ndelete de;\r\n	return 0;\r\n}','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (537,'// ChildView.cpp : implementation of the CChildView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"graffik.h\"\r\n#include \"ChildView.h\"\r\n#include<math.h>\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CChildView message handlers\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\n\r\nvoid CChildView::OnPaint() \r\n{\r\n	CPaintDC dc(this); // device context for painting\r\n	RECT rect;\r\n	dc.GetWindow()->GetWindowRect (&rect);\r\n\r\n\r\n	int l=0, r=rect.right, b=rect.bottom, t=0, x0=(l+r)/2, y0=(b+t)/2,px=l, py;\r\n	double kx=20., ky=20., w=(l-x0)/kx, z=(r-x0)/ky, x=w, y, a=5., m=5.;\r\n	dc.MoveTo(l, y0);\r\n	dc.LineTo(r, y0);\r\n	dc.MoveTo(x0, t);\r\n	dc.LineTo(x0, b);\r\n	\r\n	x=(px-x0)/kx;\r\n	y=a*sin(m*x);\r\n	py=(int)(y0-ky*y);\r\n	dc.MoveTo(px, py);\r\n	for (px=l; px<=r; px++)\r\n	{	\r\n		x=(px-x0)/kx;\r\n		y=a*sin(m*x);\r\n		py=(int)(y0-kx*y);\r\n		dc.LineTo(px, py);\r\n	}\r\n\r\n\r\n\r\n	// TODO: Add your message handler code here\r\n	\r\n	// Do not call CWnd::OnPaint() for painting messages\r\n}\r\n\r\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (538,'#include <iostream>\r\nusing namespace std;\r\n\r\nclass Expression\r\n{\r\n		public:\r\n				virtual Expression* diff() = 0;\r\n				virtual void print() = 0;\r\n};\r\n\r\nclass Number: public Expression\r\n{\r\n		private:\r\n				int x;\r\n		public:\r\n				Number (int y)\r\n				{\r\n						x = y;\r\n				}\r\n				Expression* diff()\r\n				{\r\n						return new Number(0);\r\n				}\r\n				void print()\r\n				{\r\n						std::cout<<x;\r\n				}\r\n};\r\nclass Variable: public Expression\r\n{\r\n		private:\r\n				char x;\r\n		public:\r\n				Variable(char a)\r\n				{\r\n						x = a;\r\n				}\r\n				Expression* diff()\r\n				{\r\n						return new Number(1);\r\n				}\r\n				void print()\r\n				{\r\n						std::cout<<x;\r\n				}\r\n};\r\nclass Add: public Expression\r\n{\r\n		private:\r\n				Expression *x, *y;\r\n		public:\r\n				Add (Expression *u, Expression *v):x(u), y(v) {};\r\n				Expression* diff()\r\n				{\r\n						return new Add (x->diff(),y->diff());\r\n				}\r\n				void print()\r\n				{\r\n						x->print();\r\n						std::cout<<\"+\";\r\n						y->print();\r\n				}\r\n};\r\nclass Sub: public Expression\r\n{\r\n		private:\r\n				Expression *x, *y;\r\n		public:\r\n				Sub (Expression *u, Expression *v):x(u), y(v) {};\r\n				Expression* diff()\r\n				{\r\n						return new Sub (x->diff(),y->diff());\r\n				}\r\n				void print()\r\n				{\r\n						x->print();\r\n						std::cout<<\"-\";\r\n						y->print();\r\n				}\r\n};\r\nclass Mul: public Expression\r\n{\r\n		private:\r\n				Expression *x, *y;\r\n		public:\r\n				Mul (Expression *u, Expression *v):x(u), y(v) {};\r\n				Expression* diff()\r\n				{\r\n						return new Add (new Mul(x->diff(),y),new Mul(x,y->diff()));\r\n				}\r\n				void print()\r\n				{\r\n						x->print();\r\n						std::cout<<\"*\";\r\n						y->print();\r\n				}\r\n};\r\nclass Div: public Expression\r\n{\r\n		private:\r\n				Expression *x, *y;\r\n		public:\r\n				Div (Expression *u, Expression *v):x(u), y(v) {};\r\n				Expression* diff()\r\n				{\r\n						return new Div (new Sub(new Mul(x->diff(),y),new Mul(x,y->diff())),new Mul(y,y));\r\n				}\r\n				void print()\r\n				{\r\n						x->print();\r\n						std::cout<<\"/\";\r\n						y->print();\r\n				}\r\n};\r\n\r\nint main()\r\n{\r\n		Expression *e = new Mul(new Number(1), new Variable(\'x\'));\r\n		std::cout << \"\\n\";\r\n		Expression *de = e->diff();\r\n		e->print();\r\n		std::cout << \"\\n\";\r\n		de->print();\r\n		std::cout << \"\\n\";\r\n		delete e;\r\n		delete de;\r\n		return 0;\r\n}\r\n\r\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (539,'#include <iostream>\r\nusing namespace std;\r\n\r\ntemplate <typename T> \r\nclass List\r\n{\r\n	class Knot\r\n	{\r\n		public:\r\n			T data;\r\n			Knot *next;\r\n			Knot *prev;\r\n			Knot(T dat = 0){data=dat;next=0;prev=0;}\r\n	};\r\n	Knot *head, *tail;\r\n	public:\r\n		class Iterator\r\n		{\r\n			private:\r\n				Knot* i;\r\n			public:\r\n			Iterator()\r\n			{\r\n				i = 0;\r\n			}\r\n		Iterator(Knot*a)\r\n		{\r\n			i = a;\r\n		}\r\n		Iterator(const Iterator &other)\r\n		{\r\n			i = other.i;\r\n		}\r\n		~Iterator() {}\r\n		Iterator& operator++()\r\n		{\r\n			i = i->next;\r\n			return *this;\r\n		}\r\n		bool operator!=(const Iterator &other) const\r\n		{\r\n			return (i != other.i);\r\n		}\r\n		T* operator->()\r\n		{\r\n			return &(i->data);\r\n		}\r\n		T& operator*()\r\n		{\r\n			return i->data;\r\n		}\r\n	};\r\nIterator begin() const\r\n{\r\nreturn Iterator(head);\r\n}\r\nIterator end() const\r\n{\r\nreturn Iterator(0);\r\n		};\r\n		List(){head=0;tail=0;}\r\n		~List();\r\n		void addend(T data);\r\n		int removefirst();\r\n		int removelast();\r\n		void addbeg(T data);\r\n		int print();\r\n	private:\r\n		List(const List & other);\r\n		List & operator = (List & other);\r\n\r\n};\r\ntemplate <typename T>\r\nList<T>::~List()\r\n{\r\n	if(head!=0)\r\n	{\r\n		Knot *cu=head;\r\n		while (cu){\r\n			cu=cu->next;\r\n			delete head;\r\n			head=cu;}\r\n	}\r\n}\r\ntemplate <typename T>\r\nvoid List <T>::addend(T data)\r\n{\r\n	Knot *cu=new Knot(data);\r\n	if(head==0)\r\n		head=tail=cu;\r\n	else{\r\n		cu->prev=tail;\r\n		tail->next=cu;\r\n		tail=cu;}\r\n}\r\ntemplate <typename T>\r\nint List <T>::removefirst()\r\n{\r\n	if(head==0)\r\n	{\r\n		return 0;\r\n	}\r\n	if (head->next == 0)\r\n	{\r\n		head=head->next;\r\n		return 0;\r\n	}\r\n	else\r\n	{\r\n	head=head->next;\r\n	head->prev=0;\r\n	}\r\n}\r\ntemplate <typename T>\r\nint List <T>::removelast()\r\n{\r\n	if(head==0)\r\n	{\r\n		return 0;\r\n	}\r\n	if (head->next == 0)\r\n	{\r\n		removefirst();\r\n		return 0;\r\n	}\r\n	tail=tail->prev;\r\n	delete(tail->next);\r\n	tail->next=0;\r\n	return 0;\r\n	}\r\ntemplate <typename T>\r\nvoid List <T>::addbeg(T data)\r\n{\r\n	Knot *cu=new Knot(data);\r\n	if(tail==0)\r\n		tail=head=cu;\r\n	else\r\n	{	cu->next=head;\r\n		head->prev=cu;\r\n		head=cu;}\r\n}\r\ntemplate <typename T>\r\nint List <T>::print()\r\n{\r\n	if (!head)\r\n	{\r\n		cout << \"\";\r\n		return 0;\r\n	}\r\n	Knot *cu=head;\r\n	cout << endl << \"list\";\r\n	while(cu)\r\n	{\r\n		cout << cu->data << \' \';\r\n		cu=cu->next;\r\n	cout << endl;\r\n	}\r\n}\r\n\r\nint main()\r\n{\r\n	List<int> isp;\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		isp.addend(i);\r\n		isp.addbeg(i);\r\n		isp.print();\r\n	}\r\n\r\n	for (List<int>::Iterator i = isp.begin(); i != isp.end(); ++i)\r\n	{\r\n		std::cout << *i << \" \";\r\n	}\r\n	std::cout << \"\\n\";\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		isp.removefirst();\r\n		isp.removelast();\r\n		isp.print();\r\n	}\r\n\r\n	return 0;\r\n}\r\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (540,'#include <iostream>\r\n#include <string.h>\r\ntemplate <typename T> class List\r\n{\r\n	private:\r\n		struct element\r\n		{\r\n			T data;\r\n			element *next;\r\n		};\r\n		element *head;\r\n\r\n		List(const List &r);			\r\n		List& operator=(const List &r);		//?????? ?????????? \r\n 	public:\r\n		List()\r\n		{\r\n			head = 0;\r\n			std::cout <<\"Go\\n\";\r\n		}\r\n		~List()\r\n		{\r\n			element *p;\r\n			p=head;\r\n			while(head)\r\n			{\r\n				p=head;\r\n				head=head->next;\r\n				delete p;\r\n			}\r\n			std::cout <<\"End\\n\";\r\n		}\r\n		void addfirst(const T a) // ????????\r\n		{\r\n			element *p;\r\n			p = new element;\r\n			if (p==0)\r\n			{\r\n				head=p;\r\n				p->data=a;\r\n				p->next=0;\r\n			}\r\n			else\r\n			{\r\n				p->data=a;\r\n				p->next = head;\r\n				head = p;\r\n			}\r\n		}\r\n		void addlast(const T a)  // ????????\r\n		{\r\n			element *p=head;\r\n			element *h = new element;\r\n			if(p==0)\r\n			{\r\n				head=h;\r\n				h->data=a;\r\n				head->next=0;\r\n			}\r\n			else\r\n			{\r\n				element *q=0;\r\n				while(p!=0)\r\n				{\r\n					q=p;\r\n					p=p->next;\r\n				}\r\n				q->next=h;\r\n				h->data=a;\r\n				h->next=0;\r\n			}\r\n		}\r\n		void delfirst()// ????????\r\n		{\r\n			element *p=head;\r\n			if(p==0) {std::cout<<\"Pusto bilo\"; return;}\r\n			if(p->next==0)\r\n			{\r\n				head=0;\r\n				delete p;\r\n			}\r\n			else\r\n			{\r\n				head = head->next;\r\n				delete p;\r\n			}\r\n		}\r\n		void dellast() //  ????????\r\n		{\r\n			struct element *p=head;\r\n			if(p==0){std::cout<<\"Pusto bilo\";return;}\r\n			if(p->next==0)\r\n			{\r\n				head =0;\r\n				delete p;\r\n			}\r\n			else  // ?????? ?? ???????\r\n			{\r\n				struct element *q=0;\r\n				while(p->next!=0)\r\n				{\r\n					q=p;\r\n					p=p->next;\r\n				}\r\n				q->next=0;\r\n				delete p;\r\n			}\r\n		}\r\n		void printAll() const   //// ?????? ?????\r\n		{	\r\n			struct element *p;\r\n			for(p=head;p;p=p->next)\r\n				std::cout << p->data;\r\n			std::cout << \"\\n\";\r\n		}\r\n//////////////////////////////////////////////////////////////////\r\n		class Iterator\r\n		{\r\n			private:\r\n				element *ukaz;\r\n			public:\r\n			Iterator(void)\r\n			{\r\n				ukaz=0;\r\n			};\r\n			Iterator(element *r)\r\n			{\r\n				ukaz=r;\r\n			};\r\n			T operator*(void)\r\n			{\r\n				return(ukaz->data);\r\n			};\r\n			bool operator != (Iterator &r) const\r\n			{\r\n				if(ukaz!=r.ukaz)\r\n					return(1);\r\n				return(0);\r\n			};\r\n			T *operator->(void)\r\n			{\r\n				return &(ukaz->data);\r\n			};\r\n			Iterator operator++(void)\r\n			{\r\n				ukaz=ukaz->next;\r\n				return Iterator(ukaz);\r\n			};	\r\n		};\r\n		Iterator begin(void) const \r\n		{\r\n			return Iterator(head);\r\n		};\r\n		Iterator end(void) const \r\n		{\r\n			return Iterator(); \r\n		};\r\n//////////////////////////////////////////////////////////////////		\r\n};\r\n\r\nint main()\r\n{\r\n	List<int> f;\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		f.addlast(i);\r\n		f.addfirst(i);\r\n	}\r\n	f.printAll();\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		f.delfirst();\r\n		f.dellast();\r\n		f.printAll();\r\n	}\r\n//////////////////////////////////////////////////////////////////		\r\n	List<int> f1;\r\n	for(int i=1;i<11;i++)\r\n		f1.addlast(i);\r\n	for(List<int>::Iterator i=f1.begin(); i!=f1.end();++i )\r\n		std::cout<<*i<<\"  \";\r\n	std::cout<<\"\\n\\n\\n\";\r\n//////////////////////////////////////////////////////////////////		\r\n	struct school\r\n	{\r\n		char *klas;\r\n		char *bukva;\r\n	};\r\n	school s;\r\n	List<school> f2;\r\n	s.klas=\"10\";\r\n	s.bukva=\"A\";\r\n	f2.addlast(s);\r\n	s.klas=\"11\";\r\n	s.bukva=\"B\";\r\n	f2.addlast(s);\r\n	for(List<school>::Iterator i=f2.begin();i!=f2.end();++i)\r\n		std::cout<<i->klas<<\" \"<<i->bukva<<\"\\n\";\r\n	std::cout<<\"\\n\\n\\n\";\r\n}','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (541,'// ChildView.cpp : implementation of the CChildView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"l1ast.h\"\r\n#include \"ChildView.h\"\r\n#include<iostream>\r\n#include<cmath>\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CChildView message handlers\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\ndouble f (double x)\r\n{\r\n	if(x!=0)\r\n		return 1/x;\r\n}\r\ndouble g (double x)\r\n{\r\n	return x;\r\n}\r\ndouble w (double x)\r\n{\r\n	if(x!=0)\r\n		return sin(1/x);\r\n}\r\n\r\nvoid CChildView::OnPaint() \r\n{\r\n	CPaintDC dc(this); // device context for painting\r\n	\r\n	// TODO: Add your message handler code here\r\n	int mx = 50;\r\n	int my = 50;\r\n\r\n	RECT rect;\r\n	dc.GetWindow()->GetWindowRect(&rect);\r\n	int width = rect.right - rect.left;\r\n	int height = rect.bottom - rect.top;\r\n	int cx = width/2;\r\n	int cy = height/2;\r\n	dc.MoveTo(0, cy);\r\n	dc.LineTo(width, cy);\r\n	dc.MoveTo(cx, 0);\r\n	dc.LineTo(cx, height);\r\n	\r\n	for(double i=0; i<width; i++)\r\n	{\r\n		double x = (double)(i-cx)/mx;			\r\n		if(x!=0)\r\n		{	\r\n			double y = f(x);\r\n			double j = cy - my*y;\r\n			if(i==0)\r\n				dc.MoveTo(i,j);\r\n			else\r\n				dc.LineTo(i,j);	\r\n		}\r\n	}\r\n	for(double i=0; i<width; i++)\r\n	{\r\n		double x = (double)(i-cx)/mx;			\r\n		if(x!=0)\r\n		{	\r\n			double y = w(x);\r\n			double j = cy - my*y;\r\n			if(i==0)\r\n				dc.MoveTo(i,j);\r\n			else\r\n				dc.LineTo(i,j);	\r\n		}\r\n	}\r\n	for(int i=0; i<width; i++)\r\n	{\r\n		double x = (double)(i-cx)/mx;			\r\n		double y = g(x);\r\n		int j = cy - my*y;\r\n		if(i==0)\r\n			dc.MoveTo(i,j);\r\n		else\r\n			dc.LineTo(i,j);	\r\n	}\r\n	// Do not call CWnd::OnPaint() for painting messages\r\n}\r\n','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (542,'#include<iostream>\r\n#include\"template.h\"\r\n\r\n\r\nint main()\r\n{\r\n	int k=5;\r\n	setlocale(LC_ALL, \"Russian\");\r\n	List<int> a;\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n	//	a.AddEnd(i);\r\n		a.AddHead(10-i);\r\n	//	a.print();\r\n	}\r\n	a.print();\r\n	/*for (int i = 0; i < 5; i++)\r\n	{\r\n		a.DelHead();\r\n		a.DelEnd();\r\n		a.print();\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		a.AddHead(i);\r\n		a.AddEnd(i);\r\n		a.print();\r\n	}\r\n\r\n	for (int i = 0; i < 5; i++)\r\n	{\r\n		a.DelEnd();\r\n		a.DelHead();\r\n		a.print();\r\n	}*/\r\n	List<int>::iter z=0;\r\n	for(List<int>::iter i=a.begin();i!=z;++i)\r\n		std::cout<<*i<<\"\\n\";\r\n	std::cout<<\"\\n\";\r\n	struct uni\r\n	{\r\n		char* group;\r\n		char* surname;\r\n	};\r\n	uni U;\r\n	List<uni> q;\r\n	U.group=\"9113\";\r\n	U.surname=\"rostomyan\";\r\n	q.AddHead(U);\r\n	List<uni>::iter zz = 0;\r\n	for(List<uni>::iter i=q.begin();i!=zz;++i)\r\n	{\r\n		std::cout<<i->group<<\"\\n\";\r\n		std::cout<<i->surname<<\"\\n\";\r\n	}\r\n	return 0;\r\n\r\n}','Ð¡ÐµÐ¼Ñ‘Ð½','Semyon','m');
INSERT INTO `bias` VALUES (543,'// ChildView.cpp : implementation of the CChildView class\r\n//\r\n\r\n#include \"stdafx.h\"\r\n#include \"4zadanie.h\"\r\n#include \"ChildView.h\"\r\n\r\n#ifdef _DEBUG\r\n#define new DEBUG_NEW\r\n#endif\r\n\r\n\r\n// CChildView\r\n\r\nCChildView::CChildView()\r\n{\r\n}\r\n\r\nCChildView::~CChildView()\r\n{\r\n}\r\n\r\n\r\nBEGIN_MESSAGE_MAP(CChildView, CWnd)\r\n	ON_WM_PAINT()\r\nEND_MESSAGE_MAP()\r\n\r\n\r\n\r\n// CChildView message handlers\r\n\r\nBOOL CChildView::PreCreateWindow(CREATESTRUCT& cs) \r\n{\r\n	if (!CWnd::PreCreateWindow(cs))\r\n		return FALSE;\r\n\r\n	cs.dwExStyle |= WS_EX_CLIENTEDGE;\r\n	cs.style &= ~WS_BORDER;\r\n	cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, \r\n		::LoadCursor(NULL, IDC_ARROW), reinterpret_cast<HBRUSH>(COLOR_WINDOW+1), NULL);\r\n\r\n	return TRUE;\r\n}\r\n\r\n#include <math.h>\r\n\r\ndouble f(double x)\r\n{\r\n	if (x == 0) return 0;\r\n	return(1/x);\r\n}\r\nvoid CChildView::OnPaint() \r\n{\r\n	int x0,y0;\r\n	int x1,y1;\r\n	int mx,my;\r\n	int t=10;\r\n	double a;\r\n	CPaintDC dc(this); // device context for painting\r\n	RECT rect;\r\n	dc.GetWindow()->GetWindowRect(&rect);\r\n	x0=(rect.right-rect.left)/2;\r\n	y0=(rect.bottom-rect.top)/2;\r\n	mx=(rect.right-rect.left)/(2*t);\r\n	my=(rect.top-rect.bottom)/(2*t);\r\n	dc.MoveTo(x0,0); \r\n	dc.LineTo(x0,rect.bottom); \r\n	dc.MoveTo(0,y0); \r\n	dc.LineTo(rect.right,y0);\r\n\r\n	CPen pen1(PS_SOLID, 2, RGB(128,10,55)); \r\n	dc.SelectObject(pen1);\r\n\r\n	x0=-t*mx;\r\n	y0=(f(-t))*my;\r\n	dc.MoveTo(x0+rect.right/2, y0+rect.bottom/2);\r\n	\r\n	for (a=-t;a<t;a+=0.001)\r\n	{\r\n		x1=(a+0.001)*mx;\r\n		y1=(f(a+0.001))*my;\r\n		dc.LineTo(x1+(rect.right-rect.left)/2, y1+(rect.bottom-rect.top)/2);\r\n	}\r\n\r\n}\r\n\r\n\r\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (544,'#include <stdio.h>\n\n#define sto 101\n\nvoid obhod(int sm[sto][sto], int * vis ,int tec,int cv)\n{\n	int i;\n	vis[tec]=1;\n	printf(\"%d \",tec);\n	for(i=1;i<=cv;i++)\n		if((sm[tec][i])&&(!vis[i]))\n			obhod(sm,vis,i,cv);\n}\n\nint main()\n{\n	FILE * f=fopen(\"graph.txt\",\"r\");\n	int cv,cr;\n	int sm[sto][sto]={0};\n	int vis[sto]={0};\n	int i,l,r,nach=1;\n								\n	fscanf(f,\"%d %d\\n\",&cv,&cr);\n	for(i=0;i<cr;i++)\n	{\n		fscanf(f,\"%d %d\\n\",&l,&r);\n		sm[l][r]=1;\n		sm[r][l]=1;\n	}\n	fscanf(f,\"&d\",&nach);\n	obhod(sm, vis, nach,cv);	\n	printf(\"\\n\");\n	\n	close(f);\n	return 0;						\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (545,'#include <stdio.h>\n#include <stdlib.h>\n\n#define sto 101\n\nstruct list\n{\n	int ver;\n	struct list * next;\n};\nvoid ins(int tec, struct list * head1)\n{\n	struct list *p=head1,*q=head1,*f;\n	while(q)\n	{\n		p=q;\n		q=q->next;\n	}\n	f=malloc(sizeof(struct list));\n	f->ver=tec;\n	f->next=NULL;\n	p->next=f;\n}\nvoid obhod(int sm[sto][sto], int * vis,int tec ,int cv, struct list * head1)\n{\n	int i;\n	printf(\"%d \",tec);\n	for(i=1;i<=cv;i++)\n		if((sm[tec][i])&&(!vis[i]))\n		{\n			ins(i,head1);\n			vis[i]=1;\n		}	\n}\n\nint main()\n{\n	FILE * f=fopen(\"graph.txt\",\"r\");\n	struct list * p,* head;\n	int cv,cr;\n	int sm[sto][sto]={0};\n	int vis[sto]={0};\n	int i,l,r,nach=1;\n	\n	fscanf(f,\"%d %d\\n\",&cv,&cr);\n	for(i=0;i<cr;i++)\n	{\n        	fscanf(f,\"%d %d\\n\",&l,&r);\n        	sm[l][r]=1;\n        	sm[r][l]=1;\n        }\n        fscanf(f,\"&d\",&nach);\n\n	head=malloc(sizeof(struct list));\n	head->ver=nach;\n	head->next=NULL;\n	p=head;\n	vis[nach]=1;\n	while(p)\n	{\n		nach=p->ver;\n		obhod(sm, vis, nach,cv,head);	\n		p=p->next;\n	}\n        \n	printf(\"\\n\");\n	\n	close(f);\n        return 0;				\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (546,'#include<stdio.h>\n#define NMAX 100000\n\nvoid sift(int *A, int N, int k)\n{\n	int a,b,tmp,c;\n	a = 2*k + 1;\n	b = 2*k + 2;\n	c = k;\n	if (a < N && A[a] > A[c])\n		c = a;\n	if (b < N && A[b] > A[c])\n		c = b;\n	if (c != k)\n	{\n		tmp = A[k];\n		A[k] = A[c];\n		A[c] = tmp;\n		sift(A,N,c);\n	}\n}\nvoid hsort (int *A,int n)\n{\n	int i,tmp,j;\n	for (i=n/2;i>=0;i--)\n		sift (A,n,i);\n	for (i = n-1; i > 0; i--)\n	{\n		tmp = A[0];\n		A[0]=A[i];\n		A[i]=tmp;\n		sift(A,i,0);\n	}\n}\nvoid sort(int *A,int n)\n{\n	hsort (A,n);\n}\n\nint main ()\n{\n	int N,i,j;\n	int A[NMAX];\n	FILE* f=fopen(\"input.txt\",\"r\");\n	FILE* I=fopen(\"output.txt\",\"w\");\n	fscanf(f,\"%d\",&N);\n	for(i=0;i<N;i++)\n	{\n		fscanf(f,\"%d\",&A[i]);\n	}\n	sort(A,N);\n	for(i=0;i<N;i++)\n	{\n		fprintf(I,\"%d \",A[i]);\n	}		\n	return 0;\n}\n\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (547,'#include <stdio.h>\n#include <stdlib.h>\nint main()\n{\n	struct item \n	{\n		int data;\n		struct item *next;\n	};\n	struct item *head = NULL;\n	struct item *p = head,*q = NULL,*r;\n	FILE *f = fopen (\"/home/other/fenster/input_list.txt\",\"r\");\n	int a,i=0,j=0;\n	\n	fscanf (f,\"%d\",&a);\n	head=malloc(sizeof(*head));\n	head->data=a;\n	head->next = NULL;\n	p=head;\n	\n	while (fscanf(f,\"%d\",&a) == 1)\n	{	j=0;\n		q = NULL;\n\n		for( ; p && a>=p->data; q = p, p=p->next)\n			j++;\n\n		if (!p)\n		{\n			// ???????? ? ????? ?????\n			q->next = malloc(sizeof(*q));\n			q->next->data = a;\n			q->next->next = NULL;\n		}\n		else if(j!=0)\n		{	\n			int tmp = 0;\n			// ???????? ????? p\n			r = q->next;\n			q->next = malloc(sizeof(*q));\n			q->next->data = a;\n			q->next->next = r;\n		//	tmp = q->data;\n		//	q->data = p->data;\n		//	p->data = tmp;\n		}\n		else\n		{\n			// ???????? ? ??????\n			r = malloc(sizeof(*r));\n			r->data=a;\n			r->next = p;\n			head=r;\n		}\n		p=head;\n	}\n	fclose (f);\n\n	for (p = head; p; p = p->next)\n	{\n		printf(\"%d \", p->data);\n	}\n	printf(\"\\n\");\n\n	while (head)\n	{\n		p = head->next;\n		free(head);\n		head = p;\n	}\n	\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (548,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct item {\n	char word [11];\n	int count;\n	struct item *next;\n};\n\nint Bs(char a)\n{\n	if (a >=\'A\' && a<= \'Z\')\n		return a - \'A\' + \'a\';\n	return a;\n}\n\nint main ()\n{\n	struct item *head = NULL,*q = NULL,*p=malloc(sizeof(*p));\n	char s[11]={0};\n	int a=0,b=0,flag=0;\n	char c; \n	FILE* F = fopen (\"text.txt\",\"r\");\n	FILE* I = fopen (\"output\",\"w\");\n	while ((c=fgetc(F)) != EOF)\n	{\n		flag=0;\n		if ((c>=\'A\' && c<=\'Z\') || (c>=\'a\' && c<=\'z\'))\n			s[a++]=Bs(c);\n		else\n		{\n			for (q=head;q;p=q, q=q->next)\n			{\n				if (strcmp(s,q->word) == 0)\n				{\n					q->count++;\n					flag=1;\n					memset(s,0,11);\n					a=0;\n				}\n			}\n			if (flag==0)\n			{	q = malloc (sizeof (*q));\n				strcpy(q->word,s);\n				q->count = 1;\n				q->next = NULL;\n				p->next=q;\n				memset(s,0,11);\n				a=0;\n				if (head == NULL)\n				{\n					head = q;\n					p=head;\n				}\n			}\n		}\n	}\n	for (q=head;q;q=q->next)\n	{\n		fprintf (I,\"%s  -  %d\\n\",q->word,q->count);\n	}\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (549,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item \n{\n	int data;\n	struct item *left, *right;\n};\nvoid s_tree(struct item *root,int a)\n{\n	struct item *p;\n	if(a>root->data)\n	{\n		if(root->right == NULL)\n		{\n			p=malloc(sizeof(*p));\n			p->data=a;\n			p->left=NULL;\n			p->right=NULL;\n			root->right=p;\n		}\n		else\n		{\n			s_tree(root->right,a);\n		}\n	}\n	else\n	{\n		if(root->left == NULL)\n		{\n			p=malloc(sizeof(*p));\n			p->data=a;\n			p->left=NULL;\n			p->right=NULL;\n			root->left=p;\n		}\n		else\n		{\n			s_tree(root->left,a);\n		}\n		\n	}\n}\nvoid dfs(struct item *root)\n{\n	if(!root) \n		return;\n	dfs(root->left);\n	\n	\n	printf (\"%d \",root->data);\n	dfs(root->right);\n\n	free(root);\n}\n	\nint main()\n{\n	struct item *root = NULL;\n	struct item *p = root,*q = NULL,*r;\n	FILE *f = fopen (\"input.txt\",\"r\");\n	FILE *I = fopen (\"output.txt\",\"w\");\n	int a,i=0,j=0;\n	fscanf (f,\"%d\",&a);\n	root=malloc(sizeof(*root));\n	root->data=a;\n	root->left = NULL;\n	root->right = NULL;\n	while (fscanf(f,\"%d\",&a) == 1)\n	{\n		s_tree(root,a);\n	}\n	dfs (root);\n\n				\n\n			\n	fclose (f);\n\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (550,'#include <stdio.h>\n#define NMAX 100\n\nint visited[NMAX]={0};\nint A[NMAX][NMAX];\nvoid dfs (int c)\n{\n	int i;\n	printf (\"%d\\n\",c);\n	visited[c]=1;\n	for(i=0;i<NMAX;i++)\n	{\n		if(A[c][i] == 1 && !visited[i])\n		{\n		//	printf(\"%d\\n\",i);\n		//	visited[i]=1;\n			dfs(i);\n		}\n	}\n}\nint main ()\n{\n	int edge,vert,i,j,a,b,t;\n	FILE* F=fopen (\"graf.txt\",\"r\");\n	FILE* I=fopen (\"output.txt\",\"w\");\n	fscanf (F,\"%d %d\",&vert,&edge);\n//	printf (\"%d %d\",edge,vert);\n	for (i=0;i<edge;i++)\n	{\n		fscanf (F,\"%d %d\",&a,&b);\n		printf(\"%d %d\\n\", a, b);\n		A[a][b]=1;\n		A[b][a]=1;\n	//	printf (\"%d %d\",a,b);\n	}\n	dfs(1);\n		\n	fclose (F);\n	fclose (I);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (551,'#include <stdio.h>\n#define NMAX 100\nint queue[100];\nint r=0,w=0;\nvoid enqueue (int a)\n{\n	queue[w++] = a;\n}\nint dequeue (void)\n{\n	return (queue[r++]);\n}\nint empty(void)\n{\n	return (r==w);\n}\nint main ()\n{\n	int edge,vert,i,j,a,b,t;\n	int A[NMAX][NMAX]={0};\n	int visited[NMAX]={0};\n	FILE* F=fopen (\"graf.txt\",\"r\");\n	FILE* I=fopen (\"output.txt\",\"w\");\n	fscanf (F,\"%d %d\",&vert,&edge);\n//	printf (\"%d %d\",edge,vert);\n	for (i=0;i<edge;i++)\n	{\n		fscanf (F,\"%d %d\",&a,&b);\n		A[a][b]=1;\n		A[b][a]=1;\n	}\n	enqueue(1);\n	visited[1]=1;\n	while (!empty())\n	{	t=dequeue();\n		printf (\">> %d\\n\", t);\n		for (i=1;i<=vert;i++)\n		{\n			if (A[t][i]==1 && !visited[i])\n			{\n				enqueue(i);\n				visited[i]=1;\n			}\n		}\n	}\n	fclose (F);\n	fclose (I);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (552,'#include <stdio.h>\n#include <stdlib.h>\nint main()\n{\n	int a;\n	struct item {\n		int data;\n		struct item*next;\n	};\n	struct item *head = NULL;\n	struct item *t;\n	struct item *p;\n	struct item *q;\n\n	\n	FILE*f = fopen(\"input1.txt\",\"r\");\n\n	\n\n		if (fscanf(f,\"%d\",&a)==1)\n		{\n		 head=malloc(sizeof(*head));\n		 head->data=a;\n		 head->next=NULL;\n		 p=head;\n		 printf(\"%d\",head->data);\n		}\n		\n		\n	while (fscanf(f,\"%d\",&a)==1)\n	{\n		struct item *q=malloc(sizeof(*q));\n		for (p=head;(p->next) && (a>=p->data);p=p->next)\n		{}\n			\n			\n			q->next=p->next;\n			p->next=malloc(sizeof(*p));\n			p->next=q;\n				\n			if (p->data >a)\n			{\n				q->data=p->data;\n				p->data=a;\n			}\n\n			else q->data=a;\n			\n	}			\n	for(p=head;p;p=p->next)\n	{\n		printf(\"%d \",p->data);\n		printf(\"\\n\");\n	}\n	\n	while (head)\n	{\n		p = head->next;\n		free(head);\n		head = p;\n	}\n	\n	fclose(f);\n	return 0;\n}\n		\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (553,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*int strcmp(char *a, char *b)\n{\n	 while (*a && *b && *a == *b)\n	 {\n		 a++;\n		 b++;\n	 }\n	 return *a-*b;\n}\n*/\nchar *readword(FILE*f)\n{\n	char *p=NULL;\n	int all=0;\n	int u=0;\n	int c;\n	\n	while ((c=fgetc(f))!=EOF)\n			{\n				if (!isalpha(c)) break;\n				if (all==u)\n				{\n					char *q=realloc(p, all + 11);\n					if (!q) break;\n					p=q;\n					all+=11;\n				}\n				p[u]=c;\n				u++;\n			}\n	if (p)\n	{\n		p[u]=0;\n	}\n\n	return p;\n}\nvoid readword2(FILE *f)\n{\n	int wc=0;\n	char *k;\nstruct word {\n	char word[11];\n	int count;\n	struct word *next;\n};\nstruct word *head=NULL;\nstruct word *p;\np=head;\nwhile ((k=readword(f))!=NULL)\n{\n	wc=0;\n\n	for(p=head;p;p=p->next)\n	{\n		if(strcmp(k,p->word)==0)\n		{\n			wc=1;\n			break;\n		}\n		\n	}\n	if (wc!=0) p->count++;\n		\n	else\n	{\n		struct word *t=malloc(sizeof(*t));\n		strcpy(t->word, k);\n		t->next=head;\n		t->count=1;\n		head=t;\n	}\n\n	\n\n }\n   for(p=head;p;p=p->next)\n   {\n	printf(\"%s  %d\",p->word,p->count);\n	printf(\"\\n\");\n   }\n}\n	/*for(i=0;i<wc;i++)\n		if (strcmp(k,W[i].s)==0) break;\n	if (i=wc)\n	{\n		wc++;\n		W[i].s=k;\n		W[i].count=1;\n	}\n	else\n	{\n		W[i].count++;\n		free(k);\n	}*/\n\n\nint main()\n{\n	FILE *f=fopen(\"input2.txt\",\"r\");\n	readword2(f);\n	\n	return 0;\n\n\n\n}	\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (554,'#include <stdio.h>\nint N, visited[100]={0};\nint a[100][100];\nvoid dfs(int c)\n{\n	int i;\n	printf(\"%d \",c);\n	visited[c]=1;\n	for(i=0;i<100;i++)\n	{\n		if (a[c][i]==1 && !visited[i]) \n			dfs(i);\n	}\n}\nint main()\n{\n	FILE*f=fopen(\"input3.txt\",\"r\");\n	int R,x,j,y;\n        fscanf(f,\"%d %d \",&N, &R);\n	for (j=0;j<R;j++)\n	{\n		fscanf(f,\"%d %d\", &x,&y);\n		a[x][y]=1;\n		a[y][x]=1;\n	}\n\n	dfs(1);\n	fclose(f);\n	printf(\"\\n\");\n	return 0;\n}\n		\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (555,'#include <stdio.h>\n#define N 100\nint A[N][N]={0};\nint Q[N];\nint r=0,w=0;\nvoid enqueue(int a)\n{\n	Q[w++]=a;\n}\nint dequeue()\n{\n	return Q[r++];\n}\nint empty()\n{\n	return(r==w);\n}\nvoid bfs(int c)\n{\n	int i,d;\n	int visited[N]={0};\n	enqueue(c);\n	visited[c]=1;\n	while (!empty())\n	{\n		c=dequeue();\n		printf(\"%d\",c);\n		\n		for (i=1;i<=N;i++)\n		{\n			if (A[c][i] && !visited[i])\n			{\n				enqueue(i);\n				visited[i]=1;\n			}\n		}\n	}\n}\n\nint main()\n{\n	FILE *f=fopen(\"input4.txt\",\"r\");\n	int x,y,j,R;\n	fscanf(f,\"%*d%d\", &R);\n	for(j=1;j<=R;j++)\n	{\n		fscanf(f, \"%d %d\", &x,&y);\n		A[x][y]=1;\n		A[y][x]=1;\n	}\n	bfs(1);\n	fclose(f);\n	printf(\"\\n\");\n	return 0;\n}\n\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (556,'#include<stdio.h>\n#include<string.h>\n#define N 100 \nint main()\n{\n	char login[N]={0};\n	int a1=0, a2=0, b, c, d=0, i, n=0;\n	FILE *f;\n	printf(\"??????? ?????: \");\n	scanf(\"%s\", login);\n	b=strlen(login);\n	printf(\"??? ???????????? \\\"%s\\\": \", login);\n	f=fopen(\"/etc/passwd\", \"r\");\n	for(i=0; (c=fgetc(f))!=EOF; i++)\n	{\n		if (a1==4 && a2)\n		{\n			if (c==\':\' || c==\',\')\n			{\n				break;\n			}\n			printf(\"%c\", c);\n		}\n		if (c==\':\')\n		{\n			a1++;\n			if (n==b && d==b)\n			{\n				a2=1;\n			}\n			else\n			{\n				continue;\n			}\n		}\n		if (a1==0)\n		{\n			if (c==login[i])\n			{\n				n++;\n			}\n			d++;\n		}\n		if (c==\'\\n\')\n		{\n			i=-1;\n			n=0;\n			a1=0;\n			d=0;\n		}\n	}\n	if (a2==0)\n	{\n		printf(\"?????? ???????????\");\n	}\n	printf(\"\\n\");\n	fclose(f);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (557,'#include<stdio.h>\n#include<stdlib.h>\nvoid print(int *a)\n{\n	int i;\n	for(i=0; a[i]; i++)\n		printf(\"%d \", a[i]);\n	printf(\"\\n\");\n}\nint length(int *a)\n{\n	int i;\n	for(i=0; a[i]; i++);\n	return i--;\n}\nvoid copy1(int *a, int *b)\n{\n	int i=0;\n	for(i=0; b[i]; i++)\n	{\n		a[i]=b[i];\n	}\n	a[i]=0;\n}\nvoid copy2(int *a, int *b, int n)\n{\n	int i=0;\n	for(i=0; i<n; i++)\n	{\n		a[i]=b[i];\n	}\n	a[i]=0;\n}\nvoid permut1(int *start, int *rest, int n)\n{\n	int i, lens=length(start), lenr=length(rest);\n	int *a, *b;\n	a=(int *)malloc((n+1)*sizeof(int));\n	b=(int *)malloc((n+1)*sizeof(int));\n	a[0]=0;\n	b[0]=0;\n	if(lenr==0)\n	{\n		print(start);\n	}\n	else\n	{\n		for(i=0; i<lenr; i++)\n		{\n			copy1(a, start);\n			a[lens]=rest[i];\n			a[lens+1]=0;\n			copy2(b, rest,i);\n			copy2(b+i, rest+i+1, lenr-i-1);\n			b[lenr-1]=0;\n			permut1(a, b, n);\n		}\n	}\n	free(a);\n	free(b);\n}\nvoid permut2(int *start, int *rest, int n, int a)\n{\n	int i;\n	if(a==n)\n	{\n		print(start);\n	}\n	else\n	{\n		for(i=0; i<n; i++)\n		{\n			if(rest[i]!=0)\n			{\n				int tmp=rest[i];\n				rest[i]=0;\n				start[a]=tmp;\n				permut2(start, rest, n, a+1);\n				rest[i]=tmp;\n			}\n		}\n	}\n}\nint main()\n{\n	int *rest, *start;\n	int i, n;\n	printf(\"?? ?????? ?????? ???? ??? ???????????? ????????? ????????? {1,...,N} (?????). ??????? N:\\n\");\n	scanf(\"%d\", &n);\n	start=(int*)malloc((n+1)*sizeof(int));\n	rest=(int*)malloc((n+1)*sizeof(int));\n	start[0]=0;\n	for(i=0; i<n; i++)\n	{\n		rest[i]=i+1;\n	}\n	rest[i]=0;\n	permut2(start, rest, n, 0);\n	free(start);\n	free(rest);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (558,'#include <stdio.h>\n\nstruct item\n{\n	int data;\n	struct item *next;\n};\n\nint main(int argc, char **argv)\n{\n	FILE* I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE* O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n\n	struct item *head = NULL, *p = NULL, *l = NULL;\n\n	int i = 0;\n	int a = 0;\n\n	if(fscanf(I, \"%d\", &a) != EOF)\n	{\n//		printf(\"[%d]\\n\", a);\n		head = p = (struct item*)malloc(sizeof(struct item));\n		p -> data = a;\n		p -> next = NULL;\n	}\n	else\n	{\n		fclose(I);\n		fclose(O);\n		return 0;\n	}\n	\n	while(fscanf(I, \"%d\", &a) != EOF)\n	{\n//		printf(\"[%d]\\n\", a);\n		l = p = head;\n		i = 0;\n		for(;p && a > p -> data; i++, l = p, p = p -> next)\n		{\n//			printf(\"{%d} \", p -> data);\n		}\n//		putchar(\'\\n\');\n\n		if(!p)\n		{\n//			printf(\"!p\\n\");\n			p = (struct item*)malloc(sizeof(struct item));\n			p -> next = NULL;\n			p -> data = a;\n			l -> next = p;\n		}\n		else if(i)\n		{\n//			printf(\"i\\n\");\n			l -> next = (struct item*)malloc(sizeof(struct item));\n			l -> next -> next = p;\n			l -> next -> data = a;\n		}\n		else\n		{\n//			printf(\"else\\n\");\n			l = (struct item*)malloc(sizeof(struct item));\n			head = l;\n			l -> next = p;\n			l -> data = a;\n		}\n	}\n	p = head;\n	while(p)\n	{\n		fprintf(O, \"{[%d]} \", p -> data);\n		p = p -> next;\n	}\n\n	while (head)\n	{\n		p = head->next;\n		free(head);\n		head = p;\n	}\n	fputc(\'\\n\', O);\n	fclose(I);\n	fclose(O);\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (559,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct item\n{\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nchar foo(char c)\n{\n	if(c >= \'A\' && c <= \'Z\')\n		return c - \'A\' + \'a\';\n	return c;\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n	\n	struct item *head = NULL;\n	struct item *foot = NULL;\n	char word[256] = {0};\n	int wP = 0;\n	char tmp = 0;\n	\n	while((tmp = fgetc(I)) != EOF)\n	{\n		int f = 0;\n		if((tmp >= \'a\' && tmp <= \'z\') || (tmp >= \'A\' && tmp <= \'Z\'))\n			word[wP++] = foo(tmp);\n		else\n			if(wP != 0)\n			{\n				word[wP] = 0;\n				wP = 0;\n				f = 0;\n				struct item *p = NULL;\n				p = head;\n				while(p)\n				{\n					if(strcmp(word, p -> word) == 0)\n					{\n						p -> count++;\n						f = 1;\n						//printf(\"\\n(%s++ [%d])\\n\", p -> word, p -> count);\n						break;\n					}\n					p = p -> next;\n				}\n				if(!f)\n				{\n					struct item *q = (struct item *)malloc(sizeof(struct item));\n					if(!head)\n					{\n						head = q;\n						foot = q;\n					}\n					else\n						foot -> next = q;\n					foot = q;\n					q -> next = NULL;\n					strncpy(q -> word, word, 10);\n					q -> count = 1;\n					q -> word[10] = 0;\n					//printf(\"\\n(%s++ [%d])\\n\", q -> word, q -> count);\n				}\n			}\n		//printf(\"[%c]\", tmp);\n	}\n\n	struct item *p = head;\n	//printf(\"Starting print list!\\n\");\n	while(p)\n	{\n//		getchar();\n		fprintf(O, \"[%s]: %d\\n\", p -> word, p -> count);\n		//p -> next ? printf(\"Next exists!\\n\") : printf(\"Next does not exists!\\n\");\n	 	p = p -> next;\n	}\n	\n	p = head;\n	struct item *q = NULL;\n	while(p)\n	{\n		q = p -> next;\n		free(p);\n		p = q;\n	}\n\n	fclose(I);\n	fclose(O);\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (560,'#include <stdio.h>\n\nstruct node\n{\n	int data;\n	struct node *left, *right;\n};\n\nvoid addRoot(struct node *root, int a)\n{\n	if(a <= root -> data)\n		if(root -> left)\n			addRoot(root -> left, a);\n		else\n		{\n			root -> left = (struct node *)malloc(sizeof(struct node));\n			root -> left -> left = root -> left -> right = NULL;\n			root -> left -> data = a;\n		}\n	else if(a > root -> data)\n		if(root -> right)\n			addRoot(root -> right, a);\n		else\n		{\n			root -> right = (struct node *)malloc(sizeof(struct node));\n			root -> right -> left = root -> right -> right = NULL;\n			root -> right -> data = a;\n		}\n			\n}\n\nvoid infix(struct node *root, FILE *O)\n{\n	if(!root)\n		return;\n	infix(root -> left, O);\n	fprintf(O, \"%d \", root -> data);\n	infix(root -> right, O);\n\n	free(root);\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n	\n	struct node *hRoot = NULL;\n	struct node *tmp = NULL;\n\n	int a = 0;\n	\n	if(fscanf(I, \"%d\", &a) == 1)\n	{\n		tmp = (struct node *)malloc(sizeof(struct node));\n		tmp -> data = a;\n		tmp -> left = tmp -> right = NULL;\n		hRoot = tmp;\n	}\n	else\n	{\n		fprintf(O, \"error!\\n\");\n		exit(1);\n	}\n	\n	while(fscanf(I, \"%d\", &a) == 1)\n	{\n		addRoot(tmp, a);\n	}\n\n	infix(hRoot, O);\n	fprintf(O, \"\\n\");\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (561,'#include <stdio.h>\n\nint main()\n{\n    FILE *fin,*fout;\n    char c;\n    int newrow, newcol,prevkav,textkav;\n    fin = fopen(\"test.csv\",\"r\");\n    fout = fopen(\"test.html\",\"w\");\n    fputs(\"<table border=\\\"1\\\">\\n\",fout);\n    newrow = 1;\n    newcol = 1;\n    prevkav = 0;\n    textkav = 0;\n    while(!feof(fin)){\n	if(newrow)\n	{\n	    fputs(\"<tr>\\n\",fout);\n	    newrow = 0;\n	}\n	if(newcol)\n	{\n	    fputs(\"<td>\",fout);\n	    newcol = 0;\n	}\n	c = fgetc(fin);\n	if(c==\'\"\')\n	{\n	    if(prevkav)\n	    {\n		fputs(\"\\\"\",fout);\n		prevkav = 0;\n	    }\n	    else\n	    {\n		prevkav = 1;\n	    }\n	}\n	else if(prevkav)\n	{\n	    textkav = !textkav;\n	    prevkav=0;\n	}\n	\n	if(c==\'\\n\' && !textkav)\n	{\n	    newrow = 1;\n	    newcol = 1;\n	    fputs(\"</td></tr>\\n\",fout);\n	}\n	else if (c == \'\\n\' && textkav)\n	{\n		fprintf(fout, \"<br/>\\n\");\n	}\n	else if(c==\',\' && !textkav)\n	{\n	    newcol = 1;\n	    fputs(\"</td> \",fout);\n	}\n	else if(c!=EOF&&c!=\'\"\')\n	    fputc(c,fout);\n    }\n    fputs(\"</table>\",fout);\n    fclose(fin);\n    fclose(fout);\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (562,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#define N 10\r\n\r\ntypedef struct item hash;\r\n\r\nstruct item {\r\n	int count;\r\n	char *word;\r\n	struct item *next;\r\n};\r\n\r\nint check(hash **x, unsigned char *s, int f) {\r\n	int n = strlen(s);\r\n	hash *p, *q;\r\n	\r\n	for (p=*x; p; p=p->next)\r\n		if (!strcmp(p->word, s)) {\r\n			//if f == 0, not increment\r\n			if (f)\r\n				p->count++;\r\n			return p->count;\r\n		}\r\n	if (f) {\r\n		p = *x;\r\n		q = (hash *) malloc(sizeof(*p));\r\n		*x = q;\r\n		q->count = 1;\r\n		q->word = (char *) malloc(n+1);\r\n		strcpy(q->word, s);\r\n		q->next = p;\r\n	}\r\n\r\n	return 0;\r\n}\r\n\r\nvoid free_hash(hash **x) {\r\n	int i;\r\n	hash *p, *q;\r\n	for (p=*x; p; p=q) {\r\n		q = p->next;\r\n		free(p->word);\r\n		free(p);\r\n	}\r\n}\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n	int i=0, c, z=0, y=0, u=0, b=0, a;\r\n	unsigned char word[50]={\'\\0\'}, s[50];\r\n	hash *x=NULL, *p;\r\n	FILE *f = fopen(\"word.txt\", \"r\");\r\n	if (!f) {\r\n		perror(\"fopen\");\r\n		return 0;\r\n	}\r\n	\r\n	for (i=1; i<argc; i++) {\r\n		//print hash table in the terminal\r\n		if (!strcmp(argv[i], \"-p\"))\r\n			z = 1;\r\n		//big and small letters - different\r\n		if (!strcmp(argv[i], \"-b\"))\r\n			b = 1;\r\n		//finf the word-parameter\r\n		if (!strcmp(argv[i], \"-i\")) {\r\n			y = i + 1;\r\n			if ( y >= argc || !strcmp(argv[y], \"-p\") || !strcmp(argv[y], \"-b\")) {\r\n				printf(\"wrong parameters\\n\");\r\n				return 0;\r\n			}\r\n		}\r\n	}\r\n	\r\n	i = 0;\r\n	while ((c = fgetc(f)) != EOF) {\r\n		if (!isalpha(c)) {\r\n			word[i] = 0;\r\n			if (word[0] != 0)\r\n				check(&x, word, 1);\r\n			i = 0;\r\n			word[0] = 0;\r\n		}else {\r\n			if (!b)\r\n				c = tolower(c);\r\n			word[i] = c;\r\n			i++;\r\n		}\r\n	}\r\n	word[i] = 0;\r\n	check(&x, word, i);\r\n	fclose(f);\r\n	\r\n	//print hash table in the \"output.txt\"\r\n	f = fopen(\"output.txt\", \"w\");\r\n	if (!f) {\r\n		perror(\"fopen\");\r\n		return 0;\r\n	}\r\n	fprintf(f, \"Hash table\\n\");\r\n	fprintf(f, \"Word - Count\\n\");\r\n	for (p=x; p; p=p->next)\r\n		fprintf(f, \"%s %d\\n\", p->word, p->count);\r\n	fclose(f);\r\n	\r\n	if (y) {\r\n		c = strlen(argv[y]);\r\n		strcpy(word, argv[y]);\r\n		for (i=0; i<c; i++)\r\n			if (!b)\r\n				word[i] = tolower(word[i]);\r\n		word[i] = 0;\r\n		a = check(&x, word, 0);\r\n		printf(\"The word \\\"%s\\\" is found in the text %d times\\n\", word, a);\r\n	}\r\n	\r\n	if (z) {\r\n		printf(\"Number of occurrences of all words in the text\\n\");\r\n		for (p=x; p; p=p->next)\r\n			printf(\"%s %d\\n\", p->word, p->count);\r\n	}\r\n	\r\n	free_hash(&x);\r\n\r\n	return 0;\r\n}\r\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (563,'#include <stdio.h>\n#define N 300\n\nint main()\n{\n	int i, c, state=0;\n	FILE *fin = fopen(\"csv.txt\", \"r\");\n	FILE *fout = fopen(\"input.html\", \"w\");\n	\n	fprintf(fout, \"<table>\\n\");\n	\n	while ((c = fgetc(fin)) != EOF) {\n		switch (state) {\n			case 0:\n				if (c == \'\\\"\') {\n					fprintf(fout, \"<tr><td>\");\n					state = 2;\n				}else\n					if (c == \',\') {\n						fprintf(fout, \"<tr><td></td>\");\n						state = 1;\n					}else {\n						fprintf(fout, \"<tr><td>\");\n						fputc(c, fout);\n						state = 4;\n					}\n				break;\n			case 1:\n				if (c == \'\\\"\') {\n					fprintf(fout, \"<td>\");\n					state = 2;\n				}else\n					if (c == \',\') {\n						fprintf(fout, \"<td></td>\");\n						state = 1;\n					}else\n						if (c == \'\\n\') {\n							fprintf(fout, \"<td></td></tr>\\n\");\n							state = 0;\n						}else {\n							fprintf(fout, \"<td>\");\n							fputc(c, fout);\n							state = 4;\n						}\n				break;\n			case 2:\n				if (c == \'\\n\') {\n					fprintf(fout, \"<br/>\");\n				}else\n					if (c == \'\\\"\') {\n						state = 3;;\n					}else {\n						fputc(c, fout);\n					}\n				break;\n			case 3:\n				if (c == \'\\\"\') {\n					fputc(c, fout);\n					state = 2;\n				}else\n					if (c == \',\') {\n						fprintf(fout, \"</td>\\n\");\n						state = 1;\n					}else\n						if (c == \'\\n\') {\n							fprintf(fout, \"</td></tr>\\n\");\n							state = 0;\n						}\n				break;\n			case 4:\n				if (c == \'\\n\') {\n					fprintf(fout, \"</td></tr>\\n\");\n					state = 0;\n				}else\n					if (c == \',\') {\n						fprintf(fout, \"</td>\");\n						state = 1;\n					}else\n						if (c == \'\\n\') {\n							fprintf(fout, \"</td></tr>\\n\");\n							state = 0;\n						}else {\n							fputc(c, fout);\n						}\n				break;\n		}\n	}\n	fprintf(fout, \"</table>\");\n	\n	fclose(fin);\n	fclose(fout);\n\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (564,'#include <stdio.h>\n#include <math.h>\n#define N 100\n\nint n;\nfloat x[N], y[N];\nint use[N];\nint path[N], cur[N];\nfloat ans = 1000000, curAns;\n\n\nfloat sqr(float d) {\n	return d * d;\n}\n\nvoid search(int k) {\n	int i;\n	if (k == n) {\n		curAns = sqrt(sqr(x[cur[0]] - x[cur[n - 1]]) + sqr(y[cur[0]] - y[cur[n - 1]]));\n		for (i = 0; i < n - 1; i++) {\n			curAns = curAns + sqrt(sqr(x[cur[i]] - x[cur[i + 1]]) + sqr(y[cur[i]] - y[cur[i + 1]]));\n		}\n		if (curAns < ans) {\n			ans = curAns;\n			for (i = 0; i < n; i++) {\n				path[i] = cur[i];\n			}\n		}\n		return;\n	}\n\n	for (i = 0; i < n; i++) {\n		if (!use[i]) {\n			use[i] = 1;\n			cur[k] = i;\n			search(k + 1);\n			use[i] = 0;\n		}\n	}\n}\n\nint main() {\n	int i;\n	FILE *f=fopen(\"input25.txt\", \"r\");\n	fscanf(f,\"%d\", &n);\n	for (i = 0; i < n; i++) {\n		use[i] = 0;\n		fscanf(f, \"%f%f\", &x[i], &y[i]);\n	}\n	search(0);\n	printf(\"dist = %.3f\\n\", ans);\n	printf(\"path :\");\n	for (i = 0; i < n; i++) {\n		printf(\" %d\", path[i]);\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (565,'#include <stdio.h>\n\nint main()\n{\n	FILE *f=fopen(\"input13.txt\", \"r\"), *o=fopen(\"output13.txt\", \"w\");\n	int c,st = 0;\n        \n	fprintf(o, \"<html>\\n\");\n	fprintf(o, \"<table>\\n\");\n	while ((c=fgetc(f))!=EOF)\n	{\n		switch (st) \n		{\n			case 0:\n				if(c == \'\\\"\')\n				{\n					fprintf(o, \"<tr> <td>\");\n					st = 1;\n				}\n				else if(c == \',\')\n				{\n					fprintf(o, \"<tr><td></td>\");\n					st = 3;\n				}\n				else if(c == \'\\n\')\n				{\n					st = 0;\n				}\n				else\n				{\n					st = 2;\n					fprintf(o, \"<tr><td>\");\n	                                fputc(c, o);\n				}\n				break;\n			case 1:\n				if(c == \'\\n\')\n				{\n					st = 1;\n					fprintf(o, \"<br/>\");\n				}\n				else if(c == \'\\\"\')\n				{\n					st = 4;\n				}\n				else \n				{\n					fputc(c, o);\n					st = 1;\n				}\n				break;\n			case 2:\n				if(c == \'\\n\')\n				{\n					st = 0;\n					fprintf(o, \"</td></tr>\\n\");\n				}\n				else if(c == \',\')\n				{\n					st = 3;\n					fprintf(o, \"</td>\");\n				}\n				else \n				{\n					fputc(c, o);\n					st = 2;\n				}\n				break;\n			case 3:\n				if(c == \',\')\n				{\n					st = 3;\n					fprintf(o, \"<td></td>\");\n				}\n				else if(c == \'\\n\')\n				{\n					st = 0;\n					fprintf(o, \"<td></td></tr>\\n\");\n				}\n				else if(c == \'\\\"\')\n				{\n					st = 1;\n					fprintf(o, \"<td>\");\n				}\n				else \n				{\n					st = 2;\n					fprintf(o, \"<td>\");\n					fputc(c, o);\n				}\n				break;\n			case 4:\n				if(c == \'\\\"\')\n				{\n					st = 1;\n					fprintf(o, \"\\\"\");\n				}\n				else if(c == \',\')\n				{\n					st = 3;\n					fprintf(o, \"</td>\");\n				}\n				else if(c == \'\\n\')\n				{\n					st = 0;\n					fprintf(o, \"</td></tr>\\n\");\n				}\n				break;\n		}\n	}\n	fprintf(o, \"</table>\\n\");\n	fprintf(o, \"</html>\");\n	fclose(f);\n	fclose(o);\n	return 0;\n}\n\n					\n					\n	\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (566,'#include <iostream>\ntemplate <typename T> class list\n{\nprivate:\n	list(const list &orig) { }\n	list& operator=(const list &orig) { }\n	struct element\n	{\n		T data;\n		element *next;\n	};\n	element *head;\npublic:\n	class iterator\n        {\n        	private:\n        		element *i;\n        	public:\n        	\n		iterator()\n        	{\n        		i=NULL;\n        	}\n        	iterator(element *a)\n        	{\n        		i=a;\n        	}\n		iterator& operator++()\n		{\n			i=i->next;\n		}		\n		int operator!=(const iterator other)\n                {\n                        if (other.i!=i)\n                	return(1);\n                        else\n                        return(0);\n                }\n		T operator*()\n                {\n                        return(i->data);\n                }\n		T* operator->()\n                {\n                	return(&(i->data));\n                }\n	};\n\n	iterator begin() const\n        {\n                return(iterator(head));\n        }\n        iterator end() const\n        {\n                return(iterator(NULL));\n        }	\n\n	list()				//???????????\n	{\n		head=NULL;	\n	}\n	~list()				//??????????\n	{\n		while (head!=NULL)\n		{\n			hdelete();\n		}\n	}\n	void hinsert(T info)		//??????? ? ??????\n	{\n		element *p;\n		p=new element;\n		p->data=info;\n		p->next=head;\n		head=p;      \n	}\n	void hdelete()		//???????? ??????\n	{\n		element *p;\n		p=head->next;\n		delete head;\n		head=p;	\n	}\n	void tinsert (T info)	//?????? ? ?????\n	{\n		element *p,*q;\n		p=new element;\n		p->data=info;\n                p->next=NULL;\n		if (head==NULL)\n		{\n			head=p;			\n			return;\n		}\n		if (head!=NULL)	\n		{\n			for (q=head;q->next;q=q->next);	\n			q->next=p;\n			return;\n		}\n	}\n	\n\n	void tdelete ()		//???????? ??????\n	{\n		element *p,*q,*r;\n		p=head;\n		for (q=head;q->next;q=q->next)\n		{\n			p=q;\n		}\n		p->next=NULL;\n		if (q == head)\n		{\n			delete head;\n			head = NULL;\n		}\n		else\n			delete q->next;\n	}\n\n\n	void print()		//?????\n	{\n		element *p;\n		p=head;\n		while (p!=NULL)\n		{\n			std::cout<<(p->data)<<\" \";\n			p=p->next;\n                }\n		std::cout << \"\\n\";\n	}\n};\nint main()\n{\n	int i;\n	list <int> spisok1;\n	for (i = 0; i < 5; i++)\n        {\n                spisok1.tinsert(i);\n		spisok1.hinsert(i);\n                spisok1.print();\n        }\n	\n	list<int>::iterator iter;\n	for (iter=spisok1.begin();iter!=spisok1.end();++iter)\n        {\n                std::cout <<*iter<<\"\\n\";\n        }\n	\n	for (i = 0; i < 5; i++)\n	{\n		spisok1.hdelete();\n		spisok1.tdelete();\n		spisok1.print();\n	}\n	\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (567,'#include <stdio.h>\n\nint A[101][101];\nint used[101];\nint max;\n\n\nvoid go(int N){     //*int A[101,101],*int used[101],int max) {\n	int i;\n	printf(\" %d\", N);\n	used[N] = 1;\n	for (i = 0; i <= max; i++) {\n		if (A[N][i]&&!used[i]) {\n			go(i);\n		}\n	}\n}\n\nint main() {\n       /* int a[101][101];\n	int used[101];\n	int max; */\n        int from,to,i,j;\n	\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n	max = 0;\n\n	//int from, to, i, j;\n\n	for (i = 0; i < 100; i++) {\n		used[i] = 0;\n		for (j = 0; j < 100; j++) A[i][j] = 0;\n\n	}\n	\n	while (scanf(\"%d%d\", &from, &to)==2) {\n		if (from>max) max = from;\n		if (to>max) max = to;\n\n		A[from][to] = A[to][from] = 1;\n	}\n\n	go(1);\n\n	printf(\"\\n\");\n\n	fclose(stdin);\n	fclose(stdout);\n\n  return (0);\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (568,'#include <stdio.h>\n\n\nint used[101];\nint queue[101];\nint A[101][101];\nint max;\n\nint qstart, qstop; \n\nint getq() {\n	if (qstart > 100) qstart = 0;\n  if (qstart!=qstop) return queue[qstart++];\n	else\n 	{\n		fprintf(stderr, \"Attempt to read from empty queue.\\n\");\n		exit(1);		\n	}\n}\n\nvoid putq(int data) {\n  if (qstop > 100) qstop = 0;\n	if (qstop+1!=qstart) {\n		queue[qstop++] = data; return;		\n	} else {\n		fprintf(stderr, \"Attempt to put in full queue.\\n\");\n		exit(1);\n	}\n}\n\nint isEmpty() { return qstart==qstop; }\n\nvoid go(int N) {\n	int i = 0;\n  used[N] = 1;\n	printf(\"%d \", N);\n	for (i = 0; i <= max; i++) {\n		if (A[N][i]&&!used[i]) { used[i] = 1; putq(i); }\n	}\n}\n\n\n\n\nint main() {\n /* int used[101];\n  int queue[101];\n  int max;\n  int qstart,qstop; */\n  \n  int from,to,i,j;	\n  \n  freopen(\"gr.txt\", \"r\", stdin);\n  freopen(\"output.txt\", \"w\", stdout);\n\n  max = 0;\n\n    for (i = 0; i < 100; i++) {\n    used[i] = 0;\n    for (j = 0; j < 100; j++) A[i][j] = 0;\n\n  }\n  while (scanf(\"%d%d\", &from, &to)==2) {\n    if (from>max) max = from;\n    if (to>max) max = to;\n\n    A[from][to] = A[to][from] = 1;\n  }\n\n	go(1);\n\n	while (!isEmpty()) {\n		go(getq());\n	}\n\n	printf(\"\\n\");\n\n	fclose(stdin);\n	fclose(stdout);\n\n	return (0);\n\n};\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (569,'#include <stdio.h>\n\n\n#define bool char\n#define true 1\n#define false 0\n\ntypedef struct {\n	long intpart;\n	long dblpart;\n	bool negative;\n	int digits;\n	long tid;\n} r;\n\n\nint toChar(char c) {\n	return (c < 10) ? (c + \'0\') : (c - 10 + \'a\');\n}\n\n\nr convert(const char* b) {\n	r res = { 0, 0, 0, 0, 1 };\n	int i = 0;\n	if (b[0] == \'+\') i = 1;\n	if (b[0] == \'-\') { i = 1; res.negative = 1; }\n\n	for (; b[i] && b[i] != \'.\' && b[i] != \',\'; i++) {\n		res.intpart*=10;\n		res.intpart+=b[i]-\'0\';\n	}\n	if (!b[i]) return (res);\n\n	while (b[++i]) {\n		res.digits++;\n		res.dblpart*=10;\n		res.dblpart+=b[i]-\'0\';\n		res.tid *= 10;\n	}\n\n	return (res);\n}\n\n\nint main () {\n	int b;\n\n	char buff[1024];\n	r data;\n	int index;\n	int processed = 0;\n	int rpart[18]; \n	char temp;\n	int i;\n\n	scanf(\"%d %s\", &b, buff);\n	data = convert(buff);\n	if (data.negative) putc (\'-\', stdout);\n\n	\n\n	for ( index = 1023; index >= 0; index--) buff[index]=0;\n	\n	index = 0;\n	if (data.intpart==0) putc(\'0\', stdout);\n	while (data.intpart > 0) {\n		buff[index++] = toChar(data.intpart % b);\n		data.intpart /= b;\n	}\n	index--;\n	for (; index >= 0; index--) putc(buff[index], stdout);\n\n	if (data.digits == 0) { putc(\'\\n\', stdout); return (0); }\n\n	putc(\'.\', stdout);\n\n	\n	\n	while (data.dblpart != 0 && processed < 18) {		\n		rpart[processed] = data.dblpart;\n		data.dblpart*=b;		\n		\n		temp = data.dblpart / data.tid;		\n		data.dblpart -= temp * data.tid;\n		\n		buff[processed] = toChar(temp);\n		\n		processed++;\n\n		for (index = 0; index < processed-1; index++) {\n			if (rpart[index]==data.dblpart) { \n				\n				for (i = 0; i < index; i++) {\n					putc(buff[i], stdout);\n				}\n				putc(\'(\', stdout);\n				for (i = index; i<processed; i++) {\n					putc(buff[i], stdout);\n				}\n				putc(\')\', stdout);\n				putc(\'\\n\', stdout);\n				return (0);\n			}\n		}\n\n	}\n	for (i = 0; i < processed; i++) {\n		putc(buff[i], stdout);\n	}\n	putc(\'\\n\', stdout);\n	return (0);\n};\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (570,'#include <stdio.h>\n#include <errno.h>\n\n\n#define MAX_STRING_LENGTH 1024\n\n\nint main () {\n  char buff[MAX_STRING_LENGTH];\n  char uname[MAX_STRING_LENGTH];\n  int i = 0, sc = 0;\n  int ff = 0;\n\n	FILE *f = fopen (\"/etc/passwd\", \"rt\");\n	if (!f) {\n		fprintf (stderr, \"Couldn\'t open file /etc/passwd for reading: %s\\n\", strerror(errno));\n		exit (1);\n	}\n\n	scanf (\"%s\", uname);\n\n	while (fgets(buff, MAX_STRING_LENGTH, f)) {\n		i=0;\n	    while (buff[i]!=\':\') i++;\n		buff[i]=0;\n		if (!strcmp(buff, uname)) { ff = 1; break; }\n\n	}\n	if (ff)\n	{\n		while (sc<3) if (buff[i++]==\':\') sc++;\n		while (buff[i]&&buff[i]!=\',\'&&buff[i]!=\':\') putc(buff[i++], stdout);\n	}\n	else\n	{\n		printf(\"not found\");\n	}\n\n  putc(\'\\n\', stdout);\n  return (0);\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (571,'#include <stdio.h>\n\ntypedef enum { newline, newfield, field, endfield, endline } state_t;\n\n\nvoid usage(char *pname) {\n  fprintf(stderr, \"Usage: %s [input [output]]\\n\", pname);\n	exit(1);\n}\n\nint main (int argc, char* argv[]) {\n  char c; // UTF-8 character;\n  int index = 0;\n  int quoted = 0;\n  state_t state = newline;\n	\n	switch (argc) {\n		case 1: // nothing to do, work from stdin to stdout\n			break;\n		case 3: // from argv[1] to argv[2]\n			freopen(argv[2], \"w\", stdout);\n		case 2: // from argv[1] to stdout\n			freopen(argv[1], \"r\", stdin);\n			break;\n		default: // something wrong\n			usage(argv[0]);\n	}\n	\n\n	printf(\"<table>\\n\");\n  \n 	while ((c=getchar())!=EOF) {\n		index++;\n		switch (state) {\n			case newline:\n				printf(\"  <tr>\\n\");\n				state = newfield;\n				ungetc(c, stdin);\n				index--;\n				break;\n			case newfield:\n				printf(\"    <td>\");\n				state = field;\n				if (c == \'\"\')\n					quoted = 1; \n				else {\n					quoted = 0;\n					ungetc(c,stdin);\n					index--;\n				}\n				break;\n			case field:\n				switch (c) {\n					case \',\':\n						if (quoted) {\n							printf(\",\");\n							break;\n						}\n						state = endfield;\n						ungetc(c,stdin);\n						index--;\n						break;\n					case \'\\n\':\n						if (quoted) {\n							printf(\"<br />\");\n							break;\n						}\n						state = endline;\n						ungetc(c, stdin);\n						index--;\n						break;\n					case \'&\':\n						printf(\"&amp;\");\n						break;\n					case \'<\':\n						printf(\"&lt;\");\n						break;\n					case \'>\':\n						printf(\"&gt;\");\n						break;\n					case \'\"\':\n						c = getchar();					\n						if (c==\'\"\') printf(\"\\\"\");\n						else {\n							ungetc(c, stdin);\n							quoted = 0;\n						}\n						break;\n					default:\n						putchar(c);\n				}\n				break;\n			case endfield:\n				printf(\"</td>\\n\");\n				//ungetwc(c,stdin);\n				state = newfield;\n				break;\n			case endline:\n				printf(\"</td>\\n\");\n				printf(\"  </tr>\\n\");\n				state = newline;\n				break;\n			default:\n				fprintf(stderr, \"Something strange happened\\n\");\n				exit(2);\n		}\n	}\n	if (state==field)\n		printf(\"</td>\\n  </tr>\\n\");\n	printf(\"</table>\\n\");\n\n\n	fclose(stdin);\n	fclose(stdout);\n\n	return (0);\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (572,'#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_STRING_LENGTH 1024\n\n\nchar to_int(char c) {\n	static int point = 0;\n  if (c >= \'0\' && c <= \'9\') return c-\'0\';\n	if (c >= \'A\' && c <= \'Z\') return 10+c-\'A\';\n	if (c >= \'a\' && c <= \'z\') return 10+c-\'a\';\n  if (c == \'.\' || c == \',\') if (point) {\n	  printf(\"incorrect data\\n\");\n		exit (1);\n	} else {\n		point = 1;\n		return -1;\n	}\n\n	if (c == 0) return -2;\n	printf(\"Wrong char: %c\\n\", c);\n	exit (1);\n}\n\nint main() {\n        int b;\n	char curr;\n	char buff[MAX_STRING_LENGTH];\n        float after_point = 0;\n	float multiplier;\n	long before_point = 0;	\n	int index = 0;\n\n	printf (\"b: \");\n	scanf(\"%d %[0-9A-Za-z,.]\", &b, buff);\n	multiplier = 1.0 / b;\n	\n  while ((curr=to_int(buff[index++]))>=0) {\n    before_point *= b;\n		before_point += curr;\n	}\n	if (curr == -2) {\n    printf (\"result is %d.\\n\", before_point);\n		return (0);\n	} \n	\n	while ((curr=to_int(buff[index++]))!=-2) {\n    after_point += multiplier * curr;\n		multiplier /= b;\n  }\n\n	printf (\"result is %f.\\n\", after_point+before_point);\n  return (0);\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (573,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nunsigned int hash_k(char *s)\n{\n	unsigned int res = 0;\n	return res;\n	for( ; *s;s++)\n	{\n		res = res*37+*s;\n	}\n	return (res % 100);\n}\nchar *readword(FILE* f)\n{\n	int i = 0;\n	char c = 0;\n	char *p=NULL,*tmp;\n	for(i = 0; ((c=fgetc(f)) != EOF); i++)\n	{\n		if(!(c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\'))\n		{\n			if(p)\n				break;\n			i--;\n			continue;\n		}\n		if(!p)\n		{\n			p = calloc(11,sizeof(*p));;\n		}\n		p[i] = c;\n	}\n	return p;\n}\nstruct item\n{\n	char word[100];\n	int count;\n	struct item *next;\n};\nvoid hash(struct item *A[100],char *s)\n{\n	int flag=0,Hk=0;\n	struct item *p=NULL,*q;\n	Hk=hash_k(s);\n	p = A[Hk];\n	for (;p;p=p->next)\n	{\n		flag=0;\n		if (strcmp(s,p->word)==0)\n		{\n			p->count++;\n			flag = 1;\n			break;\n		}\n	}\n	if (flag == 0)\n	{\n		p=malloc(sizeof(*p));\n		strcpy(p->word,s);\n		p->count = 1;\n		p->next=A[Hk];\n		A[Hk]=p;\n	}\n	free(s);\n}\nint main(int argc, char **argv)\n{\n	int i;\n	char *s;\n	struct item *A[100],*p;\n	FILE* fi = fopen(argv[1], \"r\");\n	for(i=0;i<100;i++)\n		A[i]=NULL;\n	while (s=readword(fi))\n		hash (&A[0],s);\n	for(i=0;i<100;i++)\n	{\n		for(p=A[i];p;p=p->next)\n			printf (\"%s   -   %d  \\n\",p->word,p->count);\n	\n	}\n	for(i=0;i<100;i++)\n	{\n		while(p=A[i])\n		{\n			A[i]=A[i]->next;\n			free(p);\n		}\n	}\n	\n	\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (574,'#include <stdio.h>\n#include <stdlib.h>\n#define NMAX 100\nint D[NMAX];\nint prev[NMAX];\n#define INF 1000\nvoid Di(int A[NMAX][NMAX], int N,int *prev)\n{\n	int used[NMAX]={0},i,curr=1;\n//	int D[NMAX];\n	for (i = 0; i < NMAX; i++)\n		D[i] = INF;\n	D[1]=0;\n	for(;;)\n	{\n		curr = -1;\n		for (i=1;i<N;i++)\n		{\n			if ((curr == -1 || D[i]<D[curr]) && !used[i])\n			{\n				printf(\"i: %d, D[i]: %d, used[i]: %d\\n\", i, D[i], used[i]);\n				curr=i;\n			}\n		}\n		printf(\"curr: %d\\n\", curr);\n		if (curr == -1 || D[curr] == INF)\n			return;\n		used[curr]=1;\n		for(i=1;i<N;i++)\n		{\n			if(!used[i] && D[i]>D[curr]+A[curr][i])\n			{\n				D[i]=D[curr]+A[curr][i];\n				prev[i]=curr;\n			}\n		}\n	}\n}\n\n\nint main ()\n{\n	int edge,vert,i,j=0,a,b,c,t;\n	int A[NMAX][NMAX]={0};\n	int visited[NMAX]={0};\n//	int prev[NMAX];\n	FILE* F=fopen (\"graf.txt\",\"r\");\n	FILE* I=fopen (\"output.txt\",\"w\");\n	fscanf (F,\"%d %d\",&edge,&vert);\n	\n	for (i = 0; i < NMAX; i++)\n		prev[i] = -1;\n\n	for (i = 0; i < NMAX; i++)\n		for (j = 0; j < NMAX; j++)\n			A[i][j] = INF;\n//	printf (\"%d %d\",edge,vert);\n	for (i=1;i<edge;i++)\n	{\n		fscanf (F,\"%d %d\",&a,&b);\n		fscanf (F,\"%d\",&c);\n		A[a][b]=c;\n		A[b][a]=c;\n	}\n	for (i=1;i<=vert;i++)\n		A[i][i]=0;\n	Di(A,vert,prev);\n//	for(i=0;i<vert;i++)\n//		printf (\"%d\\n\",prev[i]);\n	\n	for (i=1;i<=vert;i++)\n	{\n		int j;\n		if(D[i]!=INF)\n		{\n			printf (\"%d %d   :  \",i, D[i]);\n			for(j = i;j != -1;j = prev[j])\n				printf (\"%d\",prev[j]);\n			printf(\"\\n\");\n		}\n		else \n			printf (\"net puti\\n\");\n				\n	}\n	fclose (F);\n	fclose (I);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (575,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 30\n#define arg 37\n#define dl 300\n\nstruct list \n{\n	char a[N];\n	int count;\n};\n\nint hash_(char * str , int i, int m)\n{\n	int a=0;\n	\n	if(i<m)a=hash_(str,i+1,m);\n	\n	return ((str[i]+arg*a)%dl);\n}\n\nvoid m_insert(struct list * mas[dl] , char * str, int i)\n{\n	if(mas[i])\n	{\n		if(strcmp(str,mas[i]->a)==0)\n			mas[i]->count++;\n		else\n			m_insert(mas,str,(i+1)%dl);\n	}\n	else\n	{\n		mas[i]=malloc(sizeof(struct list));\n		strcpy(mas[i]->a,str);\n		mas[i]->count=1;\n	}\n}\n\nint main()\n{\n	FILE *f_in;\n       	struct list * mas[dl]={NULL};\n	char a[N]={0};\n       	char b;\n       	int i=0;\n	int c=0;\n        \n       	f_in=fopen(\"input19.txt\",\"r\");\n       \n	while(fscanf(f_in,\"%c\",&b)==1)\n       	{	\n		if( ((b>=\'a\')&&(b<=\'z\'))||((b>=\'A\')&&(b<=\'Z\')) )\n       		{\n       			a[i]=b;\n       			i++;\n       			a[i]=0;\n       		}\n       		else if(i)\n		{			\n			c=hash_(a,0,strlen(a)-1);\n			m_insert(mas,a,c);\n       			i=0;	\n       		}\n       	}\n\n	for(i=0;i<dl;i++)\n		if(mas[i])\n			printf(\"%s %d \\n\",mas[i]->a,mas[i]->count);\n\n	return 0;\n}        									\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (576,'#include <iostream>\n#include <string.h>\nclass xstring\n{\nprivate:\n	char *data;\n	int length;\npublic:\n	xstring()\n	{\n		length=0;\n		data=new char[length+1];\n		data[length]=0;\n	}\n	xstring(const char *s)\n	{\n		int i;\n		length=strlen(s);\n		data=new char[length+1];\n		for (i=0; i<length; i++)\n			data[i]=s[i];	\n	}\n	xstring(const xstring &orig)\n	{\n		int i;\n		length=orig.length;\n		data=new char [length+1];\n		for (i=0;i<length;i++)\n			data[i]=orig.data[i];\n	}\n	~xstring()\n	{\n		delete [] data;\n	}\n\n	xstring operator+(const xstring &second) const\n	{\n		\n		char *p = new char[strlen(data)+strlen(second.data)+1];\n		strcpy(p,data);\n		strcat(p,second.data);\n		p[strlen(data)+strlen(second.data)]=0;\n		xstring result(p);\n		delete p;\n		return (result);\n\n	}\n	xstring& operator+=(const xstring &other)\n	{	\n		*this = *this + other;\n		return *this;	\n	}\n	xstring& operator=(const xstring &orig)\n	{\n		int i;\n		length=orig.length;\n		if(&orig!=this)\n		{\n			delete [] data;\n			data=new char [length+1];\n			for (i=0;i<length;i++)\n			data[i]=orig.data[i];\n		}\n		return *this;\n	}\n	operator const char*() const\n	{\n		return(data);\n	}\n	\n	char operator[](const int index) const\n        {\n		std::cout << \"const []\\n\";\n		return data[index];\n        }\n\n	char& operator[](const int index)\n        {\n		std::cout << \"non-const []\\n\";\n		return data[index];\n        }\n	void print()\n	{\n		std::cout<<data<<\"\\n\";\n	}	\n};\n\nvoid f(const xstring q)\n{\n	std::cout << q[0] << \"\\n\";\n}\n\nint main()\n{\n	char s0;\n	xstring s1(\"???? ????\");\n	s1.print();\n	s1[3]=\'d\';	\n	s1.print();\n	s0=s1[3];\n	std::cout<<s0<<\"\\n\";\n\n	f(s1);\n\n	return 0;\n}\n\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (577,'#include <stdio.h>\n\nint f(int a)\n{\n	if(a >= 10 && a <= 15)\n		return (\'A\' + a - 10);\n	return a + \'0\';\n	\n}\n\nint main()\n{	\n	int i = 0;\n	int base;\n	int ic;\n	int ost;\n	int cch[101]={0};\n	float number;\n	scanf(\"%f %d\", &number, &base);\n	ic = number;\n	while(ic != 0)\n	{		\n		ost = ic % base;\n		ic /= base;\n		cch[i] = ost;\n		i++;\n	}\n	for (i-- ; i >= 0; i--)\n		printf(\"%c\",f(cch[i]));\n	printf(\".\");\n	number = number -(int)number;\n	if (number == 0.0) printf(\"0\");\n	while (number != 0.0)\n	{\n		printf(\"%c\",f(number * base));\n		number = number * base - (int)(number * base);\n	}\n	printf(\"\\n\");		\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (578,'#include <stdio.h>\n#include <string.h>\n\nvoid print(int *A,int b)\n{\n	int i=0;\n	for(i=0;i<b;i++)\n	{\n		printf(\"%d\",A[i]);\n	}\n	printf(\"\\n\");\n}\nvoid permutation(int *array, int *res, int numberOfElements, int curr)\n{\n	int i,t;\n\n	if(curr == numberOfElements)\n	{\n		print(res,curr);\n		return;\n	}\n	else\n	{\n		for(i = 0; i < numberOfElements; i++)\n		{\n			if(array[i] == 0)\n				continue;\n			res[curr] = array[i];\n			array[i] = 0;\n			permutation(array, res, numberOfElements, curr + 1);\n			array[i] = res[curr];\n		}\n	}\n}\nint main(int argc, char **argv)\n{\n	int n,i=0;\n	int arr[100];\n	int result[100];\n	memset(result, 0, 100);\n	if(argc >= 2)\n		n = argv[1] - \'0\';\n	else\n		scanf(\"%d\", &n);\n	for(i = 0; i < n; i++)\n		arr[i] = i + 1;\n	permutation(arr, result, n, 0);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (579,'#include<stdio.h>\n\nvoid sift(int *arr, int n, int k)\n{\n	int a = 0, b = 0, tmp = 0, c = 0;\n	a = 2*k + 1;\n	b = 2*k + 2;\n	c = k;\n	if (a < n && arr[a] > arr[c])\n		c = a;\n	if (b < n && arr[b] > arr[c])\n		c = b;\n	if (c != k)\n	{\n		tmp = arr[k];\n		arr[k] = arr[c];\n		arr[c] = tmp;\n		sift(arr,n,c);\n	}\n}\nvoid heapSort(int *array, int n)\n{\n	int i,tmp,j;\n	for (i = n / 2; i >= 0; i--)\n		sift (array,n,i);\n	for (i = n - 1; i > 0; i--)\n	{\n		tmp = array[0];\n		array[0] = array[i];\n		array[i] = tmp;\n		sift(array, i, 0);\n	}\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n	\n	int n,i,j;\n	int *A;\n	fscanf(I, \"%d\", &n);\n	A = (int *)malloc(sizeof(int) * n);\n	for(i = 0; i < n; i++)\n	{\n		fscanf(I, \"%d\", &A[i]);\n	}\n	heapSort(A, n);\n	for(i = 0; i < n; i++)\n	{\n		fprintf(O, \"%d \", A[i]);\n	}\n	fprintf(O, \"\\n\");\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (580,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nunsigned int power(unsigned int a, int b)\n{\n	int i = 0;\n	unsigned int result = 1;\n	unsigned int c = a;\n	\n	if((b == 0 && a != 0) || a == 1)\n		return 1;\n	else if(a == 0)\n		return 0;\n	\n	for(; i < b; i++)\n	{\n		result = result * c;\n	}\n	return result;\n}\n\nunsigned int calculateHash(char *word)\n{\n	int i = 0;\n	unsigned int res = 0;\n	for( ; *word; word++, i++)\n	{\n		res = (power(res, i) + *word) % 100;\n	}\n	return res;\n}\n\nchar *readWord(FILE* f)\n{\n	char *p = NULL;\n	int i = 0;\n	char c = 0;\n	\n	for(i = 0; ((c=fgetc(f)) != EOF); i++)\n	{\n		if(!(c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\'))\n		{\n			if(p)\n				break;\n			i--;\n			continue;\n		}\n		if(!p)\n		{\n			p = malloc(11 * sizeof(*p));\n			memset(p, 0, sizeof(char) * 11);\n		}\n		p[i] = c;\n	}\n	return p;\n}\n\nstruct item\n{\n	char word[100];\n	int count;\n	struct item *next;\n};\n\nvoid putByHash(struct item *array[100], char *word)\n{\n	int flag = 0;\n	int hash = 0;\n	struct item *p = NULL;\n	hash = calculateHash(word);\n	p = array[hash];\n	for( ; p != NULL; p = p -> next)\n	{\n		flag = 0;\n		if(strcmp(word, p -> word) == 0)\n		{\n			p -> count++;\n			flag = 1;\n			break;\n		}\n	}\n	if(flag == 0)\n	{\n		struct item *q = (struct item *)malloc(sizeof(struct item));\n		strcpy(q -> word, word);\n		q -> count = 1;\n		q -> next = array[hash];			////////d/fsd/f/sdf/sd/f/sdf/d/f\n		array[hash] = q;\n	}\n	free(word);\n}\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n	\n	int i;\n	char *w = NULL;\n	struct item *arr[100],*p = NULL;\n	memset(arr, NULL, 100*sizeof(struct item *));\n	while(w = readWord(I))\n		putByHash(arr, w);\n	for(i = 0;i < 100; i++)\n	{\n		for(p = arr[i]; p; p = p -> next)\n			fprintf(O, \"[%s]: %d\\n\",p -> word, p -> count);\n	\n	}\n	for(i = 0; i < 100; i++)\n	{\n		while(p = arr[i])\n		{\n			arr[i] = arr[i] -> next;\n			free(p);\n		}\n	}\n	\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (581,'#include<stdio.h>\n#include<stdlib.h>\nstruct item\n{\n	int data;\n	struct item *next;\n};\nint main()\n{\n	struct item *head=NULL;\n	int a=0, i;\n	FILE *f; \n	struct item *p, *q, *r;\n	f=fopen(\"input.txt\", \"r\");\n	if(fscanf(f, \"%d\", &a)==1)\n	{\n		q=(struct item *)malloc(sizeof(*q));\n		head=q;\n		q->data=a;\n		q->next=NULL;\n	}\n	while(fscanf(f, \"%d\", &a)==1)\n	{\n		q=head;\n		p=NULL;\n		r=(struct item *)malloc(sizeof(*r));\n		r->next=NULL;\n		r->data=a;\n		while(q)\n		{\n			if((p==NULL)&&(a<=(q->data)))\n			{\n				head=r;\n				r->next=q;\n				break;\n			}\n			else if(a<(q->data))\n			{\n				p->next=r;\n				r->next=q;\n				break;\n			}\n			else if(q->next==NULL)\n			{\n				q->next=r;\n				break;\n			}\n			p=q;\n			q=q->next;\n		}\n	}\n	fclose(f);\n	f=fopen(\"output.txt\", \"w\");\n	for(q=head; q; q=q->next)\n	{\n		fprintf(f, \"%d \", q->data);\n	}\n	fclose(f);\n	for(q=head; q; q=p)\n	{\n		p=q->next;\n		free(q);\n	}\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (582,'#include<stdio.h>\n#include<stdlib.h>\n#define N 101\nstruct matrix\n{\n	int A[N][N];\n	int vis[N];\n};\nvoid dfs(int c, struct matrix *m)\n{\n	int i;\n	printf(\"%d \", c);\n	m->vis[c]=1;\n	for(i=1; i<N; i++)\n	{\n		if(m->A[c][i] && !m->vis[i])\n		{\n			dfs(i, m);\n		}\n	}\n}\nint main()\n{\n	int u=0, v=0;\n	FILE *f;\n	struct matrix m={{0}, {0}};\n	f=fopen(\"graph4graphtasks.txt\", \"r\");\n	while(fscanf(f, \"%d %d\", &u, &v)==2)\n	{\n		m.A[u][v]=1;\n		m.A[v][u]=1;\n	}\n	fclose(f);\n	printf(\"?? ??????? 1 ????????? ????????? ???????: \");\n        dfs(1, &m);\n        printf(\"\\n\");\n        return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (583,'#include<stdio.h>\n#include<stdlib.h>\n#define N 101\nstruct matrix\n{\n	int Q[N];\n	int r, w;\n	int A[N][N];\n	int vis[N];\n};\nvoid enqueue(int a, struct matrix *m)\n{\n	m->Q[m->w++]=a;\n}\nint dequeue(struct matrix *m)\n{\n	return m->Q[m->r++];\n}\nint empty(struct matrix *m)\n{\n	return (m->r==m->w);\n}\nvoid bfs(int a, struct matrix *m)\n{\n	int i;\n	enqueue(a, m);\n	m->vis[a]=1;\n	while(!empty(m))\n	{\n		a=dequeue(m);\n		for (i=1; i<N; i++)\n		{\n			if (m->A[a][i] && !(m->vis[i]))\n			{\n				enqueue(i, m);\n				m->vis[i]=1;\n			}\n		}\n	}\n}\nint main()\n{\n	int u=0, v=0;\n	FILE *f;\n	struct matrix m={{0}, 0, 0, {0}, {0}};\n	f=fopen(\"graph4graphtasks.txt\", \"r\");\n	while (fscanf(f, \"%d %d\", &u, &v)==2)\n	{\n		m.A[u][v]=1;\n		m.A[v][u]=1;\n	}\n	fclose(f);\n	printf(\"?? ??????? 1 ????????? ????????? ???????: \");\n	bfs(1, &m);\n	for(u=2; u<N; u++)\n	{\n		if(m.vis[u])\n		{\n			printf(\"%d \", u);\n		}\n	}\n	printf(\"\\n\");								       \n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (584,'// free all memory (recursive)\n\n#include <stdio.h>\nstruct item {\n	int data;\n	struct item *left, *right;\n};\n\nstruct item *adtot(struct item *root,int new)\n{\n	if (new>root->data)\n	{\n		if(root->right)\n			root->right=adtot(root->right,new);\n		else\n		{\n			root->right=(struct item*)malloc(sizeof(*root));\n			root->right->data=new;\n			root->right->left=NULL;\n			root->right->right=NULL;\n		}\n	}\n	else\n	{\n		if(root->left)\n			root->left=adtot(root->left,new);\n		else\n		{\n			root->left=(struct item*)malloc(sizeof(*root));\n			root->left->data=new;\n			root->left->left=NULL;\n			root->left->right=NULL;\n		}\n	}\n	return root;\n}\n\n	void inf(struct item *root)\n	{\n		if (!root) return;\n		inf(root->left);\n		printf (\"%d \",root->data);\n		inf(root->right);\n		free(root);\n	}\n\nint main()\n{\n	int k,b,x[100],i,a[100];\n	FILE*f=fopen(\"input1.txt\",\"r\");\n	struct item *root = malloc(sizeof(*root));\n	\n	fscanf(f,\"%d\",&b);\n	root->data=b;\n	root->right=root->left=NULL;\n\n	while (fscanf(f,\"%d\",&b)==1)\n	{\n		adtot(root,b);\n	}\n	inf(root);\n	printf(\"\\n\");\n	fclose(f);\n	return 0;\n}\n\n\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (585,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#define N 100\n \nunsigned int hash(char*w)\n{\n	unsigned int res=0;\n	for(;*w;w++)\n		res=res*37+*w;\n	return (res %N);\n}\n\nchar *readword(FILE*f)\n{\n	char*p=NULL;\n	int all=0;\n	int u=0;\n	int c;\n\n	while ((c=fgetc(f))!=EOF)\n	{\n		if (!isalpha(c)) break;\n		if (all==u)\n		{\n			char *q=realloc(p, all+11);\n			if (!q) break;\n			p=q;\n			all+=11;\n		}\n		p[u]=c;\n		u++;\n	}\n	if (p)\n	{\n		p[u]=0;\n	}\n	return p;\n\n\n}\nint main()\n{\n	FILE *f=fopen(\"input2.txt\",\"r\");\n	FILE *fo=fopen(\"out.txt\",\"w\");\n	int wc=0;\n	int i,j;\n	char *k;\n	struct word {\n		char word[20];\n		int count;\n		struct word *next;\n	};\n	struct word *p=NULL;\n	struct word *arr[N] = {0};\n	while ((k=readword(f))!=NULL)\n	{\n	\n		p=arr[hash(k)];\n	    wc=0;\n		for (;p;p=p->next)\n		{\n			// printf(\"k: %s\\np: %p\\np->word: %s\\n\", k, p, p->word);\n			if(strcmp(k,p->word)==0)\n			{\n				wc=1;\n				p->count++;\n				break;\n			}\n		}\n\n		if (wc == 0)\n		{\n			struct word *p=malloc(sizeof(*p));\n			strcpy(p->word,k);\n			p->next=arr[hash(k)] ;\n			p->count=1;\n			arr[hash(k)]=p;\n		\n		}\n    	free(k);\n	}\n	for (i=0;i<N;i++)\n	{\n		for(p=arr[i];p;p=p->next)\n		{\n			fprintf(fo,\"%s %d\\n\",p->word,p->count);\n		//	fprintf(fo, \"\\n\");\n			\n	        }\n	}\n	for(i=0;i<N;i++)\n	{\n		while (p=arr[i])\n		{\n			arr[i] = arr[i]->next;\n			free(p);\n		}\n	}\n	return 0;\n}\n	\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (586,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nunsigned int hash_k(char *s)\n{\n	unsigned int res = 0;\n	return res;\n	for( ; *s;s++)\n	{\n		res = res*37+*s;\n	}\n	return (res % 100);\n}\nchar *readword(FILE* f)\n{\n	int i = 0;\n	char c = 0;\n	char *p=NULL,*tmp;\n	for(i = 0; ((c=fgetc(f)) != EOF); i++)\n	{\n		if(!(c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\'))\n		{\n			if(p)\n				break;\n			i--;\n			continue;\n		}\n		if(!p)\n		{\n			p = calloc(11,sizeof(*p));;\n		}\n		p[i] = c;\n	}\n	return p;\n}\nstruct item\n{\n	char word[100];\n	int count;\n	struct item *next;\n};\nvoid hash(struct item *A[100],char *s)\n{\n	int flag=0,Hk=0;\n	struct item *p=NULL,*q;\n	Hk=hash_k(s);\n	p = A[Hk];\n	for (;p;p=p->next)\n	{\n		flag=0;\n		if (strcmp(s,p->word)==0)\n		{\n			p->count++;\n			flag = 1;\n			break;\n		}\n	}\n	if (flag == 0)\n	{\n		p=malloc(sizeof(*p));\n		strcpy(p->word,s);\n		p->count = 1;\n		p->next=A[Hk];\n		A[Hk]=p;\n	}\n	free(s);\n}\nint main(int argc, char **argv)\n{\n	int i;\n	char *s;\n	struct item *A[100],*p;\n	FILE* fi = fopen(argv[1], \"r\");\n	for(i=0;i<100;i++)\n		A[i]=NULL;\n	while (s=readword(fi))\n		hash (&A[0],s);\n	for(i=0;i<100;i++)\n	{\n		for(p=A[i];p;p=p->next)\n			printf (\"%s   -   %d  \\n\",p->word,p->count);\n	\n	}\n	for(i=0;i<100;i++)\n	{\n		while(p=A[i])\n		{\n			A[i]=A[i]->next;\n			free(p);\n		}\n	}\n	\n	\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (587,'#include <stdio.h>\n#include \"safe.h\"\n\nstruct list {\n	int data;\n	struct list *next;\n};\n\nstruct list *node(int d, struct list *n) {\n	struct list *res = (struct list*) __safe_calloc(sizeof(struct list),1);\n	res->data = d;\n	res->next = n;\n\n	return res;\n};\n\nstruct list *add (int d, struct list *root) {\n\n	struct list *p = root;\n\n	if (root->data > d) return node(d, root);\n	while (p->next && p->next->data<d) p=p->next;\n\n	p->next = node(d,p->next);\n	\n	return root;\n}\n\nvoid print(struct list *root) {\n	struct list *p = root;\n	while (p) {\n		printf(\"%d \", p->data);\n		p=p->next;		\n	}\n}\n\nint main () {\n\n	struct list *head = 0;\n	int c;\n	\n	freopen (\"input.txt\", \"rt\", stdin);\n	freopen (\"output.txt\", \"wt\", stdout);\n\n	while ((scanf (\"%d\", &c)) == 1) {\n		if (!head) head=node(c, 0);\n		else head = add(c, head);\n	}\n	print(head);\n\n	fclose(stdin);\n	fclose(stdout);\n\n	return (0);\n};\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (588,'#include <stdio.h>\n#include \"safe.h\"\n\nstruct tree {\n	int data;\n	struct tree *left, *right;\n};\n\nstruct tree *node(int d) {\n	struct tree *res = (struct tree*) __safe_calloc(sizeof(struct tree),1);\n	res->data = d;\n	res->left = 0;\n	res->right = 0;\n\n	return res;\n};\n\nvoid add (int d, struct tree *root) {\n	if (root->data > d) {\n		if (root->left) add (d, root->left);\n		else root->left = node(d);\n	} else {\n		if (root->right) add (d, root->right);\n		else root->right = node(d);\n	}	\n}\n\nvoid print(struct tree *root) {\n	if (root) {\n		print(root->left);\n		printf(\"%d \", root->data);\n		print(root->right);\n	}\n}\n\nint main () {\n\n	int c;\n	struct tree *root = 0;\n\n	freopen (\"input.txt\", \"rt\", stdin);\n	freopen (\"output.txt\", \"wt\", stdout);\n	while ((scanf (\"%d\", &c)) == 1) {\n		if (!root) root=node(c);\n		else add(c, root);\n	}\n	print(root);\n\n	fclose(stdin);\n	fclose(stdout);\n\n	return (0);\n};\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (589,'#include <stdio.h>\n\n#define pr_s 0\n#define pr_n 1\n#define td 2\n#define op_tr 3\n#define cl_tr 4\n#define pr_br 5\n#define unget 6\n#define next 7\nint main ()\n{\n	int i,f,b,c,state = 3;\n	int print [10][256];\n	int trans [10][256];\n	FILE* input = fopen (\"input.csv\",\"r\");\n	FILE* output = fopen (\"output.htm\",\"w\");\n	for(i=0;i<256;i++)\n	{\n		print [0][i]=unget;\n		trans [0][i]=1;\n		print [1][i]=pr_s;\n		trans [1][i]=1;\n		print [2][i]=pr_s;\n		trans [2][i]=2;\n		print [3][i]=op_tr;\n		trans [3][i]=1;\n	}\n	print [0][\',\']=td;\n	print [0][\'\"\']=pr_n;\n	print [0][\' \']=pr_n;\n	print [0][\'\\n\']=cl_tr;\n	trans [0][\',\']=0;\n	trans [0][\'\"\']=2;\n	trans [0][\' \']=0;\n	trans [0][\'\\n\']=3;\n	print [1][\',\']=td;\n	print [1][\'\\n\']=cl_tr;\n	trans [1][\',\']=0;\n	trans [1][\'\\n\']=3;\n	print [2][\'\"\']=next;\n	print [2][\'\\n\']=pr_br;\n	trans [2][\'\"\']=0;\n	trans [2][\'\\n\']=2;\n	print [3][\' \']=pr_n;\n	trans [3][\' \']=3;\n	print [3][\'\"\']=op_tr;\n	trans [3][\'\"\']=2;\n	print [3][\',\']=td;\n	trans [3][\',\']=0;\n	print [3][\'\\n\']=pr_n;\n	trans [3][\'\\n\']=3;\n	fprintf(output, \"<table border=1>\\n\");\n	while ((c=fgetc(input))!=EOF)\n	{\n		f = 0;\n		if (print [state][c] == pr_s)\n			fputc(c,output);\n		else if (print [state][c] == td)\n			fputs(\"</td> <td>\",output);\n		else if (print [state][c] == op_tr)\n		{\n			ungetc(c, input);\n			fputs(\"<tr><td>\",output);\n		}\n		else if (print [state][c] == cl_tr)\n			fputs(\"</td></tr>\\n\",output);\n		else if (print [state][c] == pr_br)\n			fputs(\"<br/>\\n\",output);\n		else if (print [state][c] == unget)\n			ungetc(c, input);\n		else if (print [state][c] == next)\n		{\n			f = 1;\n			b = 0;\n			if((b = fgetc(input)) != EOF)\n				if(b == \'\"\')\n				{\n					fprintf(output,\"%c\",\'\"\');\n					state = 2;\n				}\n				else\n				{\n					ungetc(b, input);\n					state = 0;\n					f=1;\n				}\n		}\n		if(!f)\n			state = trans [state][c];\n	}\n	fprintf(output, \"</table>\");\n	fclose(input);\n	fclose(output);\n\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (590,'#include <stdio.h>\n#include <math.h>\n#define NMAX 100\n\nint visited[NMAX]={0};\nint A[NMAX][NMAX];\nint path[NMAX];\nfloat dist = 1000000, tmp;\nfloat distance(float *X,float *Y,int i,int j)\n{\n	return (sqrt((X[i]-X[j])*(X[i]-X[j])+(Y[i]-Y[j])*(Y[i]-Y[j])));\n}\nvoid exs(int a,int vert,int *D,int *curr,float *X,float *Y)\n{\n	int i;\n	if (a==vert)\n	{\n		tmp = distance(X,Y,curr[0],curr[vert-1]);\n		for (i=0;i<vert-1;i++)\n		{\n			tmp = tmp + distance(X,Y,curr[i],curr[i+1]);\n		}\n		if  (tmp < dist)\n		{\n			dist=tmp;\n			for(i=0;i<vert;i++)\n			{\n				path[i]=curr[i];\n			}\n		}\n		return;\n	}\n	for(i=0;i<vert;i++)\n	{\n		if(!visited[i])\n		{\n			visited[i] = 1;\n			curr[a]=i;\n			exs(a+1,vert,D,curr,X,Y);\n			visited[i]=0;\n		}\n	}\n}\nint main ()\n{\n	int curr[NMAX],D[NMAX];\n	float X[NMAX];\n	float Y[NMAX];\n	int vert,i,j,a,b,t;\n	FILE* F=fopen (\"graf.txt\",\"r\");\n	fscanf (F,\"%d\",&vert);\n//	printf (\"%d %d\",edge,vert);\n	for (i=0;i<vert;i++)\n	{\n		fscanf (F,\"%f %f\",&X[i],&Y[i]);\n	}\n	exs(0,vert,D,curr,X,Y);\n	printf (\"%f\\n\",dist);\n	for(i=0;i<vert;i++)\n		printf(\" %d \",path[i]);\n\n	printf(\"\\n\");\n	fclose (F);\n	return 0;\n}\n\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (591,'#include <stdio.h>\n\nvoid dfs(int gr[100][100], int vertex, int *used)\n{\n	int i = 0;\n	for(i = 0; i < 100; i++)\n	{\n		if(gr[vertex][i] == 1 && used[i] == 0)\n		{\n			used[i] = 1;\n			dfs(gr, i, used);\n		}\n	}\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n	\n	int gr[100][100] = {0};\n	int used[100] = {0};\n	int i = 0;\n	int a = 0;\n	int b = 0;\n\n	used[0] = 1;\n\n	while(fscanf(I, \"%d %d\", &a, &b) == 2)\n	{\n		if(a < 100 && b < 100)\n			gr[a][b] = gr[b][a] = 1;\n	}\n	\n	dfs(gr, 0, used);\n	for(i = 0; i < 100; i++)\n	{\n		if(used[i] == 1)\n		fprintf(O, \"%d\\n\", i);\n	}\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (592,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item\n{\n	int data;\n	struct item* next;\n} *head, *foot;\n\nint empty()\n{\n	 if(head == NULL)\n		 return 1;\n	 return 0;\n}\nvoid enqueue(int a)\n{\n	struct item *p = (struct item*)malloc(sizeof(struct item));\n	p -> data = a;\n	p -> next = NULL;\n	if (empty()) {\n		head = foot = p;\n	}\n	else {\n		foot -> next = p;\n		foot = p;\n	}\n}\n\nint dequeue()\n{\n	int a = head -> data;\n	struct item *p = head;\n	head = head -> next;\n	if (head == NULL) foot = NULL;\n	free(p);\n	return a;\n}\n\n\nvoid f(int gr[100][100], int used[100], int vertex)\n{\n	int a = 0;\n	int i = 0;\n	\n	enqueue(vertex);\n\n	while(!empty())\n	{\n		a = dequeue();\n		for(i = 0; i < 100; i++)\n		{\n			if (used[i] == 0 && gr[a][i] == 1)\n			{\n				enqueue(i);\n				used[i] = 1;\n				\n			}\n		}\n	}\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n\n	int gr[100][100] = {0};\n	int used[100] = {1};\n	int a, b, i = 0;\n	\n	while(fscanf(I, \"%d %d\", &a, &b) == 2)\n	{\n		if(a < 100 && b < 100)\n			gr[a][b] = gr[b][a] = 1;\n	}\n\n	f(gr, used, 0);\n	for(i = 0; i < 100; i++)\n	{\n		if(used[i] == 1)\n		fprintf(O, \"%d\\n\", i);\n	}\n\n	return 0;\n}','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (593,'#include <stdio.h>\n#include <string.h>\n#define infinity 1000000\n\nvoid Dijkstra(int adjacencyMatrix[100][100], int *pathLen, int *history, int *used, int start)\n{\n	int curr = 0;\n	int flag = 0;\n	int tmp = 1;\n	int tmp2 = infinity + 1;\n	int i = 0;\n	while (1)\n	{\n		tmp = -1;\n		for(i = 0; i < 100; i++)\n		{\n			if(used[i] == 0)\n			{\n				if(tmp == -1 || pathLen[i] < pathLen[tmp])\n				{\n					tmp = i;\n					flag = 1;\n				}\n			}\n		}\n		if(tmp == -1 || pathLen[tmp] == infinity)\n			return;\n		curr = tmp;\n		used[curr] = 1;\n		for(i = 0; i < 100; i++)\n		{\n			if(used[i] == 0)\n			{\n				if(pathLen[i] > pathLen[curr] + adjacencyMatrix[curr][i])\n				{\n					pathLen[i] = pathLen[curr] + adjacencyMatrix[curr][i];\n					history[i] = curr;\n				}\n			}\n		}\n	}\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n\n	int a = 0, b = 0, c = 0;\n	int adjacencyMatrix[100][100];\n	int used[100] = {0};\n	int pathLen[100];\n	int history[100];\n	int start = 0;\n	int i = 0;\n	int j = 0;\n\n	for(i = 0; i < 100; i++)\n	{\n		for(j = 0; j < 100; j++)\n			adjacencyMatrix[i][j] = infinity;\n		pathLen[i] = infinity;\n		history[i] = -1;\n	}\n\n	fscanf(I, \"%d\", &start);\n	for( ;fscanf(I, \"%d %d %d\", &a, &b, &c) == 3; i++)\n	{\n		adjacencyMatrix[a][b] = adjacencyMatrix[b][a] = c;\n	}\n	for(i = 0; i < 100; i++)\n		adjacencyMatrix[i][i] = 0;\n	pathLen[start] =0;\n\n	Dijkstra(adjacencyMatrix, pathLen, history, used, start);\n\n	for(i = 0; i < 100; i++)\n	{\n		if(pathLen[i] != infinity)\n		{\n			fprintf(O, \"%d: %d, [%d <- \", i, pathLen[i], i);\n			for(j = i; j != -1; j = history[j])\n			{\n				if(history[j] == -1)\n					fprintf(O, \"Done!\");\n				else\n					fprintf(O, \"%d <- \", history[j]);\n			}\n			fprintf(O, \"]\\n\");\n		}\n	}\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (594,'#include <stdio.h>\n#include <math.h>\n#include <memory.h>\n\n#define DBL_MAX         1.7976931348623158e+308 /* max value */\n\ndouble   optimalLen = DBL_MAX;\nint optimalPath[100] = {0};\nint currPath[100] = {0};\n\nint n = 0;\nint from = 0;\nint to = 0;\n\n\nvoid dfs(double gr[100][100], int vertex, int *used, double currLen, int last)\n{\n\n	int i = 0;\n	currPath[last] = vertex;\n	if(last == n - 2)\n	{\n		if(optimalLen > currLen + gr[vertex][to])\n		{\n			memcpy(optimalPath, currPath, (n - 1) * sizeof(int));\n			optimalLen = currLen + gr[vertex][to];\n		}\n		return;\n	}\n	for(i = 0; i < n; i++)\n	{\n		if(used[i] == 0)\n		{\n			used[i] = 1;\n			dfs(gr, i, used, currLen + gr[vertex][i], last + 1);\n			used[i] = 0;\n		}\n	}\n}\n\nint main(int argc, char **argv)\n{\n	FILE *I = argc >= 2 ? fopen(argv[1], \"r\") : stdin;\n	FILE *O = argc == 3 ? fopen(argv[2], \"w\") : stdout;\n	\n	double gr[100][100] = {0};\n	int used[100] = {0};\n	double x[100] = {0};\n	double y[100] = {0};\n	int i = 0;\n	int j = 0;\n	double a = 0;\n	double b = 0;\n	float xx = 0;\n	float yy = 0;\n\n	from = to = 0;\n\n	fscanf(I, \"%*d\");\n	\n	used[from] = 1;\n	used[to] = 1;\n\n	while(fscanf(I, \"%f %f\", &xx, &yy) == 2) {\n		x[n] = xx;\n		y[n] = yy;\n		n++;\n	}\n	for(i = 0; i < n; i++)\n	{\n		for(j = 0; j < n; j++)\n		{\n			if (i != j) gr[i][j] = gr[j][i] = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n		}\n	}\n	\n	dfs(gr, from, used, 0, 0);\n	\n	fprintf(O, \"Optimal length: %f\\n\", optimalLen);\n	fprintf(O, \"Optimal path: \");\n	for(i = 0; i < n - 1; i++)\n	{\n		fprintf(O, \"%d \", optimalPath[i]);		\n	}\n	fprintf(O, \"%d\\n\", to);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (595,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 10000\nint main()\n{\n	char buf[N];\n	int prev, sym, len=0, flag1=0, flag2=1;\n	FILE *fin, *fout;\n	fin=fopen(\"inputcsv.txt\", \"r\");\n	fout=fopen(\"outputcsv.txt\", \"w\");\n	fprintf(fout, \"<table>\\n\\t<tr>\\n\\t\\t<td>\\n\");\n	while((sym=fgetc(fin))!=EOF)\n	{\n		if(sym==\'\"\' && flag2)\n		{\n			flag1=1;\n			flag2=0;\n			prev=-1;\n			continue;\n		}\n		if(sym==\'\"\' && prev==\'\"\' && flag1)\n		{\n			buf[len]=sym;\n			len++;\n			prev=-1;\n			continue;		\n		}\n		if(prev==\'\"\' && (sym==\',\' || sym==\'\\n\') && flag1)\n		{\n			flag1=0;\n		}			\n		if(sym==\',\' && !flag1)\n		{\n			flag2=1;\n			buf[len]=0;\n			fprintf(fout, \"\\t\\t%s\\n\\t\\t</td>\\n\\t\\t<td>\\n\", buf);\n			len=0;\n			prev=-1;\n			continue;\n		}\n		if(sym==\'\\n\' && !flag1)\n		{\n			flag2=1;\n			buf[len]=0;\n			fprintf(fout, \"\\t\\t%s\\n\\t\\t</td>\\n\\t</tr>\\n\\t<tr>\\n\\t\\t<td>\\n\", buf);\n			len=0;\n			prev=-1;\n			continue;\n		}\n		else if(sym==\'\\n\')\n		{\n			buf[len]=\'<\';\n			len++;\n			buf[len]=\'b\';\n			len++;\n			buf[len]=\'r\';\n			len++;\n			buf[len]=\'/\';\n			len++;\n			buf[len]=\'>\';\n			len++;\n			continue;\n		}		\n		if(sym!=\'\"\' || !flag1)\n		{			\n		buf[len]=sym;\n		len++;	\n		}\n		flag2=0;\n		prev=sym;\n	}\n	if(len!=0)\n	{\n		buf[len]=0;\n		fprintf(fout, \"\\t\\t%s\\n\", buf);\n	}\n	fprintf(fout, \"\\t\\t</td>\\n\\t</tr>\\n</table>\\n\");\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (596,'#include<stdio.h>\n#include<stdlib.h>\nstruct item\n{\n	int data;\n	struct item *next;\n};\nint main()\n{\n	struct item *head=NULL;\n	int a=0, i;\n	FILE *f; \n	struct item *p, *q, *r;\n	f=fopen(\"inputt.txt\", \"r\");\n	if(fscanf(f, \"%d\", &a)==1)\n	{\n		q=(struct item *)malloc(sizeof(*q));\n		head=q;\n		q->data=a;\n		q->next=NULL;\n	}\n	while(fscanf(f, \"%d\", &a)==1)\n	{\n		q=head;\n		p=NULL;\n		r=(struct item *)malloc(sizeof(*r));\n		r->next=NULL;\n		r->data=a;\n		while(q)\n		{\n			if((p==NULL)&&(a<=(q->data)))\n			{\n				head=r;\n				r->next=q;\n				break;\n			}\n			else if(a<(q->data))\n			{\n				p->next=r;\n				r->next=q;\n				break;\n			}\n			else if(q->next==NULL)\n			{\n				q->next=r;\n				break;\n			}\n			p=q;\n			q=q->next;\n		}\n	}\n	fclose(f);\n	f=fopen(\"output.txt\", \"w\");\n	for(q=head; q; q=q->next)\n	{\n		fprintf(f, \"%d \", q->data);\n	}\n	fclose(f);\n	for(q=head; q; q=p)\n	{\n		p=q->next;\n		free(q);\n	}\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (597,'#include<stdio.h>\n#include<stdlib.h>\n#include<ctype.h>\n#include<string.h>\n#define N 100\nstruct item\n{\n	char s[11];\n	int count;\n	struct item *next;\n};\nvoid up(struct item **head, char *w)\n{\n	struct item *p, *q;\n	for(p=*head; p; p=p->next)\n	{\n		if(strcmp(p->s, w)==0)\n		{\n			p->count++;\n			return;\n		}\n	}\n	q=malloc(sizeof(struct item));\n	q->next=*head;\n	*head=q;\n	q->count=1;\n	strcpy(q->s, w);\n	return;\n}\nint main()\n{\n	int i;\n	char s[N];\n	FILE *f=fopen(\"text.txt\", \"r\");\n	struct item *head=NULL, *p, *q;\n	while(fscanf(f, \"%s\", s)!=EOF)\n	{\n		up(&head, s);\n	}		\n	fclose(f);\n	for (p=head; p; p=p->next)\n	{\n		printf(\"%s - ??? ????? ??????????? ? ?????????? %d\\n\", p->s, p->count);\n	}\n	for (p=head; p; p=q)\n	{\n		q=p->next;\n		free(p);\n	}\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (598,'#include<stdio.h>\n#include<stdlib.h>\nstruct tree\n{\n	int data;\n	struct tree *right, *left;\n};\nstruct tree *root;\nstruct tree *input(int a)\n{\n	struct tree *p=malloc(sizeof(*p));\n	p->data=a;\n	p->left=NULL;\n	p->right=NULL;\n	return p;\n}\nvoid print(struct tree *q, FILE *f)\n{\n	if(!q)\n	{\n		return;\n	}\n	print(q->left, f);\n	fprintf(f, \"%d \", q->data);\n	print(q->right, f);\n}\nvoid add(struct tree **head, struct tree *t)\n{\n	if(*head==NULL)\n	{\n		*head=t;\n	}\n	else\n	{\n		if((*head)->data>=t->data)\n		{\n			add(&(*head)->left, t);\n		}\n		else\n		{\n			add(&(*head)->right, t);\n		}\n	}\n}\nvoid freemem(struct tree *q)\n{\n	if(!q)\n	{\n		return;\n	}\n	freemem(q->left);\n	freemem(q->right);\n	free(q);\n}\nint main()\n{\n	int a;\n	FILE *f;\n	struct tree *q;\n	f=fopen(\"inputt.txt\", \"r\");\n	while(fscanf(f, \"%d\", &a)==1)\n	{\n		add(&root, input(a));\n	}\n	fclose(f);	\n	f=fopen(\"output.txt\", \"w\");\n	print(root, f);\n	freemem(root);\n	fclose(f);	\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (599,'#include <stdio.h>\n#define N 100\n#define INF 10000000\n\nvoid deykstra(int *R, int *W, int *Visited, int A[][N+1], int kv, int start) {\n	int i, j;\n	\n	for (i = 1; i <= kv; i++) {\n		Visited[i] = 0;\n		R[i] = INF;\n	}\n\n	R[start] = 0;\n	W[start] = 0;\n	\n	for (i = 1; i <= kv; i++) {\n		int z = INF;\n		int ver = -1;\n		printf(\"for: %d ---\", i);\n		for (j = 1; j <= kv; j++)\n			if (!Visited[j] && z > R[j]) {\n				z = R[j];\n				ver = j;\n				printf(\"%d \", j);\n			}\n		if (ver == -1)\n			break;\n		Visited[ver] = 1;\n		for (j = 1; j <= kv; j++)\n			if ( !Visited[j] && A[ver][j] != -1 && R[j] > R[ver] + A[ver][j]) {\n				R[j] = R[ver] + A[ver][j];\n				W[j] = ver;\n				printf(\"%d \", j);\n			}\n		printf(\"\\n\");\n	}\n}\n\nvoid print(int x, int *W) {\n	if (x == 0)\n		return;\n	print(W[x], W);\n	printf(\"%d \", x);\n}\n	\nint main()\n{\n	int A[N+1][N+1];\n	int R[N+1];\n	int W[N+1];\n	int Visited[N+1] = {0};\n	int i, j, x, y, z, kv, kr=0, start;\n	FILE *f = fopen(\"24.txt\", \"r\");\n	if (!f) {\n		perror(\"24.txt\");\n		return 0;\n	}\n		\n	fscanf(f, \"%d%d\", &kv, &start);\n	for (i=1; i<=kv; i++)\n		for (j=1; j<=kv; j++)\n			A[i][j] = -1;\n	printf(\"Vvedite kol-vo vershin: %d\\n\", kv);\n	printf(\"Startovaya vershina: %d\\n\", start);\n		\n	while (fscanf(f, \"%d%d%d\", &x, &y, &z) == 3) {\n		A[x][y] = z;\n		A[y][x] = z;\n		kr++;\n	}\n	\n	printf(\"lalala\\n\");\n	deykstra(R, W, Visited, A, kv, start);\n	printf(\"tadada\\n\");\n	\n	for (i = 2; i <= kv; i++) {\n		printf(\"%d: \", i);\n		if (R[i] == INF)\n			printf(\"No Way\\n\");\n		else {\n			printf(\"Rasstoyanie = %d, Way = \", R[i]);\n			print(i, W);\n			printf(\"\\n\");\n		}\n	}\n		\n	fclose(f);\n	\n	return 0;\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (600,'#include <stdio.h>\nint znak(char num[101], int i)\n{\n	int a;\n	if ((num[i]>=\'0\') && (num[i]<=\'9\'))\n		a=num[i]-\'0\';\n	else\n	if ((num[i]>=\'A\') && (num[i]<=\'F\'))\n		a=num[i]-\'A\'+10;\n	else\n		a=-1;\n	return a;\n}\nint test(int a,int ss)\n{\n	if (a==-1)\n	{\n		printf(\"?? ?????????? ??????\\n\");\n		return 1;\n	}\n	if(a>=ss)\n	{\n		printf(\"?????? ????? ?? ?????? ???? ?????? ??? ????? ????????? ??????? ?????????\\n\");\n		return 1;\n	}\n	return 0;\n}\nint main()\n{\n	int ss=2,d=0,i=0,a;\n	char num[101];\n	float out=0,tmp=0;\n	printf(\"??????? ????????? ??????? ?????????\\n\");\n	scanf(\"%d\",&ss);\n	if((ss<2)||(ss>16))\n	{\n		printf(\"????????? ??????? ?????? ???? ????? 2 ? 16\\n\");\n		return 1;\n	}\n	printf(\"??????? ?????\\n\");\n	scanf(\"%s\",num);\n	d=strlen(num)-1;\n	while ((num[i]!=\'.\') && (i<=d))\n	{\n		a=znak(num,i);\n		if(test(a,ss)==1) return 1;\n		out=out*ss+a;\n		i++;\n	}\n	if (num[i]==\'.\')\n	{\n		while(d>i)\n		{\n			a=znak(num,d);\n			if(test(a,ss)==1) return 1;\n			tmp=(tmp+a)/ss;\n			d--;\n		}\n		out+=tmp;\n	}\n	printf(\"??? ????? ? ?????????? ??????? ????????? = %f\\n\",out);\n	return 0;\n}\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (601,'#include <stdio.h>\nint main()\n{\n	int sim,i,state=0;\n	FILE *f=fopen(\"t_input.csv\",\"r\");\n	FILE *g=fopen(\"t_output.htm\",\"w\");\n	fprintf(g,\"<table border=1>\\n\");\n	while ((sim=fgetc(f))!=EOF)\n	{\n		switch(state)\n		{\n			case 0:\n				if (sim==\'\\\"\') \n				{	\n					state=1;\n					fprintf(g,\"<tr><td>\");\n				}\n				else if (sim==\',\') \n				{\n					state=3;\n					fprintf(g,\"<tr><td></td>\");\n				}\n				else\n				{\n					state=4;\n					fprintf(g,\"<tr><td>\");\n					fputc(sim,g);\n				}\n			break;	\n			case 1:	\n				if (sim==\'\\\"\')\n				{\n					state=2;\n				}\n				else if (sim==\'\\n\')\n				{\n					fprintf(g,\"<br/>\");\n				}\n				else \n				{\n					fputc(sim,g);\n				}\n			break;\n			case 2:\n				if (sim==\'\\\"\')\n				{\n					state=1;\n					fputc(sim,g);\n				}\n				else if (sim==\'\\n\')\n				{\n					state=0;\n					fprintf(g,\"</td></tr>\\n\");\n				}\n				else if (sim==\',\')\n				{\n					state=3;\n					fprintf(g,\"</td>\");\n				}\n			break;\n			case 3:\n				if (sim==\'\\\"\')\n				{\n					state=1;\n					fprintf(g,\"<td>\");\n				}\n				else if (sim==\',\')\n				{\n					fprintf(g,\"<td></td>\");\n				}\n				else if (sim==\'\\n\')\n				{\n					state=0;\n					fprintf(g,\"<td></td></tr>\\n\");\n				}\n				else \n				{\n					state=4;\n					fprintf(g,\"<td>\");\n					fputc(sim,g);\n				}\n			break;	\n			case 4:\n				if (sim==\',\')\n				{\n					state=3;\n					fprintf(g,\"</td>\");\n				}\n				else if (sim==\'\\n\')\n				{\n					state=0;\n					fprintf(g,\"</td></tr>\\n\");\n				}\n				else fputc(sim,g);\n			break;\n		}\n	}\n	fprintf(g, \"</table>\\n\");\n	fclose(f);\n	fclose(g);\n	return 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (602,'#include <stdio.h>\n\nvoid sift(int *A, int N, int k)\n{\n	int r,l,max,tmp;\n	\n	k++;\n	while((l=2*k)<=N)\n	{\n		r = (l+1<=N)?l+1:k;\n		if(A[k-1]>=A[l-1] && A[k-1]>=A[r-1])\n			return;\n		max=(A[l-1]>=A[r-1])?l:r;\n		tmp=A[k-1];\n		A[k-1]=A[max-1];\n		A[max-1]=tmp;\n		k=max;\n	}\n}\n\n\nvoid heapsort(int *A, int N)\n{\n	int i;\n	for(i=N/2;i>=0;i--)\n		sift(A,N,i);\n	for(i=N-1;i>0;i--)\n	{\n		int tmp=A[0];\n		A[0]=A[i];\n		A[i]=tmp;\n		sift(A,i,0);\n	}\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (603,'#include <stdio.h>\n#define N 50\nint A[N][N];\nint visited[N]={0};\nvoid dfs(int c)\n{\n	int i;\n	visited[c]=1;\n	for (i=0;i<N;i++)\n	{\n		if (A[c][i] && !visited[i]) dfs(i);\n	}\n}\nint main()\n{\n	FILE *f=fopen(\"f_input.txt\",\"r\");\n	FILE *g=fopen(\"f_output.txt\",\"w\");\n	int i=0,x=0,y=0;\n	while(fscanf(f, \"%d %d\", &x, &y) == 2)\n			A[x][y] = A[y][x] = 1;	\n	dfs(1);\n	for(i = 0; i < N; i++)\n	{\n		if(visited[i] == 1)\n		fprintf(g, \"%d\\n\", i);\n	}\n	return 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (604,'#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct item {\n	int data;\n	struct item *next;\n} ITEM;\n\ntypedef ITEM * ITEM_PTR;\n\nvoid insert_elem(ITEM_PTR* head, int elem);\nvoid print_list(ITEM_PTR head);\nvoid delete_list(ITEM_PTR * head);\n\nint main()\n{\n	FILE *f;\n	ITEM_PTR head = NULL;\n	int data;\n\n	f = fopen(\"zadacha18_input.txt\", \"r\");\n\n	while (fscanf(f, \"%d\", &data) == 1)\n	{\n	    insert_elem(&head, data);\n	}\n\n	fclose(f);\n\n	print_list(head);\n	delete_list(&head);\n\n	return 0;\n}\n\nITEM_PTR find_pos(ITEM_PTR head, int data)\n{\n	ITEM_PTR current_ptr = head;\n	ITEM_PTR prev_ptr = NULL;\n\n	while (current_ptr != NULL)\n	{\n		if (current_ptr->data <= data)\n		{\n			prev_ptr = current_ptr;\n			current_ptr = current_ptr->next;\n		}\n		else\n			return prev_ptr;\n	}\n\n	return prev_ptr;\n}\n\nvoid insert_elem(ITEM_PTR* head, int data)\n{\n	ITEM_PTR newitem_ptr = (ITEM_PTR)malloc(sizeof(ITEM));\n	newitem_ptr->data = data;\n\n	if ((*head) == NULL)\n	{\n		(*head) = newitem_ptr;\n		newitem_ptr->next = NULL;\n	}\n	else\n	{\n		ITEM_PTR insertpos_ptr = find_pos(*head, data);\n		if (insertpos_ptr == NULL)\n		{\n			newitem_ptr->next = (*head);\n			(*head) = newitem_ptr;\n		}\n		else\n		{\n			newitem_ptr->next = insertpos_ptr->next;\n			insertpos_ptr->next = newitem_ptr;\n		}\n	}\n\n}\n\nvoid print_list(ITEM_PTR head)\n{\n	ITEM_PTR current_ptr = head;\n\n	while (current_ptr != NULL)\n	{\n		printf(\"%d \", current_ptr->data);\n		current_ptr = current_ptr->next;\n	}\n	printf(\"\\n\");\n}\n\nvoid delete_list(ITEM_PTR * head)\n{\n	ITEM_PTR current_ptr = *head;\n	ITEM_PTR prev_ptr;\n\n	while (current_ptr != NULL)\n	{\n		prev_ptr = current_ptr;\n		current_ptr = current_ptr->next;\n		free(prev_ptr);\n	}\n\n	(*head) = NULL;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (605,'#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\nint goDepth(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int startVertex);\nint addEdge(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int vertex1, int vertex2);\n\n\nint main(int argc, char * argv[], char * argp[])\n{\n	FILE * file;\n	int vertex1, vertex2, i, j;\n	int adjacency_matrix[MAX_SIZE][MAX_SIZE];\n\n	file = fopen(\"zadacha22_input.txt\", \"r\");\n\n	for (i = 0; i < MAX_SIZE; i++)\n		for (j = 0; j < MAX_SIZE; j++)\n			adjacency_matrix[i][j] = 0;\n\n	while (fscanf(file, \"(%d,%d)\", &vertex1, &vertex2) == 2)\n			addEdge(adjacency_matrix, vertex1, vertex2);\n\n	goDepth(adjacency_matrix, 1);\n	fclose(file);\n\n	return 0;\n}\n\nint goDepth(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int startVertex)\n{\n	int path[MAX_SIZE], usedVertexes[MAX_SIZE];\n	int vertex, currentVertex, lastVertex = -1;\n	int topStackIndex = -1;\n\n	memset(path, -1, MAX_SIZE);\n	memset(usedVertexes, 0, MAX_SIZE);\n	path[++topStackIndex] = startVertex;\n	usedVertexes[startVertex] = 1;\n\n	while (topStackIndex >= 0)\n	{\n		currentVertex = path[topStackIndex];\n\n		for (vertex = ++lastVertex; vertex < MAX_SIZE; vertex++)\n		{\n			if (adjacency_matrix[currentVertex][vertex] && !usedVertexes[vertex])\n			{\n				path[++topStackIndex] = vertex;\n				usedVertexes[vertex] = 1;\n				break;\n			}\n		}\n\n		if (currentVertex == path[topStackIndex])\n		{\n			lastVertex = currentVertex;\n			--topStackIndex;\n			printf(\"%d \", lastVertex);\n		}\n		else\n			lastVertex = -1;\n	}\n\n	printf(\"\\n\");\n\n	return 0;\n}\n\nint addEdge(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int vertex1, int vertex2)\n{\n	adjacency_matrix[vertex1][vertex2] = 1;\n	adjacency_matrix[vertex2][vertex1] = 1;\n\n	return 0;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (606,'#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\nint goWidth(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int startVertex);\nint addEdge(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int vertex1, int vertex2);\n\nint main()\n{\n	FILE * file;\n	int vertex1, vertex2, i, j;\n	int adjacency_matrix[MAX_SIZE][MAX_SIZE];\n\n	file = fopen(\"zadacha23_input.txt\", \"r\");\n	\n	for (i = 0; i < MAX_SIZE; i++)\n		for (j = 0; j < MAX_SIZE; j++)\n			adjacency_matrix[i][j] = 0;\n\n	while (fscanf(file, \"(%d,%d)\", &vertex1, &vertex2) == 2)\n			addEdge(adjacency_matrix, vertex1, vertex2);\n\n	goWidth(adjacency_matrix, 1);\n\n	fclose(file);\n\n	return 0;\n}\n\nint containsVertex(int vertexes[], int size, int vertex)\n{\n	int index;\n	for (index=0; index < size; index++)\n		if (vertexes[index] == vertex)\n			return 1;\n\n	return 0;\n}\n\nint goWidth(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int startVertex)\n{\n	int vertex, currentVertex;\n	int frontQueueIndex = -1, backQueueIndex = -1;\n	int queue[MAX_SIZE];\n\n	queue[++backQueueIndex] = startVertex;\n\n	while (backQueueIndex > frontQueueIndex)\n	{\n		currentVertex = queue[++frontQueueIndex];\n		printf(\"%d \", currentVertex);\n\n		for (vertex = 0; vertex < MAX_SIZE; vertex++)\n		{\n			if (adjacency_matrix[currentVertex][vertex] && !containsVertex(queue, MAX_SIZE, vertex))\n			{\n				queue[++backQueueIndex] = vertex;\n			}\n		}\n	}\n\n	printf(\"\\n\");\n	return 0;\n}\n\nint addEdge(int adjacency_matrix[MAX_SIZE][MAX_SIZE], int vertex1, int vertex2)\n{\n	adjacency_matrix[vertex1][vertex2] = 1;\n	adjacency_matrix[vertex2][vertex1] = 1;\n\n	return 0;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (607,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	FILE *I=fopen(\"/etc/passwd\",\"r\");\n	char login[20]={0};\n	char str[200] = {0};\n	char subStr[200] = {0};\n	char res[200] = {0};\n	char tmp[200] = {0};\n	int counter = 0;\n	printf(\"??????? ?????:\\n\");\n	scanf(\"%s\",&login);\n	while(fgets(str, 200, I) != NULL)\n	{\n		strncpy(subStr, str, strlen(login));\n		if((strcmp(login, subStr) == 0) && (str[strlen(login)] == \':\'))\n		{\n			int c = 0;													\n			int i = 0;	\n			for(i = 0; i < 200 && c <= 3; i++)\n			{\n				if(str[i] == \':\')\n					c++;\n				if(c == 4)\n				{\n					i++;\n					while(str[i] != \',\' && str[i] != \':\')\n					{\n						printf(\"%c\", str[i]);\n						i++;\n					}\n					printf(\"\\n\");\n					return 0;\n				}\n			}\n		}\n	}\n	return 0;\n};\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (608,'#include <stdio.h>\n#define N 100000\nvoid rek(int a[N],int b,int n,int mass[N])\n{\n	int i,j;\n	int mass1;\n	int state;			\n	if(n==b)\n	{\n		for(i=0;i<b;i++)\n			printf(\"%d \",a[i]);\n		printf(\"\\n\");\n		return;\n	}	\n	for(i=0;i<n;i++)\n	{									\n		state=0;\n		for(j=0;j<b;j++)\n			if(mass[i]==a[j]) state=1;\n		if(state==0)\n		{\n			a[b]=mass[i];\n			rek(a,b+1,n,mass);															\n		}\n	}\n	return;\n}\nint main()\n{\n	int n,i;\n	int mass[N]={0};\n	int mass2[N]={0}; 	\n	FILE *f=fopen(\"input1.txt\",\"r\");\n		fscanf(f,\"%d\\n\",&n);				\n	for(i=0;i<n;i++)\n		fscanf(f,\"%d\",&mass[i]);\n	rek(mass2,0,n,mass);\n	return 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (609,'#include <stdio.h>\n#include <stdlib.h>\nstruct list \n{\n	int a;\n	struct list * next;\n};\n\nvoid l_insert(struct list * head, int n)\n{\n	if(n<head->a)\n	{\n		struct list * p=malloc(sizeof(struct list));\n		p->a=head->a;\n		head->a=n;\n		p->next=head->next;\n		head->next=p;		\n	}\n	else if(head->next==NULL)\n	{	\n		struct list *p=malloc(sizeof(struct list));\n		p->a=n;									\n		p->next=NULL;\n		head-> next=p;\n	}\n	else l_insert(head-> next,n);\n}\n\nint main()\n{\n	FILE *f_in,*f_out;\n	struct list * head=malloc(sizeof(struct list));\n	struct list * p;\n	struct list * q;\n	int n;\n	f_in=fopen(\"input1.txt\",\"r\");\n	f_out=fopen(\"output1.txt\",\"w\");		\n	if(fscanf(f_in,\"%d\",&n)==1)\n	{	\n		head->a=n;\n		head->next=NULL;\n		while(fscanf(f_in,\"%d\",&n)==1)\n			l_insert(head,n);\n	}\n	p=head;\n	while(p!=NULL)\n	{	\n		fprintf(f_out,\"%d \",p->a);\n		q = p;\n		p=p->next;\n		free(q);\n	}\n	fclose(f_in);\n	fclose(f_out);\n	return 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (610,'#include <stdio.h>\n#include <stdlib.h>\nstruct tree \n{\n	int a;\n	struct tree * left;\n	struct tree * right;\n};\nvoid l_insert(struct tree * root, int n)\n{\n	if(root->a>n)\n		if(root->left==NULL)\n		{\n			struct tree * p=malloc(sizeof(struct tree));\n			p->a=n;					\n			p->left=NULL;\n			p->right=NULL;\n			root->left=p;\n		}\n		else\n			l_insert(root->left,n);\n	else \n		if(root->right==NULL)\n		{	\n			struct tree * p=malloc(sizeof(struct tree));\n			p->a=n;\n			p->left=NULL;\n			p->right=NULL;\n			root->right=p;																\n		}\n		else \n			l_insert(root->right,n);\n}\nvoid ret(struct tree * root, FILE * f_out)\n{\n	if(root->left)\n	{\n		ret(root->left,f_out);\n		free(root->left);\n	}\n	fprintf(f_out,\"%d \",root->a);\n	if(root->right)\n	{\n		ret(root->right,f_out);\n		free(root->right);\n	}\n}\nint main()\n\n{\n	FILE *f_in,*f_out;\n	struct tree * root=malloc(sizeof(struct tree));\n	int n;\n	f_in=fopen(\"input1.txt\",\"r\");\n	f_out=fopen(\"output1.txt\",\"w\");\n	if(fscanf(f_in,\"%d\",&n)==1)\n	{	\n		root->a=n;\n		root->left=NULL;\n		root->right=NULL;\n		while(fscanf(f_in,\"%d\",&n)==1)\n			l_insert(root,n);\n	}\n	ret(root,f_out);\n	free(root);\n	fprintf(f_out,\"\\n\");\n	fclose(f_in);		\n	fclose(f_out);\n	return 0;\n}\n\n\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (611,'#include<stdio.h>\n#include<stdlib.h>\n#define N 101\nint Q[N];\nint r=0, w=0;\nint A[N][N]={0};\nvoid enqueue(int c)\n{\n	Q[w++]=c;\n}\nint dequeue(void)\n{\n	r++;\n	return (Q[r-1]);\n}\nint empty()\n{\n	if (r==w) return 1;\n	return 0;\n}\nvoid bfs(int c, int *vis)\n{\n	int i;\n	enqueue(c);\n	vis[c]=1;\n	while (!empty())\n	{\n		c=dequeue();\n		for (i=1; i<N; i++)\n		{\n			if (A[c][i] && !vis[i])\n			{\n				enqueue(i);\n				vis[i]=1;\n			}\n		}\n	}\n}\nint main()\n{\n	int n=0, m=0, vis[N]={0};\n	FILE *f;\n	f=fopen(\"f_input.txt\", \"r\");\n	while (fscanf(f, \"%d %d\", &n, &m)==2)\n	{\n		A[n][m]=1;\n		A[m][n]=1;\n		n++;\n	}\n	fclose(f);\n	printf(\"????????? ????????? ???????: \");\n	bfs(1, vis);\n	for (n=2; n<N; n++)\n	{\n		if (vis[n])\n		{\n			printf(\"%d \", n);\n		}\n	}\n	printf(\"\\n\");								       \n	return 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (612,'#include <stdio.h>\n#include <string.h>\n\nint main(int agrc, char* agrv[])\n{\n	char login[20] = {0};\n	if(agrc == 2)\n	{\n//		printf(\"parameters: 2\\n\");\n		strcpy(login, agrv[1]);\n	}\n	else if(agrc <= 1)\n	{\n		fgets(login, 20, stdin);\n		login[strlen(login) - 1] = 0;\n	}\n	else\n	{\n		printf(\"Invalid parameters!\\n\");\n		return 0;\n	}\n\n	\n	FILE *I = fopen(\"/etc/passwd\", \"r\");\n	if(I == NULL)\n	{\n		printf(\"Error\\n\");\n		exit(-1);\n	}\n	if(I == NULL)\n	{\n		printf(\"failed to read /etc/passwd ...\\n\");\n		return 0;\n	}\n\n	char str[200] = {0};\n	char subStr[200] = {0};\n	char res[200] = {0};\n	char tmp[200] = {0};\n	\n	while(fgets(str, 200, I) != NULL)\n	{\n		int counter = 0;\n		strncpy(subStr, str, strlen(login));\n		if((strcmp(login, subStr) == 0) && (str[strlen(login)] == \':\'))\n		{\n			int c = 0;\n			for(int i = 0; i < 200 && c <= 3; i++)\n			{\n				if(str[i] == \':\')\n					c++;\n				if(c == 4)\n				{\n					i++;\n					while(str[i] != \',\' && str[i] != \':\')\n					{\n						printf(\"%c\", str[i]);\n						i++;\n					}\n					printf(\"\\n\");\n					return 0;\n				}\n			}\n		}\n	}\n	\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (613,'#include<stdio.h>\n#include<stdlib.h>\n#define N 101\nint A[N][N]={0};\nstruct queue\n{\n	int Q[N];\n	int r, w;\n};\nvoid unit(struct queue *q)\n{\n	q->r=0;\n	q->w=0;\n}\nvoid enqueue(struct queue *q,int c)\n{\n	q->Q[q->w++]=c;\n}\nint dequeue(struct queue *q)\n{\n	q->r++;\n	return (q->Q[q->r-1]);\n}\nint empty(struct queue *q)\n{\n	if (q->r==q->w) return 1;\n	return 0;\n}\nvoid bfs(int c, int *vis)\n{\n	int i;\n	struct queue q;\n	unit(&q);\n	enqueue(&q,c);\n	vis[c]=1;\n	while (!empty(&q))\n	{\n		c=dequeue(&q);\n		for (i=1; i<N; i++)\n		{\n			if (A[c][i] && !vis[i])\n			{\n				enqueue(&q,i);\n				vis[i]=1;\n			}\n		}\n	}\n}\nint main()\n{\n	int n=0, m=0, vis[N]={0};\n	FILE *f;\n	f=fopen(\"f_input.txt\", \"r\");\n	while (fscanf(f, \"%d %d\", &n, &m)==2)\n	{\n		A[n][m]=1;\n		A[m][n]=1;\n		n++;\n	}\n	fclose(f);\n	printf(\"????????? ????????? ???????: \");\n	bfs(1, vis);\n	for (n=2; n<N; n++)\n	{\n		if (vis[n])\n		{\n			printf(\"%d \", n);\n		}\n	}\n	printf(\"\\n\");								       \n	return 0;\n}\n','Ð•Ð³Ð¾Ñ€','Egor','m');
INSERT INTO `bias` VALUES (614,'#include <stdio.h>\n\nint main()\n\n\n{\nint i=2;\nint N;\n\nprintf (\"???????? ?? ?????? ?????? ???????? ?????????????????? (????? ?????? ???? ?? ????? ????)\");\nscanf(\"%d\", &N);\n\nint a1=1;\nint a2=1;\n\n\n\nprintf(\"\\n a1=1\\n\");\nprintf (\"\\n a2=1\\n\");\n	while (i!=N)\n	{	\n		i++;\n		a1=a1+a2;\n		a2=a1+a2;\n		printf (\"a%d=\",i);\n		printf (\"%d\\n\",a1);\n			i++;\n			if (i!=N)\n			{\n				printf (\"a%d=\",i);\n				printf (\"%d\\n\",a2);\n			}\n	}\n\n\n\nreturn 0;\n\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (615,'#include<stdio.h>\nint main()\n{\n	int i,l,d;\n\n	l=0;d=1;\n	for(i=0;i<10;i=i+1)\n	{\n		l=d+l;\n		d=l+d;\n		printf(\"%d %d \",l,d);\n	}\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (616,'#include<stdio.h>\nint main()\n{  int N;\nint i;\nint f;\nint f0=0;\nint f1=1;\nprintf(\"tftyguy\\n\");\n\nscanf(\"%d\", &N);\nprintf(\"%d %d \",f0,f1);\nfor(i=2;i<=N;i++)\n{ \nf=f0+f1;\nf0=f1;\nf1=f;\nprintf(\"%d \",f);\n\n\n}\n\n\n\nprintf(\"\\n\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nreturn 0;\n} \n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (617,'#include <stdio.h> \nint main()\n{\nint f0, f1, i, f2;\nf0=0;\nf1=1;\n\n for(i=0;i<10;i++)\n {\n	f2=f0+f1;\n	f0=f1;\n	f1=f2;\n printf(\"%d \", f2); \n}\nreturn 0;\n}\n\n\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (618,'#include<stdio.h>\nint main()\n{\n	int x, y, z, i;\n	x = 0;\n	y = 1;\n\n	for(i=0; i<=10; i++)\n	{\n		z=x+y;\n		x=y;\n		y=z;\n		printf(\"?????=%d\\n\",z);\n	}	\n	return 0;\n}\n\n         \n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (619,'#include <stdio.h>\nint main()\n{\n	int a, b, c, i;\n	a=0;\n	b=1;\n	for(i=0; i<=15; i++)\n	{\n		c=a+b;\n		a=b;\n		b=c;\n		printf(\"%d\\n\",c);\n	}\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (620,'#include<stdio.h>\nint main()\n\n\n{\n	int a;\n	int b;\n	int k;\n	int NOD;\n	scanf(\"%d%d\",&a,&b);\n	if(a%b==0)\n	{\n		\n		NOD=b;\n		\n		\n		}\n	\nelse\n{	while(k!=0)\n	{ k=a%b;\n	a=b;\n	b=k;\n	}\n	NOD=a;	\n		\n}		\n		\nprintf\n(\"%d\\n\",NOD);		\n		\n		\n	\n	return 0;\n\n	\n	}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (621,'#include<stdio.h>\n\nint main()\n{\n	int a=101, b=30, c;\n	while ((a%b)!=0)\n	{\n		c=a%b;\n		a=b;\n		b=c;\n	}\n	printf(\"%d\\n\",b);\n	return 0;\n}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (622,'#include<stdio.h>\nint main()\n{ int a=101, b=60, c;	\n  while (a%b!=0)\n  {c = a%b;\n   a = b;\n   b = c;\n  }\n  printf(\"%d\\n\",b);\n  return 0;\n}\n  	\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (623,'#include<stdio.h>\n\n\nint main(int a, int b, int r)\n{	\n	printf(\"??????? ????? a=\");\n	scanf(\"%d\",&a);\n	printf(\"??????? ????? b=\");\n	scanf(\"%d\",&b);\n	\nwhile(r!=0)\n{\n	r=a%b;\n	a=b;\n	b=r;\n}\n	printf(\"%d\\n\", a);\nreturn 0;\n}\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (624,'# include <stdio.h>\n#include <math.h>\n\n#define eps 0.00001\n\nfloat f(float x)\n	{\n		return sin(x);\n	}\n\nint main ()\n{\n	float c=0;\nfloat a=6;\nfloat b=7;\n\n\nint i=0;\n\nwhile (b-a>eps)\n	{\n			c=(a+b)/2;\n			if (f(a)*f(c)<0)\n			{\n				b=c;\n			}\n			if (f(b)*f(c)<0)\n			{\n				a=c;\n			}\ni++;\n\n\n\n			\n	}\n	printf (\"? ???? ?????????? ????????? ????? (%f,%f)\\n\",a,b);\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (625,'#include<stdio.h>\nfloat f(float x)\n\n{ return x*x-1.234;\n}\n\nint main()\n{   \nfloat a=0;\nfloat b=2;\nfloat m;\nfloat E = 0.0001;\n\n\nif(f(a)*f(b)>0)\n	{printf(\"??? ??????\");    }\n\n\n\nelse\n	{ while((b-a)>E)\n          {m=(a+b)/2;\n	 if(f(a)*f(m)<0)\n{	b=m;}\n	else\n	{	a=m;}\n\n		\n		\n		\n	}	}\n	\n	printf(\"%f\",m);\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	return 0;\n	}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (626,'#include<stdio.h>\n\nint main(int a, int b , int s)\n{\nprintf(\"??????? ?????? ????? \");\nscanf(\"%d\",&a);\nprintf(\"??????? ?????? ????? \");\nscanf(\"%d\",&b);	\nwhile(s!=0)\n{\n s=a%b;\n a=b;\n b=s;\n}	\nprintf(\"%d\\n \", a);\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (627,'#include <stdio.h>\nint main()\n{\n	int a,b,r;\n	scanf(\"%d%d\",&a,&b);\n	while ((a%b)!=0)		\n	{\n		r = a % b;\n		a=b;\n		b=r;\n	}\n	printf(\"%d\\n\", r);\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (628,'#include <stdio.h>\nint main()\n{\n	int f, f0, f1, i;\n	f0=0;\n	f1=1;\n	printf(\"%d\\n%d\\n\",f0, f1);\n	\n	for(i=2; i<=10; i++)\n	{\n		f=f0+f1;\n		f0=f1;\n		f1=f;\n	\n		printf(\"%d\\n\",f);\n	}\n\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (629,'# include <stdio.h>\n#include <math.h>\n\n#define eps 0.00001\n\nfloat f(float x)\n	{\n		return sin(x);\n	}\n\nint main ()\n{\n	float c=0;\nfloat a=6;\nfloat b=7;\n\n\nint i=0;\n\nwhile (b-a>eps)\n	{\n			c=(a+b)/2;\n			if (f(a)*f(c)<0)\n			{\n				b=c;\n			}\n			if (f(b)*f(c)<0)\n			{\n				a=c;\n			}\ni++;\n\n\n\n			\n	}\n	printf (\"? ???? ?????????? ????????? ????? (%f,%f)\\n\",a,b);\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (630,'#include<stdio.h>\nfloat f(float x)\n{\n	return (2*x+6);\n}\n\nint main()\n{\n	float a=-10, b=10;\n	if (f(a) * f(b) > 0)\n	{\n		printf(\"No roots\\n\");\n		return 0;\n	}\n	while (b-a>=0.001)\n	{\n		if (f(a)*f((a+b)/2)>0)\n			{\n				a=(a+b)/2;\n			}\n		else\n			{\n				b=(a+b)/2;\n			}\n	}\n	printf(\"%f\\n\", a);\n	return 0;\n}\n		\n\n\n	\n\n\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (631,'#include<stdio.h>\nfloat f(float x)\n{\n	return (2 * x + 6);\n}\n\nint main()\n{ float a=-4;\n  float b=2;\n\n  while( (b-a)> 0.0000001)\n	    \n { if( (f(a)*f((a+b)/2))<0) b=(a+b)/2;\n   else             a=(a+b)/2;\n}\n  printf(\"%f\\n\",b);\n \n\n return 0;\n}\n    	\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (632,'#include <stdio.h>\nfloat f( float x)\n{\n	return (x*x - 5);\n}\nint main()\n{\n	float a=0;\n	float b=3;\n	float e=0.0001;\nif((f(a)*f(b))<0)\n	{while((b-a)>e)\n		{\n			if (f(a)*f((a+b)/2)<0)\n			{b=((a+b)/2); }\n			else \n			{a=((a+b)/2); }\n		}\n		printf (\"?????? ?????????: b=%f\\n\", b);\n	}\nelse\n	{printf (\"?????? ???\");}\nreturn 0;\n}\n		\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (633,'#include<stdio.h>\nfloat f(float x)\n{\n	return(2*x + 8);\n}\nint main()\n{\n	float a=-5, b=5;\n	while (b-a>=0.001)\n	{\n		float m = (a + b) / 2;\n		if (f(a)*f(m)>0)\n			{ \n				a=m;\n			}\n		else	\n			{\n				b=m;\n			}	\n	}\n			\n	printf(\"%f\\n\",a);\n\n	return 0;\n}		\n		\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (634,'#include<stdio.h>\r\n\r\nint count(int i, int y)\r\n{\r\n	if (i==1 || i==3 || i==5 || i==7 || i==8 || i==10 || i==12)\r\n		return 31;\r\n\r\n	if (i==2 && ((y%4==0 && y%100!=0) || y%400==0))\r\n		return 29;\r\n	else if (i==2) \r\n		return 28;\r\n\r\n	if (i==4 || i==6 || i==9 || i==11) \r\n		return 30;\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{ \r\n	int day1, month1, year1, day2, month2, year2, i, s=0;\r\n\r\n	printf(\"the first date (DD.MM.YYYY):\\n\");\r\n	scanf(\"%d.%d.%d.\", &day1, &month1, &year1);\r\n\r\n	printf(\"the second date (DD.MM.YYYY):\\n\");\r\n	scanf(\"%d.%d.%d.\", &day2, &month2, &year2);\r\n\r\n	for(i=year1; i<year2; i++)\r\n	{\r\n		if ((i%4==0 && i%100!=0)||i%400==0)\r\n	 		s += 366;\r\n		else \r\n			s += 365;	\r\n	}\r\n\r\n	for(i=1; i<=month1-1; i++)\r\n		s -= count(i, year1);\r\n\r\n	s=s-day1+1;\r\n		\r\n	for(i=1; i<=(month2-1); i++)\r\n		s += count(i, year2);\r\n	\r\n	s=s+day2;\r\n\r\n	printf(\"days: %d\\n\",s);\r\n}\r\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (635,'#include<stdio.h>\n#include<math.h>\nfloat f(float x )\n{\nreturn (x*x*x - 8);\n}\n\nint main()\n{\nfloat a,b,c;\n	printf(\"?????? ?????? ?????????\\n\");\n	scanf(\"%f\",&a);\n	printf(\"??????? ????? ?????????\\n\");\n	scanf(\"%f\",&b);\n\n	if (a > b)\n	{\n		float t = a;\n		a = b;\n		b = t;\n	}\n\n	if (f(a)*f(b)>0)\n	{\n		printf(\"?????? ? ????????? ???\");\n	}\n	else\n	{\n		\n		while(b - a > 0.001)\n\n		{		\n			c=(a+b)/2;\n\n			if(f(a)*f(c)<0)\n				b=c;\n			else\n				a=c;\n\n		}\n	printf(\"? ???? ????????? ????? ????? %f , %f\\n\",a,b);\n	return 0;\n	}\n}\n\n\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (636,'#include <stdio.h>\n\nint main ()	\n{\n	int y;\n	int d;\n	int m;\n	int d2;\n	int m2;\n	int y2;\n	int k=0;\n	\n	printf(\"??????? ??????? ????\\n\");\n	scanf (\"%d\",&d);\n\n	printf(\"??????? ?????\\n\");\n	scanf(\"%d\",&m);\n	\n	printf(\"??????? ???\\n\");\n	scanf(\"%d\",&y);\n\n	printf(\"\\n??????? ???? ?? ?????? ???????\\n\");\n	scanf(\"%d\",&d2);\n	\n	printf(\"??????? ?????\\n\");\n	scanf(\"%d\",&m2);\n	\n	printf(\"??????? ???\\n\");\n	scanf(\"%d\",&y2);\n\nwhile (d2!=d || m2!=m || y2!=y)\n	{\n//		printf(\"%d %d %d %d %d %d\\n\", d2, d, m2, m, y2, y);\n		d2=d2-1;\n		k++;\n//	printf(\"%d,\",k);\n		if (d2==0)\n		{\n			if (m2==2 || m2==4 || m2==6 || m2 == 8 || m2==9 || m2==11 || m2==1 )\n				{ \n					d2=31;\n					\n				}\n			if ( m2==5 || m2==7 || m2==10 || m2==12 )\n				{\n					d2=30;\n					\n				}\n		\n			if (m2==3)\n				{\n					d2=28;\n					\n				}\n		m2=m2-1;\n		if (m2==2 && ( (y2%400==0) || (y2%4==0 && y2%100!=0)))\n		{d2=29;}\n			if (m2==0)\n				{\n					m2=12;\n					y2=y2-1;\n				}\n		}\n	}\n	\n	printf (\"\\n koli4estvo dney=%d\\n\",k + 1);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (637,'#include<stdio.h>\r\n\r\nint count(int i, int y)\r\n{\r\n	if (i==1 || i==3 || i==5 || i==7 || i==8 || i==10 || i==12)\r\n		return 31;\r\n\r\n	if (i==2 && ((y%4==0 && y%100!=0) || y%400==0))\r\n		return 29;\r\n	else if (i==2) \r\n		return 28;\r\n\r\n	if (i==4 || i==6 || i==9 || i==11) \r\n		return 30;\r\n	return 0;\r\n}\r\n\r\nint main()\r\n{ \r\n	int day1, month1, year1, day2, month2, year2, i, s=0;\r\n\r\n	printf(\"the first date (DD.MM.YYYY):\\n\");\r\n	scanf(\"%d.%d.%d.\", &day1, &month1, &year1);\r\n\r\n	printf(\"the second date (DD.MM.YYYY):\\n\");\r\n	scanf(\"%d.%d.%d.\", &day2, &month2, &year2);\r\n\r\n	for(i=year1; i<year2; i++)\r\n	{\r\n		if ((i%4==0 && i%100!=0)||i%400==0)\r\n	 		s += 366;\r\n		else \r\n			s += 365;	\r\n	}\r\n\r\n	for(i=1; i<=month1-1; i++)\r\n		s -= count(i, year1);\r\n\r\n	s=s-day1+1;\r\n		\r\n	for(i=1; i<=(month2-1); i++)\r\n		s += count(i, year2);\r\n	\r\n	s=s+day2;\r\n\r\n	printf(\"days: %d\\n\",s);\r\n}\r\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (638,'#include <stdio.h>\n int main(){\n	int i;\n	int N; \n 	scanf(\"%d\", &N);\n	int f0=0;\n	int f1=1;\n	int x=1;\n        printf(\"x= %d\\n\",x);\n	//for(i=2;i<=N;x=f0+f1,f0=f1,f1=x,printf (\"x= %d\\n\",x),i++);\n	for(i=2;i<=N;i++)\n	{\n		x=f0+f1;\n		f0=f1;\n		f1=x;\n		printf (\"x= %d\\n\",x);\n	}\n	return 0;\n}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (639,'#include <stdio.h>\n#include <math.h>\n\nfloat f(float x)\n{\n	return (x*x*x - 8);\n}\n\nint main()\n{\n	float a, b, c;\n	printf(\"??????? ?????? ??????? ?????????\\n\");\n	scanf(\"%f\", &a);\n	printf(\"??????? ??????? ??????? ?????????\\n\");\n	scanf(\"%f\", &b);\n	if (a>b)\n		{\n			float t = a;\n			a = b;\n			b = t;\n		}\n	else\n	\n\n	if (f(a)*f(b)>0)\n		{\n	\n		printf(\"?? ?????? ????????? ????????? ?????? ?? ?????\\n\");\n		\n		}	\n	else\n	{\n		while (b-a>0.001)\n		{\n			c=(a+b)/2; \n\n			if(f(a)*f(c)<0)\n		\n				b=c;\n			else\n				a=c;\n		}\n	}\n	\n	printf(\"????? ????? ? ????????? %f, %f\\n\",a,b);\n\nreturn 0;\n}\n\n	\n	\n	\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (640,'#include \"stack.h\"\n#include <stdlib.h>\n#include <memory.h>\n\nstruct stackHead\n{\n	struct stackItem *head;\n	size_t stackItemSize;\n};\n\nstruct stackItem\n{\n	struct stackItem *prev;\n	void *data;\n};\n\nint isEmpty(struct stackHead *stack)\n{\n	return (stack->head == NULL) ? 1 : 0;\n}\n\nint push(struct stackHead *stack, void *data, size_t size)\n{	 \n	struct stackItem *newHead = NULL;\n	if (size != stack->stackItemSize)\n		return 0;\n	newHead = (struct stackItem*)malloc(sizeof(struct stackItem));\n	newHead->data = malloc(size);\n	memcpy(newHead->data, data, size);\n	newHead->prev = stack->head;\n	stack->head = newHead;\n	return 1;\n}\n\nvoid delItem(struct stackHead *stack)\n{\n	struct stackItem *temp = stack->head;\n	if(!isEmpty(stack))\n	{\n		free(stack->head->data);\n		stack->head = stack->head->prev;\n		free(temp);\n	}\n}\nvoid *getTopVal(struct stackHead *stack)\n{\n	if (stack == NULL || stack->head == NULL)\n		return NULL;\n	return stack->head->data;\n}\n\nstruct stackHead *createStack(size_t size)\n{\n	struct stackHead *newStack = (struct stackHead*)malloc(size);\n	newStack->stackItemSize = size;\n	newStack->head = NULL;\n	return newStack;\n}\n\nvoid releaseStack(struct stackHead *stack)\n{\n	struct stackItem *temp = NULL;\n	while(!isEmpty(stack))\n	{\n		temp = stack->head;\n		free(stack->head->data);\n		stack->head = stack->head->prev;\n		free(temp);\n	}\n	free(stack);\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (641,'#include \"stack.h\"\n#include <stdio.h>\n\n\nint main()\n{\n	char c;\n\n	struct stackHead *stack = createStack(sizeof(char));\n	\n	while((c = getchar()) != \'q\')\n	{\n		if(c != \'\\n\')\n		{\n			if (push(stack, (void*)&c, sizeof(c)) == 0)\n			{\n				printf(\"Error in push((void*)&c = %c, sizeof(c) = %d)\", c, sizeof(c));\n			}\n			printf(\"Pushed: [%c]\\n\", *(char*)getTopVal(stack));\n		}\n	}\n\n	while(!isEmpty(stack))\n	{\n		printf(\"Top returned [%c]\\n\", *(char*)getTopVal(stack));\n		delItem(stack);\n		printf(\"\\tElement succesfully removed!\\n\");\n	}\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (642,'#include <stdio.h>\n#include <fcntl.h>\n\nint main()\n{\n	char c;\n\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (643,'#include <stdlib.h>\n#include \"stack.h\"\n\nstruct item\n{\n	void * data;\n	struct item * next;\n};\n\nvoid push(void * data,stack *st)\n{\n	stack tmp=malloc(sizeof(stack));\n	tmp->data=data;\n	tmp->next=*st;\n	*st=tmp;\n}\n\nvoid pop(stack * st)\n{	if(*st)\n	{\n		stack tmp=*st;\n		*st=(*st)->next;	\n		free(tmp);	\n	}\n}\n\nint empty(stack st)\n{\n	if(st==NULL)\n		return 1;\n	return 0;\n}\n\nvoid * top(stack st)\n{\n	return(st->data);\n}\n\n\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (644,'#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n\nint main()\n{\n	/*\n	typedef struct item * stack;\n\n	void push(void* data,stack st);\n	int empty(stack st);\n	void* top(stack st);\n	void pop(stack *st);\n	*/				\n\n	stack st=NULL;\n	\n	int a;\n	int *c;\n	char cr;\n	char * cr1;\n	\n	printf(\"empty - %d\\n\",empty(st));\n	/*\n	scanf(\"%d\",&a);\n	push(&a,&st);\n	c=(int *)top(st);\n	printf(\"before pop empty - %d\\n\",empty(st));\n	pop(&st);\n	printf(\"after pop empty - %d\\n\",empty(st));\n	printf(\"%d\\n\",*c);\n	*/\n	scanf(\"%c\",&cr);\n	push(&cr,&st);\n	cr1=(char *)top(st);\n	printf(\"before pop empty - %d\\n\",empty(st));\n	pop(&st);\n	printf(\"after pop empty - %d\\n\",empty(st));\n	printf(\"%c\\n\",*cr1);\n\n	return 0;\n}\n','ÐÑ€Ñ‚Ñ‘Ð¼','Artyom','m');
INSERT INTO `bias` VALUES (645,'#include <stdio.h>\n\n\n\nint main ()\n{\n// ????? ??????\nint a[100][100];\nint b[100][100];\nint c[100][100];\n\nint r;\n\nprintf (\"??????? ?????? ????????????? ?????? ?=\");\nscanf (\"%d\",&r);\n\nint i,j,k;\nint s=0;\n\nprintf (\"??????? ???????? ??????? A\\n\");\n\n\n	for (i=1;i<r+1;i++)\n		{\n			for (j=1;j<r+1;j++)\n				{\n					printf (\"??????? ??????? ?[%d,%d]=\",i,j);\n					scanf (\"%d\",&a[i][j]);\n				}\n		}\n\nprintf (\"??????? ???????? ??????? B\\n\");\n\n	for (i=1;i<r+1;i++)\n		{\n			for (j=1;j<r+1;j++)\n				{\n					printf (\"??????? ??????? b[%d,%d]=\",i,j);\n					scanf (\"%d\",&b[i][j]);\n				}	\n		}\n// ?????? ?????? \n	i=1;\n	j=1;\n	k=1;\n\n	while (k!=r+1)\n{\n	while (i!=r+1)\n	{\n		for (j=1;j<r+1;j++)\n			{ s=s+a[i][j]*b[j][k];}\n		printf(\"s: %d\\n\", s);\n		c[i][k]=s;\n		s=0;\n		i++;\n	}\n	k++;\n	i=1;\n}\n\n// ????? ?????????? ???????\nprintf (\"\\n\"); \nfor (j=1;j<r+1;j++)\n{	for (i=1;i<r+1;i++)\n	{\n		printf (\"%d \",c[j][i]);\n	}\n	printf (\"\\n\");\n}\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (646,'#include <stdio.h>\n\n\nint isprime (int a)\n{ 	\n	int k;\n	int i=2;\n	k=a/2;\n	int t;\n	int r;\n\n	\n	if (a!=2 && a!=3 && a!=1 && a!=5)\n	{\n	 while (i!=k || r!=1)\n		{\n		t=k%i;				\n			if (t==0)\n			{\n				r=1;\n				return 0;\n			}\n			else {return 1;}\n			i++;\n		}\n\n	}\n	else {return 10;}\n}\n\n\nint main ()\n{\n	int l=2;\n	int a[100];\n	int p;\n	int s;\n	\n	printf (\"??????? ?????????? ??????=\");\n	scanf (\"%d\",&s);\n	printf (\"\\n??????? ????? ? ??????\\n\");\n	for (p=0;p<s;p++)\n	{\n		printf (\"??????? ????? ??? ??????? %d=\",p );\n		scanf (\"%d\",&a[p]);\n	}\n	\n	for (p=0;p<s;p++)\n	{\n		\n		if (l!=0)\n		{\n		l=isprime (a[p]);\n	\n		}\n	}\n	\n	if (l==0)\n	{\n		printf (\"? ???? ?????? ???? ????????? ?????\\n\");\n	}\n	if (l!=0)\n	{	printf (\"????????? ????? ???\\n\");}\n\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (647,'#include<stdio.h>\n\nint is_prime(int a)\n\n{int i;\n	printf(\"is_prime(%d) = \", a);\n\n	for(i=2; i*i<=a; i++)\n			\n	if(a%i==0)\n	{\n		printf(\"0\\n\");\n						\n		return 0;\n	}\n\n	printf(\"1\\n\");\n							\n	return 1;\n\n}			\n\nint main()\n\n{	\n	int A[100];\n	int N;\n	int i;\n\n	printf(\"??????? ?????? ???????: \");\n	scanf(\"%d\", &N);\n\n	for (i = 0; i < N; i++)\n	{\n		scanf(\"%d\", &A[i]);\n	}\n	\n	for(i=0; i<N; i++) \n		if (!is_prime(A[i]))\n			break;\n\n	if (i < N) printf(\"?? ??? ????? ???????\\n\");\n\n	else        printf(\"??? ????? ???????\\n\");\n\n	return 0;\n\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (648,'#include <stdio.h>\nint main()\n{\n    int a;\n    int A[3][3];\n    int i, j;\n    int k;\n\n    printf(\"matrix A: \\n\");\n\n    for (i = 0; i < 3; i++)\n	for (j = 0; j < 3; j++)\n	    scanf(\"%d\", &A[i][j]);\n\n    printf(\"matrix B: \\n\");\n\n    int B[3][3];\n    for (i = 0; i < 3; i++)\n	for (j = 0; j < 3; j++)\n	    scanf(\"%d\", &B[i][j]);\n\n    int C[3][3] = { { 0 } };\n    for (i = 0; i < 3; i++)\n	for (j = 0; j < 3; j++)\n	    for (k = 0; k < 3; k++)\n\n		C[i][j] += A[i][k] * B[k][j];\n\n    printf(\"matrix C: \\n\");\n\n    for (i = 0; i < 3; i++) {\n	for (j = 0; j < 3; j++)\n	    printf(\"%3d \", C[i][j]);\n	printf(\"\\n\");\n    }\n}\n\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (649,'#include <stdio.h>\n\nint isprime(int a)\n{    int i;\n    for (i = 2; (i * i) <= a; i++)\n     {\n	if (a % i == 0)\n	    return 0;\n	else\n	    return 1;\n    }\n}\n\n\n\nint main()\n{\n    int A[100];\n    int k = 1;\n    int i;\n    int N;\n\n    printf(\"???????????\");\n    scanf(\"%d\", &N);\n    for (i = 0; i < N; i++)\n     {\n	scanf(\"%d\", &A[i]);\n    }\n    for (i = 0; i < N; i++)\n    {\n	if (k != 0) \n	{\n	    k = isprime(A[i]);\n	}\n    }\n    if (k == 0)\n        printf(\"?? ??? ???????\\n\");\n    else\n        printf(\"??? ???????? ???????\\n\");\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (650,'#include<stdio.h>\n\nint is_leap(int y)\n{\n	return (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0));\n}\n\nint kolvo_dnej(int a1, int a2, int a3, int b1, int b2, int b3)\n{\n	int s1=0, s2=0, s3, s4=0, S1, S2, g=0, i;\n	if ( a2==1 || a2==3 || a2==5 || a2==7 || a2==8 || a2==10 || a2==12 )\n	{\n		for (i=a1; i<=31; i++)\n		{ s1 = s1 + 1; }\n	}\n	if ( a2==4 || a2==6 || a2==9 || a2==11 )\n	{\n		for (i=a1; i<=30; i++)\n		{ s1 = s1 + 1; }\n	}\n	if (a2==2)\n	{\n	  	if ( is_leap(a3)==0 )\n		{  for (i=a1; i<=28; i++)\n		    { s1 = s1 + 1; } } \n		else { for (i=a1; i<=29; i++) { s1 = s1 + 1; }     } \n		\n	}\n	if ( (a2+1)<=12 )\n	{\n		for (i=(a2+1); i<=12; i++)\n		{\n			if ( i==1 || i==3 || i==5 || i==7 || i==8 || i==10 || i==12 )\n			{\n				s2 = s2 + 31;\n			}\n			if ( i==4 || i==6 || i==9 || i==11 )\n			{\n				s2 = s2 + 30;\n			}\n			if ( i==2 ) { s2 = s2 + 28; }\n		}\n	}\n	S1 = s1 + s2;\n	s3 = b1;\n	if ( b2>1 )\n	{\n		for (i=(b2-1); i>=1; i--)\n		{\n			if ( i==1 || i==3 || i==5 || i==7 || i==8 || i==10 || i==12 )\n			{\n				s4 = s4 + 31;\n			}\n			if ( i==4 || i==6 || i==9 || i==11 )\n			{\n				s4 = s4 + 30;\n			}\n			if ( i==2 ) { s4 = s4 + 28; }\n		}\n	}\n	S2 = S1 + s3 + s4;     \n	for (i=(a3+1); i<b3; i++)\n	{\n		if (is_leap(i)==0)\n		{ g=g+365; }\n		if (is_leap(i)==1)\n		{ g=g+366; }\n	}\n	S2 = S2 + g;\n	return (S2);\n\n}\n\nint main()\n{\n	int a1, a2, a3, b1, b2, b3;\n	printf(\"??????? ??? ???? ? ??????? DD/MM/YY\\n\");\n	scanf(\"%d/%d/%d%d/%d/%d\", &a1, &a2, &a3, &b1, &b2, &b3);\n	printf(\"?????? ????: %d/%d/%d; ?????? ????: %d/%d/%d\\n\", a1, a2, a3, b1, b2, b3);\n	printf(\"?????????? ???? ????? 2-?? ??????: %d\\n\", kolvo_dnej(a1, a2, a3, b1, b2, b3));\n	return 0;\n}\n\n\n\n\n\n\n\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (651,'#include <stdio.h>\n\nint main()\n{\n	int A[100][100], B[100][100], C[100][100];\n	int N;\n	int i, j, k;\n\n	FILE *f = fopen(\"input.txt\", \"r\");\n\n	fscanf(f, \"%d\", &N);\n\n	for(i=0;i<N;i++) \n		for(j=0;j<N;j++)\n			fscanf(f,\"%d\",&A[i][j]);\n\n	for(i=0;i<N;i++)\n		for(j=0;j<N;j++)\n			fscanf(f,\"%d\",&B[i][j]);\n\n	fclose(f);\n\n\n\n\n\n\nfor(i=0;i<N;i++)\n	for(j=0;j<N;j++)\n		{\n			C[i][j]	= 0;\n			for(k=1;k<N;k++)\n			{\n				C[i][j] += A[i][k]*B[k][j];\n			}\n		}\n\n\n	for(i=0;i<N;i++)\n		{for(j=0;j<N;j++)\n			{printf(\"%3d\",C[i][j]);\n}printf(\"\\n\");\n\n}\n\n\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (652,'#include <stdio.h>\nint main()\n{ int i, j, k, s, N;\n  int A[100][100];\n  int B[100][100];\n  int C[100][100];\n  printf(\"??????? ??????????? ??????:\");\n  scanf(\"%d\", &N);\n   for (i=0; i<N; i++)\n   {\n	    for (j=0; j<N; j++)\n	   {\n		    printf(\"??????? A[%d][%d]=\", i, j);\n     		    scanf(\"%d\", &A[i][j]);\n	   }\n   }\n   for (i=0; i<N; i++)\n   {\n	   for (j=0; j<N; j++)\n	   {\n		   printf(\"??????? B[%d][%d]=\", i, j);\n		   scanf(\"%d\", &B[i][j]);\n	   }\n   }\n   for (i=0; i<N; i++)\n   { for (j=0; j<N; j++)\n	   {C[i][j]=0;\n	    s=0;\n	   for(k=0; k<N; k++)	   \n           { s+=A[i][k]*B[k][j];} \n	    \n	     C[i][j]=s;\n	    }\n   }\n\nprintf(\"\\n\");\n\n  for (i=0; i<N; i++)\n  {\n	  for (j=0; j<N; j++) \n	  {\n		printf(\"%3d \", C[i][j]);\n  	  }\n	  printf(\"\\n\");\n  }\n	\n\n\n\n return 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (653,'#include <stdio.h>\n#define N 5\n\nint main ()\n{\n	int A[N]={1, 3, 5, 7, 9};\n	int k;\n	int r=N-1;\n	int l=0;\n\n	scanf(\"%d\", &k);\n		\n	while (l<=r)\n	{ \n		\n	int m=(r+l)/2;\n	if( k == A[m] )\n	  {\n		  printf(\"%d\\n\", m);\n		  return 0;\n	  }\n	 \n	  if( k > A[m] )\n		l=m+1;\n\n	  if( k < A[m] )	\n		r=m-1;   	\n		\n	}\n\n	printf(\"-\\n\");\n	return 0;\n}\n		\n				\n\n\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (654,'#include<stdio.h>\n\nint is_prime( int x )\n{\n	int i;\n	for ( i=2; i*i<=x; i++)\n		if ( x%i == 0) return 0; return 1;\n}\n\nint main()\n{\n	int N, i, M[100], a, p=0, s=0;\n	printf(\"??????? ??????????? ???????. N=\");\n	scanf(\"%d\",&N);\n	printf(\"??????? ??? ??????: \");\n	for (i=0; i<=(N-1); i++)\n	{\n		scanf(\"%d\",&a);\n		M[i]=a;	\n	}\n	for (i=0; i<=(N-1); i++)\n	{\n		if (is_prime(M[i])==1) { p=p+1; }\n		if (is_prime(M[i])==0) { s=s+1; }\n	}\n	if (N==p) { printf(\"??? ????? ???????\\n\"); } else { printf(\"???-?? ????????? ?????: %d\\n\", s); }\n	return 0;\n}\n\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (655,'#include <stdio.h>\nint main()\n{	int a;\n	int b;\n	int i;\n	int N;\nscanf(\"%d\", &a); // 100\nscanf(\"%d\", &b); // 40\n	    // i=20     // N=40, b=20, a=40, i=0\n	i=a%b;\n	while (i!=0)\n	{\n		N=b;\n		b=a%b;\n		a=N;\n		i=a%b;\n	}\n		\n	printf (\"%d\\n\",b);\nreturn 0;\n}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (656,'#include<string.h>\n#include<stdio.h>\nint main()\n{\n    FILE *f1, *f2;\n    int i, n, k;\n    int a = 0;\n    char s[1000];\n\n    f1 = fopen(\"input2.txt\", \"r\");\n    f2 = fopen(\"output2.txt\", \"w\");\n\n    fgets(s, 1000, f1);\n\n    for (i = 0; s[i]; i++) \n    {\n	if (s[i] == \' \')\n	{\n	    for (k = i; s[k]; k++)\n		s[k] = s[k + 1];\n	    i--;\n	}\n    }\n    fprintf(f2, \">>%s<<\", s);\n\n    n = strlen(s) - 1;\n    printf(\"%d\\n\", n);\n\n    for (i = 0; i < n; i++) \n    {\n	if (s[i] != s[n - 1 - i])\n	{\n		printf(\"?? ??????? \'%c\' ? \'%c\'\\n\", s[i], s[n - 1 - i]);\n		a++;\n	}\n    }\n    printf(\"%d\\n\", a);\n\n    if (a == 0)\n	printf(\"????????? !\\n\");\n    else\n	printf(\"?? ????????? !\\n\");\n\n\n    fclose(f1);\n    fclose(f2);\n\n    return 0;\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (657,'#include <stdio.h>\nint bsearch (int *A, int a, int k, int r)\n{\n	while (k <= r)\n	{\n		int m=(k+r)/2;\n		if (A[m]==a)\n		{\n			printf (\"????? %d ???? ? ???????\\n\", a );\n			return m;\n		}\n		else if (A[m]>a)\n		{ \n			r=m-1;\n		}\n		else \n		{\n			k=m+1;\n		}\n	}\n	return -1;\n}\n\nint main()\n{\n  int x, a;\n  int A[100]={1, 3, 5, 7, 9};\n  printf (\"??????? ????? a=\");\n  scanf (\"%d\", &a);\n  x = bsearch(A, a, 0, 4);\n  printf(\"bsearch ??????? %d\\n\", x);\n  return 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (658,'#include<stdio.h>\n\nint bsearch(int *A,int l,int r,int k)\n\n{\n \n   while(r<=k)\n   {  \n   int m=(r+k)/2;\n\n        if(A[m]==l)\n	{\n		printf(\"yes\\n\");\n		return m;\n	}\n\n	   else\n\n              if(A[m]>l)\n\n\n	         k=m-1;\n\n                 else\n	      r=m+1;\n    }\n	\n    return -1;\n\n}\n\n	\n	\n	\nint main()\n\n\n{\n	 int A[10]={1,2,2,4,5,6,7,8,8,9};\n\n\n\n\n	 int a;\n\n	 scanf(\"%d\",&a);\n\n	printf(\"%d\\n\", bsearch(A,a,0,9));\n	\n	return 0;\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	}	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (659,'#include<stdio.h>\n\nint main()\n{\n    int A[10][10], B[10][10], C[10][10];\n    int n, k, a, q, w, c, P=0;\n    printf(\"??????? ??????????? ???????\\n\");\n    scanf(\"%d\", &n);\n    printf(\"??????? ??????? ?\\n\");\n    for (q = 1; q <= n; q++)\n    {\n	for (w = 1; w <= n; w++)\n	{\n	    	scanf(\"%d\", &a);\n	    	A[q][w] = a;\n	}	\n    }\n    printf(\"??????? ??????? B\\n\");\n    for (q = 1; q <= n; q++)\n    {\n	for (w = 1; w <= n; w++)\n	{\n	    	scanf(\"%d\", &a);\n		B[q][w] = a;\n    	}\n    }\n	\n\n	for (q=1; q<=n; q++)\n		for (w=1; w<=n; w++)\n		{\n			C[q][w] = 0;\n			for (k=1; k<=n; k++)\n				C[q][w]+=A[q][k]*B[k][w];\n		}\n	printf(\"?????????? ???????:\\n\");\n	for (q=1; q<=n; q++)\n	{\n		for (w=1; w<=n; w++)\n		{\n			c=C[q][w];\n			printf(\"%d \", c);\n		}\n		printf(\"\\n\");\n	}\n	return 0;\n}\n\n\n\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (660,'#include<stdio.h>\n\nint visokosni(int y)\n	{\n		if(((y%4 == 0)&& (y%100)) || (y%400 == 0))\n			return 1;\n			return 0;\n	}\n\nint years (int y)\n	{\n		int s=0,i;\n		for (i = 1; i < y; i++)\n			if( visokosni(i)) s=s+366;\n			else s=s+365;\n			return s; \n	}\nint month(int y, int m)\n	{\n		int i,s=0, A[12]={31,28,31,30,31,30,31,31,30,31,30,31};\n		for( i = 0; i < m-1 && i < 12; i++)\n		{\n			s=s+A[i];\n		if (visokosni(y) && m > 1)\n			 s++;\n		}\n		return s;\n	}\nint days(int d)\n	{\n		return d;\n	}\nint razn (int d1, int m1, int y1, int y2, int m2, int d2  )\n	{\n		int s;\n		s=years(y1)+month(y1,m1)+days(d1)-years(y2)-month(y2,m2)-days(d2);\n		return s;\n	}\nint main()\n{\n	int s=0,i,d1,m1,y1,y2,m2,d2,summ;\n	printf(\"??????? ?????? ???? ???? ????? ???\");\n	scanf(\"%d%d%d\",&d1,&m1,&y1);\n	printf(\"??????? ?????? ???? ???? ????? ???\");\n	scanf(\"%d%d%d\",&d2,&m2,&y2);\n	summ=-razn(d1,m1,y1,y2,m2,d2);\n	printf(\"%d\\n\",summ+1);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (661,'#include <stdio.h>\n#include <string.h>\nvoid mygets (char *s)\n{int i;\n for (i=0; i<100; i++)\n { \n	s[i] = getchar();\n	if (s[i] == \'\\n\')\n	{\n		s[i] = 0;\n		return;\n	}\n }\n}\n\nint mystrlen (char *s)\n{ int i;\nfor (i=0; s[i]; i++)\n	;\n     return i;\n}\n\nint main()\n{\n	char s[100];\n	mygets(s);\n	printf(\"???????: %s\\n\", s);\nint k=mystrlen(s);\nint i=0;\nint j=k-1;	\nwhile (i<=j)\n{\n	while (s[i] == \' \')\n	{	i++; }\n\n        while (s[j] == \' \')\n	{	j--; }\n\n	if (s[i]==s[j])\n	{i++;\n	j--;\n	}\n	else \n	{ printf (\"?? ?????????\\n\");\n	  return 0;\n	}\n}\nprintf(\"?????????\\n\");\nreturn 0;\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (662,'#include <stdio.h>\nfloat f(float x)\n{\n    return (x * x - 1);\n}\n\nint main()\n{\n    int i;\n    float a = 0;\n    float b = 2;\n    float x;\n    do {\n	if (f((a + b) / 2) > 0) {\n	    b = (a + b) / 2;\n	} else {\n	    a = (a + b) / 2;\n	}\n    }\n    while (! ((fabs(f(a)) < 0.00001) || (fabs(f(b)) < 0.00001)));\n    if (f(a) == 0) {\n	x = a;\n    } else {\n	x = b;\n    }\n    printf(\"%f\\n\", x);\n    return x;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (663,'#include \"stack.h\"\n#include \"vars.h\"\n#include \"doing.h\"\n#include <stdio.h>\n#include <stdlib.h>\nint inf(char c)\n{\n	if (c==\'/\' || c==\'*\') return 2;\n	if (c==\'+\' || c==\'-\') return 1;\n	if (c==\'(\') return 0;\n	if (c>=\'0\' && c<=\'9\') return -1;\n	if ((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\'))  return -2;\n	return -3;\n}\nchar get_char(struct item **st)\n{\n	return *(char*)top(st);\n}\nint get_int(struct item **st)\n{\n	return *(int*)top(st);\n}\nvoid exec(struct item **st,void *a,int type) //computing RPN\n{\n	int t1,t2,*ans;\n	char c;\n	if (type==2)	// number\n		push(st,a);\n	if (type==1)		// operation\n	{\n		t1=get_int(st); //get from stack2\n		pop(st);\n		t2=get_int(st);\n		pop(st);\n		ans=malloc(sizeof(int));\n		c=*(char*)a;\n		free(a);\n		if (c==\'*\') (*ans)=t2*t1;\n		if (c==\'/\') (*ans)=t2/t1;\n		if (c==\'+\') (*ans)=t2+t1;\n		if (c==\'-\') (*ans)=t2-t1;\n		push(st,ans);\n	}	\n}\nvoid compute(char *s)\n{\n	int i=0,sign=1,is_unary=1; //un=1 next -/+ is unary; un=0 next -/+ is not unary\n	struct item *st1=NULL, *st2=NULL;\n	char *changevar=NULL;\n	while (s[i]!=0)\n	{\n		if (inf(s[i])==-2) //symbol\n		{\n			int j=0;\n			char *name=malloc(sizeof(char));\n			while (s[i]==\'_\' || inf(s[i])==-1 || inf(s[i])==-2) // ( _ digit symbol ) \n			{\n				name[j++]=s[i++];\n				if (j%100==1)\n					name=realloc(name,j+100);\n			}\n			is_unary=0;   // unary +/- after var\n			name[j]=0;\n			if (s[i]==\'=\')			//Type of string is assignment\n			{\n					changevar=name; \n					is_unary=1;\n					i++;\n			}\n			else \n			{\n				int *ltmp=malloc(sizeof(int));\n				*ltmp=get_value(name);\n				is_unary=0;\n				free(name);\n				exec(&st2,ltmp,2);\n			}\n		}\n		//--------------------------------------------------------------\n		if (inf(s[i])==-1)    //digit\n		{	\n			int *ltmp=calloc(sizeof(int),1);\n			while (inf(s[i])==-1)\n				*ltmp=(*ltmp)*10+s[i++]-\'0\';\n				*ltmp*=sign;\n			is_unary=0;\n			sign=1;\n			exec(&st2,ltmp,2);		//sending to stack2\n		}\n		//--------------------------------------------------------------\n		if (s[i]==\')\' || s[i]==\'(\' || inf(s[i])==1 || inf(s[i])==2)	//current symbol - (           + - * / ( )         )\n		{\n			if (s[i]==\'(\') \n			{		\n				char *tmp=malloc(sizeof(char));\n				*tmp=s[i++];\n				push(&st1,tmp);\n				is_unary=1;\n			}\n			if (s[i]==\')\')\n			{\n				while(get_char(&st1)!=\'(\')\n				{\n					char *tmp=malloc(sizeof(char));\n					*tmp=get_char(&st1);\n					exec(&st2,tmp,1);\n					pop(&st1);\n				}\n				pop(&st1);\n				is_unary=0;\n				i++;\n			}\n			//-----------------------------------------------------\n			if (inf(s[i])==1 || inf(s[i])==2) // (          * / + -        )\n			{\n				if (inf(s[i])==1 && is_unary==1)  // unary +/-\n				{\n						sign=(s[i++]==\'+\')?1:-1;\n						is_unary=0;\n						continue;\n				}	\n				else\n				{\n					char *tmp=malloc(sizeof(char));\n					*tmp=s[i];\n					while (empty(&st1)==0 && inf(get_char(&st1))>=inf(s[i]))\n					{\n						char *tmp=malloc(sizeof(char));\n						*tmp=get_char(&st1);\n						exec(&st2,tmp,1);\n						pop(&st1);\n					}\n					push(&st1,tmp);\n					is_unary=1;\n					i++;\n				}\n			}\n		}\n	}\n	while (empty(&st1)==0)\n	{\n		char *tmp=malloc(sizeof(char));\n		*tmp=get_char(&st1);\n		pop(&st1);\n		exec(&st2,tmp,1);\n	}\n	if (changevar!=NULL)\n	{\n		set_value(changevar,get_int(&st2));\n		pop(&st2);\n	}\n	else\n	{\n		printf(\"%d\",(get_int(&st2)));\n		pop(&st2);\n		printf(\"\\n\");\n	}\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (664,'#include \"doing.h\"\n#include \"vars.h\"\n#include \"vars.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main()\n{\n	char *s,c=0;\n	//clock_t time=clock();\n	//freopen(\"input.txt\",\"r\",stdin);\n	//freopen(\"output.txt\",\"w\",stdout);\n	while(c!=EOF)\n	{\n		int i=0;\n		s=malloc(sizeof(char));\n		c=getchar();\n		while (c!=\'\\n\' && c!=EOF)\n		{\n			s[i++]=c;\n			c=getchar();\n			if (i%100==1)\n				s=realloc(s,i+100);\n		}\n		s[i]=0;\n		if (s[0]!=0)\n			compute(s);\n		free(s);\n	}\n	cleanup();\n	//time=clock()-time;\n	//printf(\"TIME OF EXECUTION: %f\\n\", (double)time/CLOCKS_PER_SEC);\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (665,'#include <stdlib.h>\n#include \"stack.h\"\nvoid push(struct item **st,void* data) //add data to stack\n{\n	struct item *t;\n	t=malloc(sizeof(struct item));\n	t->next=(*st);\n	t->data=data;\n	(*st)=t;\n	return;\n}\nvoid* top(struct item **st) //return top of stack\n{\n	return (*st)->data;\n}\nvoid pop(struct item **st) //delete top item of stack\n{\n	struct item *temp=(*st)->next;\n	free((*st)->data);\n	free(*st);\n	(*st)=temp;\n}\nint empty(struct item **st) //is stack empty; 1-yes 0-no\n{\n	if ((*st)==NULL)\n		return 1;\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (666,'#include <string.h>\n#include <stdlib.h>\n#define N 19\nstruct hash\n{\n	struct hash *next;\n	char *name;\n	int data;\n};\nstruct hash *T[N];\nint hcode(char*s)\n{\n	unsigned int i=0,sum=0;\n	while(s[i]!=0)\n		sum=(sum*39+s[i++])%N;\n	return sum;\n}\nvoid set_value(char *name, int value)\n{\n	struct hash *tmp, *prevtmp;\n	int hashcode=hcode(name);\n	if (T[hashcode]==NULL)\n	{\n		T[hashcode]=malloc(sizeof(struct hash));\n		T[hashcode]->name=name;\n		T[hashcode]->data=value;\n		T[hashcode]->next=NULL;\n	}\n	else\n	{\n		prevtmp=NULL;\n		tmp=T[hashcode];\n		while (tmp!=NULL)\n		{\n			if (strcmp(name,tmp->name)==0)\n			{\n				tmp->data=value;\n				free(name);\n				return;\n			}\n			prevtmp=tmp;\n			tmp=tmp->next;\n		}\n		tmp=malloc(sizeof(struct hash));\n		tmp->name=name;\n		tmp->data=value;\n		tmp->next=NULL;\n		prevtmp->next=tmp;\n	}\n}\nint get_value(char *name)\n{\n	struct hash* tmp=T[hcode(name)];\n	while (tmp!=NULL)\n	{\n		if (strcmp(tmp->name,name)==0)\n			return tmp->data;\n		tmp=tmp->next;\n	}\n	return 0;\n}\nvoid cleanup(void)\n{\n	struct hash *tmp,*t;\n	int i;\n	for (i=0;i<N;i++)\n	{\n		tmp=T[i];\n		while (tmp!=NULL)\n		{\n			t=tmp;\n			tmp=tmp->next;\n			free(t->name);\n			free(t);\n		}\n	}\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (667,'#include \"long.h\"\n#include \"stack.h\"\n#include \"vars.h\"\n#include \"doing.h\"\n#include \"rLONG.h\"\n#include <stdio.h>\n#include <stdlib.h>\nint inf(char c)\n{\n	if (c==\'/\' || c==\'*\') return 2;\n	if (c==\'+\' || c==\'-\') return 1;\n	if (c==\'(\') return 0;\n	if (c>=\'0\' && c<=\'9\') return -1;\n	if ((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\'))  return -2;\n	return -3;\n}\nchar get_char(struct item **st)\n{\n	return *(char*)top(st);\n}\nstruct long_int get_long_int(struct item **st)\n{\n	return *(struct long_int*)top(st);\n}\nvoid exec(struct item **st,void *a,int type) //computing RPN\n{\n	struct long_int t1,t2,*ans;\n	char c;\n	if (type==2)	// number\n		push(st,a);\n	if (type==1)		// operation\n	{\n		t1=get_long_int(st); //get from stack2\n		pop(st);\n		t2=get_long_int(st);\n		pop(st);\n		ans=malloc(sizeof(struct long_int));\n		c=*(char*)a;\n		free(a);\n		if (c==\'*\') (*ans)=mul(t2,t1);\n		if (c==\'/\') (*ans)=Div(t2,t1);\n		if (c==\'+\') (*ans)=add(t2,t1);\n		if (c==\'-\') (*ans)=sub(t2,t1);\n		free_int(t1); \n		free_int(t2);\n		push(st,ans);\n	}	\n}\nvoid compute(char *s)\n{\n	int i=0,sign=1,is_unary=1; //un=1 next -/+ is unary; un=0 next -/+ is not unary\n	struct item *st1=NULL, *st2=NULL;\n	char *changevar=NULL;\n	while (s[i]!=0)\n	{\n		if (inf(s[i])==-2) //symbol\n		{\n			int j=0;\n			char *name=malloc(sizeof(char));\n			while (s[i]==\'_\' || inf(s[i])==-1 || inf(s[i])==-2) // ( _ digit symbol ) \n			{\n				name[j++]=s[i++];\n				if (j%100==1)\n					name=realloc(name,j+100);\n			}\n			is_unary=0;   // unary +/- after var\n			name[j]=0;\n			if (s[i]==\'=\')			//Type of string is assignment\n			{\n					changevar=name; \n					is_unary=1;\n					i++;\n			}\n			else \n			{\n				struct long_int *ltmp=malloc(sizeof(struct long_int));\n				*ltmp=get_value(name);\n				is_unary=0;\n				free(name);\n				exec(&st2,ltmp,2);\n			}\n		}\n		//--------------------------------------------------------------\n		if (inf(s[i])==-1)    //digit\n		{	\n			struct long_int *ltmp=malloc(sizeof(struct long_int));\n			char *t;\n			int j=0;\n			t=malloc(sizeof(char));	// count of digits\n			while (inf(s[i])==-1)\n			{\n				t[j++]=s[i++];\n				if (j%100==1)\n					t=realloc(t,j+100);\n			}\n			t[j]=0;\n			is_unary=0;\n			*ltmp=Convert(sign,t);\n			free(t);\n			sign=1;\n			exec(&st2,ltmp,2);		//sending to stack2\n		}\n		//--------------------------------------------------------------\n		if (s[i]==\')\' || s[i]==\'(\' || inf(s[i])==1 || inf(s[i])==2)	//current symbol - (           + - * / ( )         )\n		{\n			if (s[i]==\'(\') \n			{		\n				char *tmp=malloc(sizeof(char));\n				*tmp=s[i];\n				push(&st1,tmp);\n				is_unary=1;\n				i++;\n			}\n			if (s[i]==\')\')\n			{\n				while(get_char(&st1)!=\'(\')\n				{\n					char *tmp=malloc(sizeof(char));\n					*tmp=get_char(&st1);\n					exec(&st2,tmp,1);\n					pop(&st1);\n				}\n				pop(&st1);\n				is_unary=0;\n				i++;\n			}\n			//-----------------------------------------------------\n			if (inf(s[i])==1 || inf(s[i])==2) // (          * / + -        )\n			{\n				if (inf(s[i])==1 && is_unary==1)  // unary +/-\n				{\n						sign=(s[i++]==\'+\')?1:-1;\n						is_unary=0;\n						continue;\n				}	\n				else\n				{\n					char *tmp=malloc(sizeof(char));\n					*tmp=s[i];\n					while (empty(&st1)==0 && inf(get_char(&st1))>=inf(s[i]))\n					{\n						char *tmp=malloc(sizeof(char));\n						*tmp=get_char(&st1);\n						exec(&st2,tmp,1);\n						pop(&st1);\n					}\n					push(&st1,tmp);\n					is_unary=1;\n					i++;\n				}\n			}\n		}\n	}\n	while (empty(&st1)==0)\n	{\n		char *tmp=malloc(sizeof(char));\n		*tmp=get_char(&st1);\n		pop(&st1);\n		exec(&st2,tmp,1);\n	}\n	if (changevar!=NULL)\n	{\n		set_value(changevar,get_long_int(&st2));\n		pop(&st2);\n	}\n	else\n	{\n		print(get_long_int(&st2));\n		free_int(get_long_int(&st2));\n		pop(&st2);\n		printf(\"\\n\");\n	}\n}\nvoid do_cleanup()\n{\n	cleanup();\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (668,'#include \"long.h\"\n#include \"rLONG.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nstruct long_int zero()\n{\n	struct long_int a;\n	a.digits=NULL;\n	a.length=0;\n	a.sign=1;\n	return a;\n}\nint cmp(struct long_int a, struct long_int b) // < -1  = 0   > 1\n{\n	if (a.sign*b.sign==1)\n	{\n		if (a.length!=b.length)\n			if (a.length>b.length)\n				return a.sign;\n			else \n				return -a.sign;\n		else\n		{\n			int i;\n			for (i=a.length-1;i>=0;i--) \n			{\n				if (a.digits[i]!=b.digits[i])\n				{\n					if (a.digits[i]>b.digits[i])\n						return a.sign;\n					else\n						return -a.sign;												\n				}\n			}\n			return 0;\n		}\n	}\n	else\n		return a.sign;\n}\nstruct long_int short_mul(struct long_int a, int b)  //only for positive numbers\n{\n	long long *w,t;\n	struct long_int c;\n	int i=0;\n	if (b==0)\n		return zero();\n	c.digits=malloc((a.length+1)*sizeof(int));\n	c.sign=1;\n	w=calloc((a.length+1),sizeof(long long));\n	for (i=0;i<a.length;i++)\n		w[i]=(long long)a.digits[i]*b;	\n	for (i=0;i<a.length;i++)\n	{\n		t=(long long)w[i];\n		c.digits[i]=t%BIGDIGIT;\n		w[i+1]+=t/BIGDIGIT;\n	}\n	c.digits[i]=w[i];\n	free(w);\n	c.length=a.length+1;\n	if (c.digits[a.length]==0)\n		c.length--;\n	if (c.length==0)\n	{\n		free(c.digits);\n		return zero();\n	}\n	return c;\n}\nint binary(struct long_int a, struct long_int b) // a<=k*b; k-max\n{\n	int start=0,final=BIGDIGIT-1,m;\n	struct long_int c;\n	while(1)\n	{\n		m=(start+final)/2;\n		c=short_mul(b,m);\n		if (cmp(c,a)==-1)\n		{\n			struct long_int tmp=short_mul(b,m+1);\n			if (cmp(tmp,a)==1)\n			{\n				free_int(tmp);\n				free_int(c);\n				return m;\n			}\n			free_int(tmp);\n			start=m+1;\n		}\n		else if (cmp(c,a)==1)\n		{\n			final=m-1;\n		}\n		else if (cmp(c,a)==0)\n		{\n			free_int(c);\n			return m;\n		}\n		free_int(c);\n	}\n}\nstruct long_int rshift(struct long_int a,int b) //shift b digits to right\n{\n	struct long_int c;\n	int i=0,j=0;\n	c.sign=1;\n	c.digits=malloc((a.length-b)*sizeof(int));\n	for (i=b;i<a.length;i++)\n		c.digits[j++]=a.digits[i];\n	c.length=a.length-b;\n	return c;\n}\nstruct long_int unite(struct long_int a,int b) //add <b> as last(left) digit\n{\n	struct long_int c;\n	int i;\n	c.sign=a.sign;\n	c.digits=malloc((a.length+1)*sizeof(int));\n	for (i=a.length;i>0;i--)\n		c.digits[i]=a.digits[i-1];\n	c.digits[0]=b;\n	c.length=a.length+1;\n	if (a.length==0 && b==0)\n	{\n		c.length=0;\n		c.digits=NULL;\n	}\n	return c;\n}\nstruct long_int add(struct long_int a, struct long_int b)\n{\n	struct long_int c;\n	int r=0,i;\n	if (a.sign==1 && b.sign==-1)\n	{\n		b.sign=1;\n		return sub(a,b);\n	}\n	if (a.sign==-1 && b.sign==1)\n	{\n		a.sign=1;\n		return sub(b,a);\n	}\n	if (a.length<b.length)\n		return add(b,a);\n	c.digits=malloc((a.length+1)*sizeof(int));\n	for (i=0;i<b.length;i++)\n	{\n		c.digits[i]=(a.digits[i]+b.digits[i]+r)%BIGDIGIT;\n		r=(a.digits[i]+b.digits[i]+r)/BIGDIGIT;\n	}\n	for (i=b.length;i<a.length;i++)\n	{\n		c.digits[i]=(a.digits[i]+r)%BIGDIGIT;\n		r=(a.digits[i]+r)/BIGDIGIT;\n	}\n	c.length=a.length;\n	if (r!=0)\n	{\n		c.digits[i]=r;\n		c.length++;\n	}\n	if (c.length==0)\n	{\n		free(c.digits);\n		return zero();\n	}\n	c.sign=a.sign;\n	return c;\n}\nstruct long_int sub(struct long_int a, struct long_int b)\n{\n	struct long_int c;\n	int i;\n	c.sign=1;\n	if (a.sign==1 && b.sign==-1)\n	{\n		b.sign=1;\n		return add(a,b);\n	}\n	if (a.sign==-1 && b.sign==1)\n	{\n		b.sign=-1;\n		return add(a,b);\n	}\n	if (a.sign==-1 && b.sign==-1)\n	{\n		a.sign=1;\n		b.sign=1;\n		return sub(b,a);\n	}\n	if (cmp(a,b)==0)\n		return zero();\n	if (cmp(a,b)==-1)\n	{\n		c=sub(b,a);\n		c.sign=-1;\n		return c;\n	}\n	c.digits=malloc(a.length*sizeof(int));\n	for(i=0;i<b.length;i++)\n	{\n		if (a.digits[i]<b.digits[i])\n		{\n			printf(\"was 1: \");\n			print(a);\n			printf(\"\\n\");\n			a.digits[i]+=BIGDIGIT;\n			a.digits[i+1]--;\n			printf(\"now 1: \");\n			print(a);\n			printf(\"\\n\");\n		}\n		c.digits[i]=a.digits[i]-b.digits[i];\n	}\n	for (i=b.length;i<a.length;i++)\n	{\n		if (a.digits[i]<0)\n		{\n			printf(\"was 2: \");\n			print(a);\n			printf(\"\\n\");\n			a.digits[i]+=BIGDIGIT;\n			a.digits[i+1]--;\n			printf(\"now 2: \");\n			print(a);\n			printf(\"\\n\");\n		}\n		c.digits[i]=a.digits[i];\n	}\n	while (c.digits[--i]==0)\n		;\n	c.length=i+1;\n	if (c.length==0)\n	{\n		free(c.digits);\n		return zero();\n	}\n	return c;\n}\nstruct long_int mul(struct long_int a, struct long_int b)\n{\n	struct long_int c;\n	long long *w,t;\n	int i,j;\n	if (a.length==0 || b.length==0)\n		return zero();\n	w=calloc((a.length+b.length),sizeof(long long));\n	c.digits=malloc((a.length+b.length)*sizeof(int));\n	for (i=0;i<a.length;i++)\n		for(j=0;j<b.length;j++)\n			w[i+j]+=((long long)a.digits[i])*b.digits[j];\n	for (i=0;i<a.length+b.length-1;i++)\n	{\n		t=w[i];\n		c.digits[i]=t%BIGDIGIT;\n		w[i+1]+=t/BIGDIGIT;\n	}\n	c.digits[i]=w[i];\n	c.sign=a.sign*b.sign;\n	c.length=a.length+b.length;\n	if (c.digits[i]==0)\n		c.length--;\n	free(w);\n	return c;\n}\nstruct long_int Div(struct long_int a, struct long_int b)\n{\n	struct long_int c,cur,tmp,tmp1;\n	int *w,j=0,curshift,i; // curshift - number of next digit\n	c.sign=a.sign*b.sign;\n	a.sign=1;\n	b.sign=1;\n	if (cmp(a,b)==-1)\n		return zero();\n	w=malloc((a.length-b.length+1)*sizeof(int));\n	cur=rshift(a,a.length-b.length);\n	curshift=a.length-b.length-1;\n	if (cmp(cur,b)==-1)\n	{\n		free_int(cur);\n		cur=rshift(a,a.length-b.length-1);\n		curshift--;\n	}\n	while(curshift>=-1)\n	{\n		if (cmp(cur,b)==-1)\n			w[j++]=0;\n		else\n		{\n			w[j++]=binary(cur,b);\n			tmp1=short_mul(b,binary(cur,b));\n			tmp=sub(cur,tmp1);\n			free_int(tmp1);\n			free_int(cur);\n			cur=tmp;\n		}\n		if (curshift!=-1)\n		{\n			tmp=unite(cur,a.digits[curshift]);\n			free_int(cur);\n			cur=tmp;\n		}\n		curshift--;\n	}\n	free_int(cur);\n	c.digits=malloc(j*sizeof(int));\n	for (i=j-1;i>=0;i--)\n		c.digits[j-1-i]=w[i];\n	free(w);\n	c.length=j;\n	return c;\n}\nvoid print(struct long_int a)\n{\n	int i;\n	char q[5];\n	if (a.length==0)\n	{\n		printf(\"0\");\n		return;\n	}\n	if (a.sign==-1)\n		printf(\"-\");\n	printf(\"%d\",a.digits[a.length-1]);\n	strcpy(q,\"%07d\");\n	q[2]=LEN_BIGDIGIT+\'0\';\n	for (i=a.length-2;i>=0;i--)\n		printf(q,a.digits[i]);     // CHANGING WITH LEN_BIGDIGIT\n}\nvoid free_int(struct long_int a)\n{\n	free(a.digits);\n	return;\n}\nstruct long_int Convert(int sign,char *s) // in s - unsigned number\n{\n	int i,t,razr,k=0,j;\n	struct long_int a;\n	a.digits=malloc(sizeof(int));\n	a.sign=sign;\n	if (s[0]==\'0\')\n		return zero();\n	for (i=strlen(s)-1;i>=0;i-=LEN_BIGDIGIT)\n	{\n		t=0;\n		razr=1;\n		for (j=0;j<LEN_BIGDIGIT && i-j>=0;j++)\n		{\n			t+=(s[i-j]-\'0\')*razr;\n			razr*=10;\n		}\n		a.digits[k++]=t;\n		if (k%100==1)\n			a.digits=realloc(a.digits,k+100);\n	}\n	a.length=k;\n	return a;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (669,'#include \"doing.h\"\n#include \"rLONG.h\"\n#include <stdlib.h>\n#include <stdio.h>\n#include <time.h>\nint main()\n{\n	char *s,c=0;\n	//freopen(\"input.txt\",\"r\",stdin);\n	//freopen(\"output.txt\",\"w\",stdout);\n	while(c!=EOF)\n	{\n		int i=0;\n		s=malloc(sizeof(char));\n		c=getchar();\n		while (c!=\'\\n\' && c!=EOF)\n		{\n			s[i++]=c;\n			c=getchar();\n			if (i%100==1)\n				s=realloc(s,i+100);\n		}\n		s[i]=0;\n		if (s[0]!=0)\n			compute(s);\n		free(s);\n	}\n	do_cleanup();\n	//time=clock()-time;\n	//printf(\"TIME OF EXECUTION: %f\\n\", (double)time/CLOCKS_PER_SEC);\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (670,'#include <stdlib.h>\n#include \"stack.h\"\nvoid push(struct item **st,void* data) //add data to stack\n{\n	struct item *t;\n	t=malloc(sizeof(struct item));\n	t->next=(*st);\n	t->data=data;\n	(*st)=t;\n	return;\n}\nvoid* top(struct item **st) //return top of stack\n{\n	return (*st)->data;\n}\nvoid pop(struct item **st) //delete top item of stack\n{\n	struct item *temp=(*st)->next;\n	free((*st)->data);\n	free(*st);\n	(*st)=temp;\n}\nint empty(struct item **st) //is stack empty; 1-yes 0-no\n{\n	if ((*st)==NULL)\n		return 1;\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (671,'#include <string.h>\n#include <stdlib.h>\n#include \"long.h\"\n#define N 19\nstruct hash\n{\n	struct hash *next;\n	char *name;\n	struct long_int data;\n};\nstruct hash *T[N];\nint hcode(char*s)\n{\n	unsigned int i=0,sum=0;\n	while(s[i]!=0)\n		sum=(sum*39+s[i++])%N;\n	return sum;\n}\nvoid set_value(char *name, struct long_int value)\n{\n	struct hash *tmp, *prevtmp;\n	int hashcode=hcode(name);\n	if (T[hashcode]==NULL)\n	{\n		T[hashcode]=malloc(sizeof(struct hash));\n		T[hashcode]->name=name;\n		T[hashcode]->data=value;\n		T[hashcode]->next=NULL;\n	}\n	else\n	{\n		prevtmp=NULL;\n		tmp=T[hashcode];\n		while (tmp!=NULL)\n		{\n			if (strcmp(name,tmp->name)==0)\n			{\n				free(name);\n				free_int(tmp->data);\n				tmp->data=value;\n				return;\n			}\n			prevtmp=tmp;\n			tmp=tmp->next;\n		}\n		tmp=malloc(sizeof(struct hash));\n		tmp->name=name;\n		tmp->data=value;\n		tmp->next=NULL;\n		prevtmp->next=tmp;\n	}\n}\nstruct long_int get_value(char *name)\n{\n	struct hash* tmp=T[hcode(name)];\n	while (tmp!=NULL)\n	{\n		if (strcmp(tmp->name,name)==0)\n		{\n			int i;\n			struct long_int a;\n			a.sign=(tmp->data).sign;\n			a.length=(tmp->data).length;\n			a.digits=malloc(a.length*sizeof(struct long_int));\n			for (i=0;i<a.length;i++)\n				a.digits[i]=(tmp->data).digits[i];\n			return a;	\n		}\n		tmp=tmp->next;\n	}\n	return zero();\n}\nvoid cleanup(void)\n{\n	struct hash *tmp,*t;\n	int i;\n	for (i=0;i<N;i++)\n	{\n		tmp=T[i];\n		while (tmp!=NULL)\n		{\n			t=tmp;\n			tmp=tmp->next;\n			free_int(t->data);\n			free(t->name);\n			free(t);\n		}\n	}\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (672,'#include <stdio.h>\n#include <fcntl.h>\n\nint main()\n{\n	char c;\n\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (673,'#include \"stack.h\"\n#include <stdlib.h>\n#include <memory.h>\n\nstruct stackHead\n{\n	struct stackItem *head;\n	size_t stackItemSize;\n};\n\nstruct stackItem\n{\n	struct stackItem *prev;\n	void *data;\n};\n\nint isEmpty(struct stackHead *stack)\n{\n	return (stack->head == NULL) ? 1 : 0;\n}\n\nint push(struct stackHead *stack, void *data, size_t size)\n{	 \n	struct stackItem *newHead = NULL;\n	if (size != stack->stackItemSize)\n		return 0;\n	newHead = (struct stackItem*)malloc(sizeof(struct stackItem));\n	newHead->data = malloc(size);\n	memcpy(newHead->data, data, size);\n	newHead->prev = stack->head;\n	stack->head = newHead;\n	return 1;\n}\n\nvoid delStackItem(struct stackHead *stack)\n{\n	struct stackItem *temp = stack->head;\n	if(!isEmpty(stack))\n	{\n		free(stack->head->data);\n		stack->head = stack->head->prev;\n		free(temp);\n	}\n}\nvoid *getTopVal(struct stackHead *stack)\n{\n	if (stack == NULL || stack->head == NULL)\n		return NULL;\n	return stack->head->data;\n}\n\nstruct stackHead *createStack(size_t size)\n{\n	struct stackHead *newStack = (struct stackHead*)malloc(size);\n	if(newStack)\n	{\n		newStack->stackItemSize = size;\n		newStack->head = NULL;\n	}\n	return newStack;\n}\n\nvoid releaseStack(struct stackHead *stack)\n{\n	struct stackItem *temp = NULL;\n	while(!isEmpty(stack))\n	{\n		temp = stack->head;\n		free(stack->head->data);\n		stack->head = stack->head->prev;\n		free(temp);\n	}\n	free(stack);\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (674,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"hash.h\"\n\nstruct hashTableListItem\n{\n	char *varName;\n	int varValue;\n	struct hashTableListItem *next;\n};\n\nstruct hashTableList\n{\n	struct hashTableListItem *head;\n};\n\nstruct hashTable\n{\n	struct hashTableList *list;\n	int size;\n	int (*calculateHash)(char* word, int hashTableSize);\n};\n\nint sCalculateHash(char *word, int hashTableSize)\n{\n	int res = 0;\n	for( ; *word; word++)\n	{\n		res = res * *word * 37 % hashTableSize;\n	}\n	return res;\n}\n\nstruct hashTable *createHashTable(int size, int (*calculateHash)(char *word, int hashTableSize))\n{\n	struct hashTable *newHashTable = NULL;\n	struct hashTableList *newHashTableList = NULL;\n	newHashTable = (struct hashTable*)calloc(1, sizeof(struct hashTable));\n	newHashTableList = (struct hashTableList*)calloc(size, sizeof(struct hashTableList));\n	if(newHashTable)\n	{\n		newHashTable->size = size;\n		if(newHashTableList)\n			newHashTable->list = newHashTableList;\n	}\n	newHashTable->calculateHash = &sCalculateHash;\n	return newHashTable;\n}\n\nvoid releaseHashTable(struct hashTable *table)\n{\n	struct hashTableListItem *itemTemp = NULL;\n	int i = 0;\n	\n	for(i = (table->size - 1) ; i >= 0; i--)\n	{\n		while(table->list[i].head)\n		{\n			itemTemp = table->list[i].head;\n			table->list[i].head = itemTemp->next;\n			free(itemTemp->varName);\n			free(itemTemp);\n		}\n	}\n	free(table->list);\n	free(table);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvoid addHashTableItem(char *name, int value, struct hashTable *table)\n{\n	struct hashTableListItem *newItem= NULL;\n	int hashCode = table->calculateHash(name, table->size);\n\n	if(hashCode >= table->size || hashCode < 0)\n	{\n		printf(\"Incorrect calculateHash function!\\n\'%s\'[%d] is not added!\\n\", name, value);\n		return;\n	}\n\n	newItem = (struct hashTableListItem*)calloc(1, sizeof(struct hashTableListItem));\n	newItem->next = table->list[hashCode].head;\n	newItem->varName = (char*)calloc(strlen(name) + 1, 1);\n	strcpy(newItem->varName, name);\n	newItem->varValue = value;\n\n	table->list[hashCode].head = newItem;\n}\n\nint delHashTableItem(char *name, struct hashTable *table)\n{\n	struct hashTableListItem *item = NULL;\n	struct hashTableListItem *prevItem = NULL;\n	int hashCode = 0;\n	int found = 0;\n\n	hashCode = table->calculateHash(name, table->size);\n	item = table->list[hashCode].head;\n	for(; item->next; prevItem = item, item = item->next)\n	{\n		if(strcmp(item->varName, name) == 0)\n		{\n			found = 1;\n			break;\n		}\n	}\n\n	if(found)\n	{\n		if(!prevItem)\n			table->list[hashCode].head = item->next;\n		else\n			prevItem->next = item->next;\n		free(item->varName);\n		free(item);\n		return 1;\n	}\n	return 0;	//Element not found\n}\n\nvoid setHashTableItemValue(char *name, int value, struct hashTable *table)\n{\n	struct hashTableListItem *item = NULL;\n	int hashCode = 0;\n	int found = 0;\n\n	hashCode = table->calculateHash(name, table->size);\n	item = table->list[hashCode].head;\n	for(; item; item = item->next)\n	{\n		if(strcmp(item->varName, name) == 0)\n		{\n			found = 1;\n			break;\n		}\n	}\n\n	if(found)\n		item->varValue = value;\n}\n\nint *getHashTableItemValue(char *name, struct hashTable *table)\n{\n	struct hashTableListItem *item = NULL;\n	int hashCode = 0;\n	int found = 0;\n\n	hashCode = table->calculateHash(name, table->size);\n	item = table->list[hashCode].head;\n	for(; item; item = item->next)\n	{\n		if(strcmp(item->varName, name) == 0)\n		{\n			found = 1;\n			break;\n		}\n	}\n\n	if(found)\n		return &(item->varValue);\n	return NULL;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (675,'#include <stdio.h>\n#include <stdlib.h>\n#include \"../stack/stack.h\"\n#include \"../hash/hash.h\"\n\nchar *readWord(FILE* f)\n{\n	char *p = NULL;\n	char c = 0;\n	int i = 0;\n\n	size_t allocated = 0;\n	size_t used = 0;\n	\n	while(c = fgetc(f))\n	{\n		if((c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\') || (c >= \'0\' && c <= \'9\') || c == \'_\')\n		{\n			if(allocated <= (used + 1))\n			{\n				char *temp = NULL;\n				temp = realloc((void*)p, allocated += (size_t)10);\n				if(temp)\n					p = temp;\n				else\n				{\n					printf(\"Can not allocate memory for new word!..\\n=(\\n\");\n					exit(1);\n				}\n			}\n			p[used++] = c;\n		}\n		else\n			break;\n	}\n	ungetc(c, f);\n	p[used++] = 0;\n	return p;\n}\n\nint readNum(FILE *f)\n{\n	int res = 0;\n	char c = 0;\n	while((c = fgetc(f)) >= \'0\' && c <= \'9\')\n		res = res * 10 + (c - \'0\');\n	ungetc(c, f);\n	return res;\n}\n\nint calculateOperation(char operation, struct stackHead *numberStack)\n{\n	int a = 0;\n	int b = 0;\n	int res = 0;\n\n	if(!isEmpty(numberStack))\n	{\n		b = *(int*)getTopVal(numberStack);\n		delStackItem(numberStack);\n	}\n	else\n		return 0;\n	if(!isEmpty(numberStack))\n	{\n		a = *(int*)getTopVal(numberStack);\n		delStackItem(numberStack);\n	}\n	else\n		return 0;\n\n	switch(operation)\n	{\n	case \'+\':\n		res = a + b;\n		break;\n	case \'-\':\n		res = a - b;\n		break;\n	case \'*\':\n		res = a * b;\n		break;\n	case \'/\':\n		res = a / b;\n		break;\n	}\n\n	push(numberStack, (void*)(&res), sizeof(res));\n	return 1;\n}\n\nvoid pushVariableValue(char *variableName, struct hashTable *variables, struct stackHead *numberStack)\n{\n	int varValue = 0;\n	varValue = *getHashTableItemValue(variableName, variables);\n	push(numberStack, (void*)(&varValue), sizeof(int));\n}\n\nvoid calculateExpressionInBrackets(struct stackHead *operationStack, struct stackHead *numberStack)\n{\n	int c = 0;\n	while((c = *(char*)getTopVal(operationStack)) != \'(\')\n	{\n		calculateOperation(c, numberStack);\n		delStackItem(operationStack);\n	}\n	delStackItem(operationStack);\n}\n\nvoid parse(FILE *input, struct stackHead *operationStack, struct stackHead *numberStack, struct hashTable *variables, int Sign)\n{\n	const int zero = 0;\n	const char openingBracket = \'(\';\n	const char closingBracket = \')\';\n\n	int priority[8] = {0, 0, 2, 1, 0, 1, 0, 2};\n\n	int character = 0;\n	int mayBeSign = Sign;\n\n	int bracketsLevel = 0;\n	struct stackHead *bracketsStack = createStack(sizeof(int));\n\n	while((character = fgetc(input)) != EOF)\n	{\n		if(character >= \'0\' && character <= \'9\')\n		{\n			int number = 0;\n			ungetc(character, input);\n			number = readNum(input);\n			push(numberStack, (void*)(&number), sizeof(int));\n			mayBeSign = 0;\n		}\n		else if(character == \'(\')\n		{\n			mayBeSign = 1;\n			bracketsLevel++;\n			push(operationStack, (void*)(&character), 1);\n		}\n		else if(character == \')\')\n		{\n			calculateExpressionInBrackets(operationStack, numberStack);\n			mayBeSign = 0;\n			bracketsLevel--;\n			if(!isEmpty(bracketsStack))\n				if(*(int*)getTopVal(bracketsStack) - bracketsLevel == 1)\n				{\n					ungetc(character, input);\n					delStackItem(bracketsStack);\n				}\n		}\n		else if(character == \'+\' || character == \'-\' || character == \'*\' || character == \'/\')\n		{\n			if(mayBeSign == 1)	//unary operation\n				if(character != \'-\' && character != \'+\')	//sign validation\n				{\n					printf(\"Parsing error!\\n\");\n					exit(1);\n				}\n				else\n				{\n					push(operationStack, (void*)(&openingBracket), 1);\n					bracketsLevel++;\n					push(numberStack, (void*)(&zero), sizeof(zero));\n					push(operationStack, (void*)(&character), 1);\n					\n					character = fgetc(input);\n					if(character >= \'0\' && character <= \'9\')	//next is value\n					{\n						int num = 0;\n						ungetc(character, input);\n						num = readNum(input);\n						push(numberStack, (void*)(&num), sizeof(int));\n						calculateExpressionInBrackets(operationStack, numberStack);\n						bracketsLevel--;\n						mayBeSign = 0;\n					}\n					else if((character >= \'a\' && character <= \'z\') || (character >= \'A\' && character <= \'Z\') || character == \'_\')	//next is variable\n					{\n						char *word = readWord(input);\n						ungetc(character, input);\n						pushVariableValue(word, variables, numberStack);\n						calculateExpressionInBrackets(operationStack, numberStack);\n						bracketsLevel--;\n						mayBeSign = 0;\n					}\n					else if(character == \'(\')	//next is expression\n					{\n						push(bracketsStack, (void*)(&bracketsLevel), sizeof(int));\n						push(operationStack, (void*)(&character), 1);\n					}\n				}\n			else	//binary operation\n			{\n				while(!isEmpty(operationStack) && (priority[*(char*)getTopVal(operationStack) - (char)40] >= priority[character - (char)40]))\n				{\n					calculateOperation(*(char*)getTopVal(operationStack), numberStack);\n					delStackItem(operationStack);\n				}\n				push(operationStack, (void*)(&character), 1);\n				mayBeSign = 1;\n			}\n		}\n		else if((character >= \'a\' && character <= \'z\') || (character >= \'A\' && character <= \'Z\') || character == \'_\')\n		{\n			ungetc(character, input);\n			pushVariableValue(readWord(stdin), variables, numberStack);\n			mayBeSign = 0;\n		}\n		else if(character == \'\\n\')\n		{\n			while(!isEmpty(operationStack))\n			{\n				calculateOperation(*(char*)getTopVal(operationStack), numberStack);\n				delStackItem(operationStack);\n			}\n			mayBeSign = 1;\n			return;\n		}\n	}\n}','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (676,'#include \"hash/hash.h\"\n#include \"stack/stack.h\"\n#include \"parser/parser.h\"\n\nint main()\n{\n	int c = 0;\n\n	struct stackHead *intStack = createStack(sizeof(int));\n	struct stackHead *charStack = createStack(sizeof(char));\n	struct hashTable *variables = createHashTable(10, sCalculateHash);\n	\n	while((c = fgetc(stdin)) != EOF)\n	{\n		if((c >= \'a\' && c <= \'z\') || (c >= \'a\' && c <= \'z\') || c == \'_\')\n		{\n			char *varName = NULL;\n			ungetc(c, stdin);\n			varName = readWord(stdin);\n			while((c = fgetc(stdin)) == \' \');\n			if(c == \'=\')\n			{\n				if(getHashTableItemValue(varName, variables) == NULL)	//variable not found\n				{\n					parse(stdin, charStack, intStack, variables, 1);\n					addHashTableItem(varName, *(int*)getTopVal(intStack), variables);\n				}\n				else	//variable found\n				{\n					parse(stdin, charStack, intStack, variables, 0);\n					setHashTableItemValue(varName, *(int*)getTopVal(intStack), variables);\n				}\n			}\n			else\n			{\n				ungetc(c, stdin);\n				pushVariableValue(varName, variables, intStack);\n				parse(stdin, charStack, intStack, variables, 0);\n			}\n\n			\n		}\n		else if(c == \' \')\n		{}\n		else\n		{\n			ungetc(c, stdin);\n			parse(stdin, charStack, intStack, variables, 1);\n		}\n	}\n	printf(\"[%d]\\n\", *(int*)getTopVal(intStack));\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (677,'#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n#include \"vars.h\"\nint pr (char *s)\n{\n	int i;\n	switch(*s)\n	{\n		case \'+\': i=1;break;\n		case \'-\': i=1;break;\n		case \'*\': i=2;break;\n		case \'/\': i=2;break;\n		case \'(\': i=0;break;\n	}\n	return i;\n}\nint main ()\n{\n	stack st_num = createStack();\n	stack st_obr = createStack();\n	int i=0,j=0,*a,*d,unary = 0,ucount=0,wcount = 0,*b,k=0,binary = 0,p=0;\n	char c;\n	char *s,*word;\n\n	while ((c=fgetc(stdin)) != EOF)\n	{\n		p=0;\n		if(c == \'-\' || c == \'+\')\n		{\n			unary = 1;\n		}\n		if(!empty(st_obr))\n		{\n			j=1;\n		}\n		else\n		{\n			j=0;\n		}\n	 	if (c == \'_\' || (c >= \'a\' && c <= \'z\'))\n		{\n			ungetc(c,stdin);\n			word = readword(stdin);\n			wcount = 1;\n		}\n		if (wcount == 1 && c == \'=\')\n		{\n			while ((c=fgetc(stdin)) != EOF)\n			{\n				if(c == \'-\' || c == \'+\')\n				{\n					unary = 1;\n				}\n				if(!empty(st_obr))\n				{\n					j=1;\n				}\n				else\n				{\n					j=0;\n				}\n	 			if (c == \'_\' || (c >= \'a\' && c <= \'z\'))\n				{\n					ungetc(c,stdin);\n					word = readword(stdin);\n					wcount = 1;\n				}\n				if(binary ==0 && ucount == 0 && i == 1 && (c == \'-\' || c == \'+\'))\n				{\n					char *t = malloc (sizeof(1));\n					*t = c;\n					b = malloc(sizeof(int));\n					*b = 0;\n					unary = 0;\n					push(&st_num,(void*)(b));\n					push(&st_obr,(void*)(t));\n				}\n				else if(c>=\'0\' && c<=\'9\')\n				{	\n					if(i==1)\n						i=0;\n					binary = 1;\n					a = malloc(sizeof(int));\n					ungetc(c,stdin);\n					*a = readnum(stdin);\n					push (&st_num,a);\n				}\n				else if (c == \'(\')\n				{\n					char *t = malloc (sizeof(1));\n					*t = c;\n					push(&st_obr,(void*)(t));\n					i=1;\n					if (unary == 1 && binary == 0)\n					{\n						 b = malloc(sizeof(int));\n						*b = 0;\n						unary = 0;\n						push(&st_num,(void*)(b));\n						ucount++;\n					}\n					binary = 0;\n				}\n				else if (c == \'+\' || c == \'-\' || c == \'/\' || c == \'*\')\n				{\n		 			char *t = malloc (sizeof(1));\n					*t = c;\n					if((j!=0 && i==0) || (j!=0 && pr(t)<=pr((char*)(top(st_obr))) && i==1))\n					{\n						while (pr(t)<=pr((char*)(top(st_obr))))\n						{\n							s = (char*)top(st_obr);\n							a = malloc (sizeof(int));\n							a = (int*)top(st_num);\n							pop(&st_num);\n							d = malloc(sizeof(int));\n							d = (int*)top (st_num);\n							pop(&st_num);\n							switch (*s)\n							{\n								case \'+\': (*a) = (*d)+(*a);break;\n								case \'-\': (*a) = (*d)-(*a);break;\n								case \'*\': (*a) = (*d)*(*a);break;\n								case \'/\': (*a) = (*d)/(*a);break;\n							}\n							push(&st_num,a); \n							pop(&st_obr);\n							if(empty(st_obr))\n							{\n								break;\n							}\n						}\n						push (&st_obr,(void*)(t));\n						i=0;\n					}\n					else\n					{\n						push(&st_obr,(void*)(t));\n						i=0;\n					}\n				}\n				if((c == \')\' || c == \'\\n\') && j==1)\n				{\n					while ((*(char*)top(st_obr) != \'(\') || (top(st_obr) != NULL))\n					{\n						s = (char*)top(st_obr);\n						pop(&st_obr);\n						a = malloc(sizeof(int));\n						a = (int*)top(st_num);\n						pop(&st_num);\n						d = malloc(sizeof(int));\n						d = (int*)top(st_num);\n						pop(&st_num);\n						switch (*s)\n						{\n							case \'+\': (*a) = (*d)+(*a);break;\n							case \'-\': (*a) = (*d)-(*a);break;\n							case \'*\': (*a) = (*d)*(*a);break;\n							case \'/\': (*a) = (*d)/(*a);break;\n						}\n						push(&st_num,a);\n						if(top(st_obr) == NULL)\n							break;\n						if(*(char*)top(st_obr) == \'(\')\n						{\n							pop(&st_obr);\n							break;\n						}\n					}\n					binary=1;\n					i=0;\n				}\n			}\n			set_value(word,a);\n			pop(&st_num);\n			wcount = 0;\n			binary = 0;\n		}\n		\n		if (wcount == 1 && (c == \'+\' || c == \'-\' || c == \'*\' || c == \'/\' || c == \'\\n\' || c == \')\'))\n		{\n			char *t = malloc(sizeof(1));\n			*t = c;\n			wcount = 0;\n			binary = 1;\n			a = malloc(sizeof(int));\n			*a = get_value(word);\n			push(&st_num,a);\n		}\n		if(binary ==0 && ucount == 0 && i == 1 && (c == \'-\' || c == \'+\'))\n		{\n			char *t = malloc (sizeof(1));\n			*t = c;\n			b = malloc(sizeof(int));\n			*b = 0;\n			unary = 0;\n			push(&st_num,(void*)(b));\n			push(&st_obr,(void*)(t));\n		}\n		else if(c>=\'0\' && c<=\'9\')\n		{	\n			if(i==1)\n				i=0;\n			binary = 1;\n			a = malloc(sizeof(int));\n			ungetc(c,stdin);\n			*a = readnum(stdin);\n			push (&st_num,a);\n		}\n		else if (c == \'(\')\n		{\n			char *t = malloc (sizeof(1));\n			*t = c;\n			push(&st_obr,(void*)(t));\n			i=1;\n			if (unary == 1 && binary == 0)\n			{\n				 b = malloc(sizeof(int));\n				*b = 0;\n				unary = 0;\n				push(&st_num,(void*)(b));\n				ucount++;\n			}\n			else\n			{\n				ucount=0;\n			binary = 0;\n			}\n		}\n		else if ((c == \'+\' || c == \'-\' || c == \'/\' || c == \'*\') && p!=1 )\n		{\n		 	char *t = malloc (sizeof(1));\n			*t = c;\n			if((j!=0 && i==0) || (j!=0 && pr(t)<=pr((char*)(top(st_obr))) && i==1))\n			{\n				while (pr(t)<=pr((char*)(top(st_obr))))\n				{\n					s = (char*)top(st_obr);\n					a = malloc (sizeof(int));\n					a = (int*)top(st_num);\n					pop(&st_num);\n					d = malloc(sizeof(int));\n					d = (int*)top (st_num);\n					pop(&st_num);\n					switch (*s)\n					{\n						case \'+\': (*a) = (*d)+(*a);break;\n						case \'-\': (*a) = (*d)-(*a);break;\n						case \'*\': (*a) = (*d)*(*a);break;\n						case \'/\': (*a) = (*d)/(*a);break;\n					}\n					push(&st_num,a); \n					pop(&st_obr);\n					if(empty(st_obr))\n					{\n						break;\n					}\n				}\n				push (&st_obr,(void*)(t));\n				i=0;\n				unary=0;\n				binary=0;\n			}\n			else\n			{\n				push(&st_obr,(void*)(t));\n				i=0;\n			}\n		}\n			if((c == \')\' || c == \'\\n\') && j==1)\n			{\n				wcount = 0;\n				while ((*(char*)top(st_obr) != \'(\') || (top(st_obr) != NULL))\n				{\n					s = (char*)top(st_obr);\n					pop(&st_obr);\n					a = malloc(sizeof(int));\n					a = (int*)top(st_num);\n					pop(&st_num);\n					d = malloc(sizeof(int));\n					d = (int*)top(st_num);\n					pop(&st_num);\n					switch (*s)\n					{\n						case \'+\': (*a) = (*d)+(*a);break;\n						case \'-\': (*a) = (*d)-(*a);break;\n						case \'*\': (*a) = (*d)*(*a);break;\n						case \'/\': (*a) = (*d)/(*a);break;\n					}\n					push(&st_num,a);\n					if(top(st_obr) == NULL)\n						break;\n					if(*(char*)top(st_obr) == \'(\')\n					{\n						pop(&st_obr);\n						break;\n					}\n				}\n				binary=1;\n				i=0;\n			} \n	}\n	\n	printf(\"otvet: %d\\n\",*a);\n	\n	\n	\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (678,'#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n\nstruct item {\n	void *data;\n	struct item *next;\n};\nvoid push (stack *st, void *data)\n{\n	stack p;\n	p = malloc(sizeof(*p));\n	if(p)\n	{\n		p->data = data;\n		p->next = *st;\n		*st = p;\n	}\n}\nvoid pop (stack *st)\n{\n	stack p = *st;\n	*st = (*st)->next;\n	free(p);\n}\nvoid *top(stack st)\n{\n	if(st == NULL)\n		return NULL;\n	return (st->data);\n}\nint empty (stack st)\n{\n	return (st->data == NULL);\n}\nstack createStack ()\n{\n	stack st = malloc(sizeof(stack));\n	st->data = NULL;\n	st->next = NULL;\n	return st;\n}\nvoid makenull(stack *st)\n{\n	stack *p = NULL;\n	while (!empty(*st))\n	{	\n		p = st;\n		free((*st)->data);\n		free(*st);\n		*st=(*st)->next;\n		free(p);\n	}\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (679,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"vars.h\"\nunsigned int hash_k(char *s)\n{\n	unsigned int res = 0;\n//	return res;\n	for( ; *s;s++)\n	{\n		res = res*37+*s;\n	}\n	return (res % 100);\n}\nstruct dsi\n{\n	char *v;\n	int dt;\n	struct item *nt;\n};\ntypedef struct dsi hash;\n//struct item *A[100];\nhash *A[100];\nvoid set_value(char *name, int* value)\n{\n	int Hk = 0;\n	int l = strlen(name);\n//	struct item *p = NULL;\n	hash *p = NULL;\n	Hk = hash_k(name);\n	p = A[Hk];\n	p = malloc(sizeof(*p));\n	p->v = malloc(sizeof(l+1));\n	strcpy(p->v,name);\n	p->dt = *value;\n	p->nt=A[Hk];\n	A[Hk]=p;\n}\nint get_value(char *name)\n{\n	int Hk = 0;\n//	struct item *p = NULL;\n	hash *p = NULL;\n	Hk = hash_k(name);\n	for(p=A[Hk];p;p=p->nt)\n	{\n		if ((strcmp(p->v,name)) == 0)\n		{\n			return (p->dt);\n		}\n	}\n	return 0;\n}\nvoid cleanup(void)\n{\n	//struct item *p = NULL;\n	hash *p = NULL;\n	int i = 0;\n	for (i = 0;i<100;i++)\n	{\n		while (p=A[i])\n		{\n			free (A[i]->v);\n			A[i] = A[i] -> nt;\n			free (p);\n		}\n	}\n}\nchar *readword(FILE *f)\n{\n	int i = 0;\n	char c = 0;\n	char *p = NULL, *tmp = NULL;\n	size_t allocated = 0, used = 0;\n	while ((c = fgetc(f)) != \'+\' || c != \'-\' || c != \'*\' || c != \'/\' || c != \' \' || c != EOF || c != \'(\' || c != \')\' || c != \'\\n\')\n	{\n		if( (c >= \'a\' && c <= \'z\') || (c >= \'0\' && c <= \'9\') || c == \'_\')\n		{\n			if (allocated == used)\n			{\n				char *tmp = realloc(p,allocated += (size_t)5);\n				if(!tmp) \n					break;\n				p=tmp;\n			}\n			p[used++] = c;\n		}\n		else\n		{\n			break;\n		}\n	}\n	p[used++] = 0;\n	ungetc(c,f);\n	return p;\n}\nint *readnum(FILE *f)\n{\n	int i = 0;\n	char c =0;\n	while ((c = fgetc(f)) >= \'0\' && c <=\'9\')\n	{\n				i = 10*i + c -\'0\';\n	}\n	ungetc(c,f);\n	return i;\n}','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (680,'#ifdef _MSC_VER\r\n#define _CRTDBG_MAP_ALLOC\r\n#define  _DEBUG 2\r\n#include <stdlib.h>\r\n#include <crtdbg.h>\r\n#else\r\n#include <stdlib.h>\r\n#endif\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include \"parser.h\"\r\n#include \"var.h\"\r\n\r\nint main()\r\n{\r\n	\r\n        stack *value_st = create();\r\n		stack *operation_st = create();\r\n		char buffer_array[100];\r\n		char stop = 0;\r\n		char tmp;\r\n		int *resultat = NULL;\r\n		int position, first, second;\r\n		element *result;\r\n		int is_init = 0;\r\n		var *var_list = (var*)malloc(sizeof(var));		\r\n		var_list->name = strdup(\"head\");\r\n		var_list->value = 0;\r\n		var_list->next = NULL;\r\n		result = NULL;\r\n		printf(\"Press \'!\' to finish the programm\\n\\n\\n\");\r\n		while(stop != \'!\' )\r\n		{\r\n			char *buffer = buffer_array;\r\n			if (!fgets(buffer_array, 100, stdin))\r\n				break;\r\n			stop = buffer[0];\r\n			while (*buffer != 0)\r\n			{\r\n				element* a = parser(buffer, &position);\r\n				element* unar_minus;\r\n				buffer+= position;\r\n				//printf(\"got a->type = %d, a->data = %s\\n\", a ? a->type : -12345, a ? a->data : \"xxx\");\r\n				if(a != NULL)\r\n				{\r\n					if (a->type == value)\r\n					{\r\n						resultat = (int *) malloc(sizeof(int));\r\n						*resultat = atoi(a->data);\r\n						push(&value_st, (void*)resultat);\r\n						free(a->data);\r\n						free(a);\r\n						continue;\r\n					}\r\n					if (a->type == operation)\r\n					{\r\n						char* allocOperation;\r\n						\r\n						tmp = a->data[0];\r\n							switch (tmp)\r\n							{\r\n							case \'(\' :\r\n								allocOperation = (char*)malloc(sizeof(char));\r\n								*allocOperation = a->data[0];\r\n								push(&operation_st, allocOperation);\r\n								if (*(char *)(unar_minus = parser(buffer, &position))->data == \'-\')\r\n								{\r\n									resultat = (int *) malloc(sizeof(int));\r\n									*resultat = 0;\r\n									push(&value_st, (void *) resultat);\r\n									free(unar_minus->data);\r\n									free(unar_minus);\r\n								}\r\n								break;\r\n							case \'*\' :\r\n							case \'/\' :\r\n								while(empty(operation_st))\r\n								{\r\n									if (*(char *)top(operation_st) == \'*\')\r\n									{\r\n										first = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										second = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										resultat = (int *) malloc(sizeof(int));\r\n										*resultat = first * second;\r\n										push(&value_st, (void*)(resultat));\r\n										pop(&operation_st);\r\n									}\r\n									else if (*(char *)top(operation_st) == \'/\')\r\n									{\r\n										first = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										second = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										resultat = (int *) malloc(sizeof(int));\r\n										*resultat = second / first;\r\n										push(&value_st, (void*)(resultat));\r\n										pop(&operation_st);\r\n									}\r\n									else\r\n									break;\r\n								}\r\n								allocOperation = (char*)malloc(sizeof(char));\r\n								*allocOperation = a->data[0];\r\n								push(&operation_st, allocOperation);\r\n								break;\r\n							case \'-\' :\r\n							case \'+\' :\r\n								if(!empty(value_st) )\r\n								{\r\n									resultat = (int *) malloc(sizeof(int));\r\n									*resultat = 0;\r\n									push(&value_st, (void *) resultat);\r\n								}\r\n								while(empty(operation_st))\r\n								{\r\n									if (*(char *)top(operation_st) != \'(\')\r\n									{\r\n										first = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										second = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										tmp = *(char *)top(operation_st);\r\n										resultat = (int *) malloc(sizeof(int));\r\n										switch (tmp)\r\n										{\r\n										case \'+\' : *resultat = first + second;\r\n												pop(&operation_st);\r\n												break;\r\n										case \'-\' : *resultat = second - first;\r\n												pop(&operation_st);\r\n												break;\r\n										case \'*\' : *resultat = first * second;\r\n												pop(&operation_st);\r\n												if ((empty(operation_st))&&*(char *)top(operation_st) == \'-\')\r\n												 {\r\n													first = *resultat;\r\n													second = *((int*)top(value_st));\r\n													pop(&value_st);\r\n													*resultat = second - first;\r\n													pop(&operation_st);\r\n												 }\r\n												break;\r\n										case \'/\' :\r\n											 if(first != 0)\r\n											 {\r\n												 *resultat = second / first;\r\n												 pop(&operation_st);\r\n												 if ((empty(operation_st))&&*(char *)top(operation_st) == \'-\')\r\n												 {\r\n													first = *resultat;\r\n													second = *((int*)top(value_st));\r\n													pop(&value_st);\r\n													*resultat = second - first;\r\n													pop(&operation_st);\r\n												 }\r\n											 }\r\n											 else printf(\"ERROR!!\");\r\n											 break;\r\n										}\r\n										push(&value_st, (void*)(resultat));\r\n									}\r\n									else\r\n										break;\r\n								}\r\n								allocOperation = (char*)malloc(sizeof(char));\r\n								*allocOperation = a->data[0];\r\n								push(&operation_st, allocOperation);\r\n								break;\r\n							case \')\' : \r\n								if(empty(operation_st))\r\n								{\r\n									tmp = *(char *)top(operation_st);\r\n									while (tmp != \'(\')\r\n									{\r\n										first = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										second = *((int*)top(value_st));\r\n										pop(&value_st);\r\n										resultat = (int *) malloc(sizeof(int));\r\n										switch (tmp)\r\n										{\r\n										case \'+\' : *resultat = first + second;\r\n												break;\r\n										case \'-\' : *resultat = second - first;\r\n												break;\r\n										case \'*\' : *resultat = first * second;\r\n												break;\r\n										case \'/\' : \r\n											if (first != 0)\r\n												{*resultat = second / first;\r\n											}\r\n												break;\r\n\r\n										}\r\n										pop(&operation_st);\r\n										push(&value_st, (void*)(resultat));\r\n										tmp = *(char *)top(operation_st);\r\n									}\r\n								}\r\n								pop(&operation_st);\r\n								break;\r\n							}\r\n						free(a->data);\r\n						free(a);\r\n						continue;\r\n					}\r\n					if (a->type == variable)\r\n					{\r\n						char *ptr = a->data;\r\n						char *name = (char *) malloc (sizeof (char));\r\n						int allocated = 0;\r\n						//char *value = (char *) malloc(sizeof (char));\r\n						int is_equal = 0;\r\n						*name = 0;\r\n						while (*ptr != 0)\r\n						{\r\n							if (*ptr == \'=\')\r\n							{\r\n								is_equal = 1;\r\n								ptr++;\r\n								break;\r\n							}\r\n							name = (char *)realloc(name, sizeof(char)*(allocated+2));\r\n							name[allocated] = *ptr;\r\n							name[allocated+1] = 0;\r\n							allocated++;\r\n							ptr++;\r\n						}\r\n						if (is_equal)\r\n						{\r\n							if(is_init)\r\n							{\r\n								printf(\"ERROR!!\\n\");\r\n								is_init=0;\r\n								break;\r\n							}\r\n							else\r\n							{\r\n								is_init = 1;\r\n								result = (element*)malloc(sizeof(element));\r\n								result->type = a->type;\r\n								result->data = strdup(a->data);\r\n							}\r\n						}\r\n						else\r\n						{\r\n							resultat = (int *) malloc(sizeof(int));\r\n							*resultat = get_value(var_list, name);\r\n							push(&value_st, (void *) resultat);\r\n						}\r\n						free(name);\r\n						free(a->data);\r\n						free(a);\r\n					}\r\n				}\r\n			}\r\n			while(empty(operation_st))\r\n			{\r\n				first = *((int*)top(value_st));\r\n				pop(&value_st);\r\n				second = *((int*)top(value_st));\r\n				pop(&value_st);\r\n				tmp = *(char *)top(operation_st);\r\n				resultat = (int *) malloc(sizeof(int));\r\n				switch (tmp)\r\n				{\r\n				case \'+\' : *resultat = first + second;\r\n						break;\r\n				case \'-\' : *resultat = second - first;\r\n						break;\r\n				case \'*\' : *resultat = first * second;\r\n						break;\r\n				case \'/\' : if(first != 0)\r\n							   {\r\n								   *resultat = second / first;\r\n						   }\r\n						   else printf(\"ERROR!!\");\r\n						break;\r\n				}\r\n				pop(&operation_st);\r\n				push(&value_st, (void*)(resultat));\r\n\r\n			}\r\n			while (empty(value_st))\r\n			{\r\n				if(is_init)\r\n				{\r\n					char* name;\r\n					int length = 0;\r\n					is_init = 0;\r\n					length = strlen(result->data) - 1;\r\n					name = (char*)malloc((length + 2)*sizeof(char));\r\n					strcpy(name, result->data);\r\n					name[length] = 0;\r\n					set_value (var_list, name, *(int *) top(value_st));\r\n					free(name);\r\n					\r\n				}\r\n				printf(\"%d\\n\",*(int *) top(value_st));\r\n				pop(&value_st);\r\n				if(result != NULL)\r\n				{\r\n					free(result->data);\r\n					free(result);\r\n					result =NULL;\r\n				}\r\n			}\r\n		}\r\n\r\n		clean_up(var_list);\r\n\r\n		while(empty(value_st))\r\n		{\r\n			pop(&value_st);\r\n		}\r\n		free(value_st->data);\r\n		free(value_st);\r\n		while(empty(operation_st))\r\n		{\r\n			pop(&operation_st);\r\n		}\r\n		free(operation_st->data);\r\n		free(operation_st);\r\n		\r\n		if(result != NULL)\r\n		{\r\n			free(result);\r\n		}\r\n#ifdef _MSC_VER\r\n		_CrtDumpMemoryLeaks();\r\n#endif\r\n		return 0;\r\n}','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (681,'#include \"parser.h\"\r\n#include <ctype.h>\r\n\r\n\r\nelement *parser(char* buffer, int* position)\r\n{\r\n	char c;\r\n	element* obj;\r\n	int index;\r\n	c = *buffer;\r\n	if(*buffer == 0)\r\n	{\r\n		return NULL;\r\n	}\r\n	obj = (element* ) malloc(sizeof(element));\r\n	obj->data = (char *) malloc(2*sizeof(char));\r\n	*position = 1;\r\n	switch(c)\r\n	{\r\n	case \'+\' :\r\n		obj->type = operation;		\r\n		obj->data[0] = \'+\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'-\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'-\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'*\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'*\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'/\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'/\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'(\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'(\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \')\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \')\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	}\r\n\r\n	index = 0;	\r\n	if (isdigit(c))\r\n	{\r\n		while (isdigit(c))\r\n		{\r\n			if(index == 0)\r\n			{\r\n				obj->type = value;\r\n				obj->data[0] = c;\r\n				obj->data[1] = 0;\r\n				buffer++;\r\n				c = *buffer;\r\n				index++;\r\n			}\r\n			else\r\n			{\r\n				obj->data = (char *) realloc(obj->data, 2*sizeof(char) + index);\r\n				obj->data[index] = c;\r\n				obj->data[index + 1] = 0;\r\n				buffer++;\r\n				c = *buffer;		\r\n				index++;\r\n			}\r\n		}\r\n		*position = index;\r\n		return obj;\r\n	}\r\n	else\r\n	if (isalpha(c))\r\n	{\r\n		while (isalpha(c) || (c==\'_\') || isdigit(c))\r\n		{\r\n			if(index == 0)\r\n			{\r\n				obj->type = variable;\r\n				obj->data[0] = c;\r\n				obj->data[1] = 0;\r\n				buffer++;\r\n				c = *buffer;\r\n				index++;\r\n			}\r\n			else\r\n			{\r\n				obj->data = (char *) realloc(obj->data, 2*sizeof(char) + index);\r\n				obj->data[index] = c;\r\n				obj->data[index + 1] = 0;\r\n				buffer++;\r\n				c = *buffer;		\r\n				index++;\r\n			}\r\n		}\r\n		if (c == \'=\')\r\n		{\r\n			obj->data = (char *) realloc(obj->data, 2*sizeof(char) + index);\r\n			obj->data[index] = c;\r\n			obj->data[index + 1] = 0;\r\n			buffer++;\r\n			c = *buffer;		\r\n			index++;\r\n		}\r\n		*position = index;\r\n		return obj;\r\n	}\r\n	free(obj->data);\r\n	free(obj);\r\n	return NULL;\r\n}\r\n	\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (682,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct item {\r\n        void *data;\r\n        struct item *next;\r\n};\r\n\r\ntypedef struct item stack;\r\n\r\nstack *create ()\r\n{\r\n        stack *p = (stack *) malloc(sizeof(*p));\r\n        p->next = NULL;\r\n        p->data = NULL;\r\n        return p;\r\n}\r\n\r\nvoid push (stack **st, void *value)\r\n{\r\n        stack *p = (stack *) malloc(sizeof(*p));\r\n        p->data = value;\r\n        p->next = *st;\r\n        *st = p;\r\n}\r\n\r\nvoid pop (stack **st)\r\n{\r\n        stack *p = *st;\r\n        *st = p->next;\r\n		free(p->data);\r\n        free (p);\r\n}\r\n\r\nvoid *top (stack *st)\r\n{\r\n        return (st->data);\r\n}\r\n\r\nint empty (stack *st)\r\n{\r\n	return (st->next != NULL);\r\n}\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (683,'#include \"var.h\"\r\n\r\n\r\nvoid set_value (var *head, char *name, int value)\r\n{\r\n	var *ptr;\r\n	var* prev;\r\n	int is_founded = 0;\r\n	ptr = head;\r\n	prev = head;\r\n	while (ptr != NULL)\r\n	{\r\n		if (strcmp(ptr->name,name) == 0)\r\n		{\r\n			ptr->value = value;\r\n			is_founded = 1;\r\n			break;\r\n		}\r\n		prev = ptr;\r\n		ptr = ptr->next;\r\n	}\r\n	if(!is_founded)\r\n	{\r\n		var *new_var = (var *)malloc (sizeof(var));\r\n		new_var->name = strdup(name);\r\n		new_var->value = value;\r\n		new_var->next = NULL;\r\n\r\n		prev->next = new_var;\r\n	}\r\n}\r\n\r\n\r\nint get_value (var *head, char *name)\r\n{\r\n	var *ptr = head;\r\n	while (ptr != NULL)\r\n	{\r\n		if (strcmp(ptr->name,name) == 0)\r\n		{\r\n			return ptr->value;\r\n		}\r\n		ptr = ptr->next;\r\n	}\r\n	return 0;\r\n}\r\n\r\nvoid clean_up (var *head)\r\n{\r\n	var *ptr = head;\r\n	while (ptr != NULL)\r\n	{\r\n		var *cleaner = ptr->next;\r\n		free(ptr->name);\r\n		free(ptr);\r\n		ptr = cleaner;\r\n	}\r\n}','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (684,'#include<stdio.h>\r\n#include\"Stack.h\"\r\n#include<ctype.h>\r\n#include<stdlib.h>\r\n#include \"var.h\" \r\n#include<string.h>\r\nint *int_p (int a)\r\n{\r\n	int *tmp = malloc ( sizeof(int) ) ;\r\n	if ( !tmp )\r\n	{\r\n		perror ( \"malloc \\n\" ) ;\r\n		return NULL ;\r\n	}\r\n//	printf(\"allocated int at address %p\\n\", tmp);\r\n	*tmp = a ;\r\n	return tmp ;\r\n}\r\nchar *char_p ( char a )\r\n{\r\n	char *tmp = malloc (1) ;\r\n	if ( !tmp )\r\n	{\r\n		perror( \"malloc \\n\" ) ;\r\n		return NULL ;\r\n	}\r\n//	printf(\"allocated char at address %p\\n\", tmp);\r\n	*tmp = a ;\r\n	return tmp ;\r\n}\r\n\r\nvoid makenull_deep(stack *st)\r\n{\r\n	while (!empty(*st))\r\n	{\r\n//		printf(\"freeing data at address %p\\n\", top(*st));\r\n		free(top(*st));\r\n		pop(st);\r\n	}\r\n}\r\n\r\nvoid pushout ( stack *st1, stack *st2, int *Zero )\r\n{\r\n	int *t1, *t2, *res ;\r\n	int R = 0 ;\r\n	char *r ;\r\n	if (empty(*st2))\r\n	{\r\n		printf(\"Error in expression\\n\");\r\n		makenull_deep(st1);\r\n		makenull_deep(st2);\r\n		return;\r\n	}\r\n	t1 = (int *)top( *st2 ) ;\r\n	pop ( st2 ) ;\r\n	if (empty(*st2))\r\n	{\r\n		printf(\"Error in expression\\n\");\r\n		free(t1);\r\n		makenull_deep(st1);\r\n		makenull_deep(st2);\r\n		return;\r\n	}\r\n	t2 = (int *)top( *st2 ) ;\r\n	pop ( st2 ) ;\r\n	r = (char *)top( *st1 ) ;\r\n	pop ( st1 ) ;\r\n	if ( (*r) == \'+\' )\r\n		R = *t1 + *t2 ;\r\n	if ( (*r) == \'-\' )\r\n		R = *t2 - *t1 ;\r\n	if ( (*r) == \'*\' )\r\n		R = *t1 * (*t2) ;\r\n	if ( (*r) == \'/\' )\r\n	{\r\n		if ( *t1 )\r\n			R = *t2 / (*t1) ;\r\n		else \r\n		{\r\n			(*Zero) = 1;\r\n			printf ( \"Error: Division by zero \\n\" );\r\n			makenull_deep(st1);\r\n			makenull_deep(st2);\r\n			return;\r\n		}\r\n	}\r\n	res = int_p( R ) ;\r\n	push ( st2, res ) ;\r\n	free(t1);\r\n	free(t2);\r\n	free(r);\r\n}\r\nint pr( char c )\r\n{ switch (c)\r\n	{\r\n		case \'(\':\r\n		case \')\': return 0 ;\r\n		case \'+\':\r\n		case \'-\': return 1 ;\r\n		case \'*\':\r\n		case \'/\': return 2 ;\r\n	}\r\n	return 0;\r\n\r\n}\r\nint calc ( )\r\n{\r\n	extern hkod *H[100];\r\n	extern stack st1,st2;\r\n	char c;\r\n	int a, flg=0, nul=0, alpha = 0, allocated = 0, used = 0, zero = 0;\r\n	int *tmp;\r\n	char *ctmp, *name = NULL;\r\n	while((c=getchar())!=\'\\n\')\r\n	{	\r\n		\r\n		if ( isalpha (c) || c == \'_\' || (isdigit(c)&&alpha) )\r\n		{\r\n			if ( allocated == used )\r\n			{\r\n				ctmp = realloc ( name, allocated + 10);\r\n				if ( !ctmp )\r\n				{\r\n					perror (\"realloc \\n\");\r\n				}\r\n				name = ctmp;\r\n				allocated += 10;\r\n			}\r\n				name[ used ] = c;\r\n				used++;\r\n				if ( name )\r\n					name[ used ] = 0;\r\n				alpha = 1;\r\n		}\r\n		else \r\n		{\r\n\r\n			if(empty(st2)&&!name)\r\n				nul=1;\r\n			if(isdigit(c))\r\n			{\r\n				nul = 0;\r\n				if(flg)\r\n				{\r\n					int *old;\r\n					a= 10*a + c-\'0\';\r\n					old = top(st2);\r\n					free(old);\r\n					pop(&st2);\r\n					tmp=int_p(a);\r\n					push(&st2,tmp);\r\n				}\r\n				else\r\n				{\r\n					flg=1;\r\n					a=c-\'0\';\r\n					tmp=int_p(a);\r\n					push(&st2,tmp);\r\n				}\r\n			}\r\n			else\r\n			{\r\n				if ( name )\r\n				{\r\n					a = get_value ( name, H );\r\n					tmp = int_p(a);\r\n					push ( &st2, tmp );\r\n					free ( name );\r\n					name = NULL;\r\n					allocated = 0;\r\n					used = 0;\r\n					alpha = 0;\r\n				}\r\n				flg=0;\r\n				if ( c==\'(\')\r\n				{\r\n					ctmp=char_p(c);\r\n					push(&st1,ctmp);\r\n					nul = 1;\r\n				\r\n				}\r\n				if(c==\')\')\r\n				{\r\n					while(!empty(st1)&&(*(char *)top(st1))!=\'(\')\r\n					{\r\n\r\n						pushout(&st1,&st2,&zero);\r\n						if ( zero )\r\n						{	\r\n							free( name);\r\n							free ( tmp );\r\n							free( ctmp );\r\n							makenull_deep( &st1);\r\n							makenull_deep( &st2 );\r\n							return 0;\r\n						}\r\n					}\r\n					if (empty(st1))\r\n					{\r\n						makenull_deep(&st1);\r\n						makenull_deep(&st2);\r\n						return 0;\r\n					}\r\n					if((*(char *)top(st1))==\'(\')\r\n					{\r\n						free(top(st1));\r\n						pop(&st1);\r\n					}\r\n				\r\n				}\r\n				if(c==\'+\'||c==\'*\'||c==\'-\'||c==\'/\')\r\n				{\r\n					if( nul && c== \'-\')\r\n					{\r\n						tmp = int_p(0);\r\n						push( &st2, tmp );\r\n						nul = 0;\r\n					\r\n					}\r\n					if(empty(st1))\r\n					{\r\n						ctmp=char_p(c);\r\n						push(&st1,ctmp);\r\n						continue;\r\n					}\r\n					while((!empty(st1))&&(pr(c)<=pr(*(char *)top(st1))))\r\n					{\r\n						pushout( &st1, &st2, &zero );\r\n						if ( zero )\r\n						{\r\n							free ( name );\r\n							free ( tmp );\r\n							free ( ctmp );\r\n							makenull_deep(&st1);\r\n							makenull_deep(&st2);\r\n						}\r\n					}\r\n					ctmp=char_p(c);\r\n					push(&st1,ctmp);\r\n				\r\n				}\r\n			}\r\n		}\r\n			\r\n	}\r\n	if( name )\r\n	{\r\n		a = get_value(name, H);\r\n		tmp = int_p(a);\r\n		push(&st2, tmp );\r\n		free(name);\r\n	}\r\n	while(!empty(st1))\r\n	{\r\n		pushout(&st1,&st2, &zero);\r\n                if ( zero )\r\n                {\r\n	                free ( name );\r\n        	        free ( tmp );\r\n                        free ( ctmp ); \r\n                        makenull_deep(&st1);\r\n                        makenull_deep(&st2);\r\n			return 0;\r\n		}\r\n	}\r\n	if (empty(st2))\r\n	{\r\n		//free(ctmp);\r\n		makenull_deep(&st1);\r\n		makenull_deep(&st2);\r\n		return 0;\r\n	}\r\n	tmp=top(st2);\r\n	pop ( &st2 );\r\n	a = *tmp;\r\n	free (tmp);\r\n	return a ;\r\n}\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (685,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include \"var.h\"\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include \"Stack.h\"\r\n\r\n#define FREE(p) do { printf(\"free() at %s:%d\\n\", __FILE__, __LINE__); free(p); p = NULL; } while (0)\r\n\r\nint calc() ;\r\nhkod *H[100] = { NULL };\r\nstack st1;\r\nstack st2;\r\nint main( )\r\n{\r\n	int i ,res, allocated = 0, used = 0, alpha = 0, val, *p=NULL, nul = 1, h = 0;\r\n	char c,*q =\"quit\", *tmp = NULL, *name = NULL;\r\n	st1=creat();\r\n	st2=creat();\r\n	while ( scanf(\"%c\",&c)==1)\r\n	{\r\n		if( c == \'+\' || c == \'/\' || c == \'*\' || (c ==\'-\'&&!nul))\r\n		{\r\n			if (!name)\r\n			{\r\n				printf(\"Error in expression\\n\");\r\n				makenull_deep(&st1);\r\n				makenull_deep(&st2);\r\n				continue;\r\n			}\r\n			res = get_value( name, H );\r\n			p = malloc(sizeof(int));\r\n			if(!p)\r\n			{\r\n				perror(\"malloc\\n\");\r\n				return 0;\r\n			}\r\n			*p=res;\r\n			push(&st2,p);\r\n			ungetc(c, stdin);\r\n			res = calc();\r\n			printf( \"%d\\n\",res);\r\n			makenull_deep(&st1);\r\n			makenull_deep(&st2);\r\n			free (name);\r\n			name = NULL;\r\n			allocated = 0;\r\n			used = 0;\r\n			alpha = 0;\r\n			continue;\r\n		}\r\n		else if( isdigit (c) || c == \'(\' || c == \'-\' )\r\n		{\r\n			ungetc( c,stdin );\r\n			res = calc();\r\n			printf( \"%d\\n\",res);\r\n			makenull_deep(&st1);\r\n			makenull_deep(&st2);\r\n		}\r\n		else if ( isalpha (c) || c == \'_\' || (isdigit(c)&&alpha) )\r\n		{\r\n			if ( allocated == used )\r\n			{\r\n				tmp = realloc ( name, allocated + 10);\r\n				if ( !tmp )\r\n				{\r\n					perror (\"realloc \\n\");\r\n				}\r\n				name = tmp;\r\n				allocated += 10;\r\n			}\r\n			name[ used ] = c;\r\n			used++;\r\n			if ( name && (used!=allocated))\r\n			{\r\n				name[ used ] = 0;\r\n			\r\n			}\r\n			if (name&&used==allocated)	\r\n			{\r\n				tmp = realloc ( name, allocated +1);\r\n				if ( !tmp )\r\n				{\r\n					perror (\"realloc \\n\");\r\n				}\r\n				name = tmp;\r\n				allocated++;\r\n				name[used]=0;\r\n				\r\n			}\r\n			alpha = 1;\r\n			nul = 0;\r\n		}\r\n		else if ( c == \'=\')\r\n		{\r\n			res = calc();\r\n			set_value ( name, res, H );\r\n			h = 1;\r\n			free ( name );\r\n			tmp=NULL;\r\n			name = NULL;\r\n			allocated = 0;\r\n			used = 0;\r\n			alpha = 0;\r\n			nul =1;\r\n		}\r\n		else if ( c == \'\\n\' )\r\n		{\r\n			if (name && q && strcmp ( q, name) == 0)\r\n			{\r\n				if (name)\r\n					free (name);\r\n				tmp=NULL;\r\n				if(p)\r\n					FREE(p);\r\n				break;\r\n			}\r\n			if (name)\r\n			{\r\n				val = get_value ( name, H );\r\n				printf ( \"%d\\n\", val );\r\n				free ( name );\r\n			}\r\n			name = NULL;\r\n			allocated = 0;\r\n			used = 0;\r\n			alpha = 0;\r\n			nul=1;\r\n			makenull_deep(&st1);\r\n			makenull_deep(&st2);\r\n		}\r\n		else\r\n		{\r\n			printf(\"Error in expression!\\n\");\r\n		}\r\n	}\r\n	makenull_deep(&st1);\r\n	makenull_deep(&st2);\r\n	if ( h )\r\n	{\r\n		cleanup(H);\r\n	}\r\n	return 0 ;\r\n\r\n\r\n}\r\n\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (686,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#include \"Stack.h\"\r\nstruct item{\r\n	void *data;\r\n	struct item *next;\r\n};\r\n\r\nvoid push(stack *st, void *d)\r\n{\r\n	struct item *p=(void *)malloc(sizeof(*p));\r\n	if(!p)\r\n	{\r\n		perror(\"malloc\\n\");\r\n	}\r\n	p->data=d;\r\n	p->next=st->head;\r\n	st->head=p;\r\n}\r\nvoid pop(stack *st)\r\n{\r\n	struct item *p=st->head;\r\n	st->head=p->next;\r\n	free(p);\r\n}\r\nint empty(stack st)\r\n{\r\n	return(st.head==NULL);\r\n}\r\nvoid *top(stack st)\r\n{\r\n	void *p=st.head->data;\r\n\r\n	return p;\r\n}\r\nvoid makenull(stack *st)\r\n{\r\n	while(!empty(*st))\r\n	{\r\n		pop(st);\r\n	}\r\n}\r\nstack creat()\r\n{\r\n	stack st;\r\n	st.head= NULL;\r\n	return st;\r\n}\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (687,'#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#include<ctype.h>\r\n#define SIZE 100\r\n#include \"var.h\"\r\nunsigned int hashkod ( char *s )\r\n{\r\n	unsigned int res=0;\r\n	for(;*s;s++)\r\n	\r\n		res=res*37+*s * 38;\r\n		return(res%SIZE);\r\n}\r\n\r\nvoid set_value( char *name, int value, hkod *(*H))\r\n{\r\n\r\n	unsigned int K;\r\n	int fl=0;\r\n	hkod *p=NULL ;\r\n	K = hashkod ( name );\r\n	p = H[K];\r\n	for(;p;p=p->next)\r\n	{\r\n		fl=0;\r\n		if(strcmp(p->name,name)==0)\r\n		{\r\n			fl=1;\r\n			break;\r\n		}\r\n	}\r\n	if(!fl)\r\n	{\r\n		\r\n		p = malloc(sizeof(*p));\r\n		p -> name = malloc( strlen(name) + 1);\r\n		strcpy ( p->name, name ) ; \r\n		p->value =value;\r\n		p->next=H[K];\r\n		H[K]=p;\r\n	}\r\n	else\r\n	{\r\n		p->value=value;\r\n	}\r\n	\r\n}\r\nint get_value( char * name , hkod *( *H))\r\n{\r\n	unsigned int K=hashkod(name);\r\n	hkod *p = H[ K ];\r\n	for(;p;p=p->next)\r\n	{\r\n		if ( strcmp(p->name, name) == 0)\r\n		{\r\n			return p->value;\r\n		}\r\n	}\r\n	return 0;\r\n}\r\nvoid cleanup (  hkod *( *H) )\r\n{\r\n	int i=0;\r\n	hkod *p=H[0], *tmp;\r\n	for ( i=0; i<SIZE; i++)\r\n	{\r\n		p=H[i];\r\n		for(;p;)\r\n		{\r\n			tmp=p;\r\n			p=p->next;\r\n			free(tmp->name);\r\n			free(tmp);\r\n		}\r\n	}\r\n}\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (688,'#include \"stack.h\"\n\nstack * newstack (void)\n{\n    stack * tmp;\n    tmp = malloc(sizeof(stack));\n    tmp->head = NULL;\n    return(tmp);\n}\n\nvoid push(stack *st, void *data)\n{\n    stackel *tmp;\n    tmp = (stackel *) malloc(sizeof(stackel));\n    tmp->elt = data;\n    tmp->next = st->head;\n    st->head = tmp;\n} \n\nvoid * top (stack *st)\n{\n    return(st->head->elt);\n}\n\nint empty (stack *st)\n{\n    return(st->head == NULL);\n}\n\nvoid pop (stack *st)\n{\n    stackel *tmp;\n    if(st->head!=NULL)\n    {\n	tmp = st->head;\n	st->head = st->head->next;\n	free(tmp);\n    }\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (689,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct storageel storageel;\ntypedef struct pair pair;\n\nstruct pair\n{\n    char* name;\n    int value;\n};\n\nstruct storageel {\n    pair elt;\n    storageel* next;\n};\n\nvoid setvalue (char* name,int value);\nint getvalue (char* name);\nvoid cleanup( void);\n\nstorageel* head = NULL;\n\nstorageel* find(char* name)\n{\n    storageel* a;\n    a=head;\n    while((a!=NULL)&&(strcmp(name,a->elt.name)!=0))\n	a=a->next;\n    return a;\n}\n\nvoid setvalue (char* name,int value)\n{\n    storageel* tmp;\n    tmp=find(name);\n    if (tmp!=NULL)\n	tmp->elt.value=value;\n    else\n    {\n	tmp = (storageel *) malloc(sizeof(storageel));\n	tmp->elt.value=value;\n	tmp->elt.name = (char*)malloc(sizeof(char)*(strlen(name)+1));\n	strcpy(tmp->elt.name, name);\n	tmp->next = head;\n	head = tmp;\n    }\n}\n\nint getvalue(char* name)\n{\n    storageel* tmp;\n    tmp=find(name);\n    if (tmp!=NULL)\n	return tmp->elt.value;\n    return 0;//!!!!!\n}\n\n\nvoid cleanup ()\n{\n    storageel *tmp;\n    while(head!=NULL)\n    {\n	tmp = head;\n	head = head->next;\n	free(tmp->elt.name);\n	free(tmp);\n    }\n}\n\nint main()\n{\n    setvalue(\"a\",3);//a=3\n    setvalue(\"b\",5);//b=5\n    printf(\"a*b=%d*%d=%d\\n\",getvalue(\"a\"),getvalue(\"b\"),getvalue(\"a\")*getvalue(\"b\"));\n    cleanup();\n}\n\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (690,'#include <stdio.h>\n#include <fcntl.h>\n\nint main()\n{\n	char c;\n\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n	c = getchar();\n	putchar(c);\n	fflush(stdout);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (691,'#include \"stack.h\"\n#include <stdlib.h>\n#include <memory.h>\n\nstruct stackHead\n{\n	struct stackItem *head;\n	size_t stackItemSize;\n};\n\nstruct stackItem\n{\n	struct stackItem *prev;\n	void *data;\n};\n\nint isEmpty(struct stackHead *stack)\n{\n	return (stack->head == NULL) ? 1 : 0;\n}\n\nint push(struct stackHead *stack, void *data, size_t size)\n{\n	struct stackItem *newHead = NULL;\n	if (size != stack->stackItemSize)\n		return 0;\n	newHead = (struct stackItem*)malloc(sizeof(struct stackItem));\n	newHead->data = malloc(size);\n	memcpy(newHead->data, data, size);\n	newHead->prev = stack->head;\n	stack->head = newHead;\n	return 1;\n}\n\nvoid delStackItem(struct stackHead *stack)\n{\n	struct stackItem *temp = stack->head;\n	if(!isEmpty(stack))\n	{\n		free(stack->head->data);\n		stack->head = stack->head->prev;\n		free(temp);\n	}\n}\nvoid *getTopVal(struct stackHead *stack)\n{\n	if (stack == NULL || stack->head == NULL)\n		return NULL;\n	return stack->head->data;\n}\n\nstruct stackHead *createStack(size_t size)\n{\n	struct stackHead *newStack = (struct stackHead*)malloc(sizeof(*newStack));\n	if(newStack)\n	{\n		newStack->stackItemSize = size;\n		newStack->head = NULL;\n	}\n	return newStack;\n}\n\nvoid releaseStack(struct stackHead *stack)\n{\n	struct stackItem *temp = NULL;\n	if(stack)\n	{\n		while(!isEmpty(stack))\n		{\n			temp = stack->head;\n			free(stack->head->data);\n			stack->head = stack->head->prev;\n			free(temp);\n		}\n		free(stack);\n	}\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (692,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"hash.h\"\n\nstruct hashTableListItem\n{\n	char *varName;\n	int varValue;\n	struct hashTableListItem *next;\n};\n\nstruct hashTableList\n{\n	struct hashTableListItem *head;\n};\n\nstruct hashTable\n{\n	struct hashTableList *list;\n	int size;\n	int (*calculateHash)(char* word, int hashTableSize);\n};\n\nint sCalculateHash(char *word, int hashTableSize)\n{\n	int res = 0;\n	for( ; *word; word++)\n	{\n		res = res * *word * 37 % hashTableSize;\n	}\n	return res;\n}\n\nstruct hashTable *createHashTable(int size, int (*calculateHash)(char *word, int hashTableSize))\n{\n	struct hashTable *newHashTable = NULL;\n	struct hashTableList *newHashTableList = NULL;\n	newHashTable = (struct hashTable*)calloc(1, sizeof(struct hashTable));\n	newHashTableList = (struct hashTableList*)calloc(size, sizeof(struct hashTableList));\n	if(newHashTable)\n	{\n		newHashTable->size = size;\n		if(newHashTableList)\n			newHashTable->list = newHashTableList;\n	}\n	newHashTable->calculateHash = &sCalculateHash;\n	return newHashTable;\n}\n\nvoid releaseHashTable(struct hashTable *table)\n{\n	struct hashTableListItem *itemTemp = NULL;\n	int i = 0;\n	\n	for(i = (table->size - 1) ; i >= 0; i--)\n	{\n		while(table->list[i].head)\n		{\n			itemTemp = table->list[i].head;\n			table->list[i].head = itemTemp->next;\n			free(itemTemp->varName);\n			free(itemTemp);\n		}\n	}\n	free(table->list);\n	free(table);\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nvoid addHashTableItem(char *name, int value, struct hashTable *table)\n{\n	struct hashTableListItem *newItem= NULL;\n	int hashCode = table->calculateHash(name, table->size);\n\n	if(hashCode >= table->size || hashCode < 0)\n	{\n		printf(\"Incorrect calculateHash function!\\n\'%s\'[%d] is not added!\\n\", name, value);\n		return;\n	}\n\n	newItem = (struct hashTableListItem*)calloc(1, sizeof(struct hashTableListItem));\n	newItem->next = table->list[hashCode].head;\n	newItem->varName = (char*)calloc(strlen(name) + 1, 1);\n	strcpy(newItem->varName, name);\n	newItem->varValue = value;\n\n	table->list[hashCode].head = newItem;\n}\n\nint delHashTableItem(char *name, struct hashTable *table)\n{\n	struct hashTableListItem *item = NULL;\n	struct hashTableListItem *prevItem = NULL;\n	int hashCode = 0;\n	int found = 0;\n\n	hashCode = table->calculateHash(name, table->size);\n	item = table->list[hashCode].head;\n	for(; item->next; prevItem = item, item = item->next)\n	{\n		if(strcmp(item->varName, name) == 0)\n		{\n			found = 1;\n			break;\n		}\n	}\n\n	if(found)\n	{\n		if(!prevItem)\n			table->list[hashCode].head = item->next;\n		else\n			prevItem->next = item->next;\n		free(item->varName);\n		free(item);\n		return 1;\n	}\n	return 0;	//Element not found\n}\n\nvoid setHashTableItemValue(char *name, int value, struct hashTable *table)\n{\n	struct hashTableListItem *item = NULL;\n	int hashCode = 0;\n	int found = 0;\n\n	hashCode = table->calculateHash(name, table->size);\n	item = table->list[hashCode].head;\n	for(; item; item = item->next)\n	{\n		if(strcmp(item->varName, name) == 0)\n		{\n			found = 1;\n			break;\n		}\n	}\n\n	if(found)\n		item->varValue = value;\n}\n\nint *getHashTableItemValue(char *name, struct hashTable *table)\n{\n	struct hashTableListItem *item = NULL;\n	int hashCode = 0;\n	int found = 0;\n\n	hashCode = table->calculateHash(name, table->size);\n	item = table->list[hashCode].head;\n	for(; item; item = item->next)\n	{\n		if(strcmp(item->varName, name) == 0)\n		{\n			found = 1;\n			break;\n		}\n	}\n\n	if(found)\n		return &(item->varValue);\n	return NULL;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (693,'#include <stdio.h>\n#include <stdlib.h>\n#include \"../stack/stack.h\"\n#include \"../hash/hash.h\"\n\nchar *readWord(FILE* f)\n{\n	char *p = NULL;\n	char c = 0;\n	int i = 0;\n\n	size_t allocated = 0;\n	size_t used = 0;\n	\n	while(c = fgetc(f))\n	{\n		if((c >= \'a\' && c <= \'z\') || (c >= \'A\' && c <= \'Z\') || (c >= \'0\' && c <= \'9\') || c == \'_\')\n		{\n			if(allocated <= (used + 1))\n			{\n				char *temp = NULL;\n				temp = realloc((void*)p, allocated += (size_t)10);\n				if(temp)\n					p = temp;\n				else\n				{\n					printf(\"Can not allocate memory for new word!..\\n=(\\n\");\n					exit(1);\n				}\n			}\n			p[used++] = c;\n		}\n		else\n			break;\n	}\n	ungetc(c, f);\n	p[used++] = 0;\n	return p;\n}\n\nint readNum(FILE *f)\n{\n	int res = 0;\n	char c = 0;\n	while((c = fgetc(f)) >= \'0\' && c <= \'9\')\n		res = res * 10 + (c - \'0\');\n	ungetc(c, f);\n	return res;\n}\n\nint calculateOperation(char operation, struct stackHead *numberStack)\n{\n	int a = 0;\n	int b = 0;\n	int res = 0;\n\n	if(!isEmpty(numberStack))\n	{\n		b = *(int*)getTopVal(numberStack);\n		delStackItem(numberStack);\n	}\n	else\n		return 0;\n	if(!isEmpty(numberStack))\n	{\n		a = *(int*)getTopVal(numberStack);\n		delStackItem(numberStack);\n	}\n	else\n		return 0;\n\n	switch(operation)\n	{\n	case \'+\':\n		res = a + b;\n		break;\n	case \'-\':\n		res = a - b;\n		break;\n	case \'*\':\n		res = a * b;\n		break;\n	case \'/\':\n		res = a / b;\n		break;\n	}\n\n	push(numberStack, (void*)(&res), sizeof(res));\n	return 1;\n}\n\nvoid pushVariableValue(char *variableName, struct hashTable *variables, struct stackHead *numberStack)\n{\n	int varValue = 0;\n	varValue = *getHashTableItemValue(variableName, variables);\n	push(numberStack, (void*)(&varValue), sizeof(int));\n}\n\nvoid calculateExpressionInBrackets(struct stackHead *operationStack, struct stackHead *numberStack)\n{\n	int c = 0;\n	while((c = *(char*)getTopVal(operationStack)) != \'(\')\n	{\n		calculateOperation(c, numberStack);\n		delStackItem(operationStack);\n	}\n	delStackItem(operationStack);\n}\n\nvoid parse(FILE *input, struct stackHead *operationStack, struct stackHead *numberStack, struct hashTable *variables, int Sign)\n{\n	const int zero = 0;\n	const char openingBracket = \'(\';\n	const char closingBracket = \')\';\n\n	int priority[8] = {0, 0, 2, 1, 0, 1, 0, 2};\n\n	int character = 0;\n	int mayBeSign = Sign;\n\n	int bracketsLevel = 0;\n	struct stackHead *bracketsStack = createStack(sizeof(int));\n\n	while((character = fgetc(input)) != EOF)\n	{\n		if(character >= \'0\' && character <= \'9\')\n		{\n			int number = 0;\n			ungetc(character, input);\n			number = readNum(input);\n			push(numberStack, (void*)(&number), sizeof(int));\n			mayBeSign = 0;\n		}\n		else if(character == \'(\')\n		{\n			char c = character;\n			mayBeSign = 1;\n			bracketsLevel++;\n			push(operationStack, (void*)(&c), 1);\n		}\n		else if(character == \')\')\n		{\n			calculateExpressionInBrackets(operationStack, numberStack);\n			mayBeSign = 0;\n			bracketsLevel--;\n			if(!isEmpty(bracketsStack))\n				if(*(int*)getTopVal(bracketsStack) - bracketsLevel == 1)\n				{\n					ungetc(character, input);\n					delStackItem(bracketsStack);\n				}\n		}\n		else if(character == \'+\' || character == \'-\' || character == \'*\' || character == \'/\')\n		{\n			if(mayBeSign == 1)	//unary operation\n				if(character != \'-\' && character != \'+\')	//sign validation\n				{\n					printf(\"Parsing error!\\n\");\n					exit(1);\n				}\n				else\n				{\n					char c = character;\n					push(operationStack, (void*)(&openingBracket), 1);\n					bracketsLevel++;\n					push(numberStack, (void*)(&zero), sizeof(zero));\n					push(operationStack, (void*)(&c), 1);\n					\n					character = fgetc(input);\n					if(character >= \'0\' && character <= \'9\')	//next is value\n					{\n						int num = 0;\n						ungetc(character, input);\n						num = readNum(input);\n						push(numberStack, (void*)(&num), sizeof(int));\n						calculateExpressionInBrackets(operationStack, numberStack);\n						bracketsLevel--;\n						mayBeSign = 0;\n					}\n					else if((character >= \'a\' && character <= \'z\') || (character >= \'A\' && character <= \'Z\') || character == \'_\')	//next is variable\n					{\n						char *word = readWord(input);\n						ungetc(character, input);\n						pushVariableValue(word, variables, numberStack);\n						calculateExpressionInBrackets(operationStack, numberStack);\n						bracketsLevel--;\n						mayBeSign = 0;\n					}\n					else if(character == \'(\')	//next is expression\n					{\n						char c = character;\n						push(bracketsStack, (void*)(&bracketsLevel), sizeof(int));\n						push(operationStack, (void*)(&c), 1);\n					}\n				}\n			else	//binary operation\n			{\n				char c = character;\n				while(!isEmpty(operationStack) && (priority[*(char*)getTopVal(operationStack) - (char)40] >= priority[character - (char)40]))\n				{\n					calculateOperation(*(char*)getTopVal(operationStack), numberStack);\n					delStackItem(operationStack);\n				}\n				push(operationStack, (void*)(&c), 1);\n				mayBeSign = 1;\n			}\n		}\n		else if((character >= \'a\' && character <= \'z\') || (character >= \'A\' && character <= \'Z\') || character == \'_\')\n		{\n			char *x;\n			ungetc(character, input);\n			pushVariableValue((x = readWord(stdin)), variables, numberStack);\n			free(x);\n			mayBeSign = 0;\n		}\n		else if(character == \'\\n\')\n		{\n			while(!isEmpty(operationStack))\n			{\n				calculateOperation(*(char*)getTopVal(operationStack), numberStack);\n				delStackItem(operationStack);\n			}\n			printf(\"\\t[%d]\\n\", *(int*)getTopVal(numberStack));\n			mayBeSign = 1;\n			releaseStack(bracketsStack);\n			return;\n		}\n	}\n\n	releaseStack(bracketsStack);\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (694,'#include \"hash/hash.h\"\n#include \"stack/stack.h\"\n#include \"parser/parser.h\"\n#include <stdlib.h>\n\nint main()\n{\n	int c = 0;\n\n	struct stackHead *numberStack = createStack(sizeof(int));\n	struct stackHead *operationStack = createStack(sizeof(char));\n	struct hashTable *variables = createHashTable(10, sCalculateHash);\n	\n	while((c = fgetc(stdin)) != EOF)\n	{\n		if((c >= \'a\' && c <= \'z\') || (c >= \'a\' && c <= \'z\') || c == \'_\')\n		{\n			char *varName = NULL;\n			ungetc(c, stdin);\n			varName = readWord(stdin);\n			while((c = fgetc(stdin)) == \' \');\n			if(c == \'=\')\n			{\n				if(getHashTableItemValue(varName, variables) == NULL)	//variable not found\n				{\n					parse(stdin, operationStack, numberStack, variables, 1);\n					addHashTableItem(varName, *(int*)getTopVal(numberStack), variables);\n				}\n				else	//variable found\n				{\n					parse(stdin, operationStack, numberStack, variables, 0);\n					setHashTableItemValue(varName, *(int*)getTopVal(numberStack), variables);\n				}\n			}\n			else\n			{\n				ungetc(c, stdin);\n				pushVariableValue(varName, variables, numberStack);\n				parse(stdin, operationStack, numberStack, variables, 0);\n			}\n\n			free(varName);	\n		}\n		else if(c == \' \')\n		{}\n		else\n		{\n			ungetc(c, stdin);\n			parse(stdin, operationStack, numberStack, variables, 1);\n		}\n	}\n\n	releaseHashTable(variables);\n	releaseStack(numberStack);\n	releaseStack(operationStack);\n\n	return 0;\n}\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (695,'#include<stdio.h>\n\n\nint isprime(int a)\n{\n	int b=a-1;\n	while(b > 1 && a % b != 0 )\n	{\n		b=b-1;\n	}\n	if(b == 1)\n		return 0;\n	return 1;\n\n\n}\nint main()\n{\n	int A[5],i,l=0;\n\n	\n	for ( i = 0; i < 5 ; i++)\n	{\n		\n		printf(\"??????? ??????? %d\\n\",i);\n		scanf(\"%d\", &A[i]);\n	}\n		\n	for ( i = 0; i < 5; i++)\n	{\n		l=l+isprime(A[i]);\n	}\n	if (l>0)\n		printf(\"? ??????? ???? ????????? ?????\\n\");\n	else\n		printf(\"??? ???????? ??????? ?????\\n\");\n\n\nreturn 0;\n}\n\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (696,'#include<stdio.h>\n\nint main()\n{ int i=0;\nint k=0;\nint q,w,e;\nint d1,m1,y1;\nint d2,m2,y2;\nint A[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nscanf(\"%d%d%d\",&d1,&m1,&y1);\nscanf(\"%d%d%d\",&d2,&m2,&y2);\n\nq=d1;\nw=m1;\ne=y1;\nwhile(d1!=d2||m1!=m2||y1!=y2)\n{  k=k+1;\nd1++;\nif((y1%400==0||(y1%4==0&&y1%100!=0))&&m1==2)\n	{   A[2]=29;\n	}\n\n	else\n\n		{A[2]=28;\n                }\n\n\n		if(d1>A[m1])\n		{d1=1;\n		m1++;\n\n	if(m1>12)\n		{m1=1;\n		y1++;\n		}\n		}\n}\n      printf(\"?-? %d/ %d/ %d/ ? %d/ %d/ %d   %d ????\\n\",q,w,e,d2,m2,y2,k+1);\nreturn 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (697,'#include<stdio.h>\n\nint main()\n{\nint day1, month1, year1, day2, month2, year2, S, nd, ld, b1number/*???-?? ???? ? ?????? ?????? ??????? ???????????? ???? */, b2number, month3, i, z, a, b, c;\n\n	printf(\"??????? ?????? (??????) ???? ? ??????? ???? ????? ??? \\n\");\n	scanf(\"%d %d %d\", &day1, &month1, &year1);\n	printf(\"??????? ?????? (???????) ???? ? ??????? ???? ????? ??? \\n\");\n	scanf(\"%d %d %d\", &day2, &month2, &year2);\nS=year2-year1-1;\nint lnumber=0;\nfor(i=year1+1; i<year2; i++)\n	{\n		if(i%400==0||(i%100!=0&&i%4==0))\n		lnumber=lnumber+1;\n	}\nld=lnumber*366; /*???-?? ???? ? ?????????? ?????*/\nnd=(S-lnumber)*365; /*???-?? ???? ? ?????????? ?????*/\n\nprintf(\"????? ??? ????? ??????????: %d\\n\", S);\nprintf(\"?? ??? ??????????: %d\\n\", lnumber);\nprintf(\"???? ? ??????????: %d\\n\", ld);\nprintf(\"???? ? ???????: %d\\n\", nd);\n\n/* ??????? ?????????? ???? ? ?????? ??????????? ???? */\nif (year1%400==0||(year1%100!=0&&year1%4==0))\n	{\n		if (month1==1)\n			a=366-day1;\n			else\n			{if (month1==2)\n				a=366-day1-31;\n				else\n				{if (month1==3)\n					a=366-day1-31-29;\n					else\n						{if (month1==4)\n							a=366-day1-31-29-31;\n							else\n								{if (month1==5)\n								a=366-day1-31-29-31-30;\n								else\n									{if (month1==6)\n									a=366-day1-31-29-31-30-31;\n									else\n										{if (month1==7)\n										a=366-day1-31-29-31-30-31-30;\n										else\n											{if (month1==8)\n											a=366-day1-31-29-31-30-31-30-31;\n											else\n												{if (month1==9)\n												a=366-day1-31-29-31-30-31-30-31-31;\n												else\n													{if (month1==10)\n													a=366-day1-31-29-31-30-31-30-31-31-30;\n													else\n														{if (month1==11)\n														a=366-day1-31-29-31-30-31-30-31-31-30-31;\n														else\n															{if (month1==12)\n															a=366-day1-31-29-31-30-31-30-31-31-30-31-30;\n															}}}}}}}}}}}a++;}\nelse\n{if (month1==1)\n	a=365-day1;\n	else\n	{if (month1==2)\n		a=365-day1-31;\n		else\n		{if (month1==3)\n			a=365-day1-31-29;\n			else\n				{if (month1==4)\n					a=365-day1-31-29-31;\n					else\n						{if (month1==5)\n						a=365-day1-31-29-31-30;\n						else\n							{if (month1==6)\n							a=365-day1-31-29-31-30-31;\n							else\n								{if (month1==7)\n								a=365-day1-31-29-31-30-31-30;\n								else\n									{if (month1==8)\n									a=365-day1-31-29-31-30-31-30-31;\n									else\n										{if (month1==9)\n										a=365-day1-31-29-31-30-31-30-31-31;\n										else\n											{if (month1==10)\n											a=365-day1-31-29-31-30-31-30-31-31-30;\n											else\n												{if (month1==11)\n												a=365-day1-31-29-31-30-31-30-31-31-30-31;\n												else\n													{if (month1==12)\n													a=365-day1-31-29-31-30-31-30-31-31-30-31-30;\n													}}}}}}}}}}}a++;}\n/* ??????? ???-?? ?? ?????? ??????????? ???? */\n\nif (year2%400==0||(year2%100!=0&&year2&4==0))\n	{\n		if (month2==1)\n			b=day2;\n			else\n				{if (month2==2)\n					b=day2+31;\n					else\n						{if (month2==3)\n							b=day2+31+29;\n							else\n								{if (month2==4)\n									b=day2+31+29+31;\n									else\n										{if (month2==5)\n											b=day2+31+29+31+30;\n											else\n												{if (month2==6)\n													b=day2+31+29+31+30+31;\n													else\n														{if (month2==7)\n															b=day2+31+29+31+30+31+30;\n															else\n																{if (month2==8)\n																	b=day2+31+29+31+30+31+30+31;\n																	else\n																		{if (month2==9)\n																			b=day2+31+29+31+30+31+30+31+31;\n																			else\n																				{if (month2==10)\n															b=day2+31+29+31+30+31+30+31+31+30;\n															else\n															{if (month2==11)\n															b=day2+31+29+31+30+31+30+31+31+30+31;\n															else\n															{if (month2==12)\n															b=day2+31+29+31+30+31+30+31+31+30+31+30;\n															}}}}}}}}}}}}\nelse\n{if (month2==1)\n	b=day2;\n	else\n		{if (month2==2)\n			b=day2+31;\n			else\n				{if (month2==3)\n					b=day2+31+28;\n					else\n						{if (month2==4)\n							b=day2+31+28+31;\n							else\n								{if (month2==5)\n									b=day2+31+28+31+30;\n										{if (month2==6)\n											b=day2+31+28+31+30+31;\n											else\n												{if (month2==7)\n													b=day2+31+28+31+30+31+30;\n													else\n														{if (month2==8)\n															b=day2+31+28+31+30+31+30+31;\n															else\n																{if (month2==9)\n																	b=day2+31+28+31+30+31+30+31+31;\n																	else\n																		{if (month2==10)\n																			b=day2+31+28+31+30+31+30+31+31+30;\n																			else\n																				{if (month2==11)\n																					b=day2+31+28+31+30+31+30+31+31+30+31;\n																					else\n																				{if (month2==12)\n																				b=day2+31+28+31+30+31+30+31+31+30+31+30;\n																				}}}}}}}}}}}}\n\nc=ld+nd+a+b;\nprintf(\"%d\\n\", c);\n\nreturn 0;\n}\n																																																																																																																																																																																																																																																																																																																																																												\n\n		\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (698,'#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n\nint main()\n{\n\n\n\n\nchar A[1000];\nint a,b,k,i,j;\nprintf(\"??????\\n\");\n\nfgets(A,1000,stdin);\n\nfor(k=0;A[k]!=0;k++)\n{ \n}\nk--;\n\ni=0;\nj=k-1;\nwhile(i<j)\n\n\n   { while(A[i]==\' \')\n     i++;\n\n     while(A[j]==\' \')\n	  j--;\n\n         \n	  if(A[i]==A[j])\n	  {i++;\n          j--;\n	  }\n	  else\n	  {\n		  printf(\"???????? %c ? %c\\n\", A[i], A[j]);\n		 printf(\"???\\n\");\n		 return 0;\n	  }\n\n\n\n   }\n\n   printf(\"??\\n\");\n\n   }\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (699,'#include <stdio.h>\n#include <string.h>\n\n\nint main()\n{\n	char s[1000];\n	int r;\n	int i;\n	int k;\n	int j=0;\n\n\n	printf (\"??????? ?????\\n\");\n	fgets (s,1000,stdin);\n\n	printf (\"??????? ??????????? ?????? ??????? ??????????:\");\n	scanf(\"%d\",&r );\n	\n	i=strlen (s)-1;\n\n	for (k=0;k<i;k++)\n	{\n		if (s[k]>\'9\')\n		{\n			printf(\"%d \", s[k]);\n			s[k]=s[k]-\'A\'+10;\n			printf(\"%d\\n\", s[k]);\n		}\n		else if (s[k]<=\'9\')\n			s[k]=s[k]-\'0\';\n	}\n	\n//	if (r!=10){\n	for (k=0;k<i;k++)\n	{\n		printf(\"%d\\n\", s[k]);\n		j=j*r+s[k];\n	}\n	printf(\"\\n ????? ? ????????????=%d\\n\",j);\n//}\n//else\n//{\n//	for (k=0;k<i;k++)\n//	{\n//		printf (\"%d/n\",s[k]);\n//	}\n//}\n	\n\n\n\n\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (700,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{ int i, j, b, l, r=0;\n int x=1;\n  char s[100];\n	printf(\"??????? ????????? ??????? ?????????: \");\n	scanf(\"%d\", &b);\n	printf(\"??????? ????? ? ??????? %d: \", b);\n	scanf(\"%s\", s);\n\n	if(b > 1 && b <= 16)\n		\n		 printf(\"%d\\n\", b);\n\n	else	 printf(\"???????????? ????????? !\\n\");\n\n  l = strlen(s);\n\n  	for(i=0; i<l; i++)\n		if (s[i] >= \'0\' && s[i] <= \'9\')\n			s[i] = s[i] - \'0\';\n		else\n			s[i]= s[i]-\'A\'+10;\n\n 		 for(i=l-1; i>=0; i--)\n		 {\n		  r += s[i]*x ;\n		  x = x * b;\n		 }\n\nprintf(\"%d\\n\", r);\n		  	\n\n		\n\n	\nreturn 0;\n}\n 	\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (701,'#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdlib.h>\n\n#include \"stack.h\"\n#include \"vars.h\"\n\n#include \"free.h\"\n\n#define N 20\n\n//  )  +  -  *  /  ????????\n//  0  1  2  3  4  ??????\n\nint computation(hash *H) {\n	// type = 0: ???????????????????? ???????????????? ????????????\n	// type = 1: ?Â©?????????????????????? \n	int c, x, n, nvar, fl, gl, vfl, fzero, ravno;\n	int *p, *q, *a, *b, *d, *z;\n	unsigned char s[50] = {0}, *var = NULL;\n	stack S, R;\n	\n	x = 0;\n	n = 0;\n	nvar = 0;\n	fl = 0;\n	gl = 1;\n	vfl = 0;\n	fzero = 0;\n	ravno = 0;\n	R = create();\n	S = create();\n	\n	while (c=getchar()) {		\n		// ?????Â© ???????????? (c \'=\' ?????? ??????)\n		if (c == \'=\') {\n			ravno = 1;\n			if (!strlen(s)) {\n				printf(\"(error: there is no variable name)\\n\");\n				return 0;\n			}\n			var = strdup(s);\n			gl = 0;\n			while (empty(S)) {\n				FREE(top(S));\n				pop(&S);\n			}\n		}\n		\n		// ???????????????????? ?Â©??????????????????\n		if (isalpha(c) && !vfl) {\n			vfl = 1;\n			s[n] = c;\n			n++;\n			continue;\n		}\n		if (( isalnum(c) || c == \'_\' ) && vfl) {\n			s[n] = c;\n			n++;\n			continue;\n		} \n		if (!isalnum(c) && c != \'_\' && vfl) {\n			s[n] = 0;\n			vfl = 0;\n			n = 0;\n			nvar++;\n			// ???????? \'=\', ???? ???????????????? ?Â©???????????????????? ?? ??????-??????????????\n			// ???????? ???? \'=\', ???? ?????Â©???????????? ?? R ???????????????? ?Â©?????????????????? (???????? ????????????????????, ?? ?Â©???????????????? ???????????? ?????Â©???????????? 0)\n			q = (int *) MALLOC(sizeof(int));\n			if (!q)\n				return 0;\n			p = return_hash(H, s);\n			if (p)\n				*q = *p;\n			else\n				*q = 0;\n			push(&R, q);\n		}\n		\n		// ???????? ?Â©?????????????? ???? \'-\' ?? ???????????? ???????????? ?? ?Â©???????? ?????????????????????? ????????????\n		if (gl && c == \'-\') {\n			p = (int *) MALLOC(sizeof(int));\n			if (!p)\n				return 0;\n			*p = 0;\n			push(&R, p);\n			q = (int *) MALLOC(sizeof(int));\n			if (!q)\n				return 0;\n			*q = 2;\n			push(&S, q);\n			gl = 0;\n			continue;\n		}\n		else\n			gl = 0;		\n		\n		// ?Â©???????????? ???????????? ?? ??????????	\n		if (isdigit(c)) {\n			fl = 1;\n			x = 10*x + c - \'0\';\n			continue;\n		}\n			\n		// ???????????? ?????????? ?? ???????? R\n		if (!isdigit(c) && fl) {\n			if (fzero && !x) {\n				printf(\"(error: division by zero)\\n\");\n				while (empty(R)) {\n					FREE(top(R));\n					pop(&R);\n				}\n				return 0;\n			}\n			fzero = 0;\n			p = (int *) MALLOC(sizeof(int));\n			if (!p)\n				return 0;\n			*p = x;\n			push(&R, p);\n			x = 0;\n			fl = 0;\n		}\n		\n		switch (c) {\n			case \'(\':\n				p = (int *) MALLOC(sizeof(int));\n				*p = 0;\n				push(&S, p);\n				gl = 1;\n				break;\n			case \'+\':\n			case \'-\':\n				while ( empty(S) && (*(z=(int *)top(S)) >= 1) ) {\n					a = (int *) top(R);\n					pop(&R);\n					b = (int *) top(R);\n					pop(&R);\n					d = (int *) MALLOC(sizeof(int));\n					if (!d)\n						return 0;\n					switch (*z) {\n						case 1:\n							*d = *b + *a;\n							break;\n						case 2:\n							*d = *b - *a;\n							break;\n						case 3:\n							*d = (*b) * (*a);\n							break;\n						case 4:\n							*d = (*b) / (*a);\n					}\n					FREE(a);\n					FREE(b);\n					FREE(z);\n					push(&R, d);\n					pop(&S);					\n				}\n				p = (int *) MALLOC(sizeof(int));\n				if (!p)\n						return 0;\n				if (c == \'+\')\n					*p = 1;\n				else\n					*p = 2;\n				push(&S, p);				\n				break;\n			case \'*\':\n			case \'/\':\n				while (empty(S) && (*(z=(int *)top(S)) >= 3)) {\n					a = (int *) top(R);\n					pop(&R);\n					b = (int *) top(R);\n					pop(&R);\n					d = (int *) MALLOC(sizeof(int));\n					if (!d)\n						return 0;\n					switch (*z) {\n						case 3:\n							*d = (*b) * (*a);\n							break;\n						case 4:\n							*d = (*b) / (*a);\n					}\n					FREE(a);\n					FREE(b);\n					FREE(z);\n					push(&R, d);\n					pop(&S);				\n				}\n				p = (int *) MALLOC(sizeof(int));\n				if (!p)\n						return 0;\n				if (c == \'*\')\n					*p = 3;\n				else {\n					*p = 4;\n					fzero = 1;\n				}\n				push(&S, p);			\n				break;\n			case \')\':\n				while (empty(S) && (*(z=(int *)top(S)) >= 1)) {\n					a = (int *) top(R);\n					pop(&R);\n					b = (int *) top(R);\n					pop(&R);\n					d = (int *) MALLOC(sizeof(int));\n					if (!d)\n						return 0;\n					switch (*z) {\n						case 1:\n							*d = *b + *a;\n							break;\n						case 2:\n							*d = *b - *a;\n							break;\n						case 3:\n							*d = (*b) * (*a);\n							break;\n						case 4:\n							*d = (*b) / (*a);\n					}\n					FREE(a);\n					FREE(b);\n					FREE(z);\n					push(&R, d);\n					pop(&S);\n				}\n				if (ravno && *(int *)top(S) == 0) {\n					printf(\"(error: division by zero)\\n\");\n					while (empty(R)) {\n						FREE(top(R));\n						pop(&R);\n					}\n					return 0;\n				}\n				fzero = 0;\n				pop(&S);\n				break;\n			case \'\\n\':\n				while (empty(S)) {\n					z = (int *) top(S);\n					pop(&S);\n					a = (int *) top(R);\n					pop(&R);\n					b = (int *) top(R);\n					pop(&R);\n					d = (int *) MALLOC(sizeof(int));\n					if (!d)\n						return 0;\n					switch (*z) {\n						case 1:\n							*d = *b + *a;\n							break;\n						case 2:\n							*d = *b - *a;\n							break;\n						case 3:\n							*d = (*b) * (*a);\n							break;\n						case 4:\n							*d = (*b) / (*a);\n					}\n					FREE(a);\n					FREE(b);\n					FREE(z);\n					push(&R, d);\n				}\n		} // end switch\n		if (c == \'\\n\')\n			break;\n	} // end while\n	\n	if (ravno) {\n		add_hash(H, var, *(int *)top(R));\n	} else\n		printf(\"%d\\n\", *(int *)top(R));\n	\n	while (empty(R)) {\n		FREE(top(R));\n		pop(&R);\n	}\n	printf(\"+++\\n\");\n	FREE(S);\n	FREE(R);\n		\n	return 0;\n}\n\nint main() {\n	int c, i, type;\n	hash H[N], p, q;\n	\n	printf(\"facepalm v1.00\\n\");\n	printf(\"This is free software with ABSOLUTLY NO WARRANTY.\\n\");\n	printf(\"To exit this program, press \\\'Ctrl+D\\\'\\n\");\n	\n	for (i=0; i<N; i++)\n		H[i] = NULL;\n	\n	while (1)\n	{\n		c = getchar();\n		if (c == EOF)\n			break;\n		if (c == \'\\n\')\n			continue;\n		ungetc(c, stdin);\n		computation(H);\n	}\n	\n	print_hash(H);\n\n	for (i=0; i<N; i++) {\n		if (H[i])\n			for (p=H[i]; p; p=q) {\n				q = p->next;\n				if (p->value)\n					FREE(p->value);\n				FREE(p->var);\n				FREE(p);\n			}\n	}\n	return 0;				\n}\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (702,'#include <stdio.h>\n#include <stdlib.h>\n\n#include \"free.h\"\n\nstruct item {\n	void *data;\n	struct item *next;\n};\n\ntypedef struct item *stack;\n\nvoid push(stack *S, void *data) {\n	stack p = MALLOC(sizeof(*p));\n	p->data = data;\n	p->next = *S;\n	*S = p;\n}\n\nvoid *top(stack S) {\n	return (S->data);\n}\n\nvoid pop(stack *S) {\n	stack p = *S;\n	*S = (*S)->next;\n	FREE(p);\n}\n\nint empty(stack S) {\n	return (S->next != NULL);\n}\n\nstack create() {\n	stack S = MALLOC(sizeof(*S));\n	if (!S)\n		return 0;\n	S->data = NULL;\n	S->next = NULL;\n}\n\nvoid free_stack(stack *S) {\n	stack p, q;\n	\n	for (p=*S; p->next; p=q) {\n		q = p->next;\n		FREE(p);\n	}\n}\n\nvoid removal(stack *S) {\n	stack p, q;\n	\n	for (p=*S; p; p=q) {\n		q = p->next;\n		FREE(p);\n	}\n}\n\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (703,'#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\n#include \"free.h\"\n\n#define N 20\n\nstruct table {\n	int code, *value;\n	unsigned char *var;\n	struct table *next;\n};\n\ntypedef struct table *hash;\n\nunsigned int f_hash(char *s, int n)\n{\n	unsigned int i, x=0, k=2;\n	\n	for (i=0; i<n; i++) {\n		x += s[i]*(k+1);\n		k *= 2;\n	}\n	\n	return x;\n}\n\nvoid add_hash(hash *x, unsigned char *s, int value) {\n	unsigned int hashcode = f_hash(s, strlen(s)), i = hashcode % N;\n	int *r;\n	hash p, q;\n	\n	for (p = x[i]; p; p = p->next)\n		if (p->code == hashcode  && !strcmp(s, p->var)) {\n			*p->value = value;\n			free(s);\n			return;\n		}\n		\n	q = MALLOC(sizeof(*q));\n	if (!q)\n		exit;\n	q->code = hashcode;\n	q->value = (int *) MALLOC(sizeof(int));\n	if (!q->value)\n		exit;\n	*q->value = value;\n	q->var = s;\n	q->next = x[i];\n	x[i] = q;\n}\n\nint *return_hash(hash *x, unsigned char *s) {\n	unsigned int hashcode = f_hash(s, strlen(s)), i = hashcode % N;\n	hash p, q;\n	\n	for (p=x[i]; p; p=p->next)\n		if (p->code == hashcode  && !strcmp(s, p->var))\n			return p->value;\n			\n	return NULL;\n}\n\nvoid print_hash(hash *x) {\n	int i;\n	hash p;\n	\n	for (i=0; i<N; i++)\n		for (p=x[i]; p; p=p->next) {\n			printf(\" { %s %d %d }\\n\", (unsigned char *)p->var, *p->value, p->code);\n		}\n	return;\n}\n\nvoid free_hash(hash *x) {\n	int i;\n	hash p, q;\n	\n	for (i=0; i<N; i++) {\n		for (p=x[i]; p; p=q) {\n			q = p->next;\n			if (p->value)\n				FREE(p->value);\n			FREE(p->var);\n			FREE(p);\n		}\n	}\n}\n\n/*\nunsigned char *read_var() {\n	unsigned char *var = NULL;\n	int a=0, u=0, c, fl=1;\n	\n	while (c=getchar()) {\n		if (c != \'_\' && !isalpha(c) && !isdigit(c)) {\n			ungetc(c, stdin);\n			break;\n		}\n		if (a == u) {\n			unsigned char *tmp = realloc(var, a + 6);\n			if (!tmp)\n				break;\n			var = tmp;\n			a += 6;\n		}\n		var[u] = c;\n		u++;\n	}\n	if (var)\n		var[u] = 0;\n	return var;\n}\n\nvoid check(int c) {\n	if (!isalnum(c) && c!=\'+\' && c!=\'-\' && c!=\'*\' && c!=\'/\' && c!=\'_\' && c!=\' \') {\n		printf(\"illegal character: %c\\n\", c);\n	return;\n}\n\nint main()\n{\n	int i, c, n=1, fl;\n	unsigned char *var, s[50];\n	hash x[N], p;\n	\n	for (i=0; i<N; i++)\n		x[i] = NULL;\n	\n	while (1) {\n		c = getchar();\n		if (c == EOF)\n			return 0;\n		check(c);\n		if (isdigit(c)) {\n			while (1) {\n				c = getchar();\n				if (c == \'\\n\')\n					break;\n			}\n		} else {\n			ungetc(c, stdin);\n			var = read_var();\n			if (!var) {\n				printf(\"ololo\\n\");\n				break;\n			}\n			printf(\"   (%s)\\n\", var);\n			add_hash(x, var, n);\n			n += 3;\n			while (1) {\n				c = getchar();\n				if (c == \'\\n\')\n					break;\n			}\n		}\n	}\n	\n	scanf(\"%s\", s);\n	printf(\"=%d\\n\", *return_hash(x, s));\n	\n	scanf(\"%s\", s);\n	printf(\"=%d\\n\", *return_hash(x, s));\n\n	return 0;\n}\n*/\n\n','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (704,'#include <stdio.h>\nint main()\n{\n	int i;\n	int d;\n	int m;\n	int y;\n	int dd;\n	int mm;\n	int yy;\n	int x=0;\n	int xx=0;\n	scanf(\"%d\",&dd);\n	scanf(\"%d\",&mm);\n	scanf(\"%d\",&yy);\n\n\n	scanf(\"%d\",&d);\n	scanf(\"%d\",&m);\n	scanf(\"%d\",&y);\n\n	for (i=1;i!=d;x++,i++);\n\n\n	if (m!=1) for (i=1;i!=m;x=x+30,i++);\n\n\n	if (m==2) x=x+1; \n	if ((m>2) && (m<9)) x=x-2+(m/2);\n	if (m>8) x=x-2+((m+1)/2); \n	if (y % 400 == 0 || (y % 4 == 0  && y % 100 != 0) && (m>2)) x++;\n\n	printf(\"x: %d\\n\", x);\n\n	x=x+((y-1)*365);\n	for	(i=1;\n		i!=y; \n		i++)\n		if  ( i % 400 == 0 || (i % 4 == 0  && i % 100 != 0)  ) { printf(\"[1] leap year %d\\n\", i); x++ ; }\n\n					        for (i=1;i!=dd;xx++,i++);\n					        if (mm!=1) for (i=1;i!=mm;xx=xx+30,i++);\n						        if (mm==2) xx=xx+1;\n							        if ((mm>2) && (mm<9)) xx=xx-2+(mm/2);\n								        if (mm>8) xx=xx-2+((mm+1)/2);\n									        if ( ( yy % 400 == 0 || (yy % 4 == 0  && yy % 100 != 0) ) && (mm>2)) xx++;\n										        xx=xx+((yy-1)*365);\n											        for(i=1;i!=yy; i++)\n													if  ( i % 400 == 0 || (i % 4 == 0  && i % 100 != 0)  ) { printf(\"[2] leap year %d\\n\", i); xx++; }\n												x=xx-x;\n												if (x<0) \n												printf(\"%d\\n\",-x-1);\n												else printf(\"%d\\n\",x+1);\n												return x;}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (705,'#include<stdio.h>\n\n\n\nint main()\n{\n\nint C[3][3],A[3][3],B[3][3],i=0/*???????*/,j=0/*??????*/,s=0,k=0;\n\n\n	printf(\"??????? ??????? A\\n\");\n		for(j = 0; j < 3; j++ )\n		{\n			for (i = 0; i < 3; i++)				\n				scanf(\"%d\", &A[i][j]);\n		}	\n	\ni = 0;\nj = 0;\n	printf(\"??????? ??????? ?\\n\");\n		for(j = 0; j < 3; j++ )\n		{\n			for(i = 0; i < 3; i++)\n				scanf(\"%d\", &B[i][j]);\n		}\ni = 0;\nj = 0;\n	for(j = 0; j < 3; j++)\n	{\n		for( i = 0; i < 3; i++)\n		{\n			for(k = 0; k < 3; k++)\n			{	\n				s=A[i][k]*B[k][j]+s;\n			}\n			C[i][j]=s;\n			s=0;\n						\n		}\n	}	\n	for(j = 0; j < 3; j++)\n	{\n		for(i = 0; i < 3;i++)\n		{\n				printf(\" %2d\",C[i][j]);\n		}\n		printf(\"\\n\");\n	}\n\n\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (706,'#include <stdio.h>\n\nint isprime (int a)\n{\n		int b=a-1;\n		if (a!=1)\n		{\n		while (b>1&&a%b!=0&&b!=0)\n{\n			b=b-1;\n}\n		}\n		else \n			return 0;\n\n		if(b==1)\n			return 0;\n		return 1;\n}\n\nint main()\n{\n	int A[7],i=0,k=0;\n\n	while (i<7)\n{		\n		printf(\"??????? ??????? ??????? %d\\n\", i);\n		scanf(\"%d\", &A[i]);\n		i++;\n}\n	for ( i=0;i<7;i++)\n{\n		k=k+isprime(A[i]);\n}\n	if (k>0)\n		printf(\"? ?????? ??????? ???? ????????? ?????\\n\");\n	else\n		printf(\"? ?????? ??????? ??? ????????? ?????\\n\");\n\n	return 0;\n}\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (707,'#include<stdio.h>\n#define N 20\n\nint main()\n{\n	int A[N];\n	int dim, l, r, k, mid=21, i, a;\n	printf(\"??????? ??????????? ???????(<=20)\\n\");\n	scanf(\"%d\", &dim);\n	printf(\"??????? ??????, ????????????? ?? ??????????\\n\");\n	for (i=1; i<=dim; i++)\n	{\n		scanf(\"%d\", &a);\n		A[i]=a;\n	}\n	printf(\"??????? l\\n\");\n	scanf(\"%d\", &l);\n	printf(\"??????? r\\n\");\n	scanf(\"%d\", &r);\n	printf(\"??????? ????? k ??? ??????\\n\");\n	scanf(\"%d\", &k);\n	if (l>r) return (-1);\n	while ((A[mid]!=k) & (l<=r))\n	{\n		mid=(l+r)/2;\n		if (A[mid]==k) { printf(\"??????? ??????: mid=%d, A[mid]=%d, k=%d\\n\", mid, A[mid], k); return 0;}\n		if (A[mid]>k) r=mid-1; else l=mid+1;		\n	}\n	printf(\"??????? ?? ??????\\n\");\n	return 0;\n}\n\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (708,'#include <stdio.h>\n int isprime(int a)\n {\n	int i;\n	for (i=2;i*i<=a; i++)\n	if (a%i==0) \n	return 0;\n	return 1;}\n\nint main()\n{\n	printf(\"????? ????????? ???????: \\n\");\n	int N;\n	scanf (\"%d\", &N);\n	int x=0;\n	int i;\n	int a;\n	int A[N];\n	for (i=0;i!=N;i++)\n		{scanf(\"%d\", &a);\n		A[i]=a;}\n	for (i=0;i!=N;i++)\n		if (isprime(A[i])==0) x++;\n		printf(\"%d\\n\", x);\n	for (i=0;i!=N;i++)\n		if (A[i]==1) x++;\n		if (x>0) printf(\"? ??????? ???? ????????? ?????\\n\");\n	else printf(\"??? ????? ? ??????? ???????\\n\");\n	return x;}\n\n\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (709,'#include <stdio.h>	\n#include <string.h>\n#include <ctype.h>\n\n\nint main ()\n\n{\n// ??????????????? ??????????\nint i=0;\nint flag=0;\nint k=0;\nint m=0;\nint t=0;\n// ?????? ???????? ????? \n	char n1[1000];\n	printf (\"??????? ?????\\n\");\n	fgets (n1,1000,stdin);\n	i=strlen (n1)-1;\n\n\n	char n2[1000];\n// ???????? ????? ? ?????? ??	\nFILE *file=fopen(\"/etc/passwd\",\"r\");\n\nif (file==NULL)\n{\n	printf (\"?????? ??? ???????? ?????\\n\");\n	return 1;\n}\n\n//???????? ?????\nwhile (flag!=1)\n{if (!fgets(n2, 1000, file))\n{	t=1;\n	printf (\"??? ?????? ? ??????? ???????\\n\");\n	break;\n\n}\n\n	m=0;\n	for (k=0;k<=i;k++)\n	{\n		if (n1[k]==n2[k])\n		m++;		\n	}\n	if (m==i && n2[m]==\':\' )\n		flag=1;\n}\nif (t!=1)\n{\n// ????? ????? \nk=0;\nm=0;\nwhile (k!=4)\n{\n	if (n2[m]==\':\')\n		k++;\n	m++;\n}\nprintf (\"\\n\");\nwhile (n2[m]!=\',\')\n{\n	printf (\"%c\",n2[m]);\n	m++;\n}\nprintf (\"\\n\");\n}\nfclose(file);\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (710,'#include <stdio.h>\n/*#define N 5*/\n\nint main()\n{	int m; int N;int i, j, a;\n	int s[100000];\n	FILE *f=fopen(\"/home/fenster/input_big.txt\", \"r\");\n	\n	fscanf(f, \"%d\", &N);\n\n	for (i = 0; i < N; i++)\n		fscanf(f, \"%d\", &s[i]);\n\n/*\n	while((N = fgetc(f))!=\'\\n\')\n	{	N=fgetc(f);\n		break;		}\n	\n	fgets(s, N, f);\n*/	\n	for (a = 0; a < N; a++)\n	{\n		j=0;\n		i=0;\n		while (i < N - 1)\n		{	j=i;\n			i++;\n			if (s[i]<s[j])\n			{	int t = s[i];\n				s[i]=s[j];\n				s[j]=t;\n			}\n		}\n	}\n\n	fclose(f);\n/*	m=(fgets(s, N, f));\n	while (m)\n		{ \n			if (m%2==0)\n			{\n			}\n		}*/\n/*	s[N]=f;\n	for (i=0; */\n	\n	for (i = 0; i < N; i++)\n	{\n		printf(\"%d \", s[i]);\n	}\n	printf(\"\\n\");\nreturn 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (711,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{ char n[100];\n  char s[100];\n  char s1[100];\n  char r[100];\n  int i, j;\n  int k=0;\n  int l=0;\n\n  FILE *f;\n  int nashli = 0;\n\n  f = fopen(\"/etc/passwd\", \"r\");\n	\n	printf(\"??????? ?????:\");\n	scanf(\"%s\", n);\n\n	l = strlen(n);\n\n	while (fgets(s, 100, f))\n	{\n\n	for(i=0; i<=l; i++)\n\n	{s1[i] = s[i];}\n\n	/* ?? ???????? ????????? ????? ? ????? ?????? */\n	s1[l] = 0;\n\n	if(strcmp(n, s1) == 0 && s[l] == \':\')\n	{\n		printf(\"??????: %s\", s);\n		printf(\"\\n\");\n		\n	\n	\n\n			for(i=0; s[i]; i++)\n			{	\n				if( s[i] == \':\' )\n				{\n					k++;\n				}\n				if (k == 4)\n					break;\n\n			}		\n		\n		/* ????? 4-? ????????? ? ??????? i */\n		\n		for(j=i+1; s[j]!= \':\' && s[j]!= \',\'; j++)\n	\n			printf(\"%c\", s[j]);\n\n		printf(\"\\n\");\n\n		nashli = 1;\n	\n	\n}\n}\n	\nfclose(f);\n\nif (!nashli)\n{\n	printf(\"?? ?????\\n\");\n}\n	\n}\n\n\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (712,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint stepen(int a, int b)\n{\n	int s = 1, i;\n	if (b==0) return 1;\n	for (i=1; i<=b; i++)\n		s=s*a;\n	return s;\n}\n\nint F(char a)\n{\n	int l, r, i, m[16];\n	l=\'0\'; r=\'A\';\n	for (i=0; i<=9; i++) m[i]=l+i;\n	for (i=0; i<=5; i++) m[i+10]=r+i;\n	for (i=0; i<=15; i++) if (a==m[i]) return i;\n}\n\nint main()\n{\n	char str[10];\n	int zifra[10]; int b, s=0, l, i;\n	printf(\"??????? ????????? ??????? ?????????\\n\");\n	scanf(\"%d\", &b);\n	FILE *f;\n	f=fopen(\"chislo.txt\", \"r\"); if (!f) { printf(\"?? ???????? ????\\n\");  return 0; }\n	fgets(str, 10, f);\n	l=strlen(str);\n	for (i=0; i<(l-1); i++)\n	{\n		zifra[i]=F(str[l-2-i]);\n		printf(\"??????: %c, ????????: %d\\n\", str[l-2-i], zifra[i]);\n	}\n	for (i=0; i<(l-1); i++)\n	{\n		s = s + zifra[i]*stepen(b,i);\n		printf(\"???????? %d * %d = %d\\n\", zifra[i], stepen(b, i), zifra[i]*stepen(b, i));\n	}\n	printf(\"? ?????????? ???????: %d\\n\", s);\n	return 0;\n}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (713,'#include \"calc.h\"\n\nint priority(token *t)\n{\n	switch(t->op)\n	{\n		case \'+\':\n		case \'-\':\n		return 1;\n		case \'*\':\n		case \'/\':\n		return 2;\n	}\n	return 0;\n}\n\nint value(token *t)\n{\n	if(t->type==TOKEN_NUM)\n	{\n		return t->num;\n	}\n	if(t->type==TOKEN_ID)\n	{\n		return get_value(t->id);\n	}\n	return 0;\n}\n\nvoid calc(list *input, list **output)\n{\n	list *p=NULL, *r;\n	stack *q=NULL;\n	while(input!=NULL)\n	{\n		token *t;\n		t=(token*)input->data;\n		switch(t->type)\n		{\n			case TOKEN_OP:\n				switch(t->op)\n				{\n					case \'(\': \n					push(&q, t);\n					break;\n					case \')\':\n					delete_token(t);\n					while(!empty(q))\n					{\n						t=(token*)top(q);\n						if((t->type==TOKEN_OP) && (t->op==\'(\'))\n						{\n							delete_token((token*)top(q));\n							pop(&q);\n							break;\n						}\n						else\n						{\n							add(&p, t);\n							//delete_token((token*)top(q));\n							pop(&q);\n						}\n					}\n					break;\n					case \'+\': \n					case \'-\':\n					case \'*\':\n					case \'/\':\n					case \'=\':\n					if(empty(q))\n					{\n						push(&q, t);\n					}\n					else\n					{\n						while(!empty(q))\n						{\n							token *r;\n							r=(token*)top(q);\n							if(priority(r)>=priority(t))\n							{\n								add(&p, r);\n								pop(&q);\n							}\n							else\n							{\n								push(&q, t);\n								break;\n							}\n						}\n						if(empty(q))\n						{\n						//	detele_token((token*)top(q));\n							push(&q, t);\n						}	\n					}\n					break;\n				}\n			break;\n			case TOKEN_ID: \n			case TOKEN_NUM:\n			add(&p, t);\n			break; \n		}\n		r=input;\n		input=input->next;\n		free(r);\n	}\n	while(!empty(q))\n	{\n		add(&p, top(q));\n		pop(&q);\n	}\n	*output=p;\n}\n\nint execute(int *result, list *input)\n{\n	list *r;\n	token *t;\n	stack *q=NULL;\n	while(input!=NULL)\n	{\n		t=(token*)input->data;\n		switch(t->type)\n		{\n			case TOKEN_ID:\n			case TOKEN_NUM:\n			push(&q, t);\n			break;\n			case TOKEN_OP:\n			{\n				int middle=0;\n				token *a, *b, *c;\n				if(empty(q))\n				{\n//					printf(\"first\\n\");\n					return 1;\n				}\n				b=(token*)top(q);\n				pop(&q);\n				if(empty(q))\n				{\n//					printf(\"second\\n\");\n					return 1;\n				}\n				a=(token*)top(q);\n				pop(&q);\n				switch(t->op)\n				{\n					case \'+\': middle=value(a)+value(b);\n					break;\n					case \'-\': middle=value(a)-value(b);\n					break;\n					case \'*\': middle=value(a)*value(b);\n					break;\n					case \'/\': middle=value(a)/value(b);\n					break;\n					case \'=\':\n					{\n						if(a->type==TOKEN_ID)\n						{\n							set_value(a->id, middle=value(b));\n						}\n					}\n					break;\n				}\n				c=malloc(sizeof(token));\n				c->num=middle;\n				c->type=TOKEN_NUM;\n				push(&q, c);\n				delete_token(a);\n				delete_token(b);\n				delete_token(t);\n//				free(a);\n//				free(b);\n			}\n			break;\n		}\n		r=input;\n		input=input->next;\n//		delete_token(r->data);\n		free(r);\n	}\n	t=(token*)top(q);\n	*result = value(t);\n	delete_token((token*)top(q));\n	pop(&q);\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (714,'#include \"lex.h\"\n\nvoid analiz(char *s, list **a)\n{\n	int flag=1;\n	token *q=0;\n	list *p=0;\n	while(*s)\n	{\n		if(((*s==\'-\') && isalpha(*(s+1)) && flag) || isalpha(*s))\n		{\n			char buf[N];\n			int len=0, sign=1;\n			if(*s==\'-\')\n			{\n				sign=-1;\n				s++;\n			}						\n			while(isalpha(*s) || (*s==\'_\'))\n			{\n				buf[len++]=*s;\n				s++;\n			}\n			buf[len]=0;\n			q=malloc(sizeof(token));\n			q->type=TOKEN_ID;\n			q->id=malloc(strlen(buf)+1);\n			strcpy(q->id, buf);\n			add(&p, q);\n			if(sign<0)\n			{\n				q=malloc(sizeof(token));\n				q->type=TOKEN_OP;\n				q->op=\'*\';\n				add(&p, q);\n				q=malloc(sizeof(token));\n				q->type=TOKEN_NUM;\n				q->num=sign;\n				add(&p, q);\n			}\n			flag=0;\n		}\n		else if(((*s==\'-\') && isdigit(*(s+1)) && flag) || isdigit(*s))\n		{\n			int x=0, sign=1;\n			if(*s==\'-\')\n			{\n				sign=-1;\n				s++;\n			}			\n			while(isdigit(*s))\n			{\n				x*=10;\n				x+=*s-\'0\';\n				s++;\n			}\n			q=malloc(sizeof(token));\n			q->type=TOKEN_NUM;\n			q->num=x*sign;\n			add(&p, q);\n			flag=0;\n							\n		}\n		else if(*s==\'+\' || *s==\'-\' || *s==\'*\' || *s==\'=\' || *s==\'/\' || *s==\'(\' || *s==\')\')\n		{\n			if(*s==\'-\' && flag && *(s+1)==\'(\')\n			{\n				q=malloc(sizeof(token));\n				q->type=TOKEN_NUM;\n				q->num=-1;\n				add(&p, q);	\n				q=malloc(sizeof(token));\n				q->type=TOKEN_OP;\n				q->op=\'*\';\n				add(&p, q);\n				flag=0;\n			} \n			else\n			{\n				if(*s==\'(\')\n				{\n					flag=1;\n				}	\n				else flag=0;\n				q=malloc(sizeof(token));\n				q->type=TOKEN_OP;			\n				q->op=*s;\n				add(&p, q);\n			}\n			s++;			\n		}\n		else\n		{\n			s++;\n			flag=0;\n		}\n	}\n	*a=p;\n}\n\nvoid delete_token(token *p)\n{\n	if(p==NULL)\n	{\n		return;\n	}\n	if(p->type==TOKEN_ID)\n	{\n		if(p->id!=NULL)\n		{\n			free(p->id);\n		}\n	}\n	free(p);\n}\n\n/*int main()\n{\n	list *h=NULL;\n	char d[N];\n	while(gets(d)!=NULL)\n	{\n		analiz(d, &h);\n		while(h!=NULL)\n		{\n			token *t;\n			t=(token*)h->data;\n			switch(t->type)\n			{\n				case TOKEN_ID: printf(\"??? ?????: %s\\n\", t->id);\n				break;\n				case TOKEN_OP: printf(\"??? ???????: %c\\n\", (char)t->op);\n				break;\n				case TOKEN_NUM: printf(\"??? ?????-?????: %d\\n\", t->num);\n				break; \n			}\n			h=h->next;\n		}\n	}\n	return 0;\n}*/\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (715,'#include \"list.h\"\n\nvoid add(list **head, void *data)\n{\n	list *p, *q;\n	p=malloc(sizeof(list));\n	p->data=data;\n	p->next=NULL;\n	if(*head==NULL)\n	{\n		*head=p;\n		return;\n	}\n	q=*head;\n	while(q->next!=NULL)\n	{\n		q=q->next;\n	}\n	q->next=p;\n}\n\nvoid delete(list *head, void (*func)(void *))\n{\n	list *p=head, *q;\n	while(p!=NULL)\n	{\n		q=p->next;\n		if(func==NULL)\n		{\n			free(p->data);\n		}\n		else\n		{\n			func(p->data);\n		}\n		free(p);\n		p=q;\n	}\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (716,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include \"calc.h\"\n#include \"lex.h\"\n#include \"list.h\"\n#include \"vars.h\"\n#define N 100500\n\nint main()\n{\n	char buf[N];\n	while(fgets(buf, N, stdin)!=NULL)\n	{\n		int result=0;\n		list *p;\n//		printf(\"Start analiz\\n\");\n		analiz(buf, &p);\n//		printf(\"Start calc\\n\");\n		calc(p, &p);\n/*		{\n			list *h=p;\n			while(h!=NULL)\n			{\n			token *t;\n			t=(token*)h->data;\n			switch(t->type)\n			{\n				case TOKEN_ID: printf(\"??? ?????: %s\\n\", t->id);\n				break;\n				case TOKEN_OP: printf(\"??? ???????: %c\\n\", (char)t->op);\n				break;\n				case TOKEN_NUM: printf(\"??? ?????-?????: %d\\n\", t->num);\n				break; \n			}\n			h=h->next;\n			}\n		}\n		printf(\"Start result\\n\");*/\n		if(execute(&result, p)!=0)\n		{\n			printf(\"? ???????? ????????\\n\");\n			continue;\n		}\n//		delete(p, NULL);\n//		printf(\"Start printf\\n\");\n		printf(\"%d\\n\", result);\n	}\n	cleanup();\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (717,'#include \"stack.h\"\n\nvoid push (stack **head, void *a)\n{\n	stack *p=malloc(sizeof(stack));\n	p->data=a;\n	p->next=*head;\n	*head=p;\n}\n\nvoid *top(stack *head)\n{\n	return head->data;\n}\n\nvoid pop(stack **head)\n{\n	stack *p;\n	p=*head;	\n	*head=(*head)->next;\n	free(p);\n\n}\n\nint empty(stack *head)\n{\n	return head==NULL;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (718,'#include \"vars.h\"\n\nstatic list *table[N];\n\nunsigned int hash_function(char *s)\n{\n	unsigned int value=0, n=1;\n	while(*s)\n	{\n		value+=(*s-\'a\'+1)*n;\n		n*=53;\n		s++;\n	}\n	return value;\n}\n\nvoid set_value(char *name, int value)\n{\n	unsigned int index;\n	list *p;\n	hash *q;\n	index=hash_function(name);\n	index%=N;\n	for(p=table[index]; p!=NULL; p=p->next)\n	{\n		q=(hash*)p->data;\n		if(strcmp(name, q->name)==0)\n		{\n			q->value=value;\n			return;\n		}\n	}\n	q=malloc(sizeof(hash));\n	q->name=strdup(name);\n	q->value=value;\n	add(&table[index], q);\n}\n\nint get_value(char *name)\n{\n	unsigned int index;\n	list *p;\n	hash *q;\n	index=hash_function(name);\n	index%=N;\n	for(p=table[index]; p!=NULL; p=p->next)\n	{\n		q=(hash*)p->data;\n		if(strcmp(name, q->name)==0)\n		{\n			return q->value;\n		}\n	}\n	return 0;\n}\n\nvoid unknown(void *a)\n{\n	hash *q=(hash*)a;\n	free(q->name);\n	free(q);\n}\n\nvoid cleanup(void)\n{\n	int i;\n	for(i=0; i<N; i++)\n	{\n		delete(table[i], unknown);\n	}\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (719,'#include<stdio.h>\n\nint main()\n\n {  int i,b=0,N,k;\n	 \n	 int A[100000];\n	 FILE *f = fopen(\"/home/fenster/input_big.txt\",\"r\");\n         fscanf(f, \"%d\",&N);\n         FILE *g = fopen(\"output.txt\",\"w\");\n\n	for(i=0;i<N;i++)\n	{\n		fscanf(f,\"%d\",&A[i]);\n	}\n\n	for(i=0;i<N;i++)\n	{\n		b = 0;\n		while(b<N-1)\n		{\n			if(A[b+1]<A[b])\n        		{ \n				k=A[b];\n	 			A[b]=A[b+1];\n	 			A[b+1]=k; \n	 		}\n			b++;\n	  	}	\n	}\n\n	for(i=0;i<N;i++)\n	{\n		fprintf(g, \"%d \", A[i]);\n	}\n		\n	fclose(f);\n	fprintf(g, \"\\n\");\n	fclose(g);\n	\n	\n	\n	}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (720,'#include <stdio.h>\nint main()\n{\n	int N;\n	printf(\"??????? ??????????? ??????: \\n\");\n	scanf(\"%d\", &N);\n	int i, c, j, m;\n	int x=0;\n	int A[N][N];\n	printf(\"??????? ????????? ???????? ????????? ??????? ?: \\n\");\n\n	for (i=0;i!=N;i++)\n	{for (j=0;j!=N;j++){\n	scanf(\"%d\", &c);\n	A[i][j]=c;} }\n	\n	int B[N][N];\n	printf(\"??????? ????????? ???????? ????????? ??????? ?: \\n\");\n\n	for (i=0;i!=N;i++)\n	{for (j=0;j!=N;j++){\n	scanf(\"%d\", &c);\n	B[i][j]=c;}}\n\n	int C[N][N];\n	printf(\"??????? ?: \\n\");\n\n	for (i=0;i!=N;i++)\n	{for (j=0;j!=N;j++)\n	{\n	for(m=0;m!=N;m++){\n		x=x+A[i][m]*B[m][j];}	\n	C[i][j]=x;\n	x=0;\n	\n	}}\n	for (i=0;i!=N;i++)\n	{printf(\" \\n\");\n		for (j=0;j!=N;j++){\n	printf(\"%3d \", C[i][j]);}}\n\n	return x;}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (721,'#include <stdio.h>\n\nvoid quicksort (int *s, int k, int l)\n{	\n	int x=(k+l)/2;\n	int z = s[x];\n	int i = k;\n	int j = l;\n	while (i <= j)\n	{	while (s[i]<z)\n		i++;\n		while (s[j]>z)\n		j--;\n		if( i <= j )\n		{int t=s[i];\n		 s[i]=s[j];\n		 s[j]=t;\n		 i++; j--;\n		 }\n	}\n\n	if (i < l) quicksort(s, i, l);\n	if (k < j) quicksort(s, k, j);\n}\n\n\nint main()\n{	int m; int N;int i, j, a, k, l, b, t, r;\n	int s[100000];\n	FILE *f=fopen(\"/home/fenster/input_big.txt\", \"r\");\n	\n	fscanf(f, \"%d\", &N);\n\n	for (i = 0; i < N; i++)\n		fscanf(f, \"%d\", &s[i]);\n	fclose(f);\n	\n	quicksort(s, 0, N-1);\n\n//	for (a = 0; a < N; a++)\n/*	{ for (k=0; k<N; k++)\n	{ for (l=N-1; l>0; l--)\n		{ t=0;\n		  r=N-1;\n		  if (t<l) { quicksort(s, l, t);}\n		  if (k<r) { quicksort(s, k, r);}}}}*/\n/*	{	k=0;\n		l=(N-1);\n		while (k<=l)\n		{while (k<=a)\n		{	k++;\n			if (s[k]>=s[a])\n			{   while (l>=a) \n				{l--;\n				if (s[l]<=s[a])\n				{t=s[l];\n				s[l]=s[k];\n				s[k]=t;}\n				}			\n			}}}\n	printf(\"%d\\n\", s[a]);}\n*/	\n	\n	for (a = 0; a < N; a++)\n	{\n		printf(\"%d \", s[a]);\n	}\n	printf(\"\\n\");\n\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (722,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{ int i, j, k, N;\n  int s[100000];\n  FILE *f1, *f2;\n\n  f1 = fopen(\"/home/fenster/input_big.txt\", \"r\");\n  f2 = fopen(\"output.txt\", \"w\");\n\n  fscanf(f1, \"%d\", &N);\n\n	printf(\"%d \", N);\n	printf(\"\\n\");\n\n  for(i=0; i<N; i++)\n	{  	\n	  fscanf(f1, \"%d\", &s[i]);\n	  printf(\"%d \", s[i]);\n	}\n	\n	printf(\"\\n\");\n\n	for(j=0; j<N-1; j++)\n	{\n	for(i=0; i<N-1; i++)\n	  {\n		  if(s[i]>s[i+1])\n		 \n		{	  k = s[i];\n			  s[i] = s[i+1];\n			  s[i+1] = k;		  \n	 	}\n	  	  \n	  }\n	 } \n\n	for(i=0; i<N; i++)\n		fprintf(f2, \"%d \" , s[i]);\n	fprintf(f2, \"\\n\");\n\n	printf(\"??. output.txt\\n\");\n\n	fclose(f1);\n	fclose(f2);\n\n	return 0;\n\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (723,'#include<stdio.h>\n\nvoid quicksort(int *A, int l, int r)\n{\n\n	int i,j,b,c,x;\n	\n	x=(l+r)/2;\n	b=A[x];\n	i=l;\n	j=r;\n	while(i<=j)\n	{		\n		while(A[i]<b)\n			i++;\n		while(A[j]>b)\n			j--;\n		if(i <= j)\n		{	\n			c=A[i];\n			A[i]=A[j];\n			A[j]=c;		   \n			i++;\n			j--;\n		}	   \n	}\n	\n	if(i<r)\n		quicksort(A,i,r);\n		\n        if(j>l)\n		quicksort(A,l,j);\n}\n\nint main()\n\n\n{int m,a,N,p;\nint B[100000];\n\n\nFILE *f =fopen(\"input.txt\",\"r\");\nfscanf(f,\"%d\",&N);\nfor(m=0;m<N;m++)\n	{ fscanf(f,\"%d\",&B[m]);\n\n		\n		\n		\n		}\n	\n	\n	fclose(f);\n	\n	\n	\n	quicksort(B,0,N-1);\n\n       for(a=0;a<N;a++)\n	       printf(\"%d \",B[a]);\n	\n	printf(\"\\n\");\n	\n	\n	}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (724,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main()\n{\n	FILE *f;\n	f = fopen(\"palindrom.txt\", \"r\");\n	if (!f)\n	{\n		printf(\"????????? ???? ?? ????????\\n\");\n		return 0;\n	}\n	char str[100];\n	int l, i, q, j; char a, b;\n	char c;\n	fgets(str, 60, f);\n	l = strlen(str);\n	for (i = 0; i <= l-1; i++)\n	{\n		c=str[i];\n		printf(\"str[ %d ] = %c\\n\", i, c);\n	}\n	printf(\"\\n\");\n	i=0;\n	for (i=0; i<=l-1; i++)\n	{\n		if ( ( str[i]==\'.\') || (str[i]==\',\') || (str[i]==\' \') || (str[i]==\'-\') || (str[i]==\'!\') || (str[i]==\'?\') )\n		{\n			j=i;\n			while ( ( str[j]==\'.\') || (str[j]==\',\') || (str[j]==\' \') || (str[j]==\'-\') || (str[j]==\'!\') || (str[i]==\'?\') )\n			{\n				while (j!=l-1) { str[j]=str[j+1]; j++; }\n				l--;\n				j=i;\n			}\n		}\n	}\n	for (i = 0; i <=l-1; i++)\n	{\n		c=str[i];\n		printf(\"str[ %d ] = %c\\n\", i, c);\n	}\n	int k=0;\n	for (i=0; i<=l-2; i++)\n	{\n		a=str[i];\n		b=str[l-2-i];\n		if (a!=b) {printf(\"\'%c\' ?? ????? \'%c\'\\n\", a, b); k++;} }	\n	if (k==0) printf(\"?????????\\n\"); else printf(\"?? ?????????\\n\");\n	return 0;\n}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (725,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 100000 \n\nint main()\n{\n	FILE *f;\n	f=fopen(\"input.txt\", \"r\");\n	if (!f) { printf(\"?? ???????? input.txt\\n\"); return 0;}\n	int M[N+1];\n	char e=\'\\n\';\n	int i, n, t, a, min, j, c, k;\n	fscanf(f, \"%d\", &n);\n	for (i=1; i<=n; i++)\n	{\n		fscanf(f, \"%d\", &a);\n		M[i]=a;\n	}\n	//for (i=1; i<=n; i++) { c=M[i]; printf(\"%d\\n\", c); }\n	for(i=1; i<=n; i++)\n	{\n		min = M[i];\n		for(j=i; j<=n; j++)\n		{\n			if (M[j]<=min) { k=j; min=M[j]; };\n		}\n		t=M[i]; M[i]=min; \n		M[k]=t;\n	}\n	//for (i=1; i<=n; i++) { c=M[i]; printf(\"%d\\n\", c); }\n\n	FILE *b;\n\n	if ((b=fopen(\"output.txt\", \"w\"))==NULL)\n		printf(\"?? ???????? output.txt\\n\");\n	else\n	{\n		for(i=1; i<=n; i++)\n		{\n			fprintf(b, \"%d \", M[i]);\n		}\n	}\n	fprintf(b, \"\\n\");\n	fclose(b);\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (726,'#include <stdio.h>\n#define N 100000\n\n\nint main()\n{\nint s[N];\nint min;\nint i;\nint k,r,q;\nint t, place;\nFILE *file=fopen (\"input.txt\",\"r\");\n\n	if (file==NULL)\n	{\n		printf (\"?????? ??? ???????? ?????\\n\");\n		return 1;\n	}\n\n	fscanf(file, \"%d\", &i);\n	for (r = 0; r < i; r++)\n	{\n		fscanf(file, \"%d\", &s[r]);\n	}\n\n	for (r=0;r<i-1;r++)\n	{	\n		min=s[r];\n		place = r;\n		for (k=r+1;k<=i-1;k++)\n		{\n			if (min>s[k])\n			{\n				min=s[k];\n				place = k;\n			}\n		}\n		t = s[r];\n		s[r] = s[place];\n		s[place] = t;\n	\n	}\n	for (r=0;r<i;r++)\n	{\n		printf (\"%d \",s[r]);\n	}\n	printf (\"\\n\");\n\n\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (727,'#include <stdio.h>\n\nint main()\n{\n\nint C[3][3], A[3][3], B[3][3],i=0 /*??????*/, j=0 /*???????*/, a=0, b=0;\n\n	printf(\"??????? ???????? ??????? ?\\n\");\n		for(j=0; j<3 ;j++)\n			{\n				for (i=0; i<3; i++)\n					scanf(\"%d\", &A[i][j]);\n			}\n\ni=0;\nj=0;\n	printf(\"??????? ???????? ??????? B\\n\");\n		for (j=0; j<3; j++)\n			{\n				for(i=0; i<3; i++)\n					scanf(\"%d\", &B[i][j]);\n			}\n\ni=0;\nj=0;\n	for(j=0; j<3; j++)\n		{\n			for(i=0; i<3; i++)\n				{\n					for(a=0; a<3; a++)\n						{\n							b=A[i][a]*B[a][j]+b;\n						}\n							C[i][j]=b;\n							b=0;\n				}\n		}\n			for(j=0; j<3; j++)\n		{\n			for(i=0; i<3; i++)\n				{\n					printf(\" %d\", C[i][j]);\n				}\n				printf(\"\\n\");\n		}\n\nreturn 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (728,'#include <stdio.h>\n\nint main()\n{\nint A[5]={1, 3, 5, 7, 9}, i=0, k, a=0, b=4; \n\n	printf(\"??????? ??????? ?????\\n\");\n	scanf(\"%d\", &k);\n\n	while (a<=b)\n		{\n			i=(a+b)/2;\n			if (A[i] == k)\n				break;\n			else\n				{if (k > A[i])\n					a=i+1;\n					else\n				{if (k < A[i])\n					b=i-1;\n					}}}\n\n	{	if (A[i] == k)\n		printf(\"?????? ????? ???????????? ? ???????? ???????\\n\");\n	\n		else\n			{printf(\"?????? ????? ??????????? ? ???????? ???????\\n\");\n			}\n	}\n\n\n\nreturn 0;\n}\n\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (729,'#include<stdio.h>\n#include<string.h>\n\n\n\n\n\nint main()\n{\n	int x=0,i=0,j=0;\n	char M[100];\n	\n		printf(\"??????? ???????????\\n\");\n		fgets(M,100,stdin);\n	\n	x=strlen(M)-1;\n	i=0;\n	j=x-1;\n	while(i<j)\n		{\n		while(M[i]==\' \' || M[i] == \',\' || M[i] == \'.\')\n			i++;\n		while(M[j]==\' \' || M[j] == \',\' || M[j] == \'.\')\n			j--;\n\n		if(M[i]==M[j])\n		{\n			i++;\n			j--;\n		}\n		else\n		{\n			printf(\"?? ????? ?? ?????????\\n\");\n			printf(\"%c != %c\\n\", M[i], M[j]);\n			return 0;\n		}\n	}\nprintf(\"?? ????? ?????????\\n\");\nreturn 0;\n}\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (730,'#include<stdio.h>\nint main() {\n	int N;\n	printf(\"????? ??????? = \\n\");\n	scanf(\"%d\", &N);\n	int A[N];\n	int i;\n	for(i=0;i!=N;i++)\n		scanf(\"%d\", &A[i]);\n	int l=0;\n	int r=N-1;\n	int x;\n	int mid;\n	printf(\"x = \\n\");\n	scanf(\"%d\", &x);\n	i=0;\n	while(l<=r) {\n	mid = (l+r)/2;\n	if (A[mid]==x) { i=100; break; }\n	if (x>A[mid]) l=mid+1;\n	if (x<A[mid]) r=mid-1;\n	\n			\n	\n}\nif (i==100) printf(\"????? ????\\n\");\nelse printf(\"????? ???\\n\");\nreturn i;}\n	\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (731,'#include <stdio.h>\nint  main()\n{int a;\nint c;\nint b;\nint M;\nint i;\na=0;\nb=0;\nprintf(\"??????? ????? ????? ??????????????????\\n\");\nscanf(\"%d\",&M);\nfor(i=1;i<=M;i++)\n	{if(i==1)\n		{\n		b=1;\n		}\n	c=a+b;\n	a=b;\n	b=c;\n	printf(\"%d\",c);\n	printf(\"\\n\");\n	};\nreturn 0;\n }  \n\n\n\n\n\n\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (732,'#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\nint main()\n\n\n\n{int a=0;\nint i;\nint b;\nint c;\nint k=0,w=0,d=0;\nint f=0;	\n	char s[1000];\nfgets(s,1000,stdin);\na=strlen(s)-1;\nchar t[1000];	\nFILE*file=fopen(\"/etc/passwd\",\"r\");\n\n\nif(file==NULL)\n       { \n	printf(\"???????????\\n\");\n	\n	}\n\n	\n	\n	\nwhile (fgets(t, 1000, file) )\n{\n//	printf(\"%s\", t);\n		// t -- ????????? ?????? ?????\n//	printf(\"a: %d\\n\", a);\n          for(i=0;i<a;i++)\n	  {\n//		  printf(\"?????????? %c ? %c\\n\", s[i], t[i]);\n  		  if(s[i]!=t[i])\n		  { \n//			  printf(\"????????????\\n\");\n				f=1;\n			 break;\n			 ;\n		  }\n          }	\n\n//	  printf(\"????? ????????: i = %d, t[i] = %c\\n\", i, t[i]);\n          if(i == a && t[i]==\':\')\n	       k=1;\n	\n//	printf(\"k: %d\\n\", k);\n	 if(k==1)\n	 {	for(i=0; t[i] ;i++)\n		{ \n			if (t[i]==\':\')\n				d++; \n			if(d==4)\n			{\n				w=i+1;\n				break;\n			}\n		}\n		break;\n         }	\n}\n\n\n//printf(\"????? ????? fgets: d=%d, w=%d\\n\", d, w);	\nif (k==1)\n	{\n\nwhile(t[w]!=\',\')	\n{\n	 printf(\"%c\",t[w]);\n	w++;\n }\n	}\n	printf(\"\\n\");\n	fclose(file);\n	\n	\n	\n}\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (733,'#include<stdio.h>\nint main()\n{\n	int a,b,c;\n	printf(\"??????? ?\");\n	scanf(\"%d\",&a);\n	printf(\"??????? ?\");\n	scanf(\"%d\",&b);\n	while(a%b)\n	{\n		c=b;\n		b=a%b;\n		a=c;\n	}\n	printf(\"???=%d\\n\",b);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (734,'#include<stdio.h>\nint main()\n{\nint d1,d2,m1,m2,y1,y2,i1,i2,s;\nint M[12]={31,28,31,30,31,30,31,31,30,31,30,31};\nprintf(\"??????? ???? ??????? \\n\");\nscanf(\"%d%d%d\",&d1,&m1,&y1);\nprintf(\"??????? ???????? ???? \\n\");\nscanf(\"%d%d%d\",&d2,&m2,&y2);\ns=0;\nfor(i1=y1+1;i1<y2;i1++)\n{\n	if(i1!=y2&&i1!=y1)\n	 {\n		s=s+365;\n		printf(\"i1=%d: +365\\n\", i1);\n		if(i1%400==0||(i1%4==0&&i1%100!=0))\n		{\n			printf(\"leap year, +1\\n\");\n			s++;\n		}\n	 }\n}\n\nif(y1!=y2)\n{		\n	for(i2=1;i2<=m2;i2++)\n	{\n		if(i2!=m2)\n		{\n			printf(\"year %d, month %d: +%d\\n\", y2, i2, M[i2-1]);\n			s=s+M[i2-1];\n		}\n		else\n		{\n			printf(\"last month: +%d\\n\", d2);\n			s=s+d2;\n		}\n		if((m2>=3||(m2==2&&d2<=29))&&(y2%400==0||(y2%4==0&&y2%100!=0))) \n		{\n			printf(\"last year is leap, +1\\n\");\n			s++;\n		}\n	}\n	for(i2=12;i2>=m1;i2--)\n	{       if(i2!=m1)\n		{\n			printf(\"year %d, month %d: +%d\\n\", y1, i2, M[i2-1]);\n			s=s+M[i2-1];\n		}\n		else\n		{\n			printf(\"first month: +%d\\n\", M[m1-1]-d1);\n			s=s+M[m1-1]-d1;\n		}\n		if(m1<=2&&(y1%400==0||(y1%4==0&&y1%100!=0))) \n		{\n			printf(\"first year is leap, +1\\n\");\n			s++;\n		}\n	}\n}\nelse\n{\n	for(i2=m1+1;i2<m2;i2++)\n	{\n		printf(\"same year, month %d: +%d\\n\", i2, M[m1-1]);\n		s=s+M[m1-1];\n	}\n	if (m1 == m2)\n	{\n		printf(\"same month, +%d\\n\", d2-d1+1);\n		s=s+d2-d1+1;\n	}\n	else\n	{\n		printf(\"first month: +%d\\n\", M[m1-1]-d1);\n		s=s+M[m1-1]-d1;\n		printf(\"last month: +%d\\n\", d2);\n		s=s+d2;\n	}\n	if(y1%400==0||(y1%4==0&&y1%100!=0))\n	{\n		if (m1 <= 2 && m2 > 2)\n		{\n			printf(\"leap year: +1\\n\");\n			s++;\n		}\n	}\n}\n	printf(\"???? ?????? %d \\n\", s);\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (735,'#include <stdio.h>\n\nvoid sift(int *a, int n, int i)\n{\n	int b = 2*i+1;\n	int c = 2*i+2;\n	int t;\n	int max = i;	\n	 \n	if (b < n && a[b] > a[max]) max = b;\n	if (c < n && a[c] > a[max]) max = c;\n	if( max != i)\n	{\n		t = a[i];\n		a[i] = a[max];\n		a[max] = t;\n//		printf(\"???????? %d ? %d\\n\", a[i], a[max]);\n		sift(a, n, max);\n	}\n}\n/*	\n		m = a[max];\n		a[max] = a[n];\n		a[n] = m;\n		\n		printf(\"?????? ? ????? %d \", a[max]);\n		printf(\"\\n\"); 	\n*/	\n\n/*\n	\n		for(i=k; i>=0; i--)\n	\n		{\n			\n			printf(\"???????? %d ? %d \", a[i], a[max]);\n			printf(\"\\n\");\n		}\n*/\n\nint main()\n{\n FILE *f1, *f2;	\n int i, N, n, m;\n int a[100000];\n\n f1 = fopen(\"input.txt\", \"r\");\n f2 = fopen(\"output.txt\", \"w\");\n\n if(!f1)\n {\n	 printf(\"no file\");\n	 return 0;\n }\n\n fscanf(f1, \"%d\", &N);\n printf(\"?????????? ?????: %d\\n\", N);\n \n	for(i=0; i<N; i++)\n	{\n		fscanf(f1, \"%d\", &a[i]);\n//		printf(\"%d \", a[i]);\n	}\n//	printf(\"\\n\");\n\n	for (i = N/2; i >= 0; i--)\n	{\n		sift(a, N, i);\n	}\n\n/*	for(i=0; i<N; i++)\n		printf(\"%d \", a[i]);\n		printf(\"\\n\");\n*/\n	n = N;\n\n	while(n > 1)\n	{ \n		m = a[n-1];\n		a[n-1] = a[0];\n		a[0] = m;\n\n		n--;\n\n		sift(a, n, 0);\n\n	/*	for(i=0; i<n+1; i++)\n		printf(\"%d \", a[i]);\n		printf(\"\\n\");\n*/\n		\n	}\n\n	for(i=0; i<N; i++)\n	{	\n		printf(\"%d \", a[i]);\n	}\n\n		printf(\"\\n\");\n\n	fclose(f1);\n	fclose(f2);\n	return 0; \n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (736,'#include<stdio.h>\n#include<string.h>\nint stepen(int n,int b)\n{\n	int p=1,j;\n	if(n == 0)\n		return 1;\n	else\n	{\n		for( j = 0; j < n; j++)\n		p=p*b;\n		return p;\n	}\n\n}\n\nint main()\n{\n	int b,i,n,l,s=0,st,S[100];\n	char M[100];\n\n        printf(\"??????? ?????\\n\");\n	fgets(M,100,stdin);\n	l=strlen(M)-1;\n			\n	printf(\"??????? ????????? ??????? ?????????\\n\");\n	scanf(\"%d\", &b);\n		\n\n\n		\n	for( i = 0;i < 100 ; i++)//??????????? ?? ???????? ????????? ?? ? ?????\n	{\n		if(\'a\'<=M[i] && M[i]<=\'f\')\n			S[i]=M[i]-\'a\'+10;\n		if(\'0\'<=M[i] && M[i]<=\'9\')\n			S[i]=M[i]-\'0\';\n	}\n\nst=0;\n	for( n = l-1; n > -1; n--)// ????????? ? ?????????? ???????.\n	{\n		s=s+S[n]*stepen(st,b);\n		st++;\n	}\n	printf(\"????????? %d\\n\", s);	\n\n\n\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (737,'#include <stdio.h>\n#include <string.h>\nint main()\n{ 	int i;\n	int j;\n	char S[]=\"abc   b   a\";\n	printf(\"%d\\n\",strlen(S));\n	int s=strlen(S);\n	for(i=0;i!=s;i++)\n	if (((S[i]>=0) && (S[i]<=47)) || ((S[i]>=91) && (S[i]<=96)) || ((S[i]>=123) && (S[i]<=126)))\n	{for (j=i;j!=s;j++)\n	S[j]=S[j+1];s--;i--;}\n\n	printf(\"%s\\n\", S);\n\n	for(i=0;i!=s/2;i++)\n		if (S[i]!=S[s-1-i]) \n//{printf(\"%c\", S[i]);\n//printf(\"%c \" , S[s-1-i]);}\n\n	{	printf(\"??? ?? ?????????\\n\");return 0;}\n		printf(\"??? ?????????\\n\");\n		return 1;}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (738,'#include<stdio.h>\nfloat f(float x)\n{\nreturn(x*x-2);\n}\nmain()\n{\nfloat a,b,c;\nint i;\nprintf(\"??????? ?????? ?????????? ??????? \\n\");\nscanf(\"%f\",&a);\nprintf(\"??????? ?????? ?????????? ??????? \\n\");\nscanf(\"%f\",&b);\nc=(a+b)/2;\ni=0;\nwhile (b-a>0.001) //   (0.001<f(c)||f(c)<-0.001)\n{       i++;\n	printf(\"?????? ,%f ,%f ????? ,%d \\n\",a,b,i+1); \n	if(f((a+c)/2)*f((a+c)/2)<f((c+b)/2)*f((c+b)/2))\n	{\n		b=c;\n		c=(a+b)/2;\n	}\n	\n	else{\n		a=c;\n		c=(a+b)/2;\n	}\n	if(i>20)\n	{	printf(\"??????????\");\n		return 0;\n	}\n\n}\n\nprintf(\"????? %f \\n \",c);\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (739,'#include<stdio.h>\nint isprime(int a)\n{\n	int d;\n	for(d=2;d<a;a++)\n	{\n		if(a%d)\n			return 2;\n	}\n	return 1;\n}\nmain()\n{\nint i1,i2,c;\nint N[15]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};\ni1=0;\nc=0;\ni2=0;\nprintf(\"??????? ???-?? ????????? \\n\");\nscanf(\"%d\",&c);\nfor(i1=0;i1<c;i1++)\n{\n	printf(\"??????? ????????? \\n\");\n	scanf(\"%d\",&N[i1]);\n}\nwhile(isprime(N[i2])==1&&i2<c)\n{	\n	printf(\"%d %d \\n\",N[i2],i2);\n	i2++;\n}\nif(i2==c)\n	 printf(\"??? ???????? ???????\\n\");\nelse\n	 printf(\"???? ?? ??????? ???????\\n\");\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (740,'#include <stdio.h>\n#include <string.h>\n\nint main()\n\n{\n	int i=0, x=0, y=0;\n	char P[100];\n\n		printf(\"??????? ???????????\\n\");\n		fgets(P, 100, stdin);\n		\n	x=strlen(P) - 1; /*????? ?????? ??? ?????????? ???????? ??????? (??????)*/\n	y=x-1; /*????? ?????? ??? ?????????? ???????? ???????????*/\n		\n		while (i<y)\n			{\n		while (P[i] == \' \' || P[i] == \',\' || P[i] == \'.\' || P[i] == \'!\' || P[i] == \'?\' || P[i] == \':\' || P[i] == \';\' || P[i] == \'\\\'\' || P[i] == \'\"\' || P[i] == \'-\')\n					i++;\n		while (P[y] == \' \' || P[y] == \',\' || P[y] == \'.\' || P[y] == \'!\' || P[y] == \'?\' || P[y] == \':\' || P[y] == \';\' || P[y] == \'\\\'\' || P[y] == \'\"\' || P[y] == \'-\')\n					y--;\n				if (P[i] == P[y])\n					{\n						i++;\n						y--;\n					}\n				else\n					{\n						printf(\"?????? ?? ?????????\\n\");\n						\n	return 0;\n					}\n			}\n	printf(\"?????? ?????????!!!\\n\");\n	\n	return 0;\n\n\n\n	 \n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (741,'#include <stdio.h>\n\nint main()\n\n{\nint i=0, a=0, A[100000], N, flag=1; \n\nFILE *f1 = fopen(\"input.txt\", \"r\");\nif (!f1)\n	{\n		perror(\"fopen\"); /*??????????? ????????? ?? ??????*/\n	}\nFILE *f2 = fopen(\"output.txt\", \"w\");\nif (!f2)\n	{\n		perror(\"fopen\"); /*??????????? ????????? ?? ??????*/\n	}\n\n\nfscanf(f1, \"%d\", &N);\n\n	for (i = 0; i < N; i++)\n{\n	fscanf(f1, \"%d\", &A[i]);\n}\n	while(flag)\n{\n	flag=0;\n	for (i = 0; i < N-1; i++)\n{\n	if (A[i]>A[i+1])\n		{\n		a=A[i+1];\n		A[i+1]=A[i];\n		A[i]=a;\n		flag=1;\n		}\n}\n\n}\n	for (i=0; i<N; i++)\n	{\n		printf(\"%d \", A[i]);\n	}\n	printf(\"\\n\");\nreturn 0;\n}\n\n\n\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (742,'#include<stdio.h>\n\n\n\nint main()\n{\nint M[100000],i,c,n,flag=1;\n\nFILE *f = fopen(\"input.txt\", \"r\");\n\n	fscanf(f,\"%d\",&n);\n\n\nfor(i = 0;i < n;i++)\n{\n	fscanf(f,\"%d\",&M[i]);\n}\n\n\n	while(flag)\n	{\n		flag=0;\n		for(i = 0; i < n-1; i++)\n		{\n			if(M[i] > M[i+1])\n			{\n				c=M[i+1];\n				M[i+1]=M[i];\n				M[i]=c;\n				flag=1;\n			}\n\n\n		}\n	}\ni=0;\n	\n	for(i = 0;i < n;i++)\n	{\n		printf(\" %d\", M[i]);\n	}\n	printf(\"\\n\");\n\n\n\n\n\n\n	return 0;\n}	\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (743,'# include<stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n struct item \n {\n	 int data;\n	 struct item *next;\n };\n\n struct item *head = 0;\n struct item *p = 0;\n struct item *prev = 0;\n struct item *q = 0;\n int a;\n\n FILE *f1 = fopen(\"input1.txt\", \"r\");\n FILE *f2 = fopen(\"output.txt\", \"w\");\n\n if(!f1)\n {\n	 printf(\"no file!\");\n	 return 0;\n }\n\n fscanf(f1, \"%d\", &a);\n\n head = malloc(sizeof(struct item));\n head->data = a;\n head->next = NULL;\n\n while(fscanf(f1,\"%d\", &a) == 1)\n {\n	 if(a > head->data )\n	 {\n		 q = head;\n		 prev = NULL;\n		 while( q && a > q->data )\n		 {\n			prev = q;\n		 	q = q->next;\n		 }\n		 // q ???? ????? NULL, ???? ????????? ?? ??????? ? ??????? ?????????\n	\n		 p = malloc(sizeof( struct item));\n\n		 if( prev->next != NULL )\n			 p->next = prev->next;\n\n		 else\n			 p->next = NULL;\n\n		 prev->next = p;\n		 p->data = a;\n	 }\n\n	 if(a <= head->data )\n	 {\n		 p = malloc(sizeof( struct item));\n		 p->data = a;\n		 p->next = head;\n		 head = p;\n	 }			\n }\n\n for(p = head; p; p = p->next)\n	 printf(\"%d \", p->data);\n	 printf(\"\\n\");\n\n for(p = head; p; p = p->next)\n	 fprintf(f2, \"%d \", p->data);\n	 fprintf(f2, \"\\n\");\n\n fclose(f1);\n fclose(f2);\n\nwhile (head)\n{\n	p = head->next;\n	free(head);\n	head = p;\n}\n\n\nreturn 0;\n\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (744,'#include<stdio.h>\n\nmain()\n{\nint A[3][3],B[3][3],N[3][3];\nint i,k,j,n,i1,i2;\nfor(i=0;i<3;i++)\n	for(j=0;j<3;j++)\n	{	\n		B[i][j]=0;\n		A[i][j]=0;\n		N[i][j]=0;\n	}\nprintf(\"??????? ?? ?????? ???????? (???? ?????????? ?? ???????)\\n\");\nprintf(\"??????? ??????? A \\n\");\nfor(i1=0;i1<3;i1++)\n{\nscanf(\"%d%d%d\",&A[0][i1],&A[1][i1],&A[2][i1]);		\n}	\nprintf(\"??????? ??????? B \\n\");\nfor(i1=0;i1<3;i1++)\n{\nscanf(\"%d%d%d\",&B[0][i1],&B[1][i1],&B[2][i1]);		\n}	\nfor(j=0;j<3;j++)\n{	for(i=0;i<3;i++)\n		for(k=0;k<3;k++)\n			N[i][j]=N[i][j]+A[k][i]*B[j][k];\n}	\nprintf(\"?????\\n\");\nfor(i=0;i<3;i++)\n{\n	printf(\"%d %d %d\\n\",N[i][0],N[i][1],N[i][2]);	\n}	\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (745,'#include <stdio.h>\r\n#include \"Stack.h\"\r\n#include <ctype.h>\r\n#include <stdlib.h>\r\n#include \"var.h\" \r\n#include <string.h>\r\n#include \"Long.h\"\r\n#define dbgfree(p) do { printf(\"free of %p at %s:%d\\n\", p, __FILE__, __LINE__); free(p); p = NULL;} while (0)\r\n\r\n#define dbgFree(p) do { printf(\"Free at %s:%d\\n\", __FILE__, __LINE__); Free(p); p = NULL;} while (0)\r\nlong_int *long_int_p ( long_int a)\r\n{\r\n	long_int *tmp = malloc ( sizeof(long_int) ) ;\r\n	if ( !tmp )\r\n	{\r\n		perror ( \"malloc \\n\" ) ;\r\n		return NULL ;\r\n	}\r\n	*tmp = a ;\r\n	return tmp ;\r\n}\r\nchar *char_p ( char a )\r\n{\r\n	char *tmp = malloc (1) ;\r\n	if ( !tmp )\r\n	{\r\n		perror( \"malloc \\n\" ) ;\r\n		return NULL ;\r\n	}\r\n	*tmp = a ;\r\n	return tmp ;\r\n}\r\nvoid pushout ( stack *st1, stack *st2, int *Zero)\r\n{\r\n	long_int *t1, *t2, *res ;\r\n	long_int R;\r\n	char *r ;\r\n	if (empty(*st2))\r\n	{\r\n		printf(\"Error in expression\\n\");\r\n		makenull_char(st1);\r\n		makenull_long_int(st2);\r\n		return;\r\n	}\r\n	t1 = (long_int *)top( *st2 ) ;\r\n	pop_long_int ( st2 ) ;\r\n	if (empty(*st2))\r\n	{\r\n		printf(\"Error in expression\\n\");\r\n		makenull_char(st1);\r\n		makenull_long_int(st2);\r\n		Free(t1);\r\n		return;\r\n	}\r\n	t2 = (long_int *)top( *st2 ) ;\r\n	pop_long_int ( st2 ) ;\r\n	r = (char *)top( *st1 ) ;\r\n	pop_char ( st1 ) ;\r\n	if ( (*r) == \'+\' )\r\n		R = Add(*t1,*t2) ;\r\n	if ( (*r) == \'-\' )\r\n		R = Sub(*t2,*t1) ;\r\n	if ( (*r) == \'*\' )\r\n		R = mult(*t1,*t2) ;\r\n	if ( (*r) == \'/\' )\r\n	{\r\n		if ( !(t1->length==1 && t1->digits[0] ==  0) )\r\n			R = Div( *t2,*t1) ;\r\n		else \r\n		{\r\n			(*Zero) = 1;\r\n			printf ( \"Error: Division by zero \\n\" );\r\n			makenull_char(st1);\r\n			makenull_long_int(st2);\r\n			Free(t1);\r\n			Free(t2);\r\n			return;\r\n		}\r\n	\r\n	}\r\n	res = long_int_p( R ) ;\r\n	push ( st2, res ) ;\r\n	Free(t1);\r\n	Free(t2);\r\n	free(r);\r\n}\r\nint pr( char c )\r\n{ switch (c)\r\n	{\r\n		case \'(\':\r\n		case \')\': return 0 ;\r\n		case \'+\':\r\n		case \'-\': return 1 ;\r\n		case \'*\':\r\n		case \'/\': return 2 ;\r\n	}\r\n	return 0;\r\n\r\n}\r\nlong_int calc ( )\r\n{\r\n	extern hkod *H[100];\r\n	extern stack st1,st2;\r\n	char c;\r\n	int  flg=0, nul=0, alpha = 0, allocated = 0, used = 0, zero = 0, fr = 0;\r\n	long_int a,tmp, tmp1, *ptmp,null,temp;\r\n	int *p ;\r\n	char *ctmp = NULL, *name = NULL,*ctemp;\r\n	while((c=getchar())!=\'\\n\')\r\n	{	\r\n		\r\n		if ( isalpha (c) || c == \'_\' || (isdigit(c)&&alpha) )\r\n		{\r\n			if ( allocated == used )\r\n			{\r\n				ctmp = realloc ( name, allocated + 10);\r\n				if ( !ctmp )\r\n				{\r\n					perror (\"realloc \\n\");\r\n				}\r\n				name = ctmp;\r\n				allocated += 10;\r\n			}\r\n				name[ used ] = c;\r\n				used++;\r\n				if ( name )\r\n					name[ used ] = 0;\r\n				alpha = 1;\r\n		}\r\n		else \r\n		{\r\n\r\n			if(empty(st2)&&!name)\r\n				nul=1;\r\n			if(isdigit(c))\r\n			{\r\n				nul = 0;\r\n				if(flg)\r\n				{\r\n					temp = Mult ( a, 10 );\r\n					tmp1.digits = calloc(1, sizeof(int));\r\n					tmp1.length = 1;\r\n					tmp1.sgn = 0;\r\n					tmp1.digits[0] = c - \'0\';\r\n					p = a.digits;\r\n					a = Add (temp, tmp1);\r\n					free(p);\r\n					pop_long_int(&st2);\r\n				free(ptmp);\r\n					free(temp.digits);\r\n					free(tmp1.digits);\r\n					ptmp=long_int_p(a);\r\n					push(&st2,ptmp);\r\n				}\r\n				else\r\n				{\r\n					a.digits = calloc(1, sizeof(int));\r\n					a.length = 1;\r\n					a.sgn = 0;\r\n					a.digits[0] = c - \'0\';\r\n					flg=1;\r\n					ptmp=long_int_p(a);\r\n					push(&st2,ptmp);\r\n				}\r\n			}\r\n			else\r\n			{\r\n				if ( name )\r\n				{\r\n					a = get_value ( name, H );\r\n					ptmp = long_int_p(a);\r\n					push ( &st2,ptmp );\r\n					free ( name );\r\n					name = NULL;\r\n					allocated = 0;\r\n					used = 0;\r\n					alpha = 0;\r\n				}\r\n				flg=0;\r\n				 if ( c==\'(\')\r\n				{\r\n					ctmp=char_p(c);\r\n					push(&st1,ctmp);\r\n					nul = 1;\r\n			\r\n				}\r\n				if(c==\')\')\r\n				{\r\n					while(!empty(st1)&&(*(char *)top(st1))!=\'(\')\r\n					{\r\n\r\n						pushout(&st1,&st2,&zero);\r\n						if ( zero )\r\n						{	\r\n							free( name);\r\n							free( ctmp );\r\n							makenull_char ( &st1);\r\n							makenull_long_int ( &st2 );\r\n							null.digits = calloc(1, sizeof(int));\r\n							null.digits[0] = 0;\r\n							null.length = 1;\r\n							null.sgn = 0;\r\n							return null;\r\n						}\r\n					}\r\n					if((*(char *)top(st1))==\'(\')\r\n					{\r\n						ctemp = (char *)(top(st1));\r\n						pop_char(&st1);\r\n						free(ctemp);\r\n					}\r\n					\r\n								\r\n				}\r\n				if(c==\'+\'||c==\'*\'||c==\'-\'||c==\'/\')\r\n				{\r\n					if( nul && c== \'-\')\r\n					{\r\n							null.digits = calloc(1, sizeof(int));\r\n							null.digits[0] = 0;\r\n							null.length = 1;\r\n							null.sgn = 0;\r\n							ptmp = long_int_p(null);\r\n							push( &st2,ptmp );\r\n							nul = 0;\r\n						\r\n					}\r\n					if(empty(st1))\r\n					{\r\n						ctmp=char_p(c);\r\n						push(&st1,ctmp);\r\n						continue;\r\n					}\r\n					while((!empty(st1))&&(pr(c)<=pr(*(char *)top(st1))))\r\n					{\r\n						pushout( &st1, &st2, &zero );\r\n						if ( zero )\r\n						{\r\n							free ( name );\r\n							Free (ptmp );\r\n							free ( ctmp );\r\n							makenull_char (&st1);\r\n							makenull_long_int(&st2);\r\n						}\r\n					}\r\n					ctmp=char_p(c);\r\n					push(&st1,ctmp);\r\n				\r\n				}\r\n			}\r\n		}\r\n			\r\n	}\r\n	if( name )\r\n	{\r\n		a = get_value(name, H);\r\n		ptmp = long_int_p(a);\r\n		push(&st2,ptmp );\r\n		free(name);\r\n	}\r\n	while(!empty(st1))\r\n	{\r\n		pushout(&st1,&st2, &zero);\r\n                if ( zero )\r\n                {\r\n	                free ( name );\r\n        	        free ( ctmp ); \r\n                        makenull_char(&st1);\r\n                        makenull_long_int(&st2);\r\n						null.digits = calloc(1, sizeof(int));\r\n						null.digits[0] = 0;\r\n						null.length = 1;\r\n						null.sgn = 0;\r\n						return null;\r\n		}\r\n	}\r\n	if (!empty(st2))\r\n	ptmp=(long_int*)top(st2);\r\n	else \r\n	{\r\n		a.digits = calloc(1,sizeof(int));\r\n		a.sgn = 0;\r\n		a.length = 1;\r\n		return a;\r\n	}\r\n	pop_long_int ( &st2 );\r\n	a = *ptmp;\r\n	free (ptmp);\r\n	if(!empty(st2))\r\n	{\r\n		free(ctmp);\r\n		if(!empty(st1))\r\n		makenull_char(&st1);\r\n//		printf(\" i was here !!!\\n\");\r\n		makenull_long_int(&st2);\r\n	}\r\n\r\n	return a ;\r\n}\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (746,'#include<stdio.h>\r\n#include\"Long.h\"\r\n#include<stdlib.h>\r\n#include<math.h>\r\n#define BASE 10000\r\n\r\n#define dbgfree(p) do {/* printf(\"free of %p at %s:%d\\n\", p, __FILE__, __LINE__);*/ free(p); p = NULL;} while (0)\r\n#define dbgFree(p) do {/* printf(\"Free at %s:%d\\n\", __FILE__, __LINE__); Free(p);*/ p = NULL;} while (0)\r\n\r\nint max_ ( int a, int b )\r\n{\r\n	if ( a > b )\r\n		return a;\r\n	 return b;\r\n}\r\nvoid shift( long_int *val, int k)\r\n{\r\n	int *t,*tmp,m=0, i = k,p=val->length+k,h =0,fl=0;\r\n	if(k == 0)\r\n		return;\r\n	for(;h<val->length;h++)\r\n	{\r\n		if(val->digits[h]!=0)\r\n		{\r\n			fl =1;\r\n			break;\r\n			}\r\n	}\r\n	if (!fl)\r\n		return;\r\n	t = calloc ( val->length + k, sizeof(int));\r\n	for ( ;i < p ; i++  )\r\n	{\r\n		\r\n		t[i] = val->digits[m];\r\n		m++; \r\n	}\r\n	val->length = p;\r\n	tmp =val->digits;\r\n	val->digits = t;\r\n	free(tmp);\r\n}\r\nvoid print_long ( long_int val )\r\n{\r\n	\r\n	int i = 0;\r\n	if ( val.sgn > 0 )\r\n		printf ( \"-\" );\r\n	for ( i = val.length-1  ; i >= 0; i-- )\r\n		{\r\n			if ( i == val.length - 1 )\r\n				printf ( \"%d\", val.digits[i] );\r\n			else \r\n				printf ( \"%04d\",val.digits[i] );\r\n		}\r\n	printf (\"\\n\");\r\n	\r\n}\r\nvoid Free( long_int *A )\r\n{\r\n		dbgfree ( A->digits );\r\n		dbgfree ( A );\r\n}\r\nint compare ( long_int val_1, long_int val_2 )\r\n{\r\n	int i = 0;\r\n	if ( val_1.length > val_2.length )\r\n		return 1;\r\n	if ( val_1.length < val_2.length )\r\n		return -1;\r\n	for ( i = val_1.length-1; i >= 0; i-- )\r\n	{\r\n		if ( val_1.digits[i] == val_2.digits[i] )\r\n			continue;\r\n		if ( val_1.digits[i] > val_2.digits[i] )\r\n			return 1;\r\n		if ( val_1.digits[i] < val_2.digits[i] )\r\n			return -1;\r\n	}\r\n	return 0;\r\n}\r\nlong_int Sub ( long_int val_1, long_int val_2 )\r\n{\r\n	long_int res,v1,v2;\r\n	int i = 0, buffer = 0, val1 = 0, val2 = 0, cmpr = 0;\r\n	if ( val_2.sgn == 1 )\r\n	{\r\n		res.digits = val_2.digits;\r\n		res.sgn = 0;\r\n		res.length = val_2.length;\r\n		return Add( val_1, res );\r\n	}\r\n	if ( val_1.sgn == 1 )\r\n	{\r\n		res.digits = val_2.digits;\r\n		res.sgn = 1;\r\n		res.length = val_2.length;\r\n		return Add( val_1, res);\r\n	}\r\n	res.digits = NULL;\r\n	res. length = max_( val_1.length, val_2.length );\r\n	res.digits = calloc( res.length,sizeof(int) ); \r\n	cmpr = compare ( val_1, val_2 );\r\n	if ( cmpr == -1 )\r\n	{\r\n		v1 = val_2;\r\n		v2 = val_1;\r\n		res.sgn = 1;\r\n	}\r\n	if ( cmpr == 1 )\r\n	{\r\n		v1 = val_1;\r\n		v2 = val_2;\r\n		res.sgn = 0;\r\n	}\r\n	if ( cmpr == 0 )\r\n	{\r\n		res.digits[0] = 0;\r\n		res.length = 1;\r\n		res.sgn = 0;\r\n		return res;\r\n	}\r\n	while ( i < val_1.length || i < val_2.length)\r\n	{		\r\n		res.digits[i] = 0;\r\n		if ( i >= v1.length )\r\n			val1 = 0;\r\n		else \r\n			val1 = v1.digits[i];\r\n		if ( i >= v2.length )\r\n				val2 = 0;\r\n		else \r\n			val2 = v2.digits[i];\r\n		res.digits[i] = val1 - val2 + buffer;\r\n		if ( res.digits[i] < 0)\r\n		{\r\n			if ( i == res.length -1 )\r\n				res.digits[i] *=(-1);\r\n			else \r\n				res.digits[i] += BASE;\r\n			buffer = -1;\r\n		}\r\n		else \r\n			buffer = 0;\r\n		i++;\r\n	}\r\n	if ( buffer == -1 )\r\n		res.sgn = 1;\r\n\r\n	while (res.length && res.digits[res.length-1] == 0) res.length--;	\r\n	return res;	\r\n}\r\nlong_int Mult ( long_int val_1, int val_2 )\r\n{\r\n	long_int res;\r\n	int i = 0, buffer = 0, val1 = 0, val2 = 0, RES, len ;\r\n	res.digits = NULL;\r\n	res.digits = calloc( val_1.length+1 , sizeof(int) );\r\n	res.length = val_1.length;\r\n	res.sgn = 0;\r\n	while ( i < val_1.length )\r\n	{\r\n		if ( !val_1.digits[i] )\r\n			val1 = 0;\r\n		else \r\n			val1 = val_1.digits[i];\r\n		RES = val1 * val_2;\r\n		res.digits[ i ] = RES % BASE + buffer;\r\n		buffer = RES / BASE;\r\n		if ( (res.digits[i] / BASE) !=0)\r\n		{\r\n			buffer += res.digits[i] / BASE;\r\n			res.digits[i] %= BASE;\r\n		}\r\n		\r\n	i++;\r\n	}\r\n	if ( buffer )\r\n	{\r\n		\r\n		res.digits [ i ] = buffer;\r\n		res.length++;\r\n	}\r\n	return res;\r\n}\r\nlong_int mult ( long_int val_1, long_int val_2 )\r\n{\r\n	int flag = 0;\r\n	long_int res, tmp;\r\n	int i = 0, t = 0, *p;\r\n	res.sgn = ( val_1.sgn + val_2.sgn )%2;\r\n	res.digits = NULL;\r\n	for ( i = 0; i < val_2.length; i++ )\r\n	{\r\n\r\n		tmp = Mult ( val_1, val_2.digits[i] );\r\n		shift ( &tmp, t );\r\n		if ( !flag )\r\n		{\r\n			res = tmp;\r\n			flag = 1;\r\n		}\r\n		else\r\n		{\r\n			p = res.digits;\r\n			res = Add ( res, tmp );\r\n			free ( p );\r\n			free(tmp.digits);\r\n		}\r\n		t++;\r\n	}\r\n	res.sgn = ( val_1.sgn + val_2.sgn )%2;\r\n	return res;\r\n}\r\nlong_int Add ( long_int val_1, long_int val_2 )\r\n{\r\n\r\n	long_int res;\r\n	int i = 0, max_len = 0, val1, val2, buffer = 0,*tmp =NULL;\r\n	res.sgn = 0;\r\n	if ( (val_1.sgn * val_2.sgn) == 1)\r\n		res.sgn = 1;\r\n	else\r\n	{\r\n		if( val_1.sgn == 1 )\r\n		{\r\n			res.digits = val_1.digits;\r\n			res.sgn = 0;\r\n			res.length = val_1.length;\r\n			return Sub( val_2, res );\r\n		}\r\n		if ( val_2.sgn == 1 )\r\n		{\r\n			res.digits = val_2.digits;\r\n			res.sgn = 0;\r\n			res.length = val_2.length;\r\n			return Sub( val_1, res );\r\n		}\r\n	}\r\n	max_len = max_( val_1.length, val_2.length );\r\n	res.digits = NULL;\r\n	res.digits = calloc (max_len+1, sizeof(int) );\r\n	res.length = max_len;\r\n	for ( i = 0 ; i < max_len; i++ )\r\n	{\r\n		res.digits[i] = 0;\r\n		if ( i>=val_1.length )\r\n			val1 = 0;\r\n		else \r\n			val1 = val_1.digits[i];\r\n		if ( i >= val_2.length)\r\n				val2 = 0;\r\n		else \r\n			val2 = val_2.digits[i];\r\n		res.digits[i]  = val1 + val2 + buffer;\r\n		buffer = res.digits[i] / BASE;\r\n		res.digits[i] = res.digits[i] %  BASE;\r\n	}\r\n	if ( buffer )\r\n	{\r\n		res.digits[i] = buffer;\r\n		res.length++;\r\n	}\r\n	return res;\r\n}\r\nlong_int Div ( long_int val_1, long_int val_2 )\r\n{\r\n	int digit, i,*p, left = 0, right = BASE, middle, flag = 0 ;\r\n	long_int result, tmp, res, product;\r\n	if (  (compare(val_1, val_2)) < 0)\r\n	{\r\n		res.digits = calloc(1, sizeof(int));\r\n		res.digits[0] = 0;\r\n		res.length = 1;\r\n		res.sgn = 0;\r\n		return res;\r\n	}\r\n	p=malloc(sizeof(int));\r\n	res.length = val_1.length-val_2.length + 1;\r\n	res.digits = calloc(res.length, sizeof(int));\r\n	res.sgn = ( val_1.sgn +val_2.sgn)%2;\r\n	tmp = val_1;\r\n	for ( i = res.length - 1; i >= 0; i-- )\r\n	{\r\n\r\n		product.digits=calloc(1,sizeof(int));\r\n		while ( right - left > 1 )\r\n		{\r\n			middle = ( left + right )/2;\r\n			free(product.digits);\r\n			product = Mult( val_2, middle );\r\n			shift ( &product, i );\r\n			if ( (compare ( tmp, product ) ) >= 0 )\r\n			{\r\n				left = middle;\r\n			}\r\n			else\r\n			{\r\n				right = middle;\r\n			}\r\n		}\r\n		digit = left;\r\n		left = 0;\r\n		right = BASE;\r\n		free(product.digits);\r\n		product = Mult ( val_2, digit );\r\n		shift ( &product, i );\r\n		res.digits[i] = digit;\r\n		if (flag )\r\n		{		\r\n			p = tmp.digits;\r\n		}\r\n		tmp = Sub ( tmp, product );\r\n		free(p);\r\n		flag = 1;\r\n\r\n		free(product.digits);\r\n\r\n	}\r\n	while (res.length && res.digits[res.length-1] == 0) res.length--;\r\n\r\nfree(tmp.digits);\r\n	return res;\r\n}\r\n\r\n\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (747,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include \"var.h\"\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#include \"Stack.h\"\r\n#include \"Long.h\"\r\nhkod *H[100] = { NULL };\r\nstack st1;\r\nstack st2;\r\nint main( )\r\n{\r\n	int i, allocated = 0, used = 0, alpha = 0, nul = 1, h = 0;\r\n	long_int res, *p,val;\r\n	char c,*q =\"quit\", *tmp = NULL, *name = NULL;\r\n	st1=creat();\r\n	st2=creat();\r\n	while ( scanf(\"%c\",&c)==1)\r\n	{\r\n		if( c == \'+\' || c == \'/\' || c == \'*\' || (c ==\'-\'&&!nul))\r\n		{\r\n			if (!name)\r\n			{\r\n				printf(\"Error in expression\\n\");\r\n				continue;\r\n			}\r\n			res = get_value( name, H );\r\n			p = malloc(sizeof(long_int));\r\n			if(!p)\r\n			{\r\n				perror(\"malloc\\n\");\r\n				return 0;\r\n			}\r\n			*p=res;\r\n			push(&st2,p);\r\n			ungetc(c, stdin);\r\n			res = calc();\r\n			print_long( res);\r\n			free (name);\r\n			free(res.digits);\r\n			tmp = NULL;\r\n			name = NULL;\r\n			allocated = 0;\r\n			used = 0;\r\n			alpha = 0;\r\n			continue;\r\n		}\r\n		if( (isdigit (c) || c == \'(\' || c == \'-\')&&!alpha )\r\n		{\r\n			ungetc( c,stdin );\r\n			res = calc();\r\n			print_long(res);\r\n			free(res.digits);\r\n		}\r\n		if ( isalpha (c) || c == \'_\' || (isdigit(c)&&alpha) )\r\n		{\r\n			if ( allocated == used )\r\n			{\r\n				tmp = realloc ( name, allocated + 10);\r\n				if ( !tmp )\r\n				{\r\n					perror (\"realloc \\n\");\r\n				}\r\n				name = tmp;\r\n				allocated += 10;\r\n			}\r\n			name[ used ] = c;\r\n			used++;\r\n			if ( name && (used!=allocated))\r\n			{\r\n				name[ used ] = 0;\r\n			\r\n			}\r\n			if (name&&used==allocated)	\r\n			{\r\n				tmp = realloc ( name, allocated +1);\r\n				if ( !tmp )\r\n				{\r\n					perror (\"realloc \\n\");\r\n				}\r\n				name = tmp;\r\n				allocated++;\r\n				name[used]=0;\r\n				\r\n			}\r\n			alpha = 1;\r\n			nul = 0;\r\n		}\r\n		if ( c == \'=\')\r\n		{\r\n			res = calc();\r\n			set_value ( name, res, H );\r\n			h = 1;\r\n			free ( name );\r\n			tmp=NULL;\r\n			name = NULL;\r\n			allocated = 0;\r\n			used = 0;\r\n			alpha = 0;\r\n			nul =1;\r\n		}\r\n		if ( c == EOF)\r\n			break;\r\n		if ( c == \'\\n\' )\r\n		{\r\n		\r\n		if ( name )\r\n		{\r\n			val = get_value ( name, H );\r\n			print_long ( val );\r\n			free ( name );\r\n			if(val.digits)\r\n			free(val.digits);\r\n			tmp = NULL;\r\n			name = NULL;\r\n			allocated = 0;\r\n			used = 0;\r\n			alpha = 0;\r\n			nul=1;\r\n		}\r\n		}\r\n	}\r\n	if( tmp )\r\n		\r\n			free(tmp);\r\n\r\n	\r\n	if ( (!empty(st1))  )\r\n		makenull_char(&st1);\r\n	if (!empty(st2))\r\n		makenull_long_int(&st2)	;\r\n	if ( h )\r\n	{\r\n		\r\n		cleanup(H);}\r\n		\r\n	return 0 ;\r\n\r\n\r\n}\r\n\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (748,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#include \"Stack.h\"\r\n#include\"Long.h\"\r\nstruct item{\r\n	void *data;\r\n	struct item *next;\r\n};\r\nvoid push(stack *st, void *d)\r\n{\r\n	struct item *p=(void *)malloc(sizeof(*p));\r\n	if(!p)\r\n	{\r\n		perror(\"malloc\\n\");\r\n	}\r\n	p->data=d;\r\n	p->next=st->head;\r\n	st->head=p;\r\n}\r\nvoid pop_char(stack *st)\r\n{\r\n	struct item *p=st->head;\r\n	st->head=p->next;\r\n	free(p);\r\n}\r\nvoid pop_long_int(stack *st)\r\n{\r\n	struct item *p = st->head;\r\n	st->head = p->next;\r\n	free(p);\r\n}\r\nint empty(stack st)\r\n{\r\n	return(st.head==NULL);\r\n}\r\nvoid *top(stack st)\r\n{\r\n	void *p=st.head->data;\r\n\r\n	return p;\r\n}\r\nvoid makenull_long_int(stack *st)\r\n{\r\n	long_int *p;\r\n	int *d;\r\n	while(!empty(*st))\r\n	{\r\n		p = top(*st);\r\n		d = p->digits;\r\n		pop_long_int(st);\r\n		free(d);\r\n	}\r\n}\r\nvoid makenull_char(stack *st)\r\n{\r\n	char *p;\r\n	while(!empty(*st))\r\n	{\r\n	p = (char *)top(*st);\r\n		pop_char(st);\r\n		free(p);\r\n	}\r\n}\r\nstack creat()\r\n{\r\n	stack st;\r\n	st.head= NULL;\r\n	return st;\r\n}\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (749,'#include<stdio.h>\r\n#include<string.h>\r\n#include<stdlib.h>\r\n#include<ctype.h>\r\n#define SIZE 100\r\n#include \"var.h\"\r\n#include\"Long.h\"\r\nunsigned int hashkod ( char *s )\r\n{\r\n	unsigned int res=0;\r\n	for(;*s;s++)\r\n	\r\n		res=res*37+*s * 38;\r\n		return(res%SIZE);\r\n}\r\n\r\nvoid set_value( char *name, long_int value, hkod *(*H))\r\n{\r\n\r\n	unsigned int K;\r\n	int fl=0;\r\n	hkod *p=NULL ;\r\n	K = hashkod ( name );\r\n	p = H[K];\r\n	for(;p;p=p->next)\r\n	{\r\n		fl=0;\r\n		if(strcmp(p->name,name)==0)\r\n		{\r\n			fl=1;\r\n			break;\r\n		}\r\n	}\r\n	if(!fl)\r\n	{\r\n		\r\n		p = malloc(sizeof(*p));\r\n		p -> name = malloc( strlen(name) + 1);\r\n		strcpy ( p->name, name ) ; \r\n		p->value = value;\r\n		p->next = H[K];\r\n		H[K] = p;\r\n	}\r\n	else\r\n	{\r\n		free(p->value.digits);\r\n		p->value = value;\r\n	}\r\n	\r\n}\r\nlong_int get_value( char * name , hkod *( *H))\r\n{\r\n	unsigned int K=hashkod(name);\r\n	hkod *p = H[ K ];\r\n	long_int a;\r\n	int i = 0;\r\n	for(;p;p=p->next)\r\n	{\r\n		if ( strcmp(p->name, name) == 0)\r\n		{\r\n			a.digits = calloc(p->value.length, sizeof(int));\r\n			for( i = 0; i<p->value.length; i++)\r\n			{\r\n				a.digits[i] = p->value.digits[i];\r\n			}\r\n			a.length = (p->value).length;\r\n			a.sgn = (p->value).sgn;\r\n			return a;\r\n		}\r\n	}\r\n	a.digits = calloc(1, sizeof(int));\r\n	a.digits[0] = 0;\r\n	a.length = 1;\r\n	a.sgn = 0;\r\n	return a;\r\n}\r\nvoid cleanup (  hkod *( *H) )\r\n{\r\n	int i=0;\r\n	hkod *p=H[0], *tmp;\r\n	for ( i=0; i<SIZE; i++)\r\n	{\r\n		p=H[i];\r\n		for(;p;)\r\n		{\r\n			tmp=p;\r\n			p=p->next;\r\n			free(tmp->name);\r\n			free((tmp->value).digits);\r\n			free(tmp);\r\n		}\r\n	}\r\n}\r\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (750,'#include \"huffman.h\"\n\nvoid huffman_calculate_freq(Huffman *huffman)\n{\n	int i, count;\n	char buffer[N];\n	huffman->size=0;\n	while((count=fread(buffer, sizeof(char), N, huffman->input))!=0)\n	{\n		huffman->size+=count;\n		for(i=0; i<count; i++)\n		{\n			huffman->frequency[(unsigned char)buffer[i]]++;\n		}\n	}\n}\n\nvoid huffman_build_tree(Huffman *huffman)\n{\n	Heap *heap;\n	int size;\n	heap=heap_create();\n	heap_init(heap, huffman->frequency);\n	size=heap_size(heap);\n	if(size!=1)\n	{\n		int i;\n		for(i=0; i<size-1; i++)\n		{\n			heap_add(heap, tree_create_2t(heap_extract(heap), heap_extract(heap)));\n		}\n		huffman->root=heap_extract(heap);\n	}\n	else\n	{\n		huffman->root=tree_create_2t(heap_extract(heap), NULL);\n	}\n	heap_destroy(heap);\n}\n\nvoid huffman_generate_codes_func(Huffman *huffman, Tree *tree, char *code, int length)\n{\n    if(!tree)\n    {\n	    return;\n    }\n    if(tree->symbol!=HUFFMAN_TREE)\n    {\n	    code[length]=0;\n	    memcpy(huffman->table[tree->symbol], code, length+1);\n//	    printf(\"%c->%s\\n\", (char)tree->symbol, code);\n    }\n    else\n    {\n	    code[length]=\'0\';\n	    huffman_generate_codes_func(huffman, tree->left, code, length+1);\n	    code[length]=\'1\';\n	    huffman_generate_codes_func(huffman, tree->right, code, length+1);\n    }\n\n}\n\n\nvoid huffman_generate_codes(Huffman * huffman)\n{\n    char code[256];\n    huffman_generate_codes_func(huffman, huffman->root, code, 0);\n}\n\nvoid huffman_encode(Huffman *huffman)\n{\n	int i, count, bit_pos=0, byte_pos=0, code;\n	char buffer_read[N], buffer_write[N];\n	char *p;\n	huffman_calculate_freq(huffman);\n	huffman_build_tree(huffman);\n	huffman_generate_codes(huffman);\n	fwrite(&huffman->size, sizeof(int), 1, huffman->output);\n	fwrite(huffman->frequency, sizeof(int), 256, huffman->output);\n	fseek(huffman->input, 0, SEEK_SET);\n	while((count=fread(buffer_read, sizeof(char), N, huffman->input))!=0)\n	{\n		for(i=0; i<count; i++)\n		{\n			\n//			fprintf(stdout, \"begin \'%c\' i: %d\\n\",buffer_read[i],i);\n			code=(unsigned char)buffer_read[i];\n//			fprintf(stdout, \"end code %d   ch:  %d\\n\",code,huffman->table[code][0]);\n\n			for(p=huffman->table[code]; *p; p++)\n			{\n				if(*p==\'1\')\n				{\n					buffer_write[byte_pos]|=(1 << bit_pos);\n				}\n				else\n				{\n					buffer_write[byte_pos]&=~(1 << bit_pos);\n				}\n				if(++bit_pos==8)\n				{\n					bit_pos=0;\n					++byte_pos;\n					if(byte_pos>=N)\n					{\n						byte_pos=0;\n						fwrite(buffer_write, sizeof(char), N, huffman->output);\n					}\n				}\n			}\n		}\n	}\n	if(byte_pos!=0)\n	{\n		if(bit_pos!=0)\n		{\n			while(bit_pos!=8)\n			{	\n				buffer_write[byte_pos]&=~(1 << bit_pos++);\n			}\n			byte_pos++;\n		}	\n		fwrite(buffer_write, sizeof(char), byte_pos, huffman->output);\n\n	}\n}\n\nvoid huffman_decode(Huffman *huffman)\n{\n	int count, bit_pos=0, byte_pos=N, written=0;\n	char buffer_read[N], buffer_write[N];\n	Tree *p;\n	fread(&huffman->size, sizeof(int), 1, huffman->input);\n	fread(huffman->frequency, sizeof(int), 256, huffman->input);\n	huffman_build_tree(huffman);\n	huffman_generate_codes(huffman);\n	while(huffman->size--)\n	{\n		p=huffman->root;\n		while(p->symbol==HUFFMAN_TREE)\n		{\n			if(byte_pos>=N)\n			{\n				count=fread(buffer_read, sizeof(char), N, huffman->input);\n				if(count==0)\n				{\n					fwrite(buffer_write, sizeof(char), written, huffman->output);\n					return;\n				}\n				bit_pos=0;\n				byte_pos=0;\n			}\n//			printf(\"byte %d bit %d\\n\", byte_pos, bit_pos);\n			if(buffer_read[byte_pos]&(1 << bit_pos))\n			{\n				p=p->right;\n			}\n			else\n			{\n				p=p->left;\n			}\n			if(++bit_pos==8)\n			{\n				bit_pos=0;\n				++byte_pos;\n			/*	if((byte_pos==count)&&(count!=N))\n				{\n					fwrite(buffer_write, sizeof(char), written, huffman->output);\n					return;\n				} */	\n			}\n		}	\n		buffer_write[written++]=p->symbol;\n		if(written>=N)\n		{\n			fwrite(buffer_write, sizeof(char), written, huffman->output);\n			written=0;\n		}\n\n	}\n	if(written!=0)\n	{\n		fwrite(buffer_write, sizeof(char), written, huffman->output);\n		written=0;\n	}\n}\n\nvoid huffman_destroy(Huffman *huffman)\n{\n	tree_destroy(huffman->root);\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (751,'#include<stdio.h>\n#include<stdlib.h>\n#include \"huffman.h\"\n\nstatic Huffman huffman;\n\nint main(int argc, char *argv[])\n{\n	if(argc<3)\n	{\n		printf(\"?? ??????? ??????????\\n\");\n		printf(\"?????????????: %s ???_?????? ???_?????\\n\", argv[0]);\n		printf(\"               %s -d ???_?????? ???_?????\\n\", argv[0]);\n		return 0;\n	}\n	else if(argc==3)\n	{\n		if((huffman.input=fopen(argv[2], \"r\"))==NULL)\n		{\n			printf(\"?????? ??????? ???? %s\\n\", argv[2]);\n			return 0;\n		}\n		if((huffman.output=fopen(argv[1], \"w\"))==NULL)\n		{\n			printf(\"?????? ??????? ???? %s\\n\", argv[1]);\n			return 0;\n		}\n		huffman_encode(&huffman);\n		fclose(huffman.input);\n		fclose(huffman.output);\n		huffman_destroy(&huffman);				\n	}\n	else if(argc==4 && !strcmp(argv[1], \"-d\"))\n	{\n		if((huffman.input=fopen(argv[2], \"r\"))==NULL)\n		{\n		printf(\"?????? ??????? ???? %s\\n\", argv[2]);\n		return 0;\n		}\n		if((huffman.output=fopen(argv[3], \"w\"))==NULL)\n		{\n			printf(\"?????? ??????? ???? %s\\n\", argv[3]);\n			return 0;\n		}\n		huffman_decode(&huffman);\n		fclose(huffman.input);\n		fclose(huffman.output);\n		huffman_destroy(&huffman);\n	}\n	else\n	{\n		printf(\"??????\\n\");\n		return 0;\n	}\n	return 0;\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (752,'#include \"tree.h\"\n\nTree *tree_create_2i(int symbol, int frequency)\n{\n    Tree *tree;\n    tree=(Tree*)malloc(sizeof(Tree));\n    tree->symbol=symbol;\n    tree->frequency=frequency;\n    tree->left=NULL;\n    tree->right=NULL;\n    return tree;\n}\n\nTree *tree_create_2t(Tree *left, Tree *right)\n{\n    Tree *tree;\n    tree=(Tree*)malloc(sizeof(Tree));\n    tree->symbol=HUFFMAN_TREE;\n    tree->frequency=(left?left->frequency:0)+(right?right->frequency:0);\n    tree->left=left;\n    tree->right=right;\n    return tree;\n}\n\nvoid tree_destroy(Tree *tree)\n{\n    if(tree==NULL) \n    {\n	    return;\n    }\n    tree_destroy(tree->left);\n    tree_destroy(tree->right);\n    free(tree);\n}\n\nvoid heap_move_up(Heap *heap, int pos)\n{\n    Tree *t;\n    int parent;\n    while(pos>0)\n    {\n        parent=(pos-1)/2;\n        if(heap->data[parent]->frequency<heap->data[pos]->frequency)\n	{\n            break;\n        }\n        t=heap->data[pos];\n        heap->data[pos]=heap->data[parent];\n        heap->data[parent]=t;\n        pos=parent;\n    }\n}\n\nvoid heap_heapify(Heap *heap, int i)\n{\n    int l, r, m;\n    Tree *t;\n    while(i<heap->size)\n    {\n        m=i;\n        l=2*i+1;\n        r=l+1;\n        if(l<heap->size && heap->data[l]->frequency<heap->data[m]->frequency)\n	{\n            m=l;\n        }\n        if(r<heap->size && heap->data[r]->frequency<heap->data[m]->frequency)\n	{\n            m=r;\n        }\n        if(i!=m)\n	{\n            t=heap->data[i];\n            heap->data[i]=heap->data[m];\n            heap->data[m]=t;\n            i=m;\n        }\n	else\n	{\n            break;\n        }\n    }\n}\nvoid heap_build(Heap *heap)\n{\n    int i;\n    for(i=heap->size/2; i>=0; --i)\n    {\n        heap_heapify(heap, i);\n    }\n}\n\nHeap *heap_create()\n{\n    Heap *heap;\n    heap=(Heap*)malloc(sizeof(Heap));\n    heap->size=0;\n    heap->data=NULL;\n    return heap;\n}\n\nvoid heap_init(Heap *heap, int *frequency)\n{\n    int i, count;\n    for(i=0, count=0; i<256; i++)\n    {\n        if (frequency[i]!=0)\n	{\n		count++;\n	}\n    }\n    heap->size=count;\n    heap->data=(Tree **)malloc(count *sizeof(Tree*));\n    for(i=0, count=0; i<256; i++)\n    {\n        if(frequency[i])\n	{\n            heap->data[count++]=tree_create_2i(i, frequency[i]);\n        }\n    }\n    heap_build(heap);\n}\n\nvoid heap_add(Heap *heap, Tree *tree)\n{\n    heap->data[heap->size++]=tree;\n    heap_move_up(heap, heap->size-1);\n}\n\nint heap_size(Heap *heap)\n{\n    return heap->size;\n}\n\nTree *heap_extract(Heap *heap)\n{\n    Tree *tree;\n    tree=heap->data[0];\n    heap->data[0]=heap->data[--(heap->size)];\n    heap_heapify(heap, 0);\n    return tree;\n}\n\nvoid heap_destroy(Heap *heap)\n{\n    if(heap->data!=NULL)\n    {\n        free(heap->data);\n    }\n    free(heap);\n}\n','Ð¡ÐµÑ€Ð³ÐµÐ¹','Sergey','m');
INSERT INTO `bias` VALUES (753,'#include \"head.h\"\n\nchar* schityvanie(char** S1, char** S2)\n{\n	int c=0,i=0,size=20,size2=20, fl = 0, fl2 = 0;\n	char* s=(char *)malloc(size*sizeof(char));\n	char* S = (char *)malloc(size2*sizeof(char));\n	while ((c = getchar())!=\'=\'){\n\n		if (c == EOF && fl == 0) {\n			*S1 = NULL;\n			free(s);\n			free (S);\n			*S2 = NULL;\n			return;\n		}\n		if (c == EOF && fl == 1){\n			*S1 = NULL;\n			free (S);\n			*S2 = s;\n			s[i] = 0;\n			return;\n		}\n\n		if (c != \' \') {\n			fl = 1;\n			if (i==size-1)\n			{\n				size+=20;\n				s =(char *)realloc(s,size*sizeof(char));\n			}\n			s[i++] = c;\n		}\n	}\n	if (s)\n		s[i] = 0;\n	*S1 = s;\n	i=0;\n	if (fl2)\n		S[i++] = c;\n	while ((c=getchar())!= \'\\n\'&& c != EOF) {\n		if (c!=\' \') {\n			if (i==size2-1)\n			{\n				size2+=20;\n				S =(char *)realloc(S,size2*sizeof(char));\n			}\n			S[i++] = c;\n		}\n	}\n	S[i] = 0;\n	*S2 = S;\n	return s;\n}\nint main()\n{	int i = 0, fl_is_oper = 0, k = 0;\n	int a;\n\n	char* s,* opz = NULL, *var;\n	storageel *p = head;\n	while (!feof(stdin)) {\n		schityvanie(&var, &s);\n		if (!var && !s)\n			break;\n#ifdef DEBUG\n			p = head;\n		if (p) {\n			printf (\"Var List:\\n\");\n			while (p) {\n				printf (\"\\t%s = %d\\n\", p->elt.name, p->elt.value);\n				p = p->next;\n			}\n		}\n#endif\n		k++;\n		fl_is_oper = 0;\n		for (i = 0; s[i]; i++)\n			if (is_fourth(s[i]) || is_fifth(s[i])) {\n				fl_is_oper = 1;\n				toopz(s, &opz);\n				a=podschet(opz);\n				break;\n			}\n#ifdef DEBUG\n		if (fl_is_oper)\n			printf (\"OPZ = %s;\\n\", opz);\n#endif\n\n		if (!fl_is_oper)\n			if (sscanf(s,\"%d\", &a) != 1){\n				if  ((a = getvalue(s)) != NULL)\n					setvalue (var,a);\n				else{\n				fprintf (stderr, \"ERROR: Incorrect value of var \\\'%s\\\'\\n\", s);\n				exit (0);\n				}\n			}\n		if (var)\n			setvalue (var,a);\n		else\n			printf (\"Result of %d string: %d;\\n\", k, a);\n		free(s);\n		free(var);\n		//if (opz)\n		free ((char *)opz);\n		s = NULL;\n		var = NULL;\n		opz = NULL;\n	}\n			p = head;\n		if (p) {\n			printf (\"Var List:\\n\");\n			while (p) {\n				printf (\"\\t%s = %d\\n\", p->elt.name, p->elt.value);\n				p = p->next;\n			}\n		}\n}\nchar * toopz(char *s, char **dest)\n{\n	int i=0,k=0,n=0,size=20;\n	stack *st;\n	struct stackel *p;\n	char* opz,c;\n	n=strlen(s);\n	opz=(char *)malloc(size*sizeof(char));\n	st =  newstack();\n	\n	while (i!=n)\n	{\n#ifdef DEBUG\n		p = st->head;\n		fprintf (stderr,\"Stack:\");\n		while (p != NULL) {\n			fprintf (stderr,\"\\\'%c\\\' -> \",p->elt);\n			p = p->next;\n		}\n		fprintf (stderr,\"NULL\\n\");\n#endif\n			\n		if (is_digit(s[i])||is_ABC(s[i])){\n			if (k>size-5)\n			{\n				size+=20;\n				opz =(char *)realloc(opz,size*sizeof(char));\n			}\n			opz[k++]=(char)s[i++];\n			continue;}\n		if (is_first(s[i])){\n			push (st, (int)s[i]);\n			i++;\n			if (k!= 0 && opz[k-1] != \' \'){\n					if (k>size-5)\n				{\n					size+=20;\n					opz =(char *)realloc(opz,size*sizeof(char));\n				}\n\n				opz[k++] = \' \';\n			}\n			continue;\n		}\n		if (is_second(s[i])) {\n			if (opz[k-1]!=\' \'){\n				if (k>size-5)\n				{\n					size+=20;\n					opz =(char *)realloc(opz,size*sizeof(char));\n				}\n\n			     opz[k++]=\' \';\n			}\n\n			while ((c =(char) pop(st)) != \'(\'){\n				opz[k++] = (char)c;\n				if (opz[k-1] != \' \')\n				opz[k++] = \' \';\n			}\n			i++;\n			continue;\n		}\n		if ( is_fourth(s[i]) || is_fifth(s[i])){\n			if (k!= 0 && opz[k-1] != \' \'){\n				if (k>size-5)\n				{\n					size+=20;\n					opz =(char *)realloc(opz,size*sizeof(char));\n				}\n				opz[k++] = \' \';\n			}\n   			if (is_fourth(s[i])){\n				while(!empty(st)&&(is_fourth(top(st))||is_fifth(top(st)))){\n					if (k>size-5)\n					{\n						size+=20;\n						opz =(char *)realloc(opz,size*sizeof(char));\n					}\n					opz[k++]=(char)pop(st);\n					if (opz[k-1] != \' \')\n						opz[k++]=\' \';\n				}\n				push(st,(int)s[i]);\n			}\n		if (is_fifth(s[i])){\n			while(!empty(st)&&is_fifth(top(st))){\n					if (k>size-5)\n					{\n						size+=20;\n						opz =(char *)realloc(opz,size*sizeof(char));\n					}\n					opz[k++]=(char)pop(st);\n					if (opz[k-1] != \' \')\n						opz[k++]=\' \';\n				}\n			push(st,(int)s[i]);\n		}\n		i++;\n		continue;\n			\n		}\n		i++;\n		}\n	\n			while(!empty(st)){\n				if (k>size-5)\n				{\n					size+=20;\n					opz =(char *)realloc(opz,size*sizeof(char));\n				}\n				if (opz[k-1] != \' \')\n					opz[k++] = \' \';\n				opz[k++]=(char)pop(st);\n				if (opz[k-1] == \'(\') {\n					printf (\"ERROR: Incorrect input data. May be annecessary operator or \\n\\t\\t\\t\\t\\t\\t\\tmistake in \\\'(\\\' \\\')\\\'\\n\");\n				}\n				opz[k++]=\' \';\n			}\n	opz[k-1] = 0;\n	*dest = opz;\n	return (char *)opz;\n}\nint podschet (char *opz) {\n	int size = 20, i = 0, a = 0, b = 0, k = 0;\n	stack *st = newstack();\n	struct stackel *p;\n	char *S =(char*)malloc(size*sizeof(char));\n	while (opz[i]){\n#ifdef DEBUG\n		p = st->head;\n		fprintf (stderr,\"Stack of podschet:\\n\");\n		while (p != NULL) {\n			fprintf (stderr,\"\\\'%d\\\' -> \",p->elt);\n			p = p->next;\n		}\n		fprintf (stderr,\"NULL\\n\");\n#endif\n		\n		if (opz[i] == \' \'){\n			i++;\n			continue;\n		}\n		if (is_digit(opz[i])){\n			a = a*10 + opz[i]-\'0\';\n			if (opz[i+1] == \' \'){\n				push(st, a);\n				a = 0;\n			}\n			i++;\n			continue;\n		}\n		if (is_summ(opz[i])){\n			b = pop (st);\n			a = pop (st);\n			if (opz[i] == \'+\')\n				push(st, a+b);\n			if (opz[i] == \'-\')\n				push(st, a-b);\n			i++;\n			a = 0;\n			b = 0;\n			continue;\n		}\n		if (is_mult(opz[i])){\n			b = pop (st);\n			a = pop (st);\n			if (opz[i] == \'*\')\n				push(st, a*b);\n			if (opz[i] == \'/\')\n				push(st, a/b);\n			i++;\n			a = 0;\n			b = 0; \n			continue;\n\n		}\n		if (is_ABC(opz[i])){\n			while (opz[i] != \' \'){\n				S[k++] = opz[i++];\n			}\n			S[k] = 0;\n			k = 0;\n			if ((a = getvalue (S)) != 0) \n				push(st, a);\n			else {\n				printf(\"Unknow var: %s\\n\", S);\n				exit (0);\n			}\n			a = 0;\n			continue;\n\n		}\n\n\n	}\n\n	\n	return pop(st);\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (754,'#include \"head.h\"\n\nstack * newstack (void)\n{\n    stack * tmp;\n    tmp = malloc(sizeof(stack));\n    tmp->head = NULL;\n    return(tmp);\n}\n\nvoid push(stack *st, int data)\n{\n    stackel* tmp;\n    tmp = (stackel *) malloc(sizeof(stackel));\n    tmp->elt = data;\n    tmp->next = st->head;\n    st->head = tmp;\n} \n\nint * top (stack *st)\n{\n    return(st->head->elt);\n}\n\nint empty (stack *st)\n{\n    return(st->head == NULL);\n}\n\nint pop (stack *st)\n{\n	int a = 0;\n    stackel *tmp;\n    if(st->head!=NULL)\n    {\n	tmp = st->head;\n	a = tmp->elt;\n	st->head = st->head->next;\n	free(tmp);\n    }\n	else{\n		printf (\"ERROR: Incorrect input data. May be annecessary operator or \\n\\t\\t\\t\\t\\t\\t\\tmistake in \\\'(\\\' \\\')\\\'\\n\");\n		exit(0);\n	}										\n	return a;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (755,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct storageel storageel;\ntypedef struct pair pair;\n\nstruct pair\n{\n    char* name;\n    int value;\n};\n\nstruct storageel {\n    pair elt;\n    storageel* next;\n};\n\nvoid setvalue (char* name,int value);\nint getvalue (char* name);\nvoid cleanup( void);\n\nstorageel* head = NULL;\n\nstorageel* find(char* name)\n{\n    storageel* a;\n    a=head;\n    while((a!=NULL)&&(strcmp(name,a->elt.name)!=0))\n	a=a->next;\n    return a;\n}\n\nvoid setvalue (char* name,int value)\n{\n    storageel* tmp;\n    tmp=find(name);\n    if (tmp!=NULL)\n	tmp->elt.value=value;\n    else\n    {\n	tmp = (storageel *) malloc(sizeof(storageel));\n	tmp->elt.value=value;\n	tmp->elt.name = (char*)malloc(sizeof(char)*(strlen(name)+1));\n	strcpy(tmp->elt.name, name);\n	tmp->next = head;\n	head = tmp;\n    }\n}\n\nint getvalue(char* name)\n{\n    storageel* tmp;\n    tmp=find(name);\n    if (tmp!=NULL)\n	return tmp->elt.value;\n    return 0;//!!!!!\n}\n\n\nvoid cleanup ()\n{\n    storageel *tmp;\n    while(head!=NULL)\n    {\n	tmp = head;\n	head = head->next;\n	free(tmp->elt.name);\n	free(tmp);\n    }\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (756,'#include<stdio.h>\n\n\nvoid sort(int *M, int l, int r)\n{\n	int i,j,k,v;\n	\n	i = l;\n	j = r;\n	k = M[(l+r)/2];\n	\n	while (i<=j)\n	{\n		while (M[i] < k)\n			i++;\n		while (M[j] > k)\n			j--;\n		if(i<=j)\n		{\n			if(i < j)\n			{\n				v=M[i];\n				M[i]=M[j];\n				M[j]=v;	\n			}\n		i++;\n		j--;\n		}\n	}\n\n	if (i < r)\n		sort(M,i,r);\n	if (l < j)\n		sort(M,l,j);\n			\n}\n\nint main()\n{	\nint M[100000],i,n,l,r;\n\nFILE *f = fopen(\"input.txt\", \"r\");\n\n\n	fscanf(f,\"%d\",&n);\n\n	for(i = 0;i < n;i++)\n	{\n		fscanf(f,\"%d\",&M[i]);\n	}\n\n	sort(M, 0, n-1);\n\n	for(i = 0; i < n; i++)\n	{\n		printf(\"%d \", M[i]);\n	}\n	printf(\"\\n\");\n	return 0;\n\n}\n\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (757,'#include<stdio.h>\nvoid sift(int *A , int N, int i)\n{int b;\nint maxind=0;\nmaxind=i;\nif(((2*i+1)<N)&&(A[2*i+1]>A[i]))maxind=2*i+1;\nif(((2*i+2)<N)&&(A[2*i+2]>A[maxind])) maxind=2*i+2;\nif(i!=maxind)\n{\n	b=A[i];\n	A[i]=A[maxind];\n	A[maxind]=b;\n	sift(A,N,maxind);\n}\n	\n		}\nint main()\n{  int M,a,b,i,c,d;\n   int A[100000];\n\nFILE *f=fopen(\"input.txt\",\"r\");\nfscanf(f,\"%d\",&M);\nfor(i=0;i<M;i++)\n {\n	 fscanf(f,\"%d\",&A[i]);\n	 \n	 \n	 }\n	\n	fclose(f);\n	\n	for(b=M/2;b>=0;b--)\n	{\n	 sift(A,M,b);\n	}\n	\n	\n	for(i=M-1;i>0;i--)\n	{  \n               c=A[i];\n	       A[i]=A[0];\n	       A[0]=c;\n	       sift(A,i,0);\n	       \n		\n		}\nfor(d=0;d<M;d++)	\nprintf(\"%d \",A[d]);\n\n	\n	printf(\"\\n\");\n\n	}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (758,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define N 100000\n\nvoid sort(int *A, int l, int r)				// ???? int p\n{\n	int x, i, k, j; \n	x=(A[l]+A[r])/2;\n\n	// x -- ??????? ???????\n\n	i = l;\n	j = r;\n	while (i <= j)\n	{\n		while (A[i]<x) i++; \n		while (A[j]>x) j--;\n\n		// ????? ???? ???????, ??????? ???? ?????? x\n		// ?????? ???? ???????, ??????? ???? ?????? x\n\n		if (i <= j)\n		{\n			k=A[i];\n			A[i]=A[j];\n			A[j]=k;\n			i++;\n			j--;\n			// ??????\n			// ???????? ??? ??? i ? j\n		}\n	}\n	if (i < r) sort(A, i, r);\n	if (l < j) sort(A, l, j);\n\n}\n\nint main()\n{\n	FILE *f;\n	f=fopen(\"input12.txt\", \"r\");\n	if (!f) { printf(\"?? ???????? input.txt\\n\"); return 0;}\n	int M[N+1];\n	int i, n, k, x, a;\n	fscanf(f, \"%d\", &n);\n	for (i=1; i<=n; i++)\n	{\n		fscanf(f, \"%d\", &a);\n		M [i]=a;\n	}\n	printf(\"__________???????? ??????_________________\\n\");\n	for (i=1; i<=n; i++)\n	{\n		a=M[i];\n		printf(\"%d \", a);\n	}\n	printf(\"\\n\");\n	sort(M, 1, n);							//   ???? sort(M, n)\n	printf(\"__________??????????????? ??????__________\\n\");\n	for (i=1; i<=n; i++)\n	{\n		a=M[i];\n		printf(\"%d \", a);\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (759,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define n 100000\n\n//#define DEBUG\n\nvoid sift(int *A, int N, int k)\n{\n	int x;\n	x=A[k];\n	int m1, m2, p=0, BbI6OP = 0; \n	if ( ((2*k+1)<N) && ((2*k+2)< N) ) BbI6OP=2;\n	if ( ((2*k+1)<N) && ((2*k+2)>=N) ) BbI6OP=1;\n	if (BbI6OP==2)\n	{\n		m1=A[2*k+1];\n		m2=A[2*k+2];\n		if (x<m1) p++;\n		if (x<m2) p++;\n		if (p!=0)\n			if (m1<m2)\n			{\n				A[k]=m2;\n				A[2*k+2]=x;\n				sift(A,N,2*k+2);\n			}\n			else\n			{\n				A[k]=m1;\n				A[2*k+1]=x;\n				sift(A,N,2*k+1);\n			}\n	}\n	if (BbI6OP==1)\n	{\n		m1=A[2*k+1];\n		if (x<m1)\n		{\n			A[k]=m1;\n			A[2*k+1]=x;\n			sift(A,N,2*k+1);\n		}\n	}\n\n}\n\nint main()\n{\n	FILE *f;\n	f = fopen(\"input12.txt\", \"r\");\n	if (!f)\n	{\n		printf(\"?? ???????? input12.txt\\n\");\n		return 0;\n	}\n	int M[n];\n	int i, j, N, a, s,  mid;\n	fscanf(f, \"%d\", &N);\n	for (i = 0; i < N; i++)\n	{\n		fscanf(f, \"%d\", &a);\n		M[i] = a;\n	}\n#ifdef DEBUG\n	printf(\"__________???????? ??????________________\\n\\n\");\n	for (i = 0; i < N; i++)\n	{\n		a = M[i];\n		printf(\"%d \", a);\n	}\n	printf(\"\\n\");\n	printf(\"_________________________________________\\n\");\n#endif\n	mid=N/2; \n	for (i=mid; i>=0; i--)\n		{\n			sift(M,N,i);\n#ifdef DEBUG\n			printf(\"????????? ????????... ???????????(1: i=%d)\\n\",i);\n			for (j = 0; j < N; j++)\n			{\n				s = M[j];\n				printf(\"%d \", s);\n			}\n        		printf(\"\\n\");\n#endif\n		}\n	a=N-1;\n#ifdef DEBUG\n	printf(\"-  -  -  -  -  -  -  -  -  -  -  -  -  -\\n\");\n#endif\n	while (a!=0)\n	{\n		i=M[a];\n		M[a]=M[0];\n		M[0]=i;\n#ifdef DEBUG\n		printf(\"??????????... ???????????(2) a=%d\\n\", a);\n#endif\n		sift(M,a,0);\n		a--;\n#ifdef DEBUG\n		for (j = 0; j < N; j++)\n		{\n			s = M[j];\n			printf(\"%d \", s);\n		}\n		printf(\"\\n\");\n#endif\n	}\n#ifdef DEBUG\n	printf(\"__________??????????????? ??????__________\\n\\n\");\n#endif\n	for (i = 0; i < N; i++)\n	{\n		a = M[i];\n		printf(\"%d \", a);\n	}\n	printf(\"\\n\");\n#ifdef DEBUG\n	printf(\"__________________________________________\\n\");\n#endif\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (760,'#include <stdio.h>\n#include <string.h>\nint degr(int i, int b)\n{	int j;\nint a=1;\nfor(j=1;j!=i;j++)\na=a*b;\nreturn a;}\nint main()\n{	int b;\nscanf(\"%d\", &b);\n	char s[100];\n	scanf(\"%s\", s);\n	int i;\n	int x=0;\n	int len=strlen(s);\n\n	printf(\"??????? ????? %s\\n\", s);\n\n	printf(\"strlen(s): %d\\n\", len);\n	for(i=0;i!=len;i++) {\n		printf(\"i: %d, strlen: %d\\n\", i, len);\n/*	if ((s[i]<48) || ((s[i]>57) && (s[i]<65)) || (s[i]>90))  \n	                return 0;*/\n			if ((s[i]>=48) && (s[i]<=57)) \n			s[i]=s[i]-48;\n		if ((s[i]>=65) && (s[i]<=90))\n			s[i]=s[i]-55;\n		}\n\n\n	for(i=0;i!=len;i++)\n	{\n		printf(\"i: %d\\n\", i);\n		x=x+s[i]*degr(len-i, b);\n	}\n	printf(\"%d\\n\", x);\n	return x;}\n\n	\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (761,'//for encoding use canonical Huffman codes\n#include \"exec.h\"\n#define BUF_SIZE 64000\nstruct tree\n{\n	uchar symb;\n	uint freq;\n	struct tree *left;\n	struct tree *right;\n};\nuint code_single_char(uchar *obuf,uchar symb,uint freq)\n{\n	uint tmp=freq,lenbuf=0,i,j=0;\n	uchar ctmp=128;\n	while ((tmp/=256)!=0) j++;\n	obuf[lenbuf++]=ctmp+(j+1);\n	for (i=0;i<j+1;i++)\n	{\n		obuf[lenbuf++]=freq%256;\n		freq/=256;\n	}\n	obuf[lenbuf++]=symb;\n	return lenbuf;\n}\nint get_freq(uint *freq,uint *symb,uchar* ibuf,FILE *src)\n{\n	int i,k,n=0;\n	while ((k=fread(ibuf,1,BUF_SIZE,src))!=0)\n		for (i=0;i<k;i++) freq[ibuf[i]]++;\n	for (i=0;i<256;i++)\n		if (freq[i]!=0)	symb[n++]=i;\n	return n;\n}\nuint greater(uint a,uint b)\n{\n	return (a>b);\n}\nuint less(uint a,uint b)\n{\n	return (a<b);\n}\nvoid sort(uint *data,uint *symb,int l,int r,uint (*cmp)(uint,uint))\n{\n	int i=l,j=r,tmp,m=(data[symb[l]]+data[symb[r]])/2;\n	if (l==r) \n		return;\n	while(i<j)\n	{\n		while (cmp(data[symb[i]],m))\n			i++;\n		while (cmp(m,data[symb[j]]))\n			j--;\n		if (i<=j)\n		{\n			tmp=symb[i];\n			symb[i]=symb[j];\n			symb[j]=tmp;\n			i++;\n			j--;\n		}\n	}\n	if (i<r) sort(data,symb,i,r,cmp);\n	if (l<j) sort(data,symb,l,j,cmp);\n}\nvoid free_tree(struct tree *root)\n{\n	if (root->left==NULL)\n	{\n		free(root);\n		return;\n	}\n	free_tree(root->left);\n	free_tree(root->right);\n	free(root);\n}\nvoid get_len(uint *len,struct tree *root)\n{\n	static int count=0;\n	if (root->left==NULL)\n	{\n		len[root->symb]=count--;\n		return;\n	}\n	count++;\n	get_len(len,root->left);\n	count++;\n	get_len(len,root->right);\n	count--;\n}\nvoid build_len(uint *len,uint *freq,uint *symb,int n)\n{\n	int i,j,k;\n	struct tree **root=malloc(n*sizeof(struct tree*));\n	if (root==NULL)\n	{\n		perror(\"ERROR\");\n		abort();\n	}\n	for(i=0;i<n;i++)\n	{\n		root[i]=malloc(sizeof(struct tree));\n		if (root[i]==NULL)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		root[i]->symb=symb[i];\n		root[i]->freq=freq[symb[i]];\n		root[i]->left=NULL;\n		root[i]->right=NULL;		\n	}\n	i=n-1;\n	while (i>0)\n	{\n		struct tree *tmp=malloc(sizeof(struct tree));\n		if (tmp==NULL)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		tmp->freq=root[i]->freq+root[i-1]->freq;\n		tmp->left=root[i];\n		tmp->right=root[i-1];\n		j=i-2;\n		//insertion descending sort\n		while(j>=0 && tmp->freq>root[j]->freq)\n			--j;\n		++j;\n		for(k=i-1;k>j;--k)\n			root[k]=root[k-1];\n		root[j]=tmp;\n		--i;\n	}\n	//computing lengths of codes\n	get_len(len,root[0]);\n	free_tree(root[0]);\n	free(root);\n}\nvoid sort_len(uint *len,uint *symb,int n)\n{\n	int j,i=0,cur_len,cur_ind;\n	uint tmp;\n	//ascending quick sort of array symb\n	sort(len,symb,0,n-1,less);\n	while (i<n)\n	{\n		cur_len=len[symb[i]];\n		cur_ind=i;\n		while (i<n && len[symb[i]]==cur_len)\n		{\n			tmp=symb[i];\n			j=i-1;\n			//insertion descending sort\n			while(j>=cur_ind && tmp>symb[j])\n			{\n				symb[j+1]=symb[j];\n				j--;\n			}\n			symb[j+1]=tmp;\n			i++;\n		}\n	}\n}\nvoid compute_codes(uchar *code,uint *len,uint *freq,uint *symb,int n)\n{\n	uchar cur_code=1;\n	uint cur_len=1,j=0,i;\n	for (i=0;i<n;i++)\n	{\n		if (cur_len<len[symb[i]])\n		{	\n			cur_code<<=(len[symb[i]]-cur_len);\n			cur_code=cur_code|(0xFF>>(8-(len[symb[i]]-cur_len)));\n			cur_len=len[symb[i]];\n			code[symb[i]]=cur_code;\n		}\n		else\n			code[symb[i]]=cur_code;\n		cur_code--;\n	}\n}\nuint get_cbits(uchar a)\n{\n	int i=0;\n	if (a==0) return 0;\n	while (a>>7==0)\n	{\n		a<<=1;\n		i++;\n	}\n	return 8-i;\n}\nuint build_node(uchar *obuf,uint *len,uint *symb,FILE *dst,uint n,uint lenbuf)\n{\n	int i,cur_depth=0,cur_len,j=0,k;\n	uint count_len[256]={0},flag[256]={0};\n	uchar NODE[510]; //array of bits of node of tree MAX bits=2+4+...+128+256=510\n					//Preorder tree traversal: for leafs write -\"1\", for other knots - \"0\"\n	for (i=0;i<n;i++) count_len[len[symb[i]]]++;\n	cur_len=len[symb[i-1]];\n	i=0;\n	while(cur_len!=0)\n	{\n		while(count_len[cur_len]!=0)\n		{\n			while (flag[cur_depth]==2) flag[cur_depth--]=0;\n			NODE[j++]=0;\n			flag[cur_depth++]++;\n			if (cur_depth==cur_len)\n			{\n				NODE[j-1]=1;\n				count_len[cur_len]--;\n				cur_depth--;\n			}\n		}\n		while(cur_len>0 && count_len[cur_len]==0)\n			cur_len--;\n	}	\n	for (i=0;i<j;i+=8)\n	{\n		for (k=i;k<j && k<i+8;k++)\n			obuf[lenbuf]=(obuf[lenbuf]<<1)+NODE[k];\n		lenbuf++;\n	}\n	obuf[lenbuf-1]<<=i-k;\n	for (k=n-1;k>=0;k--)\n		obuf[lenbuf++]=symb[k];\n	return lenbuf;\n}\nuint write_size(uchar *obuf,uint size)\n{\n	uint tmp=size,i,j=0;\n	while ((tmp/=256)!=0) j++;\n	obuf[0]=j+1;\n	for (i=0;i<j+1;i++)\n	{\n		obuf[i+1]=size%256;\n		size/=256;\n	}\n	return i+1;\n}\nvoid readtree(struct tree *stree,FILE *src)\n{\n	static int num_bit=8;\n	static uchar byte;\n	num_bit++;\n	if (num_bit>8)\n	{\n		fread(&byte,1,1,src);\n		num_bit%=8;\n	}\n	if (((byte>>(8-num_bit))&1)==1)//leaf\n	{\n		stree->left=NULL;\n		return;\n	}\n	else//not leaf\n	{\n		stree->left=malloc(sizeof(struct tree));\n		if (stree->left==NULL)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		stree->right=malloc(sizeof(struct tree));\n		if (stree->right==NULL)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		readtree(stree->left,src);\n		readtree(stree->right,src);\n	}\n}\nvoid walktree(struct tree *stree,FILE *f)\n{\n	if (stree->left==NULL)\n	{\n		fread(&stree->symb,1,1,f);\n		return;\n	}\n	walktree(stree->left,f);\n	walktree(stree->right,f);\n}\nvoid decode_single_char(uchar ctmp,FILE *src,FILE *dst,uchar *obuf)\n{\n	uint count=0;\n	uint tmp,digit=1,i,j=0;\n	ctmp=ctmp<<1;\n	tmp=ctmp>>1;\n	for (i=0;i<tmp;i++)\n	{\n		fread(&ctmp,1,1,src);\n		count+=ctmp*digit;\n		digit*=256;\n	}\n	fread(&ctmp,1,1,src);\n	for (i=0;i<count;i++)\n	{\n		obuf[j++]=ctmp;\n		if (j>BUF_SIZE)\n		{\n			fwrite(obuf,1,j,dst);\n			j=0;\n		}\n	}\n	if (j!=0)\n		fwrite(obuf,1,j,dst);\n}\nvoid compute_codes_from_tree(struct tree *stree,uchar *symb,uchar *base,int *first)\n{\n	static uint curlevel=-1,i=0;\n	curlevel++;\n	if (stree->left==NULL)\n	{\n		if (first[curlevel]==-1)\n			first[curlevel]=i;\n		symb[i++]=stree->symb;\n		curlevel--;\n		return;\n	}\n	base[curlevel]++;\n	compute_codes_from_tree(stree->left,symb,base,first);\n	compute_codes_from_tree(stree->right,symb,base,first);\n	curlevel--;\n}\nvoid build_tree(FILE *src,struct tree *stree)\n{\n	stree->left=malloc(sizeof(struct tree));\n	if (stree->left==NULL)\n	{\n		perror(\"ERROR\");\n		abort();\n	}\n	stree->right=malloc(sizeof(struct tree));\n	if (stree->right==NULL)\n	{\n		perror(\"ERROR\");\n		abort();\n	}\n	readtree(stree->left,src);\n	readtree(stree->right,src);\n	walktree(stree,src);\n}\nvoid build_codes(FILE *src,uchar *symb,uchar *base,int *first)\n{	\n	int i;\n	struct tree *stree=malloc(sizeof(struct tree));\n	if (stree==NULL)\n	{\n		perror(\"ERROR\");\n		abort();\n	}\n	\n	for (i=0;i<256;i++) first[i]=-1;\n	build_tree(src,stree);\n	compute_codes_from_tree(stree,symb,base,first);\n	free_tree(stree);\n}\nuint read_size(uchar ctmp,FILE *src)\n{\n	uint size=0;\n	uint tmp=ctmp,digit=1,i;\n	for (i=0;i<tmp;i++)\n	{\n		fread(&ctmp,1,1,src);\n		size+=ctmp*digit;\n		digit*=256;\n	}\n	return size;\n}\nvoid compressing(FILE *src,FILE *dst)\n{\n	int i,j,k;\n	uchar code[256],ibuf[BUF_SIZE]={0},obuf[2*BUF_SIZE]={0},ctmp;\n	uint lenbuf=0,size=0,arsize=0,n=0,bits[256],freq[256]={0},len[256]={0},symb[256]={0}; //in symb all symbols of file behind each other\n	uint llb=0;//length of last byte\n	clock_t time=clock();\n	n=get_freq(freq,symb,ibuf,src);					//calculation freq of char			\n	if (n==0) \n	{\n		ctmp=64;\n		fwrite(&ctmp,1,1,dst);\n		printf(\"Empty file\\n\");\n		return;\n	}\n	if (n==1) \n	{\n		arsize=code_single_char(obuf,symb[0],freq[symb[0]]);\n		fwrite(obuf,arsize,1,dst);\n		printf(\"Size of the source file: %d bytes\\nSize of the archive: %d bytes\\nAverage bpb: %f\\nTime of execution: %f\\n\",\n				freq[symb[0]],arsize,(double)arsize*8/freq[symb[0]],(double)(clock()-time)/CLOCKS_PER_SEC);\n		return;\n	}\n	sort(freq,symb,0,n-1,greater);					//descending quick sort freq of char\n	build_len(len,freq,symb,n);					//compute lengths\n	sort_len(len,symb,n);						//sort lenghts\n	compute_codes(code,len,freq,symb,n);				//building canonical Huffman codes for symbols\n	for (i=0;i<n;i++) bits[symb[i]]=get_cbits(code[symb[i]]);	//compute length of every code without first zeros\n	for (i=0;i<n;i++)\n	{\n		size+=freq[symb[i]];\n		arsize+=freq[symb[i]]*len[symb[i]];\n	}\n	lenbuf=write_size(obuf,size);\n	lenbuf=build_node(obuf,len,symb,dst,n,lenbuf);			//writing node of tree\n	arsize=(arsize+7)/8+lenbuf;\n	printf(\"Size of the source file: %d bytes\\nSize of the archive: %d bytes\\nAverage bpb: %f\\n\",size,arsize,(double)arsize*8/size);\n	//process of encoding\n	fseek(src,0,SEEK_SET);\n	while ((k=fread(ibuf,1,BUF_SIZE,src))!=0)\n	{\n		for (i=0;i<k;i++) ENCODE(bits,len,code,ibuf[i],obuf,lenbuf,llb);\n		//if (lenbuf>BUF_SIZE)\n		//{\n			fwrite(obuf,1,lenbuf,dst);\n			obuf[0]=obuf[lenbuf];\n			memset(obuf+1,0,lenbuf);\n			lenbuf=0;\n		//}\n	}\n	if (llb) fwrite(obuf,1,lenbuf+1,dst);\n	else fwrite(obuf,1,lenbuf,dst);\n	printf(\"Time of execution: %f\\n\", (double)(clock()-time)/CLOCKS_PER_SEC);\n}\nvoid decompressing(FILE *src,FILE *dst)\n{\n	int i,k,j,first[256]={0};//symb[first[i]] - first leaf knot(0,...) on level i(0,...)\n	uchar ibuf[BUF_SIZE],obuf[8*BUF_SIZE]={0},base[256]={0},//base[i] count of noleaf knots on level i(0,...)\n			symb[256]={0},ctmp;\n	uint icur_pos=0,ocur_pos=0,size,c_symb_from_prev_buf=0;\n	clock_t time=clock();\n	fread(&ctmp,1,1,src);\n	if (((ctmp>>7)&1)==1)\n	{\n		decode_single_char(ctmp,src,dst,obuf);\n		printf(\"Time of execution: %f\\n\", (double)(clock()-time)/CLOCKS_PER_SEC);\n		return;\n	}\n	if (((ctmp>>6)&1)==1) //empty file\n	{\n		printf(\"Empty file\\n\");\n		return;\n	}\n	size=read_size(ctmp,src);\n	build_codes(src,symb,base,first);\n	icur_pos=1;\n	k=fread(ibuf,1,BUF_SIZE,src);\n	for (i=0;i<size;i++)\n	{\n		DECODE(ibuf,icur_pos,symb,base,first,obuf,ocur_pos);\n		if ((icur_pos-1)/8>=k-31) //255 bits for longest code\n		{\n			c_symb_from_prev_buf=0;\n			for (j=(icur_pos-1)/8;j<k;j++) \n				ibuf[c_symb_from_prev_buf++]=ibuf[j];\n			icur_pos%=8;\n			if (icur_pos==0) icur_pos=8;\n			k=fread(ibuf+c_symb_from_prev_buf,1,BUF_SIZE-c_symb_from_prev_buf,src)+c_symb_from_prev_buf;\n		}\n		if (ocur_pos>BUF_SIZE)\n		{\n			fwrite(obuf,1,ocur_pos,dst);\n			ocur_pos=0;\n		}\n	}\n	fwrite(obuf,1,ocur_pos,dst);\n	printf(\"Time of execution: %f\\n\", (double)(clock()-time)/CLOCKS_PER_SEC);\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (762,'#include \"exec.h\"\nint main(int argc,char **argv)\n{\n	FILE *dst,*src;\n	if (argc == 1 || strcmp(argv[1], \"--help\") == 0)\n	{\n		printf(\"Usage:\\n\");\n		printf(\"%s -c input output\\n%s -d input output\\n\", argv[0], argv[0]);\n		return 0;\n	}\n	if (strcmp(argv[1],\"-c\")==0)\n	{\n		src=fopen(argv[2],\"rb\");\n		if (!src)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		dst=fopen(argv[3],\"wb\");\n		if (!dst)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		compressing(src,dst);\n		printf(\"Compressing is completed\\n\");\n		fclose(src);\n		fclose(dst);\n	}\n	else if (strcmp(argv[1],\"-d\")==0)\n	{\n		src=fopen(argv[2],\"rb\");\n		if (!src)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		dst=fopen(argv[3],\"wb\");\n		if (!dst)\n		{\n			perror(\"ERROR\");\n			abort();\n		}\n		decompressing(src,dst);\n		printf(\"Decompressing is completed\\n\");\n		fclose(src);\n		fclose(dst);\n	}\n	else\n		printf(\"usage: <comand> <infile> <outfile>\\n<comand> \\\"-c\\\" - compressing, \\\"-d\\\" - decompressing\\n\");\n	return 0;\n}\n','Ð•Ð²Ð³ÐµÐ½Ð¸Ð¹','Evgeny','m');
INSERT INTO `bias` VALUES (763,'#include \"long_int.h\"\r\n\r\nlong_int* alloc()\r\n{\r\n	long_int * a;\r\n	a = (long_int*)malloc(sizeof(long_int));\r\n	a->digits = NULL;\r\n	a->length = 0;\r\n	a->sign = 1;\r\n	return a;\r\n}\r\n\r\nlong_int* copy_long_int(long_int* a)\r\n{\r\n	int i;\r\n	long_int* newVar = alloc();\r\n	newVar->length = a->length;\r\n	newVar->sign = a->sign;\r\n	newVar->digits = (int*)malloc(sizeof(int)*(a->length+1));\r\n	for(i = 0; i < a->length; i++)\r\n	{\r\n		newVar->digits[i] = a->digits[i];\r\n	}\r\n	return newVar;\r\n}\r\n\r\nvoid init_long_int_from_string(long_int *dest, char* str)\r\n{\r\n	int i = 0;\r\n	int stringLength;\r\n	int arrayInt[1000];\r\n	int valueIndex;\r\n	int sign = 1;\r\n	if(str[0] == \'-\')\r\n	{\r\n		sign = 0;\r\n		str++;\r\n	}\r\n	stringLength = strlen(str);\r\n	//stringLength--;\r\n	valueIndex = 0;\r\n	while(stringLength > 0)\r\n	{\r\n		int index = BASE_NUM - 1;\r\n		char tmp[BASE_NUM + 1] = {\'0\', \'0\', \'0\', \'0\', 0};\r\n		\r\n		while(index >=  0 && stringLength > 0)\r\n		{\r\n			tmp[index] = str[stringLength-1];\r\n			index--;\r\n			stringLength--;\r\n		}\r\n		arrayInt[valueIndex] = atoi(tmp);\r\n		valueIndex++;\r\n	}\r\n	dest->length = valueIndex;\r\n	dest->sign = sign;\r\n	dest->digits = (int*)malloc(sizeof(int)*valueIndex);\r\n	for(i = 0; i < valueIndex; i++)\r\n	{\r\n		dest->digits[i] = arrayInt[i];\r\n	}	\r\n}\r\n\r\nint compare_abs(long_int* a, long_int* b)\r\n{\r\n	int i = 0;\r\n	if(a->length > b->length)\r\n	{\r\n		return 1;\r\n	}\r\n	else\r\n	{\r\n		if(a->length < b->length)\r\n		{\r\n			return -1;\r\n		}\r\n		else\r\n		{\r\n			for (i = a->length - 1; i >=0; i--) {								\r\n				if (a->digits[i] == b->digits[i])\r\n				{\r\n				continue;\r\n				}\r\n				return (a->digits[i] < b->digits[i] ? -1 : 1);					\r\n			}\r\n			return 0;\r\n		}\r\n	}\r\n}\r\nvoid add(long_int** ss, long_int* a, long_int* b)\r\n{\r\n	long_int *s;\r\n	if((*ss)->length != 0)\r\n	{\r\n		free_long_int(*ss);\r\n		*ss = alloc();\r\n	}\r\n	s = *ss;\r\n	if(a->sign == b->sign)\r\n	{\r\n		add_abs(&s,a,b);\r\n		s->sign = a->sign;\r\n	}\r\n	else\r\n	{\r\n		if(a->sign > b->sign)\r\n		{\r\n			int cmp = compare_abs(a,b);\r\n			switch(cmp)\r\n			{\r\n			case -1:\r\n				sub_abs(&s,b,a);\r\n				s->sign = 0;\r\n				break;\r\n			case 0:\r\n				s->sign = 1;\r\n				s->length = 1;\r\n				s->digits = (int*)malloc(sizeof(int));\r\n				s->digits[0] = 0;\r\n				break;\r\n			case 1:\r\n				sub_abs(&s,a,b);\r\n				break;\r\n			}\r\n		}\r\n		else\r\n		{\r\n			int cmp = compare_abs(a,b);\r\n			switch(cmp)\r\n			{\r\n			case 1:\r\n				sub_abs(&s,a,b);\r\n				s->sign = 0;\r\n				break;\r\n			case 0:\r\n				s->sign = 1;\r\n				s->length = 1;\r\n				s->digits = (int*)malloc(sizeof(int));\r\n				s->digits[0] = 0;\r\n				break;\r\n			case -1:\r\n				sub_abs(&s,b,a);\r\n				break;\r\n			}\r\n		}\r\n		\r\n	}\r\n	*ss = s;\r\n}\r\nvoid sub(long_int **ss, long_int *a, long_int *b)\r\n{\r\n	long_int *s;\r\n	if((*ss)->length != 0)\r\n	{\r\n		free_long_int(*ss);\r\n		*ss = alloc();\r\n	}\r\n	s = *ss;\r\n	if(a->sign == b->sign)\r\n	{\r\n		int cmp = compare_abs(a,b);\r\n			switch(cmp)\r\n			{\r\n			case -1:\r\n				sub_abs(&s,b,a);\r\n				s->sign = a->sign == 0 ? 1 : 0;\r\n				break;\r\n			case 0:\r\n				s->sign = 1;\r\n				s->length = 1;\r\n				s->digits = (int*)malloc(sizeof(int));\r\n				s->digits[0] = 0;\r\n				break;\r\n			case 1:\r\n				sub_abs(&s,a,b);\r\n				s->sign = a->sign;\r\n				break;\r\n			}\r\n		remove_first_zeros(s);	\r\n	}\r\n	else\r\n	{\r\n		if(a->sign > b->sign)\r\n		{\r\n			add_abs(&s,a,b);\r\n		}\r\n		else\r\n		{\r\n			add_abs(&s,a,b);\r\n			s->sign = 0;\r\n		}\r\n		remove_first_zeros(s);	\r\n\r\n	}\r\n	*ss = s;\r\n}\r\nvoid add_abs(long_int **ss, long_int *a, long_int *b)\r\n{\r\n	int i = 0;\r\n	int buffer = 0;		\r\n	int length = a->length > b->length ? a->length : b->length;\r\n	long_int *s;\r\n	long_int *min = a->length > b->length ? b : a;\r\n	long_int *max = a->length > b->length ? a : b;\r\n	if((*ss)->length != 0)\r\n	{\r\n		free_long_int(*ss);\r\n		*ss = alloc();\r\n	}\r\n	s = *ss;\r\n	s->sign = 1;\r\n	s->length = length;\r\n	s->digits = (int*)malloc(sizeof(int)*length);\r\n	for (i = 0; i < length; i++) \r\n	{\r\n		if( i < min->length)\r\n		{\r\n			s->digits[i] = min->digits[i] + max->digits[i];	\r\n		}\r\n		else\r\n		{\r\n			s->digits[i] = max->digits[i];\r\n		}\r\n		s->digits[i] += buffer;									\r\n\r\n		buffer = s->digits[i] / BASE;									\r\n		s->digits[i]   = s->digits[i] % BASE;	\r\n		if(i == length - 1 && buffer != 0)\r\n		{\r\n			s->digits = (int*)realloc(s->digits, sizeof(int)*(length + 1));\r\n			s->digits[length] = buffer;\r\n			s->length++;\r\n		}\r\n	}\r\n	*ss = s;\r\n}\r\nvoid sub_abs(long_int **ss, long_int *a, long_int *b)\r\n{\r\n	int i = 0;\r\n	int buffer = 0;		\r\n	int length = a->length > b->length ? a->length : b->length;\r\n	long_int *s;\r\n	if((*ss)->length != 0)\r\n	{\r\n		free_long_int(*ss);\r\n		*ss = alloc();\r\n	}\r\n	s = *ss;\r\n	s->sign = 1;\r\n	s->length = length;\r\n	s->digits = (int*)malloc(sizeof(int)*length);\r\n	for (i = 0; i < length; i++) \r\n	{\r\n		if(i < b->length)\r\n		{\r\n			s->digits[i] = a->digits[i] - b->digits[i] + buffer;\r\n		}\r\n		else\r\n		{\r\n			s->digits[i] = a->digits[i] + buffer;\r\n		}\r\n		if(s->digits[i] < 0)\r\n		{\r\n			s->digits[i] += BASE;\r\n			buffer = - 1;\r\n		}\r\n		else\r\n		{\r\n			buffer = 0;\r\n		}\r\n	}\r\n	remove_first_zeros(s);\r\n	*ss = s;\r\n}\r\n\r\nvoid remove_first_zeros(long_int *a)\r\n{\r\n	int i =  a->length - 1;\r\n	while(i > 0) \r\n	{\r\n		if(a->digits[i] == 0)\r\n		{\r\n			a->length--;\r\n			i--;\r\n			a->digits = (int*) realloc(a->digits, sizeof(int)*a->length);\r\n		}\r\n		else{\r\n			break;\r\n		}\r\n	}\r\n}\r\n\r\nvoid divide(long_int **qq, long_int *a, long_int *b)\r\n{\r\n	int i = 0;\r\n	long_int *reminder;\r\n	long_int *q;\r\n	if((*qq)->length != 0)\r\n	{\r\n		free_long_int(*qq);\r\n		*qq = alloc();\r\n	}\r\n	q = *qq;\r\n\r\n	q->digits = (int*)malloc(sizeof(int));\r\n	q->digits[0] = 0;\r\n	q->length = a->length - b->length + 1;\r\n\r\n	if (a->length < b->length)\r\n	{	\r\n		q->length = 1;\r\n		return;\r\n	}\r\n	q->digits = (int*)realloc(q->digits, sizeof(int)*q->length+1);\r\n	reminder = copy_long_int(a);\r\n	for (i = q->length - 1; i>=0; i--) \r\n	{				\r\n		int digit;\r\n		int left = 0, right = BASE, middle;\r\n		long_int *temp;\r\n		long_int *product;\r\n		product = alloc();\r\n\r\n		while (right - left > 1) {\r\n			middle = (left + right) / 2;        \r\n			multiplyShort(&product, b, middle);				\r\n			shift_long_int(product, i);								\r\n			if (compare_abs(reminder, product) >= 0)				\r\n					left = middle;\r\n			else\r\n				right = middle;\r\n		}\r\n		digit = left;\r\n		if(digit >= 0)\r\n		{\r\n			multiplyShort(&product, b, digit);\r\n			shift_long_int(product, i);\r\n			temp = copy_long_int(reminder);\r\n			sub_abs(&reminder, temp, product);\r\n			free_long_int(product);\r\n			free_long_int(temp);\r\n		}\r\n		else\r\n		{\r\n			digit = 0;\r\n		}\r\n		q->digits[i] = digit;\r\n	}\r\n	free_long_int(reminder);\r\n	remove_first_zeros(q);\r\n	q->sign = (a->sign && b->sign) || (!(a->sign) && !(b->sign));\r\n	*qq = q;\r\n}\r\n\r\nvoid mul(long_int **pp, long_int *a, long_int *b)\r\n{\r\n	int i = 0;\r\n	long_int *p;\r\n	if((*pp)->length != 0)\r\n	{\r\n		free_long_int(*pp);\r\n		*pp = alloc();\r\n	}\r\n	p = *pp;\r\n	for (i = 0; i<b->length; i++)\r\n		{\r\n			long_int *temp;\r\n			long_int *temp1 = copy_long_int(p);\r\n			temp = alloc(); \r\n			multiplyShort(&temp, a, b->digits[i]);							\r\n			shift_long_int(temp, i);		\r\n			add_abs(&p, temp, temp1);\r\n			free_long_int(temp);\r\n			free_long_int(temp1);\r\n		}\r\n	p->sign = (a->sign && b->sign) || (!(a->sign) && !(b->sign));\r\n	*pp = p;\r\n}\r\n\r\nvoid shift_long_int(long_int *val, int offset)\r\n{	\r\n	int i = 0;\r\n	val->digits = (int*)realloc(val->digits, sizeof(int)*(val->length + offset));\r\n	for(i = val->length - 1; i >= 0; i--)\r\n	{\r\n		val->digits[offset + i] = val->digits[i];\r\n	}\r\n	for(i = 0; i < offset; i++)\r\n	{\r\n		val->digits[i] = 0;\r\n	}\r\n	val->length+=offset;\r\n}\r\n\r\nvoid multiplyShort(long_int **p, long_int *a, int b) \r\n{\r\n	int i = 0;\r\n	int buffer = 0;\r\n	if((*p)->length != 0)\r\n	{\r\n		free_long_int(*p);\r\n		*p = alloc();\r\n	}\r\n	(*p)->sign = 1;\r\n	(*p)->length = a->length;\r\n	(*p)->digits = (int*)malloc(sizeof(int)*(*p)->length);\r\n\r\n	for (i = 0; i< a->length; i++)\r\n	{\r\n		buffer += a->digits[i] * b;\r\n		(*p)->digits[i] = buffer % BASE;\r\n		buffer /= BASE;\r\n		if(i == (*p)->length - 1 && buffer != 0)\r\n		{\r\n			(*p)->digits = (int*)realloc((*p)->digits, sizeof(int)*((*p)->length + 1));\r\n			(*p)->digits[(*p)->length] = buffer;\r\n			(*p)->length++;\r\n		}\r\n	}\r\n}\r\n\r\n\r\nvoid print(long_int *a)\r\n{\r\n	int i = 0, count = 0;;\r\n	if(!a->sign)\r\n	{\r\n		printf(\"-\");\r\n	}\r\n	for(i = a->length  -1 ; i >= 0; i--)\r\n	{\r\n		if(i == a->length - 1)\r\n		{\r\n			printf(\"%d\", a->digits[i]);\r\n		}\r\n		else\r\n		{\r\n			printf(\"%04d\", a->digits[i]);\r\n		}\r\n	}\r\n	printf(\"\\n\");\r\n}\r\nvoid free_long_int(long_int *a)\r\n{\r\n	if(a->digits != NULL)\r\n	{\r\n		free(a->digits);\r\n		a->length = 0;\r\n	}\r\n	free(a);\r\n	a = NULL;\r\n}\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (764,'#ifdef _MSC_VER\r\n#define _CRTDBG_MAP_ALLOC\r\n#define  _DEBUG 2\r\n#include <stdlib.h>\r\n#include <crtdbg.h>\r\n#else\r\n#include <stdlib.h>\r\n#endif\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include \"parser.h\"\r\n#include \"var.h\"\r\n\r\n\r\nint main()\r\n{\r\n		long_int  *result_value = NULL;\r\n        stack *value_st = create();\r\n		stack *operation_st = create();\r\n		char buffer_array[100];\r\n		char stop = 0;\r\n		char tmp;\r\n		int position;\r\n		long_int *first, *second;\r\n		element *result;\r\n		int is_init = 0;\r\n		var *var_list = (var*)malloc(sizeof(var));		\r\n		var_list->name = strdup(\"head\");\r\n		var_list->value = NULL;\r\n		var_list->next = NULL;\r\n		result = NULL;\r\n\r\n		printf(\"Press \'!\' to finish the programm\\n\\n\\n\");\r\n		while(stop != \'!\' )\r\n		{\r\n			char *buffer = buffer_array;\r\n			if (!fgets(buffer_array, 100, stdin))\r\n				break;\r\n			stop = buffer[0];\r\n			while (*buffer != 0)\r\n			{\r\n				element* a = parser(buffer, &position);\r\n				element* unar_minus;\r\n				buffer+= position;\r\n				if(a != NULL)\r\n				{\r\n					if (a->type == value)\r\n					{\r\n						result_value = alloc();\r\n						init_long_int_from_string(result_value, a->data);\r\n						push(&value_st, (void*)result_value);\r\n						free(a->data);\r\n						free(a);\r\n						continue;\r\n					}\r\n					if (a->type == operation)\r\n					{\r\n						char* allocOperation;\r\n						tmp = a->data[0];\r\n							switch (tmp)\r\n							{\r\n							case \'(\' :\r\n								allocOperation = (char*)malloc(sizeof(char));\r\n								*allocOperation = a->data[0];\r\n								push(&operation_st, allocOperation);\r\n								if (*(char *)(unar_minus = parser(buffer, &position))->data == \'-\')\r\n								{\r\n									long_int *result = alloc();\r\n									result->digits = (int*)malloc(sizeof(int));\r\n									result->digits[0] = 0;\r\n									result->length = 1;\r\n									result->sign = 1;\r\n									push(&value_st, (void *) result);\r\n									free(unar_minus->data);\r\n									free(unar_minus);\r\n								}\r\n								break;\r\n							case \'*\' :\r\n							case \'/\' :\r\n								while(empty(operation_st))\r\n								{\r\n									if (*(char *)top(operation_st) == \'*\')\r\n									{\r\n										first = copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										second =  copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										result_value = alloc();\r\n										mul(&result_value, first, second);\r\n										push(&value_st, (void*)(result_value));\r\n										pop(&operation_st);\r\n										free_long_int(first);\r\n										free_long_int(second);\r\n									}\r\n									else if (*(char *)top(operation_st) == \'/\')\r\n									{\r\n										first = copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										second =  copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										result_value = alloc();\r\n										divide(&result_value, second, first);\r\n										push(&value_st, (void*)(result_value));\r\n										pop(&operation_st);\r\n										free_long_int(first);\r\n										free_long_int(second);\r\n									}\r\n									else\r\n									break;\r\n								}\r\n								allocOperation = (char*)malloc(sizeof(char));\r\n								*allocOperation = a->data[0];\r\n								push(&operation_st, allocOperation);\r\n								break;\r\n							case \'-\' :\r\n							case \'+\' :\r\n								if(!empty(value_st) )\r\n								{\r\n									long_int *result = alloc();\r\n									result->digits = (int*)malloc(sizeof(int));\r\n									result->digits[0] = 0;\r\n									result->length = 1;\r\n									result->sign = 1;\r\n									push(&value_st, (void *) result);\r\n								}\r\n								while(empty(operation_st))\r\n								{\r\n									if (*(char *)top(operation_st) != \'(\')\r\n									{\r\n										first = copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										second =  copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										tmp = *(char *)top(operation_st);\r\n										result_value = alloc();\r\n										switch (tmp)\r\n										{\r\n										case \'+\' : add(&result_value, first, second);\r\n												pop(&operation_st);\r\n												free_long_int(first);\r\n												free_long_int(second);\r\n												break;\r\n										case \'-\' : sub(&result_value,second,first);\r\n												pop(&operation_st);\r\n												free_long_int(first);\r\n												free_long_int(second);\r\n												break;\r\n										case \'*\' : mul(&result_value, first, second);\r\n											pop(&operation_st);\r\n											free_long_int(first);\r\n											free_long_int(second);\r\n												if ((empty(operation_st))&&*(char *)top(operation_st) == \'-\')\r\n												 {\r\n													\r\n													first = copy_long_int(result_value);\r\n													second =  copy_long_int(((long_int*)top(value_st)));\r\n													pop_long_int(&value_st);\r\n													sub(&result_value, second, first);\r\n													pop(&operation_st);\r\n													free_long_int(first);\r\n													free_long_int(second);\r\n												 }\r\n												break;\r\n										case \'/\' :\r\n											 if(first != 0)\r\n											 {\r\n												 divide(&result_value, second, first);\r\n												 pop(&operation_st);\r\n												 free_long_int(first);\r\n												 free_long_int(second);\r\n												 if ((empty(operation_st))&&*(char *)top(operation_st) == \'-\')\r\n												 {\r\n													first = copy_long_int(result_value);\r\n													second =  copy_long_int(((long_int*)top(value_st)));\r\n													pop_long_int(&value_st);\r\n													sub(&result_value, second, first);\r\n													pop(&operation_st);\r\n													free_long_int(first);\r\n													free_long_int(second);\r\n												 }\r\n											 }\r\n											 else printf(\"ERROR!!\");\r\n											 break;\r\n										}\r\n										push(&value_st, (void*)(result_value));\r\n									}\r\n									else\r\n										break;\r\n								}\r\n								allocOperation = (char*)malloc(sizeof(char));\r\n								*allocOperation = a->data[0];\r\n								push(&operation_st, allocOperation);\r\n								break;\r\n							case \')\' : \r\n								if(empty(operation_st))\r\n								{\r\n									tmp = *(char *)top(operation_st);\r\n									while (tmp != \'(\')\r\n									{\r\n										result_value = alloc();\r\n\r\n										first = copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n										second =  copy_long_int(((long_int*)top(value_st)));\r\n										pop_long_int(&value_st);\r\n\r\n										switch (tmp)\r\n										{\r\n										case \'+\' : add(&result_value, first, second);\r\n												break;\r\n										case \'-\' : sub(&result_value, second, first);\r\n											break;\r\n										case \'*\' : mul(&result_value, first, second);\r\n												break;\r\n										case \'/\' : \r\n											if (first != 0)\r\n												{\r\n													divide(&result_value, second, first);\r\n											}\r\n												break;\r\n\r\n										}\r\n										pop(&operation_st);\r\n										push(&value_st, (void*)(result_value));\r\n										tmp = *(char *)top(operation_st);\r\n										free_long_int(first);\r\n										free_long_int(second);\r\n									}\r\n								}\r\n								pop(&operation_st);\r\n								break;\r\n							}\r\n						free(a->data);\r\n						free(a);\r\n						continue;\r\n					}\r\n					if (a->type == variable)\r\n					{\r\n						char *ptr = a->data;\r\n						char *name = (char *) malloc (sizeof (char));\r\n						int allocated = 0;\r\n						int is_equal = 0;\r\n						*name = 0;\r\n						while (*ptr != 0)\r\n						{\r\n							if (*ptr == \'=\')\r\n							{\r\n								is_equal = 1;\r\n								ptr++;\r\n								break;\r\n							}\r\n							name = (char *)realloc(name, sizeof(char)*(allocated+2));\r\n							name[allocated] = *ptr;\r\n							name[allocated+1] = 0;\r\n							allocated++;\r\n							ptr++;\r\n						}\r\n						if (is_equal)\r\n						{\r\n							if(is_init)\r\n							{\r\n								printf(\"ERROR!!\\n\");\r\n								is_init=0;\r\n								break;\r\n							}\r\n							else\r\n							{\r\n								is_init = 1;\r\n								result = (element*)malloc(sizeof(element));\r\n								result->type = a->type;\r\n								result->data = strdup(a->data);\r\n							}\r\n						}\r\n						else\r\n						{\r\n							long_int* temp = get_value(var_list, name);\r\n							if(temp == NULL)\r\n							{\r\n								result_value = alloc();\r\n								init_long_int_from_string(result_value, \"0\");\r\n							}\r\n							else\r\n							{\r\n								result_value = copy_long_int(temp);\r\n							}\r\n							push(&value_st, (void *) result_value);\r\n						}\r\n						free(name);\r\n						free(a->data);\r\n						free(a);\r\n					}\r\n				}\r\n			}\r\n			while(empty(operation_st))\r\n			{\r\n				result_value = alloc();\r\n\r\n				first = copy_long_int(((long_int*)top(value_st)));\r\n				pop_long_int(&value_st);\r\n				second =  copy_long_int(((long_int*)top(value_st)));\r\n				pop_long_int(&value_st);\r\n				tmp = *(char *)top(operation_st);\r\n				switch (tmp)\r\n				{\r\n				case \'+\' : add(&result_value, first, second);\r\n						break;\r\n				case \'-\' : sub(&result_value, second, first);\r\n						break;\r\n				case \'*\' : mul(&result_value, second, first);\r\n						break;\r\n				case \'/\' : if(first != 0)\r\n							{\r\n								   divide(&result_value, second, first);\r\n						   }\r\n						   else printf(\"ERROR!!\");\r\n						break;\r\n				}\r\n				pop(&operation_st);\r\n				push(&value_st, (void*)(result_value));\r\n				free_long_int(first);\r\n				free_long_int(second);\r\n			}\r\n			while (empty(value_st))\r\n			{\r\n				if(is_init)\r\n				{\r\n					char* name;\r\n					int length = 0;\r\n					is_init = 0;\r\n					length = strlen(result->data) - 1;\r\n					name = (char*)malloc((length + 2)*sizeof(char));\r\n					strcpy(name, result->data);\r\n					name[length] = 0;\r\n					set_value (var_list, name, copy_long_int((long_int *) top(value_st)));\r\n					free(name);\r\n				}\r\n				print((long_int*)top(value_st));\r\n				pop_long_int(&value_st);\r\n				if(result != NULL)\r\n				{\r\n					free(result->data);\r\n					free(result);\r\n					result =NULL;\r\n				}\r\n			}\r\n		}\r\n\r\n		clean_up(var_list);\r\n		\r\n		while(empty(value_st))\r\n		{\r\n			//free_long_int((long_int*)top(value_st));\r\n			pop_long_int(&value_st);\r\n		}\r\n		free(value_st->data);\r\n		free(value_st);\r\n		while(empty(operation_st))\r\n		{\r\n			pop(&operation_st);\r\n		}\r\n		free(operation_st->data);\r\n		free(operation_st);\r\n		\r\n		if(result != NULL)\r\n		{\r\n			free(result);\r\n		}\r\n	#ifdef _MSC_VER\r\n			_CrtDumpMemoryLeaks();\r\n	#endif\r\n	return 0;\r\n}\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (765,'#include \"parser.h\"\r\n#include <ctype.h>\r\n\r\n\r\nelement *parser(char* buffer, int* position)\r\n{\r\n	char c;\r\n	element* obj;\r\n	int index;\r\n	c = *buffer;\r\n	if(*buffer == 0)\r\n	{\r\n		return NULL;\r\n	}\r\n	obj = (element* ) malloc(sizeof(element));\r\n	obj->data = (char *) malloc(2*sizeof(char));\r\n	*position = 1;\r\n	switch(c)\r\n	{\r\n	case \'+\' :\r\n		obj->type = operation;		\r\n		obj->data[0] = \'+\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'-\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'-\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'*\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'*\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'/\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'/\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \'(\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \'(\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	case \')\' :\r\n		obj->type = operation;\r\n		obj->data[0] = \')\';\r\n		obj->data[1] = 0;\r\n		return obj;\r\n	}\r\n\r\n	index = 0;	\r\n	if (isdigit(c))\r\n	{\r\n		while (isdigit(c))\r\n		{\r\n			if(index == 0)\r\n			{\r\n				obj->type = value;\r\n				obj->data[0] = c;\r\n				obj->data[1] = 0;\r\n				buffer++;\r\n				c = *buffer;\r\n				index++;\r\n			}\r\n			else\r\n			{\r\n				obj->data = (char *) realloc(obj->data, 2*sizeof(char) + index);\r\n				obj->data[index] = c;\r\n				obj->data[index + 1] = 0;\r\n				buffer++;\r\n				c = *buffer;		\r\n				index++;\r\n			}\r\n		}\r\n		*position = index;\r\n		return obj;\r\n	}\r\n	else\r\n	if (isalpha(c))\r\n	{\r\n		while (isalpha(c) || (c==\'_\') || isdigit(c))\r\n		{\r\n			if(index == 0)\r\n			{\r\n				obj->type = variable;\r\n				obj->data[0] = c;\r\n				obj->data[1] = 0;\r\n				buffer++;\r\n				c = *buffer;\r\n				index++;\r\n			}\r\n			else\r\n			{\r\n				obj->data = (char *) realloc(obj->data, 2*sizeof(char) + index);\r\n				obj->data[index] = c;\r\n				obj->data[index + 1] = 0;\r\n				buffer++;\r\n				c = *buffer;		\r\n				index++;\r\n			}\r\n		}\r\n		if (c == \'=\')\r\n		{\r\n			obj->data = (char *) realloc(obj->data, 2*sizeof(char) + index);\r\n			obj->data[index] = c;\r\n			obj->data[index + 1] = 0;\r\n			buffer++;\r\n			c = *buffer;		\r\n			index++;\r\n		}\r\n		*position = index;\r\n		return obj;\r\n	}\r\n	free(obj->data);\r\n	free(obj);\r\n	return NULL;\r\n}\r\n	\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (766,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include \"long_int.h\"\r\n\r\nstruct item {\r\n        void *data;\r\n        struct item *next;\r\n};\r\n\r\ntypedef struct item stack;\r\n\r\nstack *create ()\r\n{\r\n        stack *p = (stack *) malloc(sizeof(*p));\r\n        p->next = NULL;\r\n        p->data = NULL;\r\n        return p;\r\n}\r\n\r\nvoid push (stack **st, void *value)\r\n{\r\n        stack *p = (stack *) malloc(sizeof(*p));\r\n        p->data = value;\r\n        p->next = *st;\r\n        *st = p;\r\n}\r\n\r\nvoid pop (stack **st)\r\n{\r\n        stack *p = *st;\r\n        *st = p->next;\r\n		free(p->data);\r\n        free (p);\r\n}\r\n\r\nvoid pop_long_int (stack **st)\r\n{\r\n        stack *p = *st;\r\n        *st = p->next;\r\n		free_long_int((long_int*)(p->data));\r\n        free (p);\r\n}\r\n\r\nvoid *top (stack *st)\r\n{\r\n        return (st->data);\r\n}\r\n\r\nint empty (stack *st)\r\n{\r\n	return (st->next != NULL);\r\n}\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (767,'#include \"var.h\"\r\n\r\n\r\n\r\nvoid set_value (var *head, char *name, long_int *value)\r\n{\r\n	var *ptr;\r\n	var* prev;\r\n	int is_founded = 0;\r\n	ptr = head;\r\n	prev = head;\r\n	while (ptr != NULL)\r\n	{\r\n		if (strcmp(ptr->name,name) == 0)\r\n		{\r\n			free_long_int(ptr->value);\r\n			ptr->value = value;\r\n			is_founded = 1;\r\n			break;\r\n		}\r\n		prev = ptr;\r\n		ptr = ptr->next;\r\n	}\r\n	if(!is_founded)\r\n	{\r\n		var *new_var = (var *)malloc (sizeof(var));\r\n		new_var->name = strdup(name);\r\n		new_var->value = value;\r\n		new_var->next = NULL;\r\n\r\n		prev->next = new_var;\r\n	}\r\n}\r\n\r\n\r\nlong_int * get_value (var *head, char *name)\r\n{\r\n	var *ptr = head;\r\n	while (ptr != NULL)\r\n	{\r\n		if (strcmp(ptr->name,name) == 0)\r\n		{\r\n			return ptr->value;\r\n		}\r\n		ptr = ptr->next;\r\n	}\r\n	return 0;\r\n}\r\n\r\nvoid clean_up (var *head)\r\n{\r\n	var *ptr = head;\r\n	while (ptr != NULL)\r\n	{\r\n		var *cleaner = ptr->next;\r\n		if(ptr->value != NULL)\r\n		{\r\n			free_long_int(ptr->value);\r\n		}\r\n		free(ptr->name);\r\n		free(ptr);\r\n		ptr = cleaner;\r\n	}\r\n}\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (768,'#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\nstruct item\n{\n\nint data;\nstruct item *next;\n\n};\n\nstruct item *head=0;\nstruct item *p=0;\nstruct item *pr=0;\nstruct item *q=0;\nint a;\n\n \n	\n	FILE *f=fopen(\"input.txt\",\"r\");\n	fscanf(f,\"%d\",&a);\n	head=malloc(sizeof(struct item));\n	head->data=a;\n	head->next=NULL;\n	while(fscanf(f,\"%d\",&a)==1)\n	{\n                     if(a > head->data)\n		     {q=head;\n		     pr=NULL;\n		     while(q && a > q->data)\n		     {  pr=q;\n			q=q->next;\n		     }	     \n\n		 	p=malloc(sizeof(struct item));\n                       \n		     if(pr->next!=NULL)\n			     p->next=pr->next;\n			\n			\n		     else\n			     {\n				     p->next=NULL;\n			     }\n			      \n				     pr->next=p;    	 \n				     p->data=a;\n				  		   				    \n			     }\n\n			     \n		   if(a<=head->data)\n                     { p=malloc(sizeof(struct item));\n		      p->data=a;\n                      p->next=head;\n		      head=p;\n                      }\n		}\n			     \n\nfor(p=head;p;p=p->next)\n{ printf(\"%d \",p->data);\n}\nprintf(\"\\n\");\nfclose(f);\n}\n\n\n		 	\n		   	\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (769,'#include <stdio.h>\n# define N 100\n\n\nvoid dfs(int curr, int A[N][N], int visited[], int n)\n{	\n	\n	visited[curr] = 1;\n	\n	int i;\n\n	for(i=1; i<=n; i++)\n		if(!visited[i] && A[curr][i] == 1)\n		{//	printf(\"????????? %d\\n\", i);\n			dfs(i, A, visited, n);\n		//	printf(\"????????? %d\\n \", curr);\n		}\n\n		printf(\"????????? %d\\n\", curr);\n\n}\n\nint main()\n{\n	FILE *f1 = fopen(\"input3.txt\", \"r\");\n	int visited[N] = {0};\n	int i, j, a;\n	int A[N][N] = { { 0 } };\n	\n	 if(!f1)\n	 {\n		 printf(\"no file!\");\n		 return 0;\n	 }\n\n	fscanf(f1, \"%d\", &a);\n	printf(\"%d\\n\", a);\n\n	for(i = 1; i<=a ; i++)\n	{\n		for(j = 1; j <= a; j++)\n		{\n			fscanf(f1, \"%d\", &A[i][j]);\n			printf(\"%d \", A[i][j]);\n		}\n		printf(\"\\n\");		\n	}	\n	\n	dfs(1, A, visited, a);\n\n	fclose(f1);	\n\n	return 0;\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (770,'#include<stdio.h>\n#define N 100\nint visited[N]={0};\nint A[N][N];\nvoid dfs(int curr,int A[N][N],int d)\n{\n	printf(\"%d\\n\", curr);\n	visited[curr]=1;\n	int i;\n	for(i=1;i<=d;i++)\n	 if(!visited[i]&&A[curr][i]==1)\n        {\n	dfs(i,A,d);		\n	}}\nint main()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n	int i,j,m,b,c;\n\n	fscanf(f,\"%d\",&m);\n\n	while(fscanf(f, \"%d%d\",&b,&c ) == 2)\n        {  A[b][c]=1;\n	   A[c][b]=1;		\n	}\n\n	for (i = 1; i <= m; i++)\n	{\n		for (j = 1; j <= m; j++)\n		{\n			printf(\"%d \", A[i][j]);\n		}\n		printf(\"\\n\");\n	}\n\n	dfs(1,A,m);\n	fclose(f);		\n	\n}\n\n\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n	\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (771,' #include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nstruct item\n{\n	char *word;\n	int count;\n	struct item *next;\n};\n\nint main()\n{	int i, j;\n	char s[100]; // ??????? ?????, ??????? ?? ??????????? ?? ??????\n	\n	FILE *f=fopen (\"input.txt\", \"r\");\n	\n	struct item *head = NULL;\n	struct item *p;\n	\n	int c = 0;\n	\n	for ( ; c != EOF; )\n	{\n		i = 0;\n		while ((c = fgetc(f)) >= \'a\' && c <= \'z\')\n		{\n			s[i] = c;\n			i++;\n		}\n		s[i] = 0;\n\n		if (i > 0)\n		{\n			printf(\"?????! ?? ????????? ????? %s\\n\", s);\n			// ????? ???? ??? ????????\n			\n\n	//		for (p = head; p; p = p->next)\n	//		{\n	//			if (strcmp (s, p->word) == 0)\n	//				p->count ++;\n			int found = 0;\n\n			for (p=head; p; p=p->next)\n			{	\n				if (strcmp(s, p->word) == 0)\n				{\n		  			p->count ++;\n					found = 1;\n				}\n			}\n\n			 // ???? ?? ??? ????? ??????\n			 \n			if (!found)\n			{\n				 struct item *q;\n				 q = malloc ( sizeof(struct item) );	\n				 q->word = malloc(strlen(s) + 1);\n				 strcpy(q->word, s);\n				 q->count = 1;\n				 q->next = head;\n				 head = q;\n			}\n		}\n				\n		\n			/*struct item *p;\n			for (p=head; p; p=p->next)\n			{if (strcmp(s, p->word) == 0)\n		  		p->count ++;\n			}*/\n\n		/*	struct item *r, *t;\n			for (r = head; r; r = r->next)\n			{	if (strcmp(s, r->word) == 0)\n				{j++;}\n				if (j>1)\n				{break;	}\n			free (r);\n			}*/	\n			\n	}		\n	 \n\n	fclose(f);\n\n	for (p = head; p; p = p->next)\n	{\n		printf(\"%s %d\\n\", p->word, p->count);\n	}\n\n\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (772,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define n 100\n\nint visited[n]={0};\n\nvoid dfs(int curr, int A[n][n], int M )\n{\n	int i;\n	visited[curr]=1;\n	for (i=0; i<M; i++)\n	{\n		if ( (A[curr][i]==1) && (visited[i]==0) )\n			dfs(i, A, M);\n	}\n	printf(\"%d \", curr);\n}\n\nint main()\n{\n	FILE *f;\n	f = fopen(\"input19.txt\", \"r\");\n	if (!f)\n	{\n		printf(\"?? ???????? input19.txt\\n\");\n		return 0;\n	}\n	int A[n][n];\n	int i, j, N, a;\n	fscanf(f, \"%d\", &N);\n	for (i = 0; i < N; i++)\n		for (j = 0; j < N; j++)\n		{\n			fscanf(f, \"%d\", &a);\n			A[i][j] = a;\n		}\n	printf(\"?????? ??????:\\n\");\n	dfs(1, A, N);\n	printf(\"\\n\");\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (773,'#include<stdio.h>\nmain()\n{\nint A[5]={1,3,5,7,9};\nint M[20]={0,0,0,0,0,0,0,0,0,0};\nint P[20]={0,0,0,0,0,0,0,0,0,0};\nint i,j,p,a,b,k;\nprintf(\"??? ?????? M={\");\nfor(i=0;i<5;i++)\n	{\n	printf(\"%d \",A[i]);\n	}\n\nprintf(\"} \\n\");\nprintf(\"?????? ????? ??? ????????? ???????????? ??? ? ??????? ??? ??? \\n\");\nprintf(\"??????? ????? ??????? ????? ?? ?????????\\n\");\nscanf(\"%d\",&k);\nprintf(\"??????? ????? \\n\");\nfor(i=0;i<k;i++)\n	{\n	scanf(\"%d\",&M[i]);\n	j=0;\n	a=0;\n	p=2;\n	b=4;\n	while(M[i]!=A[p]&&j!=1)\n		{\n		printf(\"?????: %d, ??????: %d\\n\", a, b);\n		if(M[i]<A[p])\n			{\n			b=p;\n			p=(p+a)/2;\n			}\n		else\n			{\n			a=p;\n			p=(p+b)/2;\n			}\n		if((M[i]<A[p]&&M[i]>A[p-1])||(M[i]<A[p+1]&&M[i]>A[p])||(M[i]<A[0])||(M[i]>A[4]))\n			{\n			printf(\"????? %d ?? ???????????? ? ???????\\n\",M[i]);\n			j=1;\n			}\n\n		}\n	if(M[i]==A[p])\n		{\n		printf(\"????? %d ??????????? ? ???????\\n\",M[i]);\n		return 1;\n		}\n	\n	}\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (774,'#include<stdio.h>\n#include<string.h>\nmain()\n{\nint p[50];\nint i,k,c;\ni=0;\nk=0;\nc=0;\nprintf(\"??????? ?????? ,?? ???????? ????????? ??? ??????????? ??? ???. \\n\");\n//????????? ????? ?????\nwhile ((c = getchar()) != EOF && c != \'\\n\')\n	{printf(\"%d \\n\",c);\n	if((65<=c&&c<=90)||(97<=c&&c<=122))\n		{ putchar(c);\n		printf(\" \\n\");\n		p[i]=0;\n	if(65<=c&&c<=90)\n		{\n		p[i]=c+32;	\n		i++;\n		}\n	else\n		{\n		p[i]=c;\n		i++;\n		}	\n		p[i]=c;\n		putchar(p[i]);\n		printf(\"\\n ?????? \\n\");	\n		}\n	}\nfor(k=0;k<i/2;k++)\n	{ printf(\" %d %d \\n\",p[k],p[i-k-1]);\n	if(p[k]!=p[i-k-1])\n		{	\n		printf(\"?? ????????? ???????????\\n\");\n		return 1;\n		}\n	\n	}\nprintf(\"????????? ???????????\\n\");\nreturn 0; \n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (775,'#include<stdio.h>\nmain()\n{\nint b,i,j,k,c,sum,elm;\nint p[50];\nb=0;\ni=0;\nk=0;\nc=0;\nsum=0;\nelm=0;\nprintf(\"??????? ?????\\n\");\nwhile ((c = getchar()) != EOF&&c != \'\\n\') \n	{\n	p[k]=c;\n	k++;\n	printf(\"%d %d\",p[k-1],k);\n	}printf(\"??????? ??????? ??????????\\n\");\nscanf(\"%d\",&b);\n\nfor(i=k;i>0;i--)\n	{\n	if(65<=p[k-i]&&p[k-i]<=90) \n	{p[k-i]=p[k-i]-55;\n	}\n	else\n	{\n	if(97<=p[k-i]&&p[k-i]<=122) \n	{p[k-i]=p[k-i]-87;\n	}\n	else\n	{\n	if(48<=p[k-i]&&p[k-i]<=57) \n	{p[k-i]=p[k-i]-48;\n	}}}\n	for(j=i;j>1;j--)\n		{\n		p[k-i]=p[k-i]*b;\n		}\n		sum=sum+p[k-i];\n	}\nprintf(\"????? ? ?????????? ??????? %d \\n\", sum);\nreturn 0;\n}\n\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (776,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint main()\n{\n int i;\n char c[20];\n\n struct item\n\n {	 char *word;\n	 int count;\n	 struct item *next;\n };\n \n struct item *head = 0;\n struct item *p = 0;\n struct item *q = 0;\n \n FILE *f2 = fopen(\"input2.txt\", \"r\");\n \n if(!f2)\n	{\n		printf(\"no file!\");\n		return 0;\n	}\n fscanf(f2, \"%s\", c);\n\n head = malloc(sizeof(struct item));\n head->word = malloc(strlen(c)+1);\n strcpy(head->word, c);\n head->count = 1;\n head->next = NULL;\n\n while (fscanf(f2,\"%s\", c) == 1)\n{\n	for(p = head; p; p = p->next)\n	{\n		if(strcmp(p->word, c) == 0)\n		{\n			p->count++;\n			break;\n		}\n	}\n	\n	if (!p)\n	{	q = malloc(sizeof(struct item));\n		q->next = head;\n		q->word = malloc(strlen(c)+1);\n		strcpy(q->word, c);\n		q->count = 1;\n		head = q;\n	}\n}\n\n	for( p = head ; p; p = p->next )\n	{\n		printf(\"%s - %d\\n\", p->word, p->count);\n	}\n\n	fclose(f2);\n	 	\n}\n','ÐÐ°Ñ‚Ð°Ð»ÑŒÑ','Natalia','f');
INSERT INTO `bias` VALUES (777,'#include \"memory.h\"\n#include <stdio.h>\n#include \"stack.h\"\n#include \"vars.h\"\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\nvoid scipSpases()\n{\n	int i = 0;\n	while((i = fgetc(stdin) != EOF))\n	{\n		if(i != \' \')\n			break;\n	}\n	ungetc(i, stdin);\n}\n\nvoid unpush(stack *st1, stack *st2)\n{\n	char *z;\n	int *x,*y,*res;\n//	res=malloc(sizeof(*res));\n	MALLOC(res, sizeof(*res));\n\n	x=top(*st1);\n	POP(st1);\n	//printf(\"UNPUSH-st1= %d\\n\",*(int*)top(*st1));\n	y=top(*st1);\n	POP(st1);\n	z=top(*st2);\n	switch(*z) \n	{\n		case \'+\': (*res)=(*x) + (*y); break;\n		case \'-\': (*res)=(*y) - (*x); break;\n		case \'*\': (*res)=(*x) * (*y); break;\n		case \'/\': (*res)=(*y) / (*x); break;\n	}\n	free(x);\n	free(y);\n	push(st1,(void*)res);\n	//printf(\"afterpush-st1= %d\\n\", *(int*)top(*st1));\n	//printf(\"afterpush-st2= %c\\n\", *(char*)top(*st2));\n	free(top(*st2));\n	POP(st2);\n}\n\nvoid countbrats(stack *st1, stack *st2)\n{\n	while((*(char *)top(*st2))!=\'(\')\n	{	\n		unpush(st1,st2);\n	}\n	POP(st2);\n}\n\nint prior(char*g)\n{\n	int pr;\n	switch(*g)\n	{  \n		case \'+\': pr=1; break;\n		case \'-\': pr=1; break;\n		case \'*\': pr=2; break;\n		case \'/\': pr=2; break;\n		case \'(\': pr=0; break;\n	}\n	return(pr);\n}\n\nchar *readword(FILE*f)\n{\n	char *p=NULL;\n	char *q=NULL;\n	int all=0;\n	int u=0;\n	char w;\n	while (((w=fgetc(f))!= EOF) && (!isdigit(w)) || (w==\'_\'))\n	{\n	\n		//printf(\"Read0000\\n\");\n		//ungetc(w,f);\n		if (!isalpha(w)) break;\n	\n		if (all==u)\n		{\n			//printf(\"read\\n\");\n			q=realloc(p, all+11);\n			if (!q) break;\n			p=q;\n			all+=11;\n		}\n		//printf(\"Inreadword\\n\");\n		p[u]=w;\n		//printf(\"afterin\\n\");\n		u++;\n		//printf(\"after++\\n\");\n	\n	\n	}\n	ungetc(w,stdin);\n	//printf(\"Inreadword2\\n\");\n	if (p)\n	{\n		p[u]=0;\n	}\n\n	//printf(\"End readword\\n\");\n	return p;\n}\n\nint main()\n{\n\n        stack st1=create();\n	stack st2=create();\n	\n	int unary = 1;\n\n	int i,f,a=0, *u, *r,zero = 0,wcnt=0;\n	char c;\n	char minus = \'-\';\n	char *word = NULL;\n	char *word_val = NULL;\n	char *s;\n	while((c=fgetc(stdin))!=EOF)\n	{\n		\n		//printf(\"read: c=%d\\n\", c);\n		\n		if(isdigit(c))\n		{\n				while (isdigit(c))\n				{\n					a=a*10+c-\'0\';\n					c=getchar();\n					//printf(\"00\\n\");\n				}\n				ungetc(c, stdin);\n										\n				//u=malloc(sizeof(*u));\n				MALLOC(u, sizeof(*u));\n				*u=a;\n				a=0;\n				push(&st1,u);\n				//printf(\"01\\n\");\n				unary = 0;\n		}\n			//ungetc(c, stdin);\n		else if (c==\'(\')\n		{\n			unary = 1;\n			//s=malloc(sizeof(*s));\n			MALLOC(s, sizeof(*s));\n			*s=c;\n			push(&st2,s);\n			//printf(\"after ( \\n\");\n		}\n		else if (c==\')\')\n		{\n			unary = 0;\n		//	printf(\"after )\\n\");\n		//	printf(\"Top_st2= %c\\n\", *(char*)top(st2));\n		//	printf(\"Top_st1= %d\\n\", *(int*)top(st1));\n			countbrats(&st1,&st2);\n		//	printf(\"aftercount!!!\\n\");\n		}\n		else if (c==\'-\' || c== \'+\' || c==\'*\' || c==\'/\')\n		{\n			//int zero = 0;\n			//char minus = \'-\';\n			if(unary)\n			{\n				//printf(\"00\\n\");\n				//printf(\"UNARYtop-st2= %c\\n\", *(char*)top(st2));\n				//pop(&st2);\n				//printf(\"UNARYtop-st2= %c\\n\", *(char*)top(st2));\n				push(&st1, &zero);\n				push(&st2, &minus);\n			}\n		//	printf(\"02\\n\");\n		//	printf(\"Top_st2= %c\\n\",*(char *)top(st2));\n		//	printf(\"Top_st1= %d\\n\", *(int *)top(st1));\n\n			if (/*empty(st2)*/ (st2->data == NULL))\n			{\n			//	printf(\"03\\n\");\n				//s=malloc(sizeof(*s));\n				MALLOC(s, sizeof(*s));\n				*s=c;\n				push(&st2,s);\n			//	printf(\"04\\n\");\n			}\n			else\n			{\n			//  printf(\"05\\n\");\n			  while(/*!empty(st2)*/st2->data!=NULL  && prior(&c)<=prior(top(st2)) && (!unary))\n			  {\n				  //printf(\"before unpush\\n\");\n				 // printf(\"top-st2= %c\\n\", *(char*)top(st2));\n				 // printf(\"top-st1= %d\\n\", *(int*)top(st1));\n				  unpush(&st1,&st2);\n				 // printf(\"after unpush\\n\");\n				 // POP(&st2);\n				 // printf(\"top-st2= %c\\n\", *(char*)top(st2));\n				 // printf(\"06\\n\");\n			  }\n			//s=malloc(1);\n			MALLOC(s, 1);\n		   	*s=c;\n			if (!unary) push(&st2,s);\n			}\n			unary = 1;\n		}\n		else if(c==\'\\n\')\n		{\n			unary = 1;\n			while(/*!empty(st2)*/ st2->data!=NULL)\n			{\n				unpush(&st1,&st2);\n				//POP(&st2);\n				//printf(\"07\\n\");\n			}\n			//if (wcnt==1)\n			//{\n			//	set_value(word, *(int*)top(st1));\n			//}\n			printf(\"Answer= %d\\n\", *(int *)top(st1));\n			if (word) free(word);\n			if (word_val) free(word_val);\n			word = NULL;\n			word_val = NULL;\n		}\n\n		else if ((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\') || c==\'_\')\n		{\n			//ungetc(c, stdin);\n			unary = 0;\n			//printf(\"001\\n\");\n			//while((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\') || c==\'_\')\n			//{\n				\n				\n					ungetc(c,stdin);\n					if (word) free(word);\n					word=readword(stdin);\n					word_val=strdup(word);\n					wcnt=1;\n					\n					//c=getchar();\n					//printf(\"Word= %s\\n\", word);\n					//printf(\"after readword\\n\");\n					if (((c = getchar())==\'=\') && wcnt==1)\n					{\n						//printf(\"After (=)\\n\");\n						unary=1;\n						while ((c=getchar())!=\'\\n\')\n						{\n								if(isdigit(c))\n								{\n									while (isdigit(c))\n									{		\n										a=a*10+c-\'0\';\n										c=getchar();\n									}		\n								\n									ungetc(c,stdin);\n									//u=malloc(sizeof(*u));\n									MALLOC(u, sizeof(*u));\n									*u=a;\n									a=0;\n									push(&st1,u);\n									//printf(\"Top-st1 isdigit= %d\\n\", *(int*)top(st1));\n									unary=0;\n								}\n								else if (c==\'(\')\n								{\n									unary=1;\n									//s=malloc(sizeof(*s));\n									MALLOC(s, sizeof(*s));\n									*s=c;\n									push(&st2,s);\n								}\n								else if (c==\')\')\n								{	\n									unary=0;\n									countbrats(&st1,&st2);\n							\n								}\n								else if (c==\'-\' || c== \'+\' || c==\'*\' || c==\'/\')\n								{\n									//printf(\"002\\n\");		\n									if(unary)\n									{\n										push(&st1, &zero);\n										push(&st2, &minus);\n									}\n\n									if (st2->data == NULL)\n									{\n										MALLOC(s, sizeof(*s));\n										*s=c;\n										push(&st2,s);\n									}\n									else\n									{	\n\n										while(st2->data!=NULL && prior(&c)<=prior(top(st2)) && (!unary))\n										{\n											unpush(&st1,&st2);\n											//POP(&st2);\n										}\n										MALLOC(s,1);\n										*s=c;\n										if (!unary) push(&st2,s);\n									}\n									unary = 1;\n								}\n								else if ((c>=\'a\' && c<=\'z\') || (c>=\'A\' && c<=\'Z\') || c==\'_\')\n								{\n										unary = 0;\n										ungetc(c,stdin);\n										if (word) free(word);\n										word=readword(stdin);\n										MALLOC(r, sizeof(*r));\n										*r=get_val(word);\n										push(&st1,r);\n										wcnt=0;\n										//printf(\"Getval\\n\");\n										\n								}	\n						} //while\n						if(c==\'\\n\')\n						{\n							//printf(\"endstring\\n\");\n							unary = 1;\n							while(st2->data!=NULL)\n							{\n								unpush(&st1,&st2);\n								//POP(&st2);\n							}\n						}\n\n						set_value(word_val, *(int*)top(st1));\n\n						wcnt=0;\n\n						free(word_val);\n						free(word);\n						word_val = NULL;\n						word = NULL;\n						//printf(\"Top_st1= %d\\n\", *(int*)top(st1));\n						//printf(\"Setval\\n\");\n			\n				//	}\n					}\n					else\n					{\n						//r=malloc(sizeof(*r));\n						MALLOC(r, sizeof(*r));\n						*r=get_val(word);\n						free(word);\n						word = NULL;\n						push(&st1,r);\n						wcnt=0;\n						ungetc(c,stdin);\n						//printf(\"Getval\\n\");\n						//printf(\"Answer-alpha= %d\\n\", *(int *)top(st1));\n					}	\n				\n		}\n\n\n	}\n\n	//printf( \"%d\\n\" , *(int*)top(st1));\n	printf(\"delete\\n\");\n\n	while (!empty(st1))\n	{\n		free(top(st1));\n		POP(&st1);\n	}\n\n	while (!empty(st2))\n	{\n		free(top(st2));\n		POP(&st2);\n	}\n\n	free(st1);\n	free(st2);\n	cleanup();\n	return 0;\n}\n\n\n\n\n\n\n	\n\n\n\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (778,'#include \"memory.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"long.h\"\n\n/*void print(struct long_int a)\n{\n	int i;\n	for(i=9999; i>=0; i--)\n	{\n		if (\n			*/\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (779,'#include \"memory.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n\n\nvoid pop(stack *st){\n	stack p=*st;\n	*st=(*st)->next;\n	//free(p);\n	FREE(p);\n\n\n}\n\nvoid push(stack *st, void *data){\n	stack p;\n//	p=malloc(sizeof(*p));\n	MALLOC(p, sizeof(*p));\n	p->data=data;\n	p->next=*st;\n	*st=p;\n}\n\nint empty(stack st){\n	return(st==NULL);\n\n}\n\nvoid *top(stack st){\n	return(st->data);\n}\n	\nstack create()\n{\n	stack st;\n	//st=malloc(sizeof(stack));\n	MALLOC(st, sizeof(*st));\n        st->data=NULL;\n	st->next=NULL;\n	return st;\n	\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (780,'#include \"memory.h\"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"vars.h\"\n#define N 100\n//#define _CRT_SECURE_NO_WARNINGS\n#pragma warning(disable: 4996)\n\nunsigned int hash(char*w)\n{\n	unsigned int res = 0;\n	for( ; *w; w++)\n		res=res*37 +*w;\n	return (res % 100);\n}\nstruct hs\n{\n	char *vl;\n	int data;\n	struct hs *next;\n};\nstruct hs *arr[N]={0};\nstruct hs *p = NULL;\nvoid set_value(char*name, int val)\n{\n	//struct hs *p= malloc(sizeof(*p));\n	int h=hash(name);\n	struct hs *p=NULL;\n	int lgt=(int)strlen(name);\n        p=arr[h];\n	MALLOC(p, sizeof(*p));\n	MALLOC(p->vl, sizeof(lgt+2));\n	\n	//p=malloc(sizeof(*p));\n	\n	strcpy(p->vl,name);\n	p->data=val;\n	p->next=arr[h];\n	arr[h]=p;\n}\n\nvoid cleanup(void)\n{\n	int i;\n	for(i=0;i<N;i++)\n	{\n		while(p=arr[i])\n		{\n			//free(arr[i]->vl);\n			FREE(arr[i]->vl);\n			arr[i]=arr[i]->next;\n			//free(p);\n			FREE(p);\n		}\n	}\n}\n\nint get_val(char*name)\n{\n	struct hs *p=NULL;\n	for(p=arr[hash(name)];p;p=p->next)\n	{\n		if(strcmp(p->vl,name)==0)\n		{\n			return(p->data);\n			break;\n		}\n	}\n	return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (781,'#include \"memory.h\"\n#include <stdio.h>\n#include \"long.h\"\n#include <string.h>\n#include <stdlib.h>\nint Max(int a,int b)\n{\n	if (a>b)\n		return a;\n	return b;\n}\nint Min(int a,int b)\n{\n	if(a<b)\n		return a;\n	return b;\n}\nint bs(int a,int b)\n{\n	int i=0;\n	for(;b>0;i++)\n	{\n		b=b-a;\n	}\n	return i;\n}\n\nvoid reverse(struct long_int a,int l,int r)\n{\n\n	/*int i = 0;\n	int j = 1;\n	int count = 0;\n		while(l < r)\n		{\n			if(l<0)\n			{\n				break;\n			}\n			i =	a.digits[l];\n			a.digits[l] = a.digits[r];\n			a.digits[r] = i;\n			l--;\n			r--;\n		i	f(l>=0)\n			{\n				if (count > 0)\n					break;\n				else\n					reverse(a,l,r);\n			}\n			break;\n		}*/ \n	int i = 0;\n	int j = 0;\n	while (l < r)\n	{\n		i =	a.digits[l];\n		a.digits[l] = a.digits[r];\n		a.digits[r] = i;\n		l++;\n		r--;		\n	}\n	\n}\nvoid add_end(struct long_int a)\n{\n	int i = 0;\n	int j = a.digits[a.length - 1];\n	for(i = a.length - 2;i>=0;i--)\n	{\n		a.digits[i+1] = a.digits [i];\n	}\n	a.digits[0] = j;\n}\nvoid addlenght(struct long_int a,struct long_int b)\n{\n	//int i = 0;\n	if(a.length < b.length)\n	{\n		int i = 0;\n		a.digits = (int*)malloc(sizeof(int)*(b.length-a.length));\n		for(i=a.length;i<b.length;i++)\n		{\n			//a.digits[i] = (int*)malloc(sizeof(int));\n			a.digits[i]=0;\n			a.length++;\n		}\n	}\n	else if(b.length < a.length)\n	{\n		int i = 0;\n		b.digits = (int*)malloc(sizeof(int)*(a.length-b.length));\n		for(i=b.length;i<a.length;i++)\n		{\n		// 	b.digits[i] = (int*)malloc(sizeof(int));\n			b.digits[i]=0;\n			b.length++;\n		}		\n	}\n}\nint compare(struct long_int a,struct long_int b) \n{\n	int i = 0;\n//	addlength(a,b);\n	if(a.length < b.length)\n	{\n		int i = 0;\n	//	a.digits = (int*)malloc(sizeof(int)*(b.length-a.length));\n		for(i=a.length;i<b.length;i++)\n		{\n//			a.digits[i] = (int*)malloc(sizeof(int));\n			a.digits[i]=0;\n			a.length++;\n		}\n	}\n	else if(b.length < a.length)\n	{\n		int i = 0;\n	//	b.digits = (int*)malloc(sizeof(int)*(a.length-b.length));\n		for(i=b.length;i<a.length;i++)\n		{\n			//b.digits[i] = (int*)malloc(sizeof(int));\n			b.digits[i]=0;\n			b.length++;\n		}		\n	}\n	for (i = Max(a.length,b.length); i>=0; i--) \n	{\n		if (a.digits[i-1] == b.digits[i-1])\n			continue;\n		return ((a.digits[i-1] < b.digits[i-1]) ? -1 : 1);\n	}\n	return 0;\n}\n\n\nvoid print (struct long_int a)\n{\n	int i = 0;\n		int flag = 0;\n		printf(\"%d\",a.digits[a.length-1]);\n		for(i = a.length-2;i >= 0;i--)\n		{\n			printf(\"%04d\",a.digits[i]);\n		}\n		printf (\"\\n\");\n}\nstruct long_int LongAdd(struct long_int a,struct long_int b)\n{\n	struct long_int temp;\n	int buf = 0,i=0;\n	int lent = 0;\n	int j = Max(a.length,b.length);\n	temp.digits = (int*)malloc(sizeof(int)*(j+1));\n	//addlength(a,b);\n	if(a.length < b.length)\n	{\n		int i = 0;\n		//a.digits = (int*)malloc(sizeof(int)*(b.length-a.length));\n		for(i=a.length;i<b.length;i++)\n		{\n		//	a.digits[i] = (int*)malloc(sizeof(int));\n			a.digits[i]=0;\n			a.length++;\n		}\n	}\n	else if(b.length < a.length)\n	{\n		int i = 0;\n		//b.digits = (int*)malloc(sizeof(int)*(a.length-b.length));\n		for(i=b.length;i<a.length;i++)\n		{\n			//b.digits[i] = (int*)malloc(sizeof(int));\n			b.digits[i]=0;\n			b.length++;\n		}		\n	}\n	for (i=0;i<j;i++)\n	{\n		temp.digits[i] = a.digits[i] + b.digits[i];\n		temp.digits[i] += buf;\n		buf = temp.digits[i]/10000;\n		if(buf!=0)\n		{\n			temp.digits[i]-=10000;\n		}\n		if(i == j && buf != 0)\n		{\n		//	temp.digits[j] = (int*)malloc(sizeof(int));\n			temp.digits[j] = buf;\n			lent++;\n		}\n	}\n	temp.length = j + lent;\n	return temp;\n}\nstruct long_int LongSub(struct long_int a,struct long_int b)\n{\n	if(a.length >= b.length)\n	{\n		struct long_int temp;\n		int buf = 0;\n		int i = 0;\n		int lent = 0;\n		int counter = 0;\n		int j = Max(a.length,b.length);\n		temp.digits = (int*)malloc(sizeof(int)*j);\n		if(a.length < b.length)\n		{\n			int i = 0;\n			//a.digits = (int*)malloc(sizeof(int)*(b.length-a.length));\n			for(i=a.length;i<b.length;i++)\n			{\n				//a.digits[i] = (int*)malloc(sizeof(int));\n				a.digits[i]=0;\n				a.length++;\n			}\n		}\n		else if(b.length < a.length)\n		{\n			int i = 0;\n		//	b.digits = (int*)malloc(sizeof(int)*(a.length-b.length));\n			for(i=b.length;i<a.length;i++)\n			{	\n				//b.digits[i] = (int*)malloc(sizeof(int));\n				b.digits[i]=0;\n				b.length++;\n			}		\n		}\n		for(i=0;i<j;i++)\n		{\n			if(a.digits[i] < b.digits[i])\n			{\n				a.digits[i] = a.digits[i]+10000;\n				counter++;\n			}\n			temp.digits[i] = a.digits[i] - b.digits[i] + buf;\n	\n			if(counter > 0)\n			{\n				buf = -1;\n				counter = 0;\n			}\n			else\n			{\n				buf = 0;\n			}\n			if(i==j && a.digits[i] == b.digits[i])\n			{\n				lent++;\n			}\n		}\n		temp.length = j+lent;\n		return temp;\n	}\n	else\n	{\n		LongSub(b,a);\n	}\n}\nstruct long_int read_long_num (struct long_int a)\n{\n	int i = 0;\n	int j = 0;\n	int first = 0;\n	int second = 0;\n	int third = 0;\n	int fourth = 0;\n	int lent = 0;\n	int lent_new = 0;\n	int c = 0;\n	char *temp = 0;\n	char *p = NULL, *tmp = NULL;\n	size_t allocated = 0, used = 0;\n	while ((c = fgetc(stdin))>=\'0\' && c<=\'9\')\n	{\n		if (allocated == used)\n			{\n				char *tmp = (char*)realloc(p,allocated += (size_t)5);\n				if(!tmp) \n					break;\n				p=tmp;\n			}\n			p[used++] = c;\n			lent++;\n	}\n	p[used++] = 0;\n	if(lent<=4)\n		lent_new=1;\n	else\n		lent_new = bs(4,lent);\n	for (i=lent,j=lent_new;i>0;i-=4,j--)\n	{\n				if(!a.digits)\n				{\n					a.digits = (int*)malloc(sizeof(int)*(lent_new));\n				}\n				(i-1>=0)?(first = p[i-1]-\'0\'):(first = 0);\n				(i-2>=0)?(second = 10*(p[i-2]-\'0\')):(second = 0);\n				(i-3>=0)?(third = 100*(p[i-3]-\'0\')):(third = 0);\n				(i-4>=0)?(fourth = 1000*(p[i-4]-\'0\')):(fourth = 0);\n			a.digits[lent_new-j]=first+second+third+fourth;\n	}\n	a.length=lent_new;\n	return a;\n}\nstruct long_int LongMul(struct long_int a,struct long_int b)\n{\n	if (a.length>=b.length)	\n	{\n		int j = Max(a.length, b.length);\n		int d=0;\n		int lent = 0;\n		int i = 0, k = 0;\n		int buf = 0;\n		int counter = 0;\n		int lent_size = a.length+b.length;\n		struct long_int temp;\n		temp.digits = (int*)calloc(lent_size,sizeof(int));\n		temp.length=lent_size;\n		for(i = 0; i < b.length; i++)\n		{\n			for(k = 0; k < j; k++)\n			{\n				buf = 0;\n				counter = 0;\n			//	d=a.digits[k]*b.digits[i];\n			//	temp.digits[k]=d%10000+temp.digits[k];\n			//	temp.digits[k+1]=d/10000+temp.digits[k+1];\n				d=a.digits[k]*b.digits[i];\n				temp.digits[k+i]=d%10000+temp.digits[k+i];\n				buf += temp.digits[k+i]/10000;\n				if(buf!=0)\n				{\n						temp.digits[k+i]-=10000;\n			//			if(k == (j-1))\n			//				temp.length++;\n				}\n			//	if(temp.digits[k+i+1] == 0)\n			//		temp.length++;\n				temp.digits[k+i+1]=d/10000+temp.digits[k+i+1] + buf;\n				if(temp.digits[k+i+1]/10000 > 0)\n				{\n					buf = temp.digits[k+i+1]/10000;\n					//counter++;\n					temp.digits[k+i+1]-=10000;\n					temp.digits[k+i+2]+=buf;\n				}\n\n				//temp.digits[k+i+1]=d/10000+temp.digits[k+i+1] + buf;\n			//	}\n			}\n		}\n		return temp;\n	}\n	else\n	{\n		LongMul(b,a);\n	}\n}\nstruct long_int mul_short(struct long_int a, int b)\n{\n	int buf = 0,i=0;\n	int lent = 0;\n	int j = a.length;\n	struct long_int tmp;\n	tmp.digits = (int*)malloc(sizeof(int)*(j+1));\n/*	for (i=0;i<a.length;i++)\n	{\n		temp.digits[i] = a.digits[i]*b;\n		temp.digits[i] += buf;\n		buf = temp.digits[i]/10000;\n		if(buf!=0)\n		{\n			temp.digits[i]-=10000;\n		}\n		if(i == a.length && buf != 0)\n		{\n			temp.digits[j] = (int*)malloc(sizeof(int));\n			temp.digits[j] = buf;\n			lent++;\n		}\n	}\n	temp.length = a.length + lent;\n	return temp;*/\n\n\n	for (i = 0; i<j; i++) \n	{\n		tmp.digits[i] = a.digits[i] * b;\n		tmp.digits[i] += buf;\n		buf = tmp.digits[i] / 10000;\n		if(buf!=0)\n		{\n			tmp.digits[i] = tmp.digits[i] % 10000;\n		}\n		//temp.digits[i]   = temp.digits[i] % 10000;\n	}\n	if(buf!=0)\n	{\n		tmp.digits[i]-=10000;\n	}\n	if(i == j && buf != 0)\n	{\n//		temp.digits[j] = (int*)malloc(sizeof(int));\n		tmp.digits[j] = buf;\n		lent++;\n	}\n	tmp.length = a.length + lent;\n	return tmp;\n}\nstruct long_int LongDiv(struct long_int a,struct long_int b)\n{\n	struct long_int answer;\n	struct long_int temp;\n	struct long_int temp_2;\n	int left = 0;\n	int i = 0;\n	int l = 0;\n	int j = Max(a.length,b.length);\n	int k = 0;\n	int h = 0;\n	int right = 9999;\n	int middle = 0;\n	int temp_lent=0;\n	int comp = 0;\n	int counter = 0;\n	int lent = a.length - b.length + 1;\n	temp.length = a.length - b.length + 1;\n	temp_2.length = 0;\n	answer.digits = (int*)malloc(sizeof(int)*a.length);\n	answer.length = 0;\n	temp_2.digits = (int*)malloc(sizeof(int)*a.length);\n	temp.digits = (int*)malloc(sizeof(int)*temp.length);\n	for(i = /*temp.length - 1*/lent,h = 0;i >= 0; i--,h++)                //? \"=\"\n	{\n		counter = 0;\n	//	temp.digits = (int*)malloc(sizeof(int)*temp.length);\n		right = 9999;\n		left = 0;\n		temp_2.length = 0;\n	//	j = Max(a.length,b.length);\n		j = a.length;\n		for (j,k=0;j>0;j--,k++)\n		{\n			temp_2.length++;\n			temp_2.digits[k] = a.digits[j-1];\n			if(temp_2.length>1)\n				add_end(temp_2);\n			if (compare(temp_2,b) < 0)\n			{\n				temp_lent++;\n				continue;\n			}\n			else\n			{\n				break;\n			}\n		}\n		while(right - left > 1)\n		{\n			middle = (left + right)/2;\n			temp = mul_short(b,middle);\n			comp = compare(temp,temp_2);\n\n			if(comp > 0)\n			{\n				right = middle;\n			}\n			else if(comp < 0)\n			{\n				left  = middle;\n			}\n			else if(comp == 0)\n				break;\n		}\n		if((compare(mul_short(b,middle),temp_2)>0))\n			middle--;\n		temp = mul_short(b,middle);\n		if(middle == 0)\n			break;\n		answer.digits[h] = middle;\n		answer.length++;\n		temp_2 = LongSub(temp_2,temp);\n		reverse(temp_2,0,temp_2.length-1);\n	//	reverse(temp,0,temp.length-1);\n		reverse(a,0,a.length-1);\n	//	temp_2 = LongSub(temp_2,temp);\n		for(l = 0;l<temp_2.length;l++)\n		{\n			a.digits[l] = temp_2.digits[l];\n		}\n	/*	k=h;\n		for(l = 0,k;l<temp_2.length;l++)\n		{\n			if(counter == 0 && temp_2.digits[l] != 0)			\n				counter++;\n			if(counter == 0)\n			{\n			//	k++;\n				a.digits[k] = 0;\n			//	a.digits[l]=temp_2.digits[k];\n			//	a.length--;\n				while (temp_2.digits[l] == 0)\n				{\n					//k++;\n					l++;\n				}\n				l--;\n				if(a.digits[k] == 0)\n				{\n					while (a.digits[k] == 0)\n					{\n						k++;\n					}\n					//k--;\n				}\n				else\n					k++;\n			}\n			else\n			{\n				a.digits[k]=temp_2.digits[l];\n				k++;\n			}\n		}\n		//a.length -= (l-k);\n	*/ 						 \n\n\n\n/*		counter = 0;\n		if(a.digits[0] == 0)\n		{\n			for(l = 0;a.digits[l] == 0;l++)\n			{\n				counter++;\n			}\n		}*/\n		reverse(temp_2,0,temp_2.length-1);\n	//	reverse(temp,0,temp.length-1);\n		reverse(a,0,a.length-1);\n//		a.length-=counter;\n	}\n	reverse (answer,0,answer.length-1);\n	return answer;\n}\n\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (782,'#include \"memory.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n#include \"vars.h\"\nint pr (char *s)\n{\n	int i;\n	switch(*s)\n	{\n		case \'+\': i=1;break;\n		case \'-\': i=1;break;\n		case \'*\': i=2;break;\n		case \'/\': i=2;break;\n		case \'(\': i=0;break;\n	}\n	return i;\n}\n\nint eval(char **firstword)\n{\n	stack st_num = createStack();\n	stack st_obr = createStack();\n	int i = 0;\n	int j = 0;\n	int *a = NULL;\n	int *d = NULL;\n	int unary = 0;\n	int ucount = 0;\n	int wcount = 0;\n	int *b = NULL;\n	int k = 0;\n	int binary = 0;\n	int p = 0;\n	char c;\n	char *s;\n	char *word = NULL;\n\n	int result = 0;\n\n	if (firstword && *firstword)\n	{\n		wcount = 1;\n		word = *firstword;\n	}\n\n	while ((c=fgetc(stdin)) != EOF)\n	{\n		p=0;\n		if(c == \'-\' || c == \'+\')\n		{\n			unary = 1;\n		}\n		if(!empty(st_obr))\n		{\n			j=1;\n		}\n		else\n		{\n			j=0;\n		}\n	 	if (c == \'_\' || (c >= \'a\' && c <= \'z\'))\n		{\n			ungetc(c,stdin);\n			word = readword(stdin);\n			wcount = 1;\n		}\n		if (wcount == 1 && c == \'=\')\n		{\n			////////////////////eval\n			set_value(word,*a);\n			FREE(word);\n			if (firstword && word == *firstword)\n			{\n				*firstword = NULL;\n			}\n			word = NULL;\n			FREE(top(st_num));\n			pop(&st_num);\n			wcount = 0;\n			binary = 0;\n			//if(c==\'\\n\')\n			//	break;\n		}\n		\n		if (wcount == 1 && (c == \'+\' || c == \'-\' || c == \'*\' || c == \'/\' || c == \'\\n\' || c == \')\'))\n		{\n			//char *t = MALLOC(sizeof(1));\n			//*t = c;\n			wcount = 0;\n			binary = 1;\n			MALLOC(a, sizeof(int));\n			*a = get_value(word);\n			FREE(word);\n			if (firstword && word == *firstword)\n			{\n				*firstword = NULL;\n			}\n			word = NULL;\n			push(&st_num,a);\n			//FREE(t);\n		}\n		if(binary ==0 && ucount == 0 && i == 1 && (c == \'-\' || c == \'+\'))\n		{\n			char *t;\n			MALLOC (t, sizeof(1));\n			*t = c;\n			MALLOC(b, sizeof(int));\n			*b = 0;\n			unary = 0;\n			push(&st_num,(void*)(b));\n			push(&st_obr,(void*)(t));\n			//FREE(t);\n		}\n		else if(c>=\'0\' && c<=\'9\')\n		{	\n			if(i==1)\n				i=0;\n			binary = 1;\n			MALLOC(a, sizeof(int));\n			ungetc(c,stdin);\n			*a = readnum(stdin);\n			push (&st_num,a);\n			//FREE(a);\n		}\n		else if (c == \'(\')\n		{\n			char *t;\n			MALLOC (t, sizeof(1));\n			*t = c;\n			push(&st_obr,(void*)(t));\n\n			i=1;\n			if (unary == 1 && binary == 0)\n			{\n				 MALLOC(b, sizeof(int));\n				*b = 0;\n				unary = 0;\n				push(&st_num,(void*)(b));\n				ucount++;\n			}\n			else\n			{\n				ucount=0;\n			binary = 0;\n			}\n			//FREE(t);\n		}\n		else if ((c == \'+\' || c == \'-\' || c == \'/\' || c == \'*\') && p!=1 )\n		{\n		 	char *t;\n			MALLOC (t, sizeof(1));\n			*t = c;\n			if((j!=0 && i==0) || (j!=0 && !empty(st_obr) && pr(t)<=pr((char*)(top(st_obr))) && i==1))\n			{\n				while (!empty(st_obr) && pr(t)<=pr((char*)(top(st_obr))))\n				{\n					s = (char*)top(st_obr);\n					//a = MALLOC (sizeof(int));\n					a = (int*)top(st_num);\n					pop(&st_num);\n					//d = MALLOC(sizeof(int));\n					d = (int*)top (st_num);\n					pop(&st_num);\n					switch (*s)\n					{\n						case \'+\': (*a) = (*d)+(*a);break;\n						case \'-\': (*a) = (*d)-(*a);break;\n						case \'*\': (*a) = (*d)*(*a);break;\n						case \'/\': (*a) = (*d)/(*a);break;\n					}\n					push(&st_num,a);\n					free(d);\n					FREE(top(st_obr)); \n					pop(&st_obr);\n\n					if(empty(st_obr))\n					{\n						break;\n					}\n				}\n			//	FREE(a);\n			//	FREE(d);\n				push (&st_obr,(void*)(t));\n			//	FREE(t);\n				i=0;\n				unary=0;\n				binary=0;\n			}\n			else\n			{\n				push(&st_obr,(void*)(t));\n				i=0;\n			}\n		//?	FREE(t);\n		}\n			if((c == \')\' || c == \'\\n\') && j==1 && (top(st_obr) != NULL))\n			{\n				wcount = 0;\n				while ((*(char*)top(st_obr) != \'(\') || ((char*)top(st_obr) != NULL))\n				{\n					s = (char*)top(st_obr);\n					pop(&st_obr);\n					//a = MALLOC(sizeof(int));\n					a  = (int*)top(st_num);\n				//?	FREE(top(st_num));\n					pop(&st_num);\n					//d = MALLOC(sizeof(int));\n					d = (int*)top(st_num);\n				//?	FREE(top(st_num));\n					pop(&st_num);\n					switch (*s)\n					{\n						case \'+\': (*a) = (*d)+(*a);break;\n						case \'-\': (*a) = (*d)-(*a);break;\n						case \'*\': (*a) = (*d)*(*a);break;\n						case \'/\': (*a) = (*d)/(*a);break;\n					}\n					free(s);\n					free(d);\n					push(&st_num,a);\n					if(top(st_obr) == NULL)\n					{\n						if(c == \'\\n\')\n						{\n							result = *a;\n							break;\n							//printf(\"otvet : %d\\n\",/*(int*)top(st_num)*/*a);\n						}\n						break;\n					}\n					if(*(char*)top(st_obr) == \'(\')\n					{\n						FREE(top(st_obr)); \n						pop(&st_obr);\n						if(c == \'\\n\')				//////////////\n						{\n							result = *a;\n							break;\n							//printf(\"otvet : %d\\n\",/*(int*)top(st_num)*/*a);\n						}\n						break;\n					}\n				//	FREE(a);\n				//	FREE(d);\n				}\n			//	FREE(d);\n				binary=1;\n				i=0;\n			} \n			if(c == \'\\n\')							///////////////\n			{\n				if(!a)\n				{\n					break;\n				}\n				result = *a;\n				break;\n			}\n//					printf(\"otevet : %d\\n\",*a);\n	}\n	makenull(&st_num);\n	makenull(&st_obr);\n\n	return result;\n	\n}\n\nint main ()\n{\n	int result;\n	int c;\n\n	while ((c = getchar()) != EOF)\n	{\n		char *word = NULL;\n	 	if (c == \'_\' || (c >= \'a\' && c <= \'z\'))\n		{\n			ungetc(c, stdin);\n			word = readword(stdin);\n			c = getchar();\n		}\n		if (word && c == \'=\')\n		{\n			result = eval(NULL);\n			set_value(word, result);\n		}\n		else\n		{\n			ungetc(c, stdin);\n			result = eval(&word);\n			printf(\"%d\\n\", result);\n		}\n		if (word)\n		{\n			FREE(word);\n			word = NULL;\n		}\n	}\n\n	cleanup();\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (783,'#include \"memory.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\n\nstruct item {\n	void * data;\n	struct item *next;\n};\nvoid push (stack *st, void *data)\n{\n	stack p;\n	MALLOC(p, sizeof(*p));\n	if(p)\n	{\n		p->data = data;\n		p->next = *st;\n		*st = p;\n	}\n}\nvoid pop (stack *st)\n{\n	stack p = *st;\n	*st = (*st)->next;\n//	FREE(p->data);\n	FREE(p);\n}\nvoid *top(stack st)\n{\n	if(st == NULL)\n		return NULL;\n	return (st->data);\n}\nint empty (stack st)\n{\n	return (st == NULL);\n}\nstack createStack ()\n{\n	stack st = NULL;\n//	MALLOC(st, sizeof(*st));\n//	st->data = NULL;\n//	st->next = NULL;\n	return st;\n}\nvoid makenull(stack *st)\n{\n	stack p = NULL;\n	while (!empty(*st))\n	{	\n		p = *st;\n		FREE((*st)->data);\n		(*st)=(*st)->next;\n		FREE(p);\n	}\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (784,'#include \"memory.h\"\n#include <stdio.h>\n\nstruct a\n{\n	int b;\n	int c;\n	char s;\n}\n\nint main()\n{\n	struct a b, c;\n	b.b = 10;\n	b.c = 15;\n	b.s = \'g\';\n	c = b;\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (785,'#include \"memory.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"stack.h\"\nint main ()\n{\n	int i,a=19;\n	int *p;\n	stack S = createStack();\n	for (i=1;i<5;i++)\n	{\n		if (!empty(S))\n		{\n			printf (\"1\\n\");\n		}\n		else\n		{\n			printf (\"2\\n\");\n		}\n		printf (\"3\\n\");\n		p = malloc(sizeof(int));\n		*p = i;\n		push(&S,p);\n		printf (\"4\\n\");\n		p = top(S);\n		printf (\"5\\n\");\n		printf (\"a = %d\\n\", *p);\n		FREE(p);\n	//	pop(&S);\n	}\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (786,'#include \"memory.h\"\n#include \"long.h\"\n#include <stdio.h>\n//#include <stdlib.h>\nint main ()\n{\n	int c;\n	struct long_int s;\n	struct long_int k;\n	s.digits = NULL;\n	s.length = 0;\n	s.sign = 0;\n	k.digits = NULL;\n	k.length = 0;\n	k.sign = 0;\n	//struct long_int k;\n\n\n	while((c=getchar())!=EOF )\n	{\n		ungetc(c,stdin);\n	//	while(c >= \'0\' && c <= \'9\')\n	//	{\n		//	s.digits = (int*)malloc(sizeof(int));\n			s = read_long_num(s);\n//			k.digits = (int*)malloc(sizeof(int));\n			k = read_long_num(k);\n	//	}\n		//	s = LongMul(s,k);\n			s = LongDiv(s,k); \n		//	s = LongAdd(s,k);\n		//	s = LongSub(s,k);\n		//	reverse(s,0,s.length-1);\n	}\n	print (s);\n	return 0;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (787,'#include \"memory.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"vars.h\"\nunsigned int hash_k(char *s)\n{\n	unsigned int res = 0;\n//	return res;\n	for( ; *s;s++)\n	{\n		res = res*37+*s;\n	}\n	return (res % 100);\n}\nstruct dsi\n{\n	char *v;\n	int dt;\n	struct dsi *nt;\n};\ntypedef struct dsi hash;\n//struct item *A[100];\nhash *A[100];\nvoid set_value(char *name, int value)\n{\n	int Hk = 0;\n	int l = (int)strlen(name);\n//	struct item *p = NULL;\n	hash *p = NULL;\n	Hk = hash_k(name);\n	p = A[Hk];\n	MALLOC(p, sizeof(*p));\n	MALLOC(p->v, sizeof(l+1));\n	strcpy(p->v,name);\n	p->dt = value;\n	p->nt=A[Hk];\n	A[Hk]=p;\n}\nint get_value(char *name)\n{\n	int Hk = 0;\n//	struct item *p = NULL;\n	hash *p = NULL;\n	Hk = hash_k(name);\n	for(p=A[Hk];p;p=p->nt)\n	{\n		if ((strcmp(p->v,name)) == 0)\n		{\n			return (p->dt);\n		}\n	}\n	return 0;\n}\nvoid cleanup(void)\n{\n	//struct item *p = NULL;\n	hash *p = NULL;\n	int i = 0;\n	for (i = 0;i<100;i++)\n	{\n		while (p=A[i])\n		{\n			FREE (A[i]->v);\n			A[i] = A[i] -> nt;\n			FREE (p);\n		}\n	}\n}\nchar *readword(FILE *f)\n{\n	int i = 0;\n	//char c = 0;\n	int c;\n	char *p = NULL, *tmp = NULL;\n	size_t allocated = 0, used = 0;\n	while ((c = fgetc(f)) != \'+\' || c != \'-\' || c != \'*\' || c != \'/\' || c != \' \' || c != EOF || c != \'(\' || c != \')\' || c != \'\\n\')\n	{\n		if( (c >= \'a\' && c <= \'z\') || (c >= \'0\' && c <= \'9\') || c == \'_\')\n		{\n			if (allocated == used)\n			{\n				char *tmp = realloc(p,allocated += (size_t)5);\n				if(!tmp) \n					break;\n				p=tmp;\n			}\n			p[used++] = c;\n		}\n		else\n		{\n			break;\n		}\n	}\n	p[used++] = 0;\n	ungetc(c,f);\n	return p;\n}\nint readnum(FILE *f)\n{\n	int i = 0;\n	char c =0;\n	while ((c = fgetc(f)) >= \'0\' && c <=\'9\')\n	{\n				i = 10*i + c -\'0\';\n	}\n	ungetc(c,f);\n	return i;\n}\n','Ð Ð¾Ð¼Ð°Ð½','Roman','m');
INSERT INTO `bias` VALUES (788,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nvoid read_name(char *cc)\n{\n	printf(\"   < ???: \");\n	char q;\n	int i=0, j, k, f1, f2;\n	while ( cc[i]!=\':\' )\n		i++;\n	j=i+3;\n	while ( cc[j]!=\':\' )\n		j++;\n	k=j+2;\n	while ( cc[k]!=\':\' )\n		k++;\n	f1=k+2;\n	f2=f1;\n	while ( cc[f2]!=\',\' )\n		f2++;\n	for(i=f1-1; i<f2; i++)\n	{\n		q=cc[i];\n		printf(\"%c\", q);\n	}\n	printf(\" >\\n\");\n}\n\nint if_login(char *a, char *aa, int q)\n{\n	int i;\n	for (i=0; i<=q; i++)\n		if (a[i]!=aa[i])\n			return 0;\n	if (aa[q+1]==\':\')\n		return 1;\n	else return 0;\n}\n\nint main()\n{\n	FILE *f;\n	f=fopen(\"/etc/passwd\", \"r\");\n	if (!f) { printf(\"?? ???????? /etc/passwd.txt\\n\"); return 0; }\n	int w=1, i, l=0;\n	char z;\n	char login[10];\n	char 	  s[200];\n	char work_s[200];\n	printf(\"   < ??????? ????? ???????????? >\\n\");\n	for (i=0; i<=9; i++)\n	{\n		scanf(\"%c\", &z);\n		if (z!=\'\\n\') \n		{\n			login[i]=z;\n			l++;\n		}\n	}\n	l--;\n	while ( fgets(s, 200, f) )\n	{\n		strcpy(work_s,s);\n		if (if_login(login,work_s,l)==1)\n		{\n			printf(\"   < ???????????? ??????. ????? ??????: %d >\\n\", w);\n			read_name(work_s);\n			return 0;\n		}\n		else w++;\n	}\n	printf(\"   < ???????????? ?? ??????... >\\n\");\n	fclose(f);\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (789,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item \n{\n	int data;\n	struct item *next;\n};\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *q=NULL;\nstruct item *prev=NULL;\n\n\nint main ()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n		if (f==NULL)\n		{\n			printf (\"eror file not open\\n\");\n			return 1;\n		}\n	int a;\n	if (fscanf(f,\"%d\",&a)==1)\n	{\n	head=malloc(sizeof(struct item));\n	head->data=a;\n	head->next=NULL;	\n	}\n\n	while (fscanf(f,\"%d\",&a)==1)\n	{\n		p=malloc(sizeof (struct item));\n\n		if (a> head->data)\n		{\n			q=head;\n			prev=NULL;\n		\n			while (q && a> q->data)\n			{\n				prev=q;\n				q=q->next;\n			}\n		\n		\n		\n			if (prev->next!=NULL)\n			{\n					p->next=prev->next;\n				\n			}\n			if (prev->next=NULL)\n			{\n				p->next=NULL;\n			}\n			prev->next=p;\n			p->data=a;\n		}\n		\n		else \n		{\n			p->data=a;\n			p->next=head;\n			head=p;\n		}\n\n	}\n\n	q=head;\n	while (q!=NULL)\n	{\n		printf(\"%d_\",q->data);\n		q=q->next;\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (790,'#include <stdio.h>\n#define N 1000010\n\nvoid  piramida (int *A,int n,int i)\n{\n	int b=2*i+1;\n	int c=2*i+2;\n	int k;\n	int max=i;\n\n	if (b<n && A[b]>A[max])\n	{\n		max=b;\n	}\n	if (c<n && A[c]>A[max])\n	{\n		max=c;\n	}\n	if (max!=i)\n	{\n		k=A[i];\n		A[i]=A[max];\n		A[max]=k;\n		piramida(A,n,max);\n	}\n}\nint main ()\n{\n	int i,j,k,o;\n	int p;\n	int A[N];\n\n	FILE *f=fopen(\"input.txt\",\"r\");\n\n	if (!f)\n	{\n		printf (\"file was not open\");\n	}\n	\n	fscanf (f,\"%d\",&p);\n	for (i=0;i<p;i++)\n	{\n		fscanf (f,\"%d\",&A[i]);\n	}\n	\n	for (i=p/2;i>=0;i--)\n	{\n		piramida (A,p,i);\n	}\n	\n\no=p;\nj=0;\n\nwhile (o>1)\n	{\n		j=A[o-1];\n		A[o-1]=A[0];\n		A[0]=j;\n		o--;\n		piramida (A,o,0);\n	}\n	i=0;\n		while (i<p)\n		{\n		\n			printf (\"%d \",A[i]);\n			i++;\n		}\n//	printf (\"infinity\");\n		printf(\"\\n\");\n\n\n\n	fclose(f);\n	return 0;\n		\n\n		\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (791,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item \n{\n	int data;\n	struct item *next;\n};\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *q=NULL;\nstruct item *prev=NULL;\n\n\nint main ()\n{\n	FILE *f=fopen(\"input.txt\",\"r\");\n		if (f==NULL)\n		{\n			printf (\"eror file not open\\n\");\n			return 1;\n		}\n	int a;\n	if (fscanf(f,\"%d\",&a)==1)\n	{\n	head=malloc(sizeof(struct item));\n	head->data=a;\n	head->next=NULL;	\n	}\n\n	while (fscanf(f,\"%d\",&a)==1)\n	{\n		p=malloc(sizeof (struct item));\n\n		if (a> head->data)\n		{\n			q=head;\n			prev=NULL;\n		\n			while (q && a> q->data)\n			{\n				prev=q;\n				q=q->next;\n			}\n		\n		\n		\n			if (prev->next!=NULL)\n			{\n					p->next=prev->next;\n				\n			}\n			if (prev->next=NULL)\n			{\n				p->next=NULL;\n			}\n			prev->next=p;\n			p->data=a;\n		}\n		\n		else \n		{\n			p->data=a;\n			p->next=head;\n			head=p;\n		}\n\n	}\n\n	q=head;\n	while (q!=NULL)\n	{\n		printf(\"%d_\",q->data);\n		q=q->next;\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (792,'#include <stdio.h>\n#define N 1000010\n\nvoid  piramida (int *A,int n,int i)\n{\n	int b=2*i+1;\n	int c=2*i+2;\n	int k;\n	int max=i;\n\n	if (b<n && A[b]>A[max])\n	{\n		max=b;\n	}\n	if (c<n && A[c]>A[max])\n	{\n		max=c;\n	}\n	if (max!=i)\n	{\n		k=A[i];\n		A[i]=A[max];\n		A[max]=k;\n		piramida(A,n,max);\n	}\n}\nint main ()\n{\n	int i,j,k,o;\n	int p;\n	int A[N];\n\n	FILE *f=fopen(\"input.txt\",\"r\");\n\n	if (!f)\n	{\n		printf (\"file was not open\");\n	}\n	\n	fscanf (f,\"%d\",&p);\n	for (i=0;i<p;i++)\n	{\n		fscanf (f,\"%d\",&A[i]);\n	}\n	\n	for (i=p/2;i>=0;i--)\n	{\n		piramida (A,p,i);\n	}\n	\n\no=p;\nj=0;\n\nwhile (o>1)\n	{\n		j=A[o-1];\n		A[o-1]=A[0];\n		A[0]=j;\n		o--;\n		piramida (A,o,0);\n	}\n	i=0;\n		while (i<p)\n		{\n		\n			printf (\"%d \",A[i]);\n			i++;\n		}\n//	printf (\"infinity\");\n		printf(\"\\n\");\n\n\n\n	fclose(f);\n	return 0;\n		\n\n		\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (793,'#include <stdio.h>\n#include <string.h>\n\nint step(int osn,int pok)\n{\n	int w=0, z=1;\n	if (pok==0)\n	return 1;\n	else\n		{\n			for (w=0;w<pok;w++)\n			z=osn*z;\n			return z;\n		}\n}\n\nint main()\n\n{\n	int b, x, k, c=0, i, y, stepen, B[100]; \n	char A[100];\n\n		/*printf(\"??????? ????? b - ????????? ??????? ?????????? (1<b<=16) \\n\");\n		scanf(\"%d\", &b);*/\n\n		printf(\"??????? ????? ?, ??????? ?? ??????? ????????? ? ?????????? ??????? ??????????\\n\");\n		fgets(A,100,stdin);		\n		printf(\"??????? ????? b - ????????? ??????? ?????????? (1<b<=16), ?? ??????? ?? ??????????? ?????????? ???????\\n\");\n		scanf (\"%d\", &b);	\n	x=strlen(A) - 1; /* ????? ??? ?????????? ???????? (??????) */\n\n	for (i=0; i<100; i++) /* ?????????? ????? */\n	{\n		if (\'a\'<=A[i] && A[i]<= \'f\')\n			B[i] = A[i] - \'a\' + 10;\n		if (\'0\'<=A[i] && A[i]<= \'9\')\n			B[i] = A[i] - \'0\';\n	} \n\nstepen=0;\n	\n	for (y=x-1; y>-1; y--) \n	{c=B[y]*step(b,stepen)+c;\n	stepen++;\n	}\nprintf(\"?????: %d\\n\", c);\nreturn 0;\n}\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (794,'#include <string.h>\n#include <stdio.h>\n#include <ctype.h> /* ?????????? ???? ? ????????? */\n\nint main()\n\n{	\n	int i,j,k,l,m;\n	char A[1000];\n	char B[1000];\n	printf(\"??????? ?????: \\n\");\n	fgets(A, 1000, stdin);\n\nFILE *file = fopen(\"/etc/passwd\", \"r\");\n	if (!file)\n	{\n		perror(\"fopen\"); /* ??????????? ????????? ?? ?????? */\n	}\n\n	i=strlen(A);\n	i--;\n\n	while (j!=1)\n	{\n		if (!fgets(B, 1000, file))\n			{	\n				m=1;\n				printf(\"????????? ????? ?? ?????????? \\n\");\n				break;\n			}\n		l=0;\n		\n		for (k=0; k <= i; k++)\n			{\n				if (A[k]==B[k])\n				l++;\n			}\n		if (l == i && B[l] == \':\')\n			j=1;\n	}\n		\n		if (m!=1)\n 			{\n				k=0;\n				l=0;\n				while(k!=4)\n					{\n						if (B[l] == \':\')\n							k++;\n						l++;\n					}\n\n				while (B[l]!=\',\')\n					{\n						printf(\"%c\", B[l]);\n						l++;\n					}\n					printf(\"\\n\");\n			}\n\nreturn 0;\n}\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (795,'#include<stdio.h>\n\nvoid QuickSort(int *A, int a, int b)\n\n{\n\nint i,j,k,l,m;\n\n	m=(a+b)/2;\n	k=A[m];\n	i=a;\n	j=b;\n	while(i<=j)\n		{\n			//printf(\"??????? j=%d i=%d \\n \", j, i);\n			while(A[i] < k)\n				{	//printf(\"A[i]=%d k=%d \\n\", A[i], k);\n					i++;\n				}\n			while(A[j] > k)\n				{	//printf(\"A[j]=%d k=%d \\n\", A[j], k);\n					j--;\n				}\n			if(i <= j)\n				{\n					l=A[i];\n					A[i]=A[j];\n					A[j]=l;\n					i++;\n					j--;\n				}\n\n		}\n	if (i<b)\n		QuickSort(A, i, b);\n	if (j>a)\n		QuickSort(A, a, j); \n\n}\n\nint main()\n\n{\n	int x, y, z;\n	int B[100000];\n\n	FILE *f =fopen(\"input12.txt\", \"r\");\n	if (!f)\n		{\n			perror(\"fopen\"); /*??????????? ????????? ?? ??????*/ \n		} \n	fscanf(f, \"%d\", &z); \n/*	while (1 == fscanf(f, \"%d\", &c))\n		{ B[x] = c;\n		 printf(\"B[x]= %d\", B[x]);\n		 x++;} */\n	for(x = 0; x < z; x++) \n	{\n		fscanf(f,\"%d\", &B[x]);\n		//printf(\"%d \\n\", B[x]);\n	}\n\n	fclose(f);\n	QuickSort(B, 0, z-1);\n\n	for(y = 0; y < z; y++)\n		printf(\"%d \", B[y]);\n		\n	printf(\"\\n\");\n\nreturn 0;\n\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (796,'#include<stdio.h>\n\nvoid sift (int *A, int a, int i)\n\n{\n	int b;\n	int max=0;\n	\n	max=i;\n\n	if (((2*i+1)<a)&&(A[2*i+1]>A[i]))\n		max=2*i+1;\n	if (((2*i+2)<a)&&(A[2*i+2]>A[max])) \n		max=2*i+2;\n	if (i!=max)\n	 	{\n			b=A[i];\n			A[i]=A[max];\n			A[max]=b;\n			sift(A,a,max);\n		}\n}\n\nint main()\n\n{\n	int H,i,j,k,l;\n	int A[100000];\n	\n	FILE *f=fopen(\"input13.txt\", \"r\");\n	fscanf(f, \"%d\", &H);\n	for (i=0; i<H; i++)\n		{\n			fscanf(f, \"%d\", &A[i]);\n		}\n\n	fclose(f);\n\n	for (j = H/2; j >= 0; j--)\n		{\n			sift(A, H, j);\n		}\n		\n	for (i = H-1; i > 0; i--)\n	 	{\n			k=A[i];\n			A[i]=A[0];\n			A[0]=k;\n			sift (A, i, 0);\n		}\n\nfor (l = 0; l < H; l++)\nprintf(\"%d \", A[l]);\n\nprintf(\"\\n\");\n\nreturn 0;\n}\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (797,'#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n\n{\n	struct item\n{\n	int data;\n	struct item *next;\n};\n\nstruct item *head=NULL;\nstruct item *x=NULL;\nstruct item *y=NULL;\nstruct item *z=NULL;\n\n	int a;\n	FILE *f = fopen(\"input14.txt\", \"r\");\n	if (!f)\n		{\n			perror(\"fopen\"); /*??????????? ????????? ?? ??????*/\n		}\n\n	fscanf(f, \"%d\", &a);\n\n	head=malloc(sizeof (struct item));\n	head->data=a;\n	head->next=NULL;\n\n	while(fscanf(f,\"%d\",&a)==1)\n		{\n			if(a>head->data)\n				{\n					z=head;\n					y=NULL;\n					while (z && a>z->data)\n						{\n							y = z;\n							z=z->next;\n						}\n\n					x=malloc(sizeof(struct item));\n					if (y->next)\n						x->next=y->next;\n					else\n						x->next=NULL;\n\n					y->next=x;\n\n					x->data=a;\n				}\n			if(a<=head->data)\n				{\n					x=malloc(sizeof(struct item));\n					x->data=a;\n					x->next=head;\n					head=x;\n				}\n		}\n		\n	x=head;\n	while(x)\n		{\n			printf(\"%d\",x->data);\n			printf(\"\\n\");\n			x=x->next;\n		}\n\nreturn 0;\n\n}\n\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (798,'#include <stdio.h>\n#define N 100\n\nint visited[N]={0};\nint A[N][N];\n\nvoid dfs(int curr, int A[N][N], int a) /* ????? ? ??????? ??? ??????? */\n\n{\n	printf(\"%d\\n\", curr);\n	visited[curr]=1;\n	int i;\n		for (i=1; i<=a; i++)\n			if (!visited[i]&&A[curr][i]==1)\n			{\n				dfs(i, A, a);\n			}\n}\n\nint main()\n\n{\n\n	FILE *f=fopen(\"input19.txt\", \"r\");\n	if (!f)\n		{\n			perror(\"fopen\"); /* ??????????? ????????? ?? ?????? */\n		}\n	int i,j;\n	int k;\n	int l,m;\n\n		fscanf(f, \"%d\", &k);\n		while(fscanf(f, \"%d%d\", &l, &m) == 2)\n			{\n				A[l][m]=1;\n				A[m][l]=1;\n			}\n\n		for (i = 1; i <= k; i++)\n			{\n				for (j = 1; j <= k; j++)\n					{\n						printf(\"%d\", A[i][j]);\n					}\n			printf(\"\\n\");\n			}\ndfs(1, A, k);\nfclose(f);\nreturn 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (799,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{	FILE *f = fopen(\"/etc/passwd\", \"r\");\n	if (!f){ perror(\"fopen\");}\n	int i,j,a;\n	char s[200];\n	char s1[200];\n	char name[200];\n	scanf(\"%s\", &name[0]);\n\n	while (fgets(s, 200, f))\n	{\n//	printf(\"????????? ??????: %s\", s) ;\n	strcpy(s1,s);\n	for(i=0;i!=strlen(s1);i++)\n		{a=i;\n				if (s1[i]==\':\'){\n			 s1[i]=0; break;}\n			 }\n//			 printf(\"%d\\n          \", (strcmp(name,s1)));\n//			 printf(\"a = %d\\n\", a);\n		if (strcmp(name,s1)==0){\n			for(i=a+13;i!=a+40;i++)	\n			{if (s[i]==\',\') {name[i]=0;break;}\n			name[i-a-13]=s[i];\n			}\n			printf(\"%s\\n\",&name[0]);\n			j=666;}}\n			if (j!=666) printf (\"?????? ???????????????\\n\");\n\n	\n\n	fclose(f);\n\n	return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (800,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{	FILE *f1=fopen(\"inputsortir.txt\",\"r\");\n	if (!f1) {perror (\"fopen\");}\n	FILE *f2=fopen(\"outputsortir.txt\",\"w\");\n	if (!f2) {perror (\"fopen\");}\n	int i,ii;\n	int b;\n	int j=0;\n	int x=0;\n	int a[100000]; \n//	char s[1000000];\n//	printf(\"...\\n\");\n	fscanf(f1,\"%d\" ,&b);\n//	printf(\"...\\n\");\n	printf(\"%d \",b);\n		for(i=0;i!=b;i++)\n	fscanf(f1,\"%d\" ,&a[i]);\n\n	for(ii=0;ii!=b-1;ii++)\n{		for(i=x;i!=b;i++)\n		{if(a[i]>=j)\n			 { j=a[i];a[i]=a[x];a[x]=j;} };\n	x++;j=0;	}\n	for(i=0;i!=b;i++)\n		fprintf(f2,\"%d \" ,a[i]);\n	printf(\"%d \",x);\n		\n\n\n\n\n\n\n	\n	fclose(f1);\n	fclose(f2);\n	return 0;}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (801,'#include <stdio.h>\n#include <string.h>\n\nvoid quicksort(int *a, int l, int r)\n{	int x=a[(l+r)/2];\n	int i=l;\n	int j=r;\n	int b;\n	while(i<=j)	 \n{		while (a[i]<x) i++;\n		while (a[j]>x) j--;\n		if (i<=j) {b=a[i]; a[i]=a[j]; a[j]=b; i++;j--;}\n}	if (i<r) quicksort(a,i,r);\n	if(j>l) quicksort (a,l,j);}\n\nint main()\n{       FILE *f1=fopen(\"inputsortir.txt\",\"r\");\n        if (!f1) {perror (\"fopen\");}\n        FILE *f2=fopen(\"outputsortir.txt\",\"w\");\n        if (!f2) {perror (\"fopen\");}\n        int i;\n        int b;\n//        int j=0;\n//        int x=0;\n        int a[100000];\n	fscanf(f1,\"%d\" ,&b);\n	for(i=0;i!=b;i++)\n	fscanf(f1,\"%d\" ,&a[i]);\n	quicksort(a,0,b-1);\n\n\n\n\n\n\n\n\n	for(i=0;i!=b;i++)\n	    fprintf(f2,\"%d \" ,a[i]);\n	\n	fclose(f1);\n	fclose(f2);\n	return 0;}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (802,'#include <stdio.h>\n#include <stdlib.h>\nint main ()\n{\n	struct item\n	{\n		int data;\n		struct item *next;\n	};\n	struct item *head=NULL;\n	struct item *p=NULL;\n	struct item *q=NULL;\n	struct item *prev=NULL;\n	FILE *f=fopen(\"inputlist.txt\",\"r\");\n        if (!f) perror(\"fopen\");\n	int a;\n	if (fscanf(f,\"%d\",&a)==1)\n{\n	head=malloc(sizeof(struct item));\n	head->data=a;\n	head->next=NULL;\n}\n\n	while (fscanf(f,\"%d\",&a)==1)\n{\n     //   p=malloc(sizeof (struct item));\n        if (a> head->data)\n{\n        q=head;\n        prev=NULL;\n        while (q && a> q->data)\n{\n        prev=q;\n        q=q->next;\n}\n        p=malloc(sizeof(struct item));\n        if (prev->next)\n        p->next=prev->next;\n        else\n        p->next=NULL;\n        prev->next=p;\n	p->data=a;\n}\n      if(a<=head->data)\n{	p=malloc(sizeof (struct item));\n	p->data=a;\n	p->next=head;\n	head=p;}\n}\n       p=head;\n\n       while (p)\n{\n       printf(\"%d \",p->data);\n       p=p->next;}\n       return 0;\n}\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (803,'#include <stdio.h>\n\nint visited[100]={0};\nint a[100][100];\nvoid dfs(int curr, int a[100][100], int x)\n{	printf(\"???????? ??????? %d\\n\",curr);\n	visited[curr]=1;\n	int i;\n	for (i=1; i<=x; i++)\n		if((!visited[i]) && (a[curr][i]==1)) dfs(i,a,x);\n}int main(){\n	int m,n,x;\n	int i,j;\n	FILE *f=fopen(\"input.txt\",\"r\");\n	if(!f) perror(\"fopen\");\n	fscanf(f,\"%d\",&x);\n	while(fscanf(f,\"%d%d\",&m,&n)==2) {a[m][n]=1;a[n][m]=1;}\n	for(i=1;i<=x;i++){\n		{for(j=1;j<=x;j++)\n			printf(\"%d \",a[i][j]);\n		 printf(\"\\n\");}}\n	dfs(1,a,x);\n	fclose(f);\n	return 0;}\n\n	\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (804,'#include<stdio.h>\n#include<string.h>\n#include<ctype.h>\n\n\n\nint main()\n{\n	int i,f,s,l,z;\n	char M[1000], L[1000];\n	printf(\"???????? ?????\\n\");\n	fgets(M,1000,stdin);\n	i=strlen(M);\n	i--;\n\n	FILE *file=fopen(\"/etc/passwd\",\"r\");\n\n\n	while(f!=1)\n	{\n		if(!fgets(L,1000, file))\n		{\n			z=1;\n			printf(\"????? ?? ??????\\n\");\n			break;\n		}\n		l=0;\n		for(s=0;s<=i;s++)\n		{\n			if(M[s]==L[s])\n			l++;\n		}\n		if(l == i && L[l] == \':\')\n			f=1;\n	}\n	if(z!=1)\n	{\n		s=0;\n		l=0;\n		while(s!=4)\n		{\n			if(L[l] == \':\')\n				s++;\n			l++;\n		}\n		\n		while(L[l]!=\',\')\n		{\n			printf(\"%c\",L[l]);\n			l++;\n		}\n		printf(\"\\n\");\n	}\n\n\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (805,'#include<stdio.h>\n#include<stdlib.h>\n\nint main()\n{\nstruct item\n{\n	int data;\n	struct item *next;\n\n};\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *pr=NULL;\nstruct item *q=NULL;\n\n	int a;\n	FILE *f = fopen(\"inp.txt\", \"r\");\n\n	fscanf(f,\"%d\",&a);\n\n\n	head=malloc(sizeof(struct item));\n	head->data=a;\n	head->next=NULL;\n\n	while(fscanf(f,\"%d\",&a)==1)\n	{\n		if(a>head->data)\n		{\n			q=head;\n			pr=NULL;\n			while(q && a>q->data)\n			{\n				pr = q;\n				q=q->next;\n			}\n				\n			p=malloc(sizeof(struct item));\n\n			if(pr->next)\n				p->next=pr->next;\n			else\n				p->next=NULL;\n\n			pr->next=p;\n\n			p->data=a;\n		}\n		if(a<=head->data)\n		{\n			p=malloc(sizeof(struct item));\n			p->data=a;\n			p->next=head;\n			head=p;\n		}\n	}\n	p=head;\n	while(p)\n	{\n		printf(\"%d\",p->data);\n		printf(\"\\n\");\n		p=p->next;\n	}\n	\n\n\n\n\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (806,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nint main()\n{\n	int i;\n	char A[10];\n\n	struct item\n	{\n		char *word;\n		int count;\n		struct item *next;\n	};\n\n	struct item *head=NULL;\n	struct item *p=NULL;\n	struct item *q=NULL;\n\n	FILE *f=fopen(\"inp2.txt\",\"r\");\n\n	fscanf(f,\"%s\",A);\n	head=malloc(sizeof(struct item));\n	head->word=malloc(strlen(A)+1);\n	strcpy(head->word,A);\n	head->count=1;\n	head->next=NULL;\n\n\n	while(fscanf(f,\"%s\",A)==1)\n	{\n		for(p=head;p;p=p->next)\n		{\n			if(strcmp(p->word,A)==0)\n			{\n				p->count++;\n				break;\n			}\n		}\n	if(!p)\n	{\n		q=malloc(sizeof(struct item));\n		q->next=head;\n		q->word=malloc(strlen(A)+1);\n		strcpy(q->word,A);\n		q->count=1;\n		head=q;\n	}\n	}\n	for(p=head;p;p=p->next)\n	{\n		printf(\"%s  %d\",p->word,p->count);\n		printf(\"\\n\");\n	}\n\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (807,'#include<stdio.h>\nvoid dfs(int curr, int A[100][100], int visited[], int n)\n{\n	visited[curr]=1;\n 	int i;	\n	for(i=1; i<=n; i++)\n		if(!visited[i] && A[curr][i]==1)\n		{\n			dfs(i,A,visited,n);\n		}\n		printf(\"????????? %d\\n\",curr);\n}\nint main()\n{\n	FILE *f = fopen(\"inp3.txt\",\"r\");\n	int visited[100]={0},i,j,k,A[100][100]={ {0} };\n\n	fscanf(f,\"%d\",&k);\n	printf(\"%d\\n\",k);\n\n	for(i=1;i<=k;i=i+1)\n	{\n		for(j=1;j<=k;j=j+1)\n		{\n			fscanf(f,\"%d\",&A[i][j]);\n			printf(\"%d\",A[i][j]);\n		}\n		printf(\"\\n\");\n	}\n	dfs(1,A,visited,k);\n\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (808,'#include <stdio.h>\n\nint main()\n{\n	int i, n, f0, f2=-1, f1=1;\n	printf(\"??????? N\\n\");\n	scanf(\"%d\", &n);\n		for (i=1; i<=n; i++)\n		{\n		f0=f1+f2;\n		f2=f1;\n		f1=f0;\n		printf(\"%d \",f0);	\n		}\n	getchar();\n	getchar();\n}\n\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (809,'#include <stdio.h>\n\nint main()\n{\n	int i, x, y, a;\n	printf(\"??????? x\\n\");\n	scanf(\"%d\", &x);\n	printf(\"??????? y\\n\");\n	scanf(\"%d\", &y);\n\n		for (i=1; i; i++)\n		{\n			a=x%y;\n			if (a==0)\n				break;\n			x=y;\n			y=a;	\n		};\n	printf(\"???=%d\", y);\n\n	getchar();\n	getchar();	\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (810,'#include <math.h>\n#include <stdio.h>\n\nfloat f(float x)\n{\n	return (x*x-2);	\n}\n\nint main()\n{\n	int i;\n	float a=0;\n	float b=2;\n	float n;\n	float e=0.001;\n	\nif (f(a)*f(b)>0)\n	printf(\"No roots\");\nelse\n	while (b-a>e)\n	{\n		n=(a+b)/2;\n		if (f(a)*f(n)<0)\n		b=n;\n		else a=n;\n	}\n	printf(\"%f\",n);\n	return 0;	\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (811,'#include <stdio.h>\n#include <math.h>\n\nint vis (int n)\n{\n	if (n%400==0)\n		return 1;\n	if (n%100==0)\n		return 0;\n	if (n%4==0)\n		return 1;\n	return 0;	\n}\nint mon (int n, int k)\n{\n	if (n==0)\n		return 0+k;\n	if (n==1)\n		return 31+k;\n	if (n<=7)\n		return (n*31-((n/2)+2)+k);\n	else\n		return (n*31-(((n-1)/2)+2)+k);\n	\n};\nint main()\n{\n	int y1, m1, d1, y2, m2, d2, i, d, a, c=0, g;\n	printf(\"?????? ????:\");\n	scanf(\"%d/%d/%d\", &d1, &m1, &y1);\n	printf(\"?????? ????:\");\n	scanf(\"%d/%d/%d\", &d2, &m2, &y2);\n	\n	for (i=1; i<=(y2-y1); i++)\n	{\n		c=i*365;	\n	};\n	for (i=y1; i<y2; i++)\n	{\n		a=vis(i);\n		c=c+a;\n	};\n	if (vis(y1)==1 && m1>=3)\n		c=c-1;\n	if (vis(y2)==1 && m2<=2 && d2<29)\n		c=c-1;\n	d=mon(m1-1, d1-1);\n	g=mon(m2-1, d2);\n	c=c-d+g;\n	printf(\"%d\",c);\n\n	getchar();\n	getchar();\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (812,'#include <stdio.h>\n#include <malloc.h>\n\nint isprime (int a)\n{\n	int r=1, i=2;\n	while (i*i<=a && r==1)\n	{\n		if (a%i==0) r=0;\n		i++;	\n	}	\n	return r;\n}\nint main()\n{\n	int i=0, N, *data, r=1;\n	FILE *f;\n	printf (\"Enter the size of array:\\n\");\n	scanf (\"%d\", &N);\n	f=fopen (\"input5.txt\", \"r\");\n	data=(int*)malloc(N*sizeof(int));\n	while (i<N && r==1)\n	{\n		fscanf(f, \"%d\", &data[i]);\n		if (isprime(data[i])==0) r=0;\n		i++;\n	}\n	if (r==0) printf (\"There is noy any simple numbers\");\n	else printf (\"Here is only simple numbers\");\n	fcloseall ();\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (813,'#include <stdio.h>\n#include <malloc.h>\n\nint main ()\n{\n	int i, j, N, k;\n	float **a, **b, **c, t;\n	FILE *f;\n	printf (\"Enter the size of matrix:\\n\");\n	scanf (\"%d\", &N);\n	f=fopen (\"input6.txt\", \"r\");\n	printf (\"Matrix A: \\n\");\n	a=(float**)malloc(N*sizeof(float));\n	for (i=0; i<N; i++)\n	{\n		a[i]=(float*)malloc (N*sizeof(float));\n		for (k=0; k<N; k++)\n		{\n			fscanf (f, \"%f\", &t);\n			a[i][k]=t;\n			printf (\"%f\\t\", a[i][k]);\n		}\n		printf (\"\\n\");\n	}	\n	printf (\"Matrix B:\\n\");\n	b=(float**)malloc(N*sizeof(float));\n	for (k=0; k<N; k++)\n	{\n		b[k]=(float*)malloc (N*sizeof(float));\n		for (j=0; j<N; j++)\n		{\n			fscanf (f, \"%f\", &t);\n			b[k][j]=t;\n			printf (\"%f\\t\", b[k][j]);\n		}\n		printf (\"\\n\");\n	}\n	printf (\"Matrix C:\\n\");\n	c=(float**)malloc(N*sizeof(float));\n	for (i=0; i<N; i++)\n	{\n		c[i]=(float*)malloc(N*sizeof(float));\n		for (j=0; j<N; j++)\n		{\n			c[i][j]=0;\n			for (k=0; k<N; k++)\n			{\n				c[i][j]+=a[i][k]*b[k][j];	\n			}	\n		}	\n	}\n	for (i=0; i<N; i++)\n	{\n		for (j=0; j<N; j++)\n		{\n			printf(\"%f\\t\", c[i][j]);	\n		}	\n		printf (\"\\n\");\n	}\n	fcloseall ();\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (814,'#include <stdio.h>\n#include <malloc.h>\n\nint main ()\n{\n	int i=0, N, r, l=0, m, b=0;\n	FILE *f;\n	float *a, k;\n	printf (\"Enter the size of array:\\n\");\n	scanf (\"%d\", &N);\n	r=N-1;\n	f=fopen (\"input7.txt\", \"r\");\n	a=(float*)malloc(N*sizeof(float));\n	for (i=0; i<N; i++)\n	{\n		fscanf(f, \"%f\", &a[i]);\n	}\n	printf (\"Number: \");\n	scanf (\"%f\", &k);\n	while (l<=r && b==0)\n	{\n		m=(l+r)/2;\n		if  (k==a[m]) b=1;\n		else if (k<a[m]) r=m-1;\n		else l=m+1;\n	}	\n	if (b==0) printf (\"A \'%f\' number wasn\'t found\", k);\n	else printf (\"A \'%f\' number was found in position %d\", k, m);\n	fcloseall ();\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (815,'#include <stdio.h>\n#include <malloc.h>\n\nint main()\n{\n	int i=0, N=0, b=1;\n	unsigned char c, *str;\n	FILE *f;\n	f=fopen(\"input8.txt\", \"r\");\n	str=(char*)malloc(0);\n	printf(\"The source string is:\\n\");\n	while (fscanf(f, \"%c\", &c)!=EOF)\n	{\n		printf (\"%c\", c);\n		if ((c>=\'A\' && c<=\'Z\') || (c>=192 && c<=223)) c+=32;\n		if (c==168) c=184;\n		if ((c>=\'a\' && c<=\'z\') || (c>=224 && c<=255) || c==184)\n		{\n			N++;\n			str=(unsigned char*)realloc (str, N);\n			str[N-1]=c;	\n		}\n	}\n	while (i<N && b==1)\n	{\n		if (str[i]!=str[N-1-i]) b=0;\n		i++;	\n	}	\n	if (b==1) printf (\"\\n The source string is a palindrom\");\n	else printf (\"\\n The source string is not a palindrom\");\n	fcloseall ();\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (816,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct item \n{\n	char *world;\n	int count;\n	struct item *next;\n};\n\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *q=NULL;\nstruct item *prev=NULL;\n\nchar S[50];\nchar k;\nint d=1;\n\nvoid chtenya( FILE *f)//??????? ??? ?????? ?????\n{\n\n	int j=0;\n	\n	while (j<=50)\n	{\n\n	S[j]=0;\n	j++;\n	}\n	\n	j=0;	\n\n	while ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\')&&(d==1))\n	{\n		d=fscanf(f,\"%c\",&k);\n\n		\n	}	\n		//???????? ????? ????? ?????????? ????? ????????? ??? ?? ???? ?????? anyting\"- and he ...\n		while (((k>=\'A\' && k<=\'Z\')||(k>=\'a\'&& k<=\'z\'))&& (d==1))\n		{\n		\n			S[j]=k;\n			\n		d=fscanf(f,\"%c\",&k);\n\n			j++;\n		}\n\n\n}\n\n\nint main ()\n{\nint flag=0;\n	int i=0;\nFILE *f=fopen(\"/home/fenster/input_words.txt\",\"r\");\n	\n	if (f==NULL)\n	{\n		printf (\"file not open\\n\");\n		return 0;\n	}\n\n	while (flag!=1)\n	{\n	\n	\n	fscanf (f,\"%c\",&k);\n		\n		if ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\'))\n			flag=1;\n		else\n			S[i]=k;\n		\n			i++;\n	\n\n	}\n\n	head= malloc (sizeof(struct item));\n	head->world=malloc (strlen(S)+1);\n	strcpy(head->world,S);\n	printf(\"%s\\n\",head->world);\n	head->count=1;\n	head->next=NULL;\nflag=0;\n	while (d==1)\n	{\n\n		chtenya(f);\n	flag=0;\n	\n		for (p=head;p;p=p->next)\n		{\n			if (strcmp(p->world,S)==0)\n				{\n	\n					p->count++;\n					flag=1;\n					break;\n				}\n		}\n\n	\n			if (flag!=1 && d==1 )\n			{\n				printf(\"%s\\n\",S);\n				q=malloc(sizeof(struct item));\n				q->world=malloc (strlen(S)+1);\n				q->next=head;\n				strcpy(q->world,S);\n				printf(\"%s\\n\",q->world);\n				q->count=1;\n				head=q;\n			}\n		\n\n	}\n\nfor (p=head;p;p=p->next)\n{\n	printf (\"%s-%d\\n\",p->world,p->count);\n}\n\nfclose (f);\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (817,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct item \n{\n	char *world;\n	int count;\n	struct item *next;\n};\n\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *q=NULL;\nstruct item *prev=NULL;\n\nchar S[50];\nchar k;\nint d=1;\n\nvoid chtenya( FILE *f)//??????? ??? ?????? ?????\n{\n\n	int j=0;\n	\n	while (j<=50)\n	{\n\n	S[j]=0;\n	j++;\n	}\n	\n	j=0;	\n\n	while ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\')&&(d==1))\n	{\n		d=fscanf(f,\"%c\",&k);\n\n		\n	}	\n		//???????? ????? ????? ?????????? ????? ????????? ??? ?? ???? ?????? anyting\"- and he ...\n		while (((k>=\'A\' && k<=\'Z\')||(k>=\'a\'&& k<=\'z\'))&& (d==1))\n		{\n		\n			S[j]=k;\n			\n		d=fscanf(f,\"%c\",&k);\n\n			j++;\n		}\n\n\n}\n\n\nint main ()\n{\nint flag=0;\n	int i=0;\nFILE *f=fopen(\"/home/fenster/input_words.txt\",\"r\");\n	\n	if (f==NULL)\n	{\n		printf (\"file not open\\n\");\n		return 0;\n	}\n\n	while (flag!=1)\n	{\n	\n	\n	fscanf (f,\"%c\",&k);\n		\n		if ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\'))\n			flag=1;\n		else\n			S[i]=k;\n		\n			i++;\n	\n\n	}\n\n	head= malloc (sizeof(struct item));\n	head->world=malloc (strlen(S)+1);\n	strcpy(head->world,S);\n	printf(\"%s\\n\",head->world);\n	head->count=1;\n	head->next=NULL;\nflag=0;\n	while (d==1)\n	{\n\n		chtenya(f);\n	flag=0;\n	\n		for (p=head;p;p=p->next)\n		{\n			if (strcmp(p->world,S)==0)\n				{\n	\n					p->count++;\n					flag=1;\n					break;\n				}\n		}\n\n	\n			if (flag!=1 && d==1 )\n			{\n				printf(\"%s\\n\",S);\n				q=malloc(sizeof(struct item));\n				q->world=malloc (strlen(S)+1);\n				q->next=head;\n				strcpy(q->world,S);\n				printf(\"%s\\n\",q->world);\n				q->count=1;\n				head=q;\n			}\n		\n\n	}\n\nfor (p=head;p;p=p->next)\n{\n	printf (\"%s-%d\\n\",p->world,p->count);\n}\n\nfclose (f);\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (818,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct item \n{\n	char *world;\n	int count;\n	struct item *next;\n};\n\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *q=NULL;\nstruct item *prev=NULL;\n\nchar S[50];\nchar k;\nint d=1;\n\nvoid chtenya( FILE *f)//??????? ??? ?????? ?????\n{\n\n	int j=0;\n	\n	while (j<=50)\n	{\n\n	S[j]=0;\n	j++;\n	}\n	\n	j=0;	\n\n	while ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\')&&(d==1))\n	{\n		d=fscanf(f,\"%c\",&k);\n\n		\n	}	\n		//???????? ????? ????? ?????????? ????? ????????? ??? ?? ???? ?????? anyting\"- and he ...\n		while (((k>=\'A\' && k<=\'Z\')||(k>=\'a\'&& k<=\'z\'))&& (d==1))\n		{\n		\n			S[j]=k;\n			\n		d=fscanf(f,\"%c\",&k);\n\n			j++;\n		}\n\n\n}\n\n\nint main ()\n{\nint flag=0;\n	int i=0;\nFILE *f=fopen(\"/home/fenster/input_words.txt\",\"r\");\n	\n	if (f==NULL)\n	{\n		printf (\"file not open\\n\");\n		return 0;\n	}\n\n	while (flag!=1)\n	{\n	\n	\n	fscanf (f,\"%c\",&k);\n		\n		if ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\'))\n			flag=1;\n		else\n			S[i]=k;\n		\n			i++;\n	\n\n	}\n\n	head= malloc (sizeof(struct item));\n	head->world=malloc (strlen(S)+1);\n	strcpy(head->world,S);\n	printf(\"%s\\n\",head->world);\n	head->count=1;\n	head->next=NULL;\nflag=0;\n	while (d==1)\n	{\n\n		chtenya(f);\n	flag=0;\n	\n		for (p=head;p;p=p->next)\n		{\n			if (strcmp(p->world,S)==0)\n				{\n	\n					p->count++;\n					flag=1;\n					break;\n				}\n		}\n\n	\n			if (flag!=1 && d==1 )\n			{\n				printf(\"%s\\n\",S);\n				q=malloc(sizeof(struct item));\n				q->world=malloc (strlen(S)+1);\n				q->next=head;\n				strcpy(q->world,S);\n				printf(\"%s\\n\",q->world);\n				q->count=1;\n				head=q;\n			}\n		\n\n	}\n\nfor (p=head;p;p=p->next)\n{\n	printf (\"%s-%d\\n\",p->world,p->count);\n}\n\nfclose (f);\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (819,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	int n,j,b,l,r=0,x=1;\n	char s[100];\n	printf(\"Enter the basis: \");\n	scanf(\"%d\", &b);\n	\n	while (!(b>1 && b<=16))\n		{\n		printf (\"The basis is wrong. Enter it again: \");\n		scanf (\"%d\", &b);	\n		}\n	printf (\"Enter the number: \", b);\n	scanf (\"%s\", s);\n		l=strlen(s);\n	for (n=0; n<l; n++)\n	{\n	if (s[n]>=\'0\' && s[n]<=\'9\')\n		s[n]=s[n]-\'0\';\n	else s[n] = s[n] - \'A\'+10;	\n	}\n	for (n=l-1; n>=0; n--)\n		{\n		r+= s[n]*x;\n		x=x*b;	\n		}\n	printf(\"The number in basis 10 is: %d\\n\",r);\nreturn 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (820,'#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n\nint main()\n{\n	int a,b,c,d,e;\n	char N[1000], M[1000];\n	printf(\"Enter the login: \");\n	fgets(N,1000,stdin);\n	a=strlen(N);\n	a--;\n\n	FILE *file=fopen(\"/etc/passwd\",\"r\");\n	while(b!=1)\n	{\n		if (!fgets(M,1000,file))\n		{\n			e=1;\n			printf(\"Error. Login does not found\");\n			break;	\n		}	\n		d=0;\n		for(c=0; c<=a; c++)\n		{\n			if(N[c]==M[c])\n			d++;	\n		}\n		if(d==a && M[d]==\':\')\n			b=1;\n	}\n	if(e!=1)\n	{\n		c=0;\n		d=0;\n		while(c!=4)	\n	{	\n		if(M[d]==\':\')\n		c++;\n		d++;\n	}\n	while(M[d]!=\',\')\n	{\n		printf(\"%c\",M[d]);\n		d++;	\n	}\n	printf(\"\\n\");\n	}\nreturn 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (821,'#include <stdio.h>\n#include <malloc.h>\n\nint main()\n{\n	int i, j, N, k, *a, m, t;\n	FILE *f, *g;\n	f=fopen (\"input11.txt\", \"r\");\n	fscanf (f, \"%d\", &N);\n	a=(int*)malloc(N*sizeof(int));\n	printf (\"Size of array is: %d\\n\", N);\n	for (i=0; i<N; i++)\n	{\n		fscanf (f, \"%d\", &a[i]);	\n	}	\n	for (i=0; i<N-1; i++)\n	{\n		t=a[i];\n		m=i;\n		for (k=i+1; k<N; k++)\n		{\n			if (t>a[k])\n			{\n			t=a[k];\n			m=k;\n			}	\n		}\n		a[m]=a[i];\n		a[i]=t;	\n	}\n	g=fopen(\"output11.txt\", \"w\");\n	for (i=0; i<N; i++)\n	{\n	fprintf (g, \"%d\\t\", a[i]);\n	}\n	fcloseall ();\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (822,'#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid sort(int *m, int f, int l)\n{\n	int i,j,s,p;\n	i=f;\n	j=l;\n	s=m[(f+l)/2];\n	do\n	{\n		while (m[i]<s) i++;\n		while (m[j]>s) j--;\n		\n		if (i<=j)\n		{\n			if (i<j)\n			{\n				p=m[j];\n				m[j]=m[i];\n				m[i]=p;\n			}	\n			i++;\n			j--;\n		}\n	}	\n	while (i<=j);\n\n	if (i<l) sort(m,i,l);\n	if (f<j) sort(m,f,j);\n}\nint main()\n{\n	int n,a[100000],t;\n	\n	FILE *f, *g;\n	f=fopen (\"input11.txt\", \"r\");\n	fscanf(f, \"%d\", &n);\n\n	for (t=0; t<n; t++)\n	{\n		fscanf( f,\"%d\", &a[t]);	\n	}	\n	sort (a,0,n-1);\n	for (t=0; t<n; t++)\n	{\n	printf(\"%d \", a[t]);\n	}\n	printf(\"\\n \");\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (823,'#include <stdio.h>\nvoid sift (int *A, int N, int i)\n{\n	int b;\n	int max=0;\n	max=i;\n	if(((2*i+1)<N) && (A[2*i+1]>A[i]))max=2*i+1;\n	if(((2*i+2)<N) && (A[2*i+2]>A[max])) max=2*i+2;\n		if (i!=max)\n		{\n			b=A[i];\n			A[i]=A[max];\n			A[max]=b;\n			sift(A,N,max);	\n		}\n}\n\nint main()\n{\n	int M,a,b,c,d,i;\n	int A[100000];\n	\nFILE *f=fopen(\"input11.txt\", \"r\");\nfscanf(f, \"%d\", &M);\nfor (i=0; i<M; i++)\n	{\n		fscanf(f, \"%d\", &A[i]);\n	}	\n	fclose(f);\n	for (b=M/2; b>=0; b--)\n	{\n		sift (A,M,b);	\n	}\n	for (i=M-1; i>0; i--)\n	{\n		c=A[i];\n		A[i]=A[0];\n		A[0]=c;\n		sift (A,i,0);\n	}\n	for (d=0; d<M; d++)\n	printf(\"%d \",A[d]);\n\n	printf(\"\\n\");\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (824,'#include<stdio.h>\r\n#include<malloc.h>\r\n#include\"list.h\"\r\n#define LIST struct list\r\nstruct list\r\n\r\n{\r\n        int item;\r\n        LIST *next;\r\n};\r\nvoid insert (LIST* *head, LIST *newel)\r\n{\r\n        newel->next=*head;\r\n        *head=newel;\r\n}\r\nLIST *create (int i)\r\n{\r\n        LIST *p=(LIST *)malloc(sizeof(LIST));\r\n        p->item=i;\r\n        p->next=NULL;\r\n        return p;\r\n}\r\nvoid display (LIST *head)\r\n{\r\n        if(head==0)\r\n        {printf(\"LOL\");return;}\r\n        printf (\"%i\\n\",head->item);\r\n        display(head->next);\r\n}\r\nvoid sortirovka(LIST** head)\r\n{\r\n//      LIST *save;//=*head;\r\n        LIST *cut;//=*head;\r\n        LIST *prev;//=*head;\r\n        prev=*head;\r\n        cut=*head;\r\n//      save=*head;\r\n        int i=0;\r\n        int k;\r\n        while (cut!=0)\r\n        {\r\n                prev=cut;\r\n                cut=cut->next;\r\n                if (cut!=0)\r\n                {\r\n                        if ((prev->item)<(cut->item))\r\n                        {\r\n                                k=cut->item;\r\n                                cut->item=prev->item;\r\n                                prev->item=k;\r\n                                i=i+1;\r\n                        }\r\n                }\r\n        }\r\n        if (i==0) return;\r\n        else\r\n        sortirovka (head);\r\n}\r\nvoid back_up(LIST** head)\r\n{\r\n        int i=1,k,s=1;\r\n        LIST *cut;\r\n        LIST *prev;\r\n        prev=*head;\r\n        cut=*head;\r\n        if (head==0) return;\r\n        if (prev==0) return;\r\n        while(cut->next!=0)\r\n        {\r\n                s=s+1;\r\n                prev=cut;\r\n                cut=cut->next;\r\n        }\r\n        while (s>1)\r\n        {\r\n                prev=*head;\r\n                cut=*head;\r\n                cut=cut->next;\r\n                k=prev->item;\r\n                prev->item=cut->item;\r\n                cut->item=k;\r\n                while (i<s-1)\r\n                {\r\n                        prev=cut;\r\n                        cut=cut->next;\r\n                        k=prev->item;\r\n                        prev->item=cut->item;\r\n                        cut->item=k;\r\n                        i=i+1;\r\n                }\r\n                s=s-1;\r\n                i=1;\r\n        }\r\n}\r\nint main ()\r\n{\r\n        LIST *head=0;\r\n        int n=1;\r\n        while (n!=0)\r\n        {\r\n\r\n                printf(\"Put a number\\n\");\r\n                scanf(\"%i\",&n);\r\n                if (n!=0)\r\n                        insert (&head,create(n));\r\n        }\r\n        sortirovka(&head);\r\n        //back_up(&head);\r\n        display (head);\r\n}\r\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (825,'#include <stdio.h>\n#define N 100\n\nvoid dfs(int current, int A[N][N], int visited[1000], int p)\n{\n	visited[current]=1;\n	int i;\n	for (i=1; i<=p; i++)\n		if (!visited[i] && A[current][i] == 1)\n		{\n			dfs (i,A,visited,p);	\n		}	\n		printf(\"????????? %d\\n\",current);\n}\nint main()\n{\n	FILE *f=fopen (\"input19.txt\", \"r\");\n	int visited[N] = {0};\n	int i, j, k;\n	int A[N][N]={{0}};\n\n	fscanf (f, \"%d\", &k);\n	printf (\"%d\\n\",k);\n\n	for (i=1; i<=k; i++)\n	{\n		for (j=1; j<=k ; j++)\n		{\n			fscanf(f, \"%d\", &A[i][j]);\n			printf(\"%d \", A[i][j]);	\n		}	\n		printf(\"\\n\");\n	}\n	dfs(1,A,visited,k);\n	fcloseall();\nreturn 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (826,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nmain()\n{\nFILE *f1=fopen(\"/etc/passwd\",\"r\");\nint i, j,l,h,z;\nchar s1[200];\nchar s2[200];\nchar c[20];\nchar C1[50];\nchar k;\ni=0;z=0;l=0;\nprintf(\"??????? ?????\\n\");\nwhile((1==scanf(\"%c\",&k))&&k!=\'\\n\')\n	{\n	c[i]=k;\n	printf(\"\\n ????? %c\",c[i]);\n	i++;\n	}\n	\nj=0;\nwhile(fgets(s1 ,100 , f1))\n	{	strcpy(s2,s1);\n		while(s2[j]==c[j])\n		{j++;\n		}\n	if(j>=i)\n	{	for(h=0;h<100;h++)\n			{\n			if((4<=l)&&(5>l))\n				{C1[z]=s2[h];\n				z++;}\n			if(s2[h]==\':\'||((l==4)&&(s2[h]==\',\')))\n				l++;\n			}\n		C1[z-1]=\'\\n\';\n		printf(\"\\n ??????? ????   %s\",C1);\n	 	return 0;\n		}\n	else j=0;\n}\nprintf(\"???????? ? ????? ??????? ???\");\nreturn 1;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (827,'#include<stdio.h>\nmain()\n{\nint a[100000]={0};\nint k,i,j,c,f;\nFILE *f1=fopen(\"input.txt\",\"r\");\ni=0;\nk=0;\nif(!f1)\n{\n	perror(\"fopen\");\n}\nwhile(1==fscanf(f1,\" %d \",&c))\n	{\n	a[k]=c;\n	k++;\n	printf(\"???????? ????? %d  ????? ????? %d \\n\",a[k-1],k);\n 	}\nfor(j=0;j<k-1;j++)\n{ \nfor(i=j+1;i<k;i++)\n	{\n	if(a[j]>a[i])\n		{//printf(\" ??????????? ????? %d ? ???????? %d ????????? ?? ?????%d ? ??????? %d\\n\",a[j],i,a[j],j);\n		f=a[j];\n		a[j]=a[i];\n		a[i]=f;\n		\n		}	\n	}\n}\nfor(i=0;i<k;i++)\n	printf(\" %d \",a[i]);\n	printf(\"\\n K????\\n\");\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (828,'#include<stdio.h>\nint A[100]={0};\nvoid dfs(int c,int B[100][100],int a)\n	{\n	int i;\n	A[c]=1;\n	printf(\"%d\\n\",c);\n	for(i=1;i<=a;i++)\n		{\n		if(!A[i]&&B[c][i]==1)\n			{\n			dfs(i,B,a);\n			}\n		}\n	}\nmain()\n{\n	FILE *f1=fopen(\"input19.txt\",\"r\");\n	int i,j,N,x1,x2;\n\n	int B[100][100];\n	fscanf(f1,\"%d\",&N);\n	while(fscanf(f1,\"%d%d\",&x1,&x2)==2)\n		{\n		B[x1][x2]=1;\n		B[x2][x1]=1;\n\n		}\n	fclose(f1);\n	dfs(1,B,N);\nreturn 0;\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (829,'#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nmain()\n{\nFILE *f1=fopen(\"input.txt\",\"r\");\nint i,j,k,r,i1;\nstruct item\n{\nint data;\nstruct item *next;\n};\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *c=NULL;\nstruct item *q=NULL;\nstruct item *h=NULL;\ni=1;\nk=1;\nfscanf(f1,\"%d\",&r);\nhead=malloc(sizeof(struct item));\nhead->data=r;\nhead->next=NULL;\nfor(i=0;fscanf(f1,\"%d\",&r)!=EOF;i++)\n	{if(r>head->data)\n		{\n		c=head;\n		h=NULL;\n		for(c=head ,h=NULL;r>c->data;h=c, c=c->next)//???? ??? ????? ???????\n		{}\n		p=malloc(sizeof(struct item));//??????? ????? ??? ?????? ?????????\n		if(h->next)//????????? ?? ?????? ?? ??? ????????\n			p->next=h->next;\n		else \n			p->next=NULL;\n		h->next=p;//????????? ???????? ? ???? ??????????????????\n		p->data=r;//??????????? \n		}\n	else\n	{\n		p=malloc(sizeof(struct item));\n		p->data=r;\n		p->next=head;\n		head=p;\n\n	}\ni++;\n	}\n	p=head;\n		while (p)\n		{\n		printf(\"%d \\n\",p->data);\n		p=p->next;\n		}\n		return 0;\n}\n\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (830,'#include <stdio.h>\n\nvoid sift(int b, int *a,int k)\n{int x,i,z1,z2;\nz1=0;z2=0;\n//for(i=0;i!=b;i++)    printf(\"%d \",a[i]);   printf(\"        \");\n\nif((2*k+1<b)&&(a[k]<=a[2*k+1])&&(2*k+1<b))\n            { {x=a[k];\n	    	a[k]=a[2*k+1];\n		a[2*k+1]=x;\n		z1=2*k+1;} \n	     sift(b, a, z1);}\n	   \nif ((2*k+2<b)&&(a[k]<=a[2*k+2])&&(2*k+2<b))\n             {{x=a[k];\n	     a[k]=a[2*k+2];\n	     a[2*k+2]=x;\n	     z2=2*k+2;}\n	     sift(b,a,z2);}\n	 //	 printf(\"%d\\n\",z1);printf(\"%d\\n\",z2);\n//	 for(i=0;i!=b;i++)\n//	 printf(\"%d \",a[i]);   printf(\"\\n\");}\n}\n\n\nint main()\n{       FILE *f1=fopen(\"inputsortir.txt\",\"r\");\n        if (!f1) {perror (\"fopen\");}\n        FILE *f2=fopen(\"outputsortir.txt\",\"w\");\n        if (!f2) {perror (\"fopen\");}\n        int i,ii;\n        int b;\n        int j;\n        int x;\n        int a[100000];\n	int A[100000];\n                fscanf(f1,\"%d\" ,&b);\n		printf(\"%d\\n\",b);\n	        for(i=0;i!=b;i++)\n		        fscanf(f1,\"%d\" ,&a[i]);\n		\n		\n//	for(i=0;i!=b;i++)    printf(\"%d   \",a[i]);   printf(\"         \");\n			j=b;\n			\n			for(i=b;i>=0;i--)\n			sift(b, a, i);\n                        \n                        \n			\n			for(ii=0;ii!=j-1;ii++)\n		{		sift(b,a,0);\n				x=a[0];\n				a[0]=a[b-1];\n				a[b-1]=x;\n				b--;\n				\n	\n			}\n\n\n	\n	for(i=0;i!=j;i++)\n     \n    fprintf(f2,\"%d \" ,a[i]);\n \nfclose(f1);\nfclose(f2);\n\n\n\n\n        return 0;}\n\n','Ð’Ð»Ð°Ð´Ð¸ÑÐ»Ð°Ð²','Vladislav','m');
INSERT INTO `bias` VALUES (831,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct item \n{\n	char *world;\n	int count;\n	struct item *next;\n};\n\nstruct item *head=NULL;\nstruct item *p=NULL;\nstruct item *q=NULL;\nstruct item *prev=NULL;\n\nchar S[50];\nchar k;\nint d=1;\n\nvoid chtenya( FILE *f)//??????? ??? ?????? ?????\n{\n\n	int j=0;\n	\n	while (j<=50)\n	{\n\n	S[j]=0;\n	j++;\n	}\n	\n	j=0;	\n\n	while ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\')&&(d==1))\n	{\n		d=fscanf(f,\"%c\",&k);\n\n		\n	}	\n		//???????? ????? ????? ?????????? ????? ????????? ??? ?? ???? ?????? anyting\"- and he ...\n		while (((k>=\'A\' && k<=\'Z\')||(k>=\'a\'&& k<=\'z\'))&& (d==1))\n		{\n		\n			S[j]=k;\n			\n		d=fscanf(f,\"%c\",&k);\n\n			j++;\n		}\n\n\n}\n\n\nint main ()\n{\nint flag=0;\n	int i=0;\nFILE *f=fopen(\"/home/fenster/input_words.txt\",\"r\");\n	\n	if (f==NULL)\n	{\n		printf (\"file not open\\n\");\n		return 0;\n	}\n\n	while (flag!=1)\n	{\n	\n	\n	fscanf (f,\"%c\",&k);\n		\n		if ((k<\'A\' || k>\'Z\')&&(k<\'a\' || k>\'z\'))\n			flag=1;\n		else\n			S[i]=k;\n		\n			i++;\n	\n\n	}\n\n	head= malloc (sizeof(struct item));\n	head->world=malloc (strlen(S)+1);\n	strcpy(head->world,S);\n	printf(\"%s\\n\",head->world);\n	head->count=1;\n	head->next=NULL;\nflag=0;\n	while (d==1)\n	{\n\n		chtenya(f);\n	flag=0;\n	\n		for (p=head;p;p=p->next)\n		{\n			if (strcmp(p->world,S)==0)\n				{\n	\n					p->count++;\n					flag=1;\n					break;\n				}\n		}\n\n	\n			if (flag!=1 && d==1 )\n			{\n				printf(\"%s\\n\",S);\n				q=malloc(sizeof(struct item));\n				q->world=malloc (strlen(S)+1);\n				q->next=head;\n				strcpy(q->world,S);\n				printf(\"%s\\n\",q->world);\n				q->count=1;\n				head=q;\n			}\n		\n\n	}\n\nfor (p=head;p;p=p->next)\n{\n	printf (\"%s-%d\\n\",p->world,p->count);\n}\n\nfclose (f);\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (832,'#include <stdio.h>\n#define N 1000010\n\nvoid  piramida (int *A,int n,int i)\n{\n	int b=2*i+1;\n	int c=2*i+2;\n	int k;\n	int max=i;\n\n	if (b<n && A[b]>A[max])\n	{\n		max=b;\n	}\n	if (c<n && A[c]>A[max])\n	{\n		max=c;\n	}\n	if (max!=i)\n	{\n		k=A[i];\n		A[i]=A[max];\n		A[max]=k;\n		piramida(A,n,max);\n	}\n}\nint main ()\n{\n	int i,j,k,o;\n	int p;\n	int A[N];\n\n	FILE *f=fopen(\"input.txt\",\"r\");\n\n	if (!f)\n	{\n		printf (\"file was not open\");\n	}\n	\n	fscanf (f,\"%d\",&p);\n	for (i=0;i<p;i++)\n	{\n		fscanf (f,\"%d\",&A[i]);\n	}\n	\n	for (i=p/2;i>=0;i--)\n	{\n		piramida (A,p,i);\n	}\n	\n\no=p;\nj=0;\n\nwhile (o>1)\n	{\n		j=A[o-1];\n		A[o-1]=A[0];\n		A[0]=j;\n		o--;\n		piramida (A,o,0);\n	}\n	i=0;\n		while (i<p)\n		{\n		\n			printf (\"%d \",A[i]);\n			i++;\n		}\n//	printf (\"infinity\");\n		printf(\"\\n\");\n\n\n\n	fclose(f);\n	return 0;\n		\n\n		\n}\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (833,'#include <stdio.h>\n#include <malloc.h>\n#include <string.h>\nstruct item\n{\n	char word[1000];\n	int count;\n	struct item *next;\n};\nint main ()\n{\n	FILE *f=fopen(\"input15.txt\",\"r\");\n	char c,z[1000];\n	int count,k=0;\n	struct item *head,*p,*A,*q;\n	while (c!=EOF)\n	{\n		c=fgetc(f);\n		while (!((c>=\'a\')&&(c<=\'z\'))&&(c!=EOF))\n		c=fgetc(f);\n		if (c==EOF)\n		break;\n		count=0;\n		z[count]=c;\n		count++;\n		while ((((c>=\'a\')&&(c<=\'z\')))&&(c!=EOF))\n		{\n		c=fgetc(f);\n		z[count++]=c;\n		}\n		z[count-1]=0;\n		if (k==0)\n		{\n		A=malloc(sizeof(struct item));\n		head=A;\n		A->count=1;\n		A->next=0;\n		strcpy(A->word,z);\n		k++;	\n		}\n		else\n		{\n		q=head;\n		for (p=head;(p)&&(strcmp(z,p->word));p=p->next)\n		q=p;\n		if (p==0)\n		{\n		A=malloc(sizeof(struct item));\n		A->count=1;\n		A->next=0;\n		strcpy(A->word,z);\n		q->next=A;\n		}\n		else\n		{\n		p->count++;\n		}	\n		}\n	}\n	for (p=head;p;p=p->next)\n	printf(\"????? %s ??????????? %d ??? \\n\",p->word,p->count);\n	while (head)\n	{\n	p=head;\n	head=head->next;\n	free(p);\n	}\n	return 0;\n}\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (834,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item\n{\nint data;\nstruct item *next;\n};\n\nint add(struct item **head, int a)\n{\nstruct item *p;\nstruct item *d;\nstruct item *q;\nstruct item *k;\n	if(*head==0)\n	{\n	*head=malloc(sizeof(struct item));\n	(*head)->data=a;\n	(*head)->next=0;\n	return(0);\n	}\nq=malloc(sizeof(struct item));\nq->data=a;\n	if( (q->data)<((*head)->data) )\n	{\n		d=*head;\n		*head=q;\n		(*head)->next=d;\n		return(0);\n	}\n		if((*head)->next==0)\n			{\n			(*head)->next=q;\n			q->next=0;\n			return(0);\n			}\n		else\n		{\n			p=*head;\n			do\n			{\n			d=p->next;\n			if( (p->data)<(q->data) && d==0)\n				{\n				p->next=q;\n				q->next=0;\n				return(0);\n			        }\n			if((p->data)<(q->data) && (d->data)>=(q->data) )\n				{\n				p->next=q;\n				q->next=d;\n				return(0);\n				}\n			p=p->next;\n			}\n			while(p!=0);\n			return(0);\n		}\n	return(1);\n	}\n\nint main()\n{\nstruct item *head=0, *p, *q;\nFILE *f = fopen(\"input17.txt\", \"r\");\nint a;\nwhile (fscanf(f, \"%d\", &a) == 1)\n	add(&head, a);\n	\nfclose(f);\n\nfor(p=head; p; p=p->next)\n	{\n	printf(\"%d \", p->data);\n	}\nprintf(\"\\n\");\np=head;\nwhile(p->next)\n	{\n		q=p->next;\n		free(p);\n		p=q;\n	}\nfree(q);\n}\n\n','Ð¯ÐºÐ¾Ð²','Yakov','m');
INSERT INTO `bias` VALUES (835,'#include <stdio.h>\n#include <stdlib.h>\n#include <memory.h>\n#include \"bitStream.h\"\n\n\n\nvoid initBitStream(BitStream* stream)\n{\n	stream->buff = 0;\n	stream->fillBits = 0;\n}\n\nint readBit(BitStream* stream, FILE* input)\n{\n	int res = -1;\n	if (stream->fillBits <= 0)\n	{\n		int readed = fread(&(stream->buff), 1, 1, input);\n		if (readed != 1)\n		{\n			printf(\"error bitStream (readBit)\");\n			exit(1);\n		}\n		stream->fillBits = 8;\n	}\n	res = (stream->buff & 0x80) != 0? 1: 0;\n	stream->buff <<= 1;\n	stream->fillBits--;\n	return res;\n}\n\nvoid write2BitStream(Code* code, BitStream* stream, FILE* out)\n{\n	int i = 0;\n	int bits  = code->len;\n	for (i = 0; i < 32 && bits > 0; i++, bits -= 8)\n	{\n		unsigned char curr = code->bytes[i] >> stream->fillBits;\n		stream->buff = stream->buff | curr;\n		if (bits + stream->fillBits >= 8)\n		{\n			fwrite(&(stream->buff), 1, 1, out);\n			stream->buff = code->bytes[i] << (8 - stream->fillBits);\n			if (bits < 8)\n				stream->fillBits = (stream->fillBits + bits) % 8;\n		}\n		else\n		{\n			stream->fillBits += bits;\n		}\n	}\n}\n\nvoid flushBitStream(BitStream* stream, FILE* out) \n{\n	if (stream->fillBits != 0)\n	{\n		fwrite(&(stream->buff), 1, 1, out);\n	}\n	fflush(out);\n	stream->buff = 0;\n	stream->fillBits = 0;\n}\n\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (836,'#include <stdio.h>\n#include \"tree.h\"\n#include <string.h>\n\nint main(int argc, char* argv[])\n{\n    if (argc <= 3)\n	{\n        printf(\"argument requered\\n\");\n		printf(\"usage:\");\n		printf(\"archive -c inputfile outfile\");\n		printf(\"archive -u inputfile outfile\");\n    }\n    else\n	{\n		if (strncmp(\"-c\", argv[1], 2) == 0)\n		{\n			compress(argv[2], argv[3]);\n		}\n		if (strncmp(\"-u\", argv[1], 2) == 0)\n		{\n			decompress(argv[2], argv[3]);\n		}\n    }\n	return 0;\n}\n\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (837,'#include <stdlib.h>\n#include <stdio.h>\n#include <memory.h>\n#include <string.h>\n#include \"tree.h\"\n#include \"bitStream.h\"\n\nchar magicNumber[] = \"PARJ\";\n\n\ntypedef struct FreqList\n{\n	long long frequency;\n	TreeNode* pTreeNode;\n\n	struct FreqList* next;\n} FreqList;\n\nFreqList* push(FreqList** head, FreqList* newListItem)\n{\n	FreqList* pHead = *head;\n	FreqList* tmp = NULL;\n\n	if (pHead)\n	{\n		if (pHead->frequency >= newListItem->frequency)\n		{\n			newListItem->next = pHead;\n			pHead = newListItem;\n		}\n		else\n		{\n			tmp = pHead;\n			while (tmp->next && tmp->next->frequency < newListItem->frequency)\n				tmp = tmp->next;\n			newListItem->next = tmp->next;\n			tmp->next = newListItem;\n		}\n	}\n	else\n		pHead = newListItem;\n\n    *head = pHead;\n	return pHead;\n}\n\nlong long fillFreqTable(FreqTable freqTable[256], char* fileName)\n{\n	long long length = 0;\n	int byte = 0;\n	FILE* input = fopen(fileName, \"rb\");\n\n    if (input != NULL)\n	{\n		while ((byte = fgetc(input)) != EOF)\n		{\n		    freqTable[byte].frequency++;\n			length++;\n		}\n        fclose(input);\n    } \n	else\n	{\n        printf(\"error open file: \'%s\'\", fileName);\n		return 0;\n    }\n	return length;\n}\n\nint readFreqTable(FreqTable freqTable[256], FILE* input)\n{\n	int num = 0;\n	int i = 0;\n	size_t readed = 0;\n	\n	char magicHead[5];\n	//?????????? ?????, ?????????, ???? ??? ?? ?????????, ?? ????? ?? ???!\n	readed = fread(magicHead, 4, 1, input);\n	magicHead[4] = 0;\n	if (readed != 1 || strncmp(magicHead, magicNumber, 4) != 0)\n	{\n		printf(\"bad input file (magic)\");\n		exit(1);\n	}\n\n	fread(&num, sizeof(int), 1, input);\n\n	for (i = 0; i < num; i++)\n	{\n		unsigned char sym = 0;\n		readed = fread(&sym, 1, 1, input);\n		if (readed != 1)\n		{\n			printf(\"bad input file (sym)\");\n			exit(1);\n		}\n		//?????? ??????? ?????????????\n		readed = fread(&freqTable[sym].frequency, sizeof(long long), 1, input);\n		if (readed != 1)\n		{\n			printf(\"bad input file (freq)\");\n			exit(1);\n		}\n	}\n	return num;\n}\n\nvoid writeFreqTable(FILE* output, FreqTable freqTable[256])\n{\n	int num = 0;\n	int i = 0;\n\n	//?????????? ?????, ?????????, ???? ??? ?? ?????????, ?? ????? ?? ???!\n	fwrite(magicNumber, 4, 1, output);\n\n	//??????? ?????????? ????????, ???????????? ? ?????\n	for (i = 0; i < 256; i++)\n	{\n		if(freqTable[i].frequency != 0) num++;\n	}\n\n	fwrite(&num, sizeof(int), 1, output);\n\n	for (i = 0; i < 256; i++)\n	{\n		if (freqTable[i].frequency != 0)\n		{\n			//???????? ???????????? ??????\n			fwrite(&i, 1/*sizeof(char)*/, 1, output);\n			//???????? ??? ??????? ?????????????\n			fwrite(&freqTable[i].frequency, sizeof(long long), 1, output);\n		}\n	}\n}\n\nvoid prefixSetCode(TreeNode* node)\n{\n	int sym = 0;\n	int bitShift = 0;\n	if (!node->left || !node->right)\n		return;\n	node->left->nodeCode.len = node->right->nodeCode.len = node->nodeCode.len + 1;\n\n	//????? ???????? ?????? ??? ????? ???, ???????? ?? ???? ??????, \n	//??? ? ?????, ?? ??????????? ????? ??????, \n	//??? ??? ???????? calloc`??, \n	//?? ??? ??? ????? ???? ? ?????? ?????? ? ????? ????? ??? ?? ????\n	memcpy(node->left->nodeCode.bytes, node->nodeCode.bytes, roundingUpDiv(node->nodeCode.len, 8));	\n	//???, ? ??????? ?? ?????? ? ????? ?????, ???? ???????? ????????.\n	sym = node->right->symbol;\n	bitShift = (8 - node->right->nodeCode.len % 8)%8;\n	\n	memcpy(node->right->nodeCode.bytes, node->nodeCode.bytes, roundingUpDiv(node->nodeCode.len, 8));	\n	node->right->nodeCode.bytes[node->nodeCode.len / 8] += (1 << bitShift);\n\n	prefixSetCode(node->left);\n	prefixSetCode(node->right);\n}\n\nvoid cleanUp(TreeNode* pRoot)\n{\n	TreeNode* left = NULL;\n	TreeNode* right = NULL;\n\n	if (pRoot == NULL)\n		return;\n\n	left = pRoot->left;\n	right = pRoot->right;\n\n	free(pRoot);\n\n	cleanUp(left);\n	cleanUp(right);\n}\n\nvoid printTree(TreeNode* root, FILE* out, int cnt)\n{\n	if(root)\n	{\n		fprintf(out, \"%07d %c[%d,%d,%0x]\\n\", cnt, root->symbol, (int)(root->frequency),root->nodeCode.len, root->nodeCode.bytes[0]);\n\n		printTree(root->left, out, ++cnt);\n		//fprintf(out, \",\");\n		printTree(root->right, out, ++cnt);\n		//fprintf(out, \")\");\n	}\n	else\n		fprintf(out, \"x\\n\");\n}\n\nTreeNode* createTree(FreqTable freqTable[256])\n{\n	FreqList* head = NULL;\n	TreeNode* left = NULL;\n	TreeNode* right = NULL;\n	TreeNode* newTreeNode = NULL;\n	FreqList* newListItem = NULL;\n	TreeNode* treeHead = NULL;\n\n	FreqList* tmp = NULL; \n	FreqList* p = NULL;\n	int f = 0;\n\n	int i = 0;\n\n	for (i = 0; i < 256; i++)\n	{\n		if (freqTable[i].frequency != 0)\n		{\n			f++;\n			newListItem = calloc(1, sizeof(FreqList));\n			freqTable[i].pTreeNode = newListItem->pTreeNode = calloc(1, sizeof(TreeNode));\n			newListItem->frequency = newListItem->pTreeNode->frequency = freqTable[i].frequency;\n			newListItem->pTreeNode->isLeaf = 1;\n			newListItem->pTreeNode->symbol = i;\n			\n			head = push(&head, newListItem);\n		}\n	}\n	\n	if (f == 1)\n	{\n		newListItem = calloc(1, sizeof(FreqList));\n		newListItem->pTreeNode = calloc(1, sizeof(TreeNode));\n		head = push(&head, newListItem);\n	}\n\n	while (head->next)\n	{\n		left = head->pTreeNode;\n		right = head->next->pTreeNode;\n		tmp = head->next->next;\n		free(head->next);\n		free(head);\n		head = tmp;\n		tmp = NULL;\n\n		newTreeNode = calloc(1, sizeof(TreeNode));\n		newTreeNode->left = left;\n		newTreeNode->right = right;\n		newTreeNode->frequency = left->frequency + right->frequency;\n		newTreeNode->isLeaf = 0;\n\n		newListItem = calloc(1, sizeof(FreqList));\n\n		newListItem->frequency = newTreeNode->frequency;\n		newListItem->pTreeNode = newTreeNode;\n		\n		head = push(&head, newListItem);\n	}\n	treeHead = head->pTreeNode;\n	free(head);\n	prefixSetCode(treeHead);\n	//printTree(treeHead, stdout, 0);\n	return treeHead;\n}\n\nvoid compressStream(FreqTable freqTable[256], long long length, FILE* input, FILE* output)\n{\n	int byte = 0;\n	BitStream stream;\n\n	writeFreqTable(output, freqTable);\n	fwrite(&length, sizeof(length), 1, output);\n	if (length != 0)\n	{\n		initBitStream(&stream);\n		while ((byte = fgetc(input)) != EOF) \n		{\n			if (freqTable[byte].pTreeNode != NULL)\n			{\n				write2BitStream(&(freqTable[byte].pTreeNode->nodeCode), &stream, output);\n			}\n		}\n		flushBitStream(&stream, output);\n	}\n}\n\n\nvoid compressFile(FreqTable freqTable[256], char* file, char* outFile, long long length)\n{\n	FILE* input = fopen(file, \"rb\");\n	FILE* output = fopen(outFile, \"wb\");\n\n	if (input != NULL && output != NULL)\n	{\n		compressStream(freqTable, length, input, output);\n	} \n	else\n	{\n		printf(\"error open file\");\n	}\n	if (input != NULL) fclose(input);\n	if (output != NULL) fclose(output);\n}\n\nvoid compress(char* file, char* outFile) \n{\n	TreeNode* pRoot = NULL;\n	long long length = 0;\n	FreqTable freqTable[256];\n	memset(freqTable, 0, sizeof(FreqTable) * 256);\n	length = fillFreqTable(freqTable, file);\n	if (length != 0)\n	{\n		pRoot = createTree(freqTable);\n	}\n	compressFile(freqTable, file, outFile, length);\n\n	cleanUp(pRoot);\n}\n\nunsigned char readSym(TreeNode* pRoot, BitStream* stream, FILE* input)\n{\n	int bit = -1;\n	TreeNode* currNode = pRoot;\n	if (currNode == NULL)\n	{\n		printf(\"bitstream error (currNode == NULL)\");\n		exit(1);\n	}\n	while (1)\n	{\n		bit = readBit(stream, input);\n		switch (bit)\n		{\n		case 0:\n			currNode = currNode->left;\n			break;\n		case 1:\n			currNode = currNode->right;\n			break;\n		default:\n			printf(\"bitstream error\");\n			exit(1);\n		}\n		if (currNode == NULL)\n		{\n			printf(\"bitstream error (currNode == NULL)\");\n			exit(1);\n		}\n		if (currNode->isLeaf)\n		{\n			return currNode->symbol;\n		}\n	}\n	return 0;\n}\n\n\nvoid decompressStream(TreeNode* pRoot, FILE* input, FILE* output) \n{\n	BitStream stream;\n	long long length = 0; \n	int readed = 0;\n\n	readed = fread(&length, sizeof(length), 1, input);\n	if (readed != 1)\n	{\n		printf(\"bad input file (length)\");\n		exit(1);\n	}\n	initBitStream(&stream);\n	for (;length > 0; length--)\n	{\n		unsigned char sym = readSym(pRoot, &stream, input);\n		fwrite(&sym, 1,1, output);\n	}\n}\n\nvoid decompress(char* inFile, char* outFile) \n{\n	FreqTable freqTable[256];\n	TreeNode* pRoot = NULL;\n	int tableLen = 0;\n	FILE* input = fopen(inFile, \"rb\");\n	FILE* output = fopen(outFile, \"wb\");\n\n	if (input == NULL || output == NULL) \n	{\n		if (input != NULL) fclose(input);\n		if (output != NULL) fclose(output);\n		printf(\"error open file\'s\");\n		exit(1);\n	}\n\n	memset(freqTable, 0, sizeof(FreqTable) * 256);\n	tableLen = readFreqTable(freqTable, input);\n	if (tableLen != 0)\n	{\n		pRoot = createTree(freqTable);\n		decompressStream(pRoot, input, output);\n	}\n	\n	cleanUp(pRoot);\n	if (input != NULL) fclose(input);\n	if (output != NULL) fclose(output);\n}\n\n','ÐŸÐ°Ð²ÐµÐ»','Pavel','m');
INSERT INTO `bias` VALUES (838,'#include <stdio.h>\n#include <stdlib.h>\n#include \"huffman.h\"\n\n/*\n  Name  : CRC-32\n  Poly  : 0x04C11DB7    x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 \n                       + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\n  Init  : 0xFFFFFFFF\n  Revert: true\n  XorOut: 0xFFFFFFFF\n  Check : 0xCBF43926 (\"123456789\")\n  MaxLen: 268 435 455 ???? (2 147 483 647 ???) - ???????????\n   ?????????, ???????, ???????? ? ???? ???????? ??????\n*/\nconst unsigned int Crc32Table[256] = {\n    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,\n    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,\n    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,\n    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,\n    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\n    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,\n    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,\n    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,\n    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,\n    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,\n    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,\n    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,\n    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,\n    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,\n    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,\n    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,\n    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,\n    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,\n    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,\n    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,\n    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,\n    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\n    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,\n    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,\n    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,\n    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,\n    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,\n    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,\n    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,\n    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,\n    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\n    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,\n    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,\n    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,\n    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,\n    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,\n    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,\n    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,\n    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,\n    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,\n    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,\n    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,\n    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,\n    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,\n    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,\n    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,\n    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,\n    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\n    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,\n    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,\n    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,\n    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,\n    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,\n    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,\n    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,\n    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D\n};\n \nunsigned int calculateCrc32(unsigned int oldCrc, const unsigned char * buf, size_t len)\n{\n    unsigned int crc = oldCrc;\n    while (len--) {\n        crc = (crc >> 8) ^ Crc32Table[(crc ^ *buf++) & 0xFF];\n	}\n    return crc ^ 0xFFFFFFFF;\n}\n\nunsigned int fileCrc32(FILE *file) {\n\n	unsigned char buffer[BUFFER_SIZE];\n	size_t count;\n	unsigned int crc32 = 0xFFFFFFFF;\n\n	if( NULL == file ) {\n		fprintf(stderr, \"Error in file\\n\");\n		return 0;\n	}\n\n	\n	while (count = fread(buffer, 1, BUFFER_SIZE, file)) {\n		crc32 = calculateCrc32(crc32, buffer, count);\n	}\n\n	return crc32;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (839,'#include <stdio.h>\n#include <malloc.h>\n#include \"huffman.h\"\n\n// ??????? ??????????????? ??????? ???????????\n\nunsigned int *createFirstDict(FILE *inputFile) {\n	// count - ??????????? ???? ??????????? ?? ???? ????????\n	size_t count = 0;\n	int i = 0;\n	// ?????? ??????\n	unsigned char buffer[BUFFER_SIZE];\n	// ???????? ???????\n	unsigned int *dict = (unsigned int *) calloc(256,sizeof(unsigned int));\n	if (!dict) {\n		printf(\"error allocating memory; file: %s function: %s line: %s\",__FILE__,__FUNCTION__,__LINE__);\n	}\n	if (!inputFile) {\n		return 0;\n	}\n\n	// ?????? ?? ??????? ? ?????\n	while (count = fread(buffer,1,BUFFER_SIZE,inputFile)) {\n		for (i=0;i<count;i++) {\n			dict[buffer[i]]++; // buffer[i] - ????, ??????? ??? ????????\n		}\n	}\n	return dict;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (840,'#include <stdio.h>\n#include <memory.h>\n#include <malloc.h>\n\n#include \"huffman.h\"\n\n//???????? ???? ??????? ? ?????????? ? ??????? ????????. ?????: \n//code - ??????? ???\n//root - ????????? ?? ??????? ???? ??????\n//deep - ??????? ??????(????????? ???????? 0)\nvoid createHuffmanCode (unsigned char code[32], Tree *root, HuffmanCode *codeArray, unsigned char deep) {\n\n\n	unsigned int bit = deep % 8, //??????????? ???????? ???? ? ?????\n				byte = (int) (deep / 8); // ??????????? ? ?????????? ????? ? ??????? ?? ????????\n	unsigned char shift[32] = \"\"; //?????? ????????? ??? ??????????? ???????? ????????? ????\n	if(root != NULL) {\n\n		// ????????? ?????\n		if ( root->left == NULL && root->right == NULL) {\n			// ????????? ?????? ??? ??? ???????\n			codeArray[root->letter].code = (unsigned char *) calloc (byte + 1,1);\n			// ?????????? ???? ???????? ??????? ??????????????? ???????? ?????\n			memcpy(codeArray[root->letter].code,code,byte+1);\n			// ?????????? ????? ???? ? ?????\n			codeArray[root->letter].bitCount = deep;\n			return;\n		}\n\n		// ????????? ?????? ?????????\n		if (root->left) {\n			//?????????? ???????? ??????? ? ??????????? ??????? ?? ???????, ??? ???? ??????\n			//code ?? ????????, ????????? ??? ???????? ? ????? ????????? ??? ???? ?????????????\n			//???? ????? ???? (?????????? code ???????)\n			createHuffmanCode(code,root->left,codeArray, deep+1); \n		}\n	\n		// ????????? ??????? ?????????\n		if (root->right) \n			// ???????? ?????? code  ? shift ????? ????????? ??? ????????? ??? ?????? ?? ???????????? ??????\n			memcpy(shift,code,32);\n			// ?????? ??????? ? ??????? ???? ???????? ????? ??????? code\n			// ??????? ???????? ??????? ????? ? ????? ????????? ???????? ????????? ???\n			code[byte] |= (1 << (7 - bit));\n			createHuffmanCode(code,root->right,codeArray, deep+1);\n			memcpy(code, shift,32);\n		}\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (841,'#include <stdio.h>\n#include \"huffman.h\"\n\n// ???????? ?????? ???????? ? ??????????? ? ???????? ???????? ???????????\n\n// dict - ?????? ???????? ??????? 2*count-1, ? ??????? ?????? count ????????? ?????? ???? ????????????? ?? ????????\n// count - ??????????? ???????? ? ????????\nTree *createhuffmanTree(Tree *dict, size_t count) {\n	size_t position;\n	// ??????? ??????????? ????????? ? ?????? ???????? ?? count ?? 2 * count - 1 \n	size_t length=count;\n	unsigned int newCount;\n	int i,j;\n	\n	if (count > 0) {\n		if( count > 1 ) {\n		for (position = count-1; position >0; position--,length++) {\n			// ??????? ????? ???? ? ???????? ????????????? ?????? ????? ???????? ? ??????????? ????????? ?? ????????\n			newCount = dict[position].count + dict[position-1].count;\n			// ??????? ?????? ???? ? ??????????? ??????????????? ?????????????????? ??????\n			// ????? ????? ??? ??????? ?????? ????????\n			for (i=0;i<length;i++) {\n				if (dict[i].count<=newCount) {\n					break;\n				}\n			}\n			// ????? ??????????? ?????? ?? 1\n			for (j=length-1; j >= i; j--) {\n				dict[j+1]=dict[j];\n			}\n			//  ??????? ?????? ????, shift - ????????????? ????????? ? ????????? ?? ???? ?? ???????\n			dict[i].count = newCount;\n			dict[i].letter = \'0\';\n			dict[i].shift = position - i;\n		}\n		// ???????????? ?????? ??????\n		for (i=0;i<(2*count-1);i++) {\n			if (dict[i].shift!=0) {\n				dict[i].left = dict + i + dict[i].shift;\n				dict[i].right = dict + i + dict[i].shift + 1;\n			}\n		}\n	} \n	 \n	// ? ?????? ?????? ???? ??????????\n	// ???????????? ???? \"????????? ????\" ??? ????, ????? ??????\n	// ?? ???????? ??????? ?????-?????? ???\n	else {\n		dict[1]=dict[0];\n\n		dict[0].letter = \'0\';\n		dict[0].count = dict[1].count;\n		dict[0].left = NULL;\n		dict[0].right = dict + 1;\n	}\n	}\n		return dict;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (842,'#include <stdio.h>\n#include <malloc.h>\n#include \"huffman.h\"\n\n// ??????? ??????????? ????????? ?? ??????? ????????????? ???????? (??? ???????? ??????? ???????????)\nTree *createPrimaryDict(unsigned int *dict, size_t *length) {\n	int i;\n	size_t j = 0;\n	size_t count = 0;\n	Tree *dictArray;\n\n\n	// ?????????? ????????, ???????????? ? ?????\n	for (i=0;i<256;i++) {\n		if (dict[i] != 0) {\n			count++;\n		}\n	}\n	// ???? ? ????????? ??????? N ?????????, ?? ????? ????????? ? ?????? ???????? N-1\n	// ??????? ???????? ???????? ?????? ??? ????????\n	if (count > 0) {\n		if( count > 1 ) {\n			dictArray = (Tree *) calloc((2*count-1), sizeof(Tree));\n		} else {\n			dictArray = (Tree *) calloc( (2*count), sizeof(Tree));\n		}\n	}\n	else {\n		dictArray = NULL;\n		return dictArray;\n\n	}\n	if (!dictArray) {\n		printf(\"error allocate memory. file: %s function: %s line: %s\",__FILE__,__FUNCTION__,__LINE__);\n	}\n\n	for (i=0;i<256;i++) {\n		if (dict[i] != 0) {\n			dictArray[j].count = dict[i];\n			dictArray[j].left = dictArray[j].right = NULL;\n			dictArray[j++].letter = i;\n		}\n	}\n	(*length) = j; // ?????????? ????????, ??????? ????????? ? ????????? ????\n	\n	orderDict(dictArray,j);\n	return dictArray;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (843,'#include <stdio.h>\n#include <stdlib.h>\n#include \"huffman.h\"\n\n#ifndef SEEK_END\n#define SEEK_END 2\n#endif\n\nvoid resetFilePointer(FILE *file) {\n	fseek(file, 0L, SEEK_SET);\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (844,'#include <stdio.h>\n#include \"huffman.h\"\n\nint getBit(unsigned char ch, int bit)  {\n	if (ch & (1 <<(7 - bit))) {\n		return 1;\n	} \n	return 0;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (845,'#include <stdio.h>\n#include <stdlib.h>\n#include \"huffman.h\"\n\nunsigned long getFileSize (char *fileName) {\n	unsigned long fileLength;\n	FILE *file;\n\n	if (!(file = fopen(fileName, \"r\"))) {\n		return(0L);\n	}\n\n	fseek(file, 0L, SEEK_END);\n	fileLength = ftell(file);\n	fclose(file);\n	return fileLength;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (846,'#include <stdio.h>\n#include <memory.h>\n#include \"huffman.h\"\n\n//????????? ?????? ?????????? ????, ??????? ????? ??? ???????? codeBitLength ???\n//????????, ??? ???????? 9 ??? ????? 2 ?????? ?????\n\nint calculateByteLength(int codeBitLength) {\n	int codeByteLength = ((int) codeBitLength / 8);\n	if (codeBitLength % 8 != 0) {\n		codeByteLength++;\n	}	\n\n	return codeByteLength;\n}\n\nvoid huffmanCoder(FILE *inputFile, FILE *outputFile, HuffmanCode *codeArray) {\n	unsigned char inputBuffer[BUFFER_SIZE] = \"\", outputBuffer[BUFFER_SIZE] = \"\"; // ????????????? ?????? ?????? ? ?????? ??????\n	int count,i,j,k;\n	unsigned int outBytePos = 0, outBitPos = 0;\n	unsigned char code[32]=\"\";\n	int codeBitLength, codeByteLength;\n	unsigned int shift;\n\n\n	while (count = fread(inputBuffer,1,BUFFER_SIZE,inputFile)) {\n		// ???? ?? ???????? ??????\n		for (i=0;i<count;i++) {\n			/* ?????? ???? for (k=0;k<32;k++) code[k] = 0; */\n			// ??????? ????? ??? ????\n			memset(code, 0, 32);\n			// ?????????? ????? ???? ???????? ???????\n			codeBitLength = codeArray[inputBuffer[i]].bitCount;\n			// ????????? ?????????? ?????? ????\n			codeByteLength = calculateByteLength(codeBitLength);\n			// ??????????? ??? ??????? ??? ?????????? ?????? \n			memcpy(&code,codeArray[inputBuffer[i]].code,codeByteLength);\n			// ????? ? ??????? ????? ???????? ????? ????????? ?????? ??????????? ?????\n			// ???? ???????, ???????? ???? outBitPos = 3, ?? ????? 5 ???? ??????? ??\n			// ????????? ?????, ??? ???? ????? ???? ????? ???? ?????? 5 (??? ???????????)\n			outputBuffer[outBytePos] |= (code[0] >> outBitPos);\n			// ?????????? ?????? ????????? outBitPos\n			shift = outBitPos;\n			outBitPos += codeBitLength;\n			// ???? ?? ????????? ???? ??????? ????, ?? ??????? ?? ???????? ?? ???????? ?????,\n			// ???? ???????? ?? ??????????, ? ???????? ????????? outBitPos ? outBytePos\n			if (outBitPos > 7) {\n				if (outBytePos >= BUFFER_SIZE - 1) {\n					fwrite(outputBuffer,1,BUFFER_SIZE,outputFile);\n					outBytePos = 0;\n					outBitPos = 0;\n					memset(outputBuffer, 0, BUFFER_SIZE);\n					// ?????? ???? for (k=0; k<BUFFER_SIZE; k++) { outputBuffer[k] = 0;}*/\n				// ???? ?? ?????????? ?? ???????? outBitPos ? ??????????? outBytePos\n				} else {\n					outBitPos = 0;\n					outBytePos++;\n				}\n			}\n			// ??????? ??????? ??? ???????? ????, ???? ?????? ?? ???????? ?? ????????? ? ?????????? ???????? ???????\n			codeBitLength -= (8 - shift); \n			if (codeBitLength <= 0) {\n				continue;\n			}\n			// ????????? ?????????? ?????? ???? ??????????? ????\n			codeByteLength = calculateByteLength(codeBitLength);\n		// ?? ??? ???????? ? ???????? ????? shift ???, ??????? ????? ???????? ?????????? ??? ?? shift ??? ?????\n			code[0] <<= (8 - shift);\n			for (j=0; j < codeByteLength; j++) {\n				code[j] |= ( code[j+1] >> shift );\n				code[j+1] <<= (8 - shift);\n			}\n			// ?????????? ? ????? ?????????? ??? ???????\n			for (j=0; j< codeByteLength; j++) {\n				// ???????????? ??????? ???? ???? ???? ? ???????? ?????\n				outputBuffer[outBytePos] = code[j];\n				// ?? ????????? ????? ???? ??????? \n				if (j >= (codeByteLength - 1) ) { \n					//??? ???? ??? ??? ??????? ???? ????? ????\n					if (codeBitLength > 7) {\n						// ????????? ?? ?????????? ?? ???????? ?????,\n						// ???? ?????????, ?? ?????????? ???????? ????? ?? ????\n						if (outBytePos >= BUFFER_SIZE - 1) { \n							fwrite(outputBuffer,1,BUFFER_SIZE,outputFile);\n							outBytePos = 0;\n							outBitPos = 0;\n							for (k=0; k<BUFFER_SIZE; k++) {\n								outputBuffer[k] = 0;\n							}\n						}\n						// ???? ???????? ????? ?? ?????????? ?? ???????????  ??????? ????? ? ??????? ?????? \n						else {\n							outBytePos++;\n							outBitPos = 0;\n						}\n					}\n					// ? ???? ??????? ??????? ??????? ????\n					else {\n						outBitPos = codeBitLength ;\n					}\n				}\n				// ???? ?? ?? ????????? ???? ?????, ?? ?????? ????? ???????? ????? ?? ????????????\n				else {\n					if (outBytePos >= BUFFER_SIZE - 1) { // ???????? ????? ??????\n						fwrite(outputBuffer,1,BUFFER_SIZE,outputFile);\n						outBytePos = 0;\n						outBitPos = 0;\n						for (k=0; k<BUFFER_SIZE; k++) {\n								outputBuffer[k] = 0;\n							}\n					}\n					else {\n						outBytePos++;\n					}\n					// ????? ???? ??? ?? ???????? ? ???????? ????? ???? ?? ???? ???????,\n					//?? ????????? ?????????? ????? ??????? ?? 8 ??? (????? ?????)\n					codeBitLength -= 8;	\n				}\n			}\n		}\n	}\n		fwrite(outputBuffer,1,outBytePos + 1,outputFile);\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (847,'#include <stdio.h>\n#include \"huffman.h\"\n\n// length - ?????????? ???? ? ????? ?? ???????????\nint huffmanDecoder(FILE *inputFile, FILE *outputFile, unsigned long length, Tree *root) {\n	unsigned char inputBuffer[BUFFER_SIZE] = \"\", outputBuffer[BUFFER_SIZE] = \"\";	\n	size_t i,count;\n	Tree *curr = root;\n	int bit = 0;\n	int j=0;\n	int outputBytePos = 0;\n\n	if (!inputFile || !outputFile) {\n		return -1;\n	}\n	if( !root ) {\n		fprintf(stderr, \"Error in huffman tree\\n\");\n		return -1;\n	}\n    // \n	if (length > 0) {\n		while (count = fread(inputBuffer,1,BUFFER_SIZE,inputFile)){\n		\n			if(1 == count && !(length % 8)) {\n				count = (length % 8);\n			}\n				for (i = 0; i < count; i++) {\n					// ???? ?? ?????? ???????? ? ???????? ?????\n					for (j = 0; j < 8; j++) {\n					//???? ?? ? ????? ?? ??? ????? ???????? ? ???????? ????? ?????? ??????? ??????????? ????? ?????\n\n						if ( curr->left == NULL && curr->right == NULL ) {\n							outputBuffer[outputBytePos++] = curr->letter;\n							// ???? ????? ?????????? ?? ?????????? ????? ?? ????\n							if (outputBytePos >= BUFFER_SIZE-1) {\n								fwrite(outputBuffer,1,outputBytePos,outputFile);\n								outputBytePos = 0;\n							}\n							// ??????? ? ?????? ?????????\n							curr = root;\n							length--;\n							if (length <=0) {\n								fwrite(outputBuffer, 1, outputBytePos, outputFile);\n								return 0;	\n							}\n						}\n						// ???? ?? ?? ? ????? ?? ???????? ??????? ??? ? ?????? ???? ???? ? ???? ??? ??????\n						bit = getBit(inputBuffer[i], j);\n						// ???? ??? ??????? ???? ??????, ? ????????? ?????? ???? ?????\n						if (bit && root->right) {\n							curr = curr->right;\n						} else if (root->left) {\n							curr = curr->left;\n						}\n					}\n				}\n			}\n			// ?????????? ??????? ???????? ??????\n			fwrite(outputBuffer,1,outputBytePos,outputFile);\n		\n	} else {\n\n		// ???? ????? ????? ????, ?? ??? ?????? ??? ??? ?????? ?? ????? ??????\n	}\n	\n	return 0;\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (848,'#include <stdio.h>\n#include <stdlib.h>\n#include \"huffman.h\"\n\nvoid showUsage(char **argv);\n\nint main (int argc, char **argv)\n{\n	FILE *inputFile, *outputFile;\n	unsigned int *dict;\n	Tree *arr;\n	size_t length = 0;                             // ?????????? ????????, ??????? ????????? ? ???????? ?????(inputFile)\n	unsigned char tmpCode[32] = \"\";\n	HuffmanCode code[256];\n	unsigned long filelength;\n\n	memset(code, 0, 256 * sizeof( HuffmanCode ) ); // ???????? ?????\n\n	if (argc < 4) {\n        showUsage(argv);     \n		exit (1);\n	}\n\n	inputFile = fopen(argv[2], \"rb\");\n	if( !inputFile ) {\n        fprintf(stderr, \"Error open input file\\n\");\n        exit(1);    \n    }\n    	\n	outputFile = fopen(argv[3],\"wb\");\n	if( !outputFile ) {\n		fprintf(stderr, \"Error while opening output file\");\n		exit(1);\n	}\n	switch (argv[1][0]) {\n		case \'c\':\n			dict = createFirstDict(inputFile);\n			arr = createPrimaryDict(dict,&length);\n			arr = createhuffmanTree(arr,length);\n			createHuffmanCode(tmpCode,arr,code,0);\n			//viewCode(code);\n			fseek(inputFile, 0L, SEEK_SET);\n			printHeaders(outputFile,getFileSize(argv[2]),dict);\n			huffmanCoder(inputFile,outputFile,code);\n		break;\n\n		case \'d\':\n			fread(&filelength,sizeof(size_t),1,inputFile);\n			dict = readDecodertDict(inputFile);\n			arr = createPrimaryDict(dict,&length);\n			arr = createhuffmanTree(arr,length);\n			huffmanDecoder(inputFile, outputFile, filelength, arr);\n		break;\n\n		default:\n                fprintf(stderr, \"Unknown action. Action must be \'c\' or \'d\'\\n\");\n			exit (4);\n	}\n\n	fclose(inputFile);\n	fclose(outputFile);\n	return 0;\n}\n\nvoid showUsage(char **argv)\n{\n		printf(\"\\n **************************<<HELP>>**************************\");\n		printf(\"\\n    Dobro pojalovat\' v programmu arhivacii dannyh\");\n		printf(\"\\n ************************************************************\");\n		printf(\"\\n Programma predostavljaet sledujuschie funkcii:\");\n		printf(\"\\n c - pomestit\' fajl v arhiv\");\n		printf(\"\\n d - izvlech\' fajl iz arhiva\");\n		printf(\"\\n **************************<<ENTER>>*************************\");\n		printf(\"\\n FORMAT VVODA: parametr InPutfile OutPutfile\");\n		printf(\"\\n ************************************************************\");\n		printf(\"\\n\");\n\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (849,'#include <stdio.h>\n#include \"huffman.h\"\n\n// ?????????? ??????? ??????????? ??????? ????????\nvoid orderDict(Tree *dict, size_t count) {\n	size_t i,j; \n	Tree tmp; // ?????? ????????? ???????, ??????? ?? ????? ?????????????\n	for (i = count; i > 0; i--) {\n		for (j = 0; j < i-1; j++) {\n			if (dict[j].count<dict[j+1].count) {\n				tmp = dict[j];\n				dict[j] = dict[j+1];\n				dict[j+1] = tmp;\n			}\n		}\n	}\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (850,'#include <stdio.h>\n#include \"huffman.h\"\n\n// ?????????? ??????? ????? ? ??????? ??????????? ? ???????? ????\nvoid printHeaders(FILE *inputFile, unsigned long fileLength, unsigned int *dict) {\n\n	if (!inputFile) return;\n	fwrite(&fileLength,sizeof(fileLength),1,inputFile);\n	fwrite(dict,sizeof(dict),256,inputFile);\n\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (851,'#include <stdio.h>\n#include <malloc.h>\n#include \"huffman.h\"\n\n// ?????? ???????????????? ??????? (??? ????????)\nunsigned int *readDecodertDict(FILE *inputFile) {\n	unsigned int *buffer = (unsigned int *) calloc(256,sizeof(unsigned int));\n	if (!buffer) {\n		printf(\"error allocate memory. file: %s function: %s line: %s\",__FILE__,__FUNCTION__,__LINE__);\n	}	\n	fread(buffer,sizeof(unsigned int),256,inputFile);\n	return buffer;\n\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (852,'#include <stdio.h>\n#include <stdlib.h>\n#include \"huffman.h\"\n\n// ?????????? ???? ? ?????????\n#define SIGNATURE_SIZE 2\n\nconst char signature[SIGNATURE_SIZE] = \"HA\";\n\nint readSignature(FILE *file) {\n	char buffer[SIGNATURE_SIZE];\n	size_t count;\n	int i;\n\n	if( NULL == file ) {\n		fprintf(stderr, \"Error in file\\n\");\n		return -1;\n	}\n\n	count = fread(buffer, 1, SIGNATURE_SIZE, file);\n	if( count < 1 ) {\n		return -1;\n	}\n\n\n	for( i = 0; i < SIGNATURE_SIZE; i++ ) {\n		if( signature[i] != buffer[i] ) {\n			return -1;\n		}\n	}\n\n	return 0;\n\n}\n\nvoid writeSignature(FILE *file) {\n	fwrite(signature, 1, SIGNATURE_SIZE, file);\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (853,'#include <stdio.h>\n#include \"huffman.h\"\n\n// ??????? ?????? ??????? ? ??????????????? ??? ????\n\nvoid viewCode(HuffmanCode *codeArray) {\n	unsigned int i,j;\n	for (i=0;i<256;i++) {\n		if (codeArray[i].bitCount != 0) {\n			printf(\"letter: %c,\\tbitCOunt: %d,\\tcode: \",i,codeArray[i].bitCount);\n			for (j=0;j<codeArray[i].bitCount;j++) {\n				printf(\"%d\",getBit(codeArray[i].code[((int) (j/8) )],j));\n			}\n			printf(\"\\n\");\n		}\n	}\n}','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (854,'#include \"head.h\"\r\n\r\nshort int GetFrequency(FILE *file, mint *freqtable) {\r\n	int a = 0;\r\n	unsigned char buffer[BUFF] = {0};\r\n\r\n	while (a = fread(buffer, 1, BUFF, file))\r\n		for (int i = 0; i < a; i++)\r\n			freqtable[buffer[i]]++;\r\n	\r\n	short int n = 0;\r\n	for (int i = 0; i < 256; i++)\r\n		if (freqtable[i])\r\n			n++;\r\n	return n;\r\n}\r\n\r\nvoid SortNode(node *head, node newnode) {	\r\n	if (!(*head)) {\r\n		*head = newnode;\r\n		return;\r\n	}\r\n\r\n	node p = *head;\r\n	node q = NULL;\r\n	int i = 0;\r\n	while (p) {\r\n		if (q == NULL) {\r\n			if (newnode->frequency <= p->frequency) {\r\n				*head = newnode;\r\n				newnode->next = p;\r\n				i++;\r\n			}\r\n		}\r\n		else {\r\n			if (newnode->frequency < p->frequency) {\r\n				q->next = newnode;\r\n				newnode->next = p;\r\n				i++;\r\n			}\r\n		}\r\n		if (i)\r\n			break;\r\n		q = p;\r\n		p = p->next;		\r\n	}\r\n	if (i == 0)\r\n		q->next = newnode;\r\n}\r\n\r\nvoid CreateSortList(mint *freqtable, node *head) {\r\n	for (int i = 0; i < 256; i++)\r\n		if (freqtable[i]) {\r\n			node newnode = (node) malloc(sizeof(*newnode));\r\n			assert(newnode);\r\n			newnode->list = true;\r\n			newnode->c = i;\r\n			newnode->frequency = freqtable[i];\r\n			newnode->next = NULL;\r\n			newnode->left = NULL;\r\n			newnode->right = NULL;\r\n			SortNode(head, newnode);\r\n		}\r\n}\r\n\r\nnode CreateTree(node *head) {\r\n	node p, q;\r\n\r\n	if ((p = *head) && !p->next) {\r\n		node newnode = (node) malloc(sizeof(*newnode));\r\n		assert(newnode);\r\n		newnode->list = false;\r\n		newnode->frequency = p->frequency;\r\n		newnode->left = p;\r\n		newnode->right = NULL;\r\n		newnode->next = NULL;\r\n		return newnode;\r\n	}\r\n\r\n	while (1) {\r\n		if (*head)\r\n			p = *head;\r\n		else\r\n			return NULL;\r\n		if (p->next)\r\n			q = p->next;\r\n		else\r\n			return *head;\r\n		*head = q->next;\r\n		p->next = NULL;\r\n		q->next = NULL;\r\n		node newnode = (node) malloc(sizeof(*newnode));\r\n		assert(newnode);\r\n		newnode->list = false;\r\n		newnode->frequency = p->frequency + q->frequency;\r\n		newnode->left = p;\r\n		newnode->right = q;\r\n		newnode->next = NULL;\r\n		SortNode(head, newnode);\r\n	}\r\n}\r\n\r\nvoid FreeTree(node Node) {\r\n	if (Node->list == true) {\r\n		free(Node);\r\n	} else {\r\n		FreeTree(Node->left);\r\n		FreeTree(Node->right);\r\n		free(Node);\r\n	}\r\n}\r\n\r\nmint CreateCodeTable(unsigned char **CodeTable, unsigned char *TmpCode, int length, node Node, mint newsize) {\r\n	if (Node->list == true) {\r\n		TmpCode[length] = 0;\r\n		CodeTable[Node->c] = (unsigned char *) malloc((length + 1)); //???????? ?????? ??? ???\r\n		strcpy((char *) CodeTable[Node->c], (const char *) TmpCode); //?????????? ?????????? ??? ? ?????\r\n		newsize += length * Node->frequency;\r\n		free(Node);\r\n	} else {\r\n		TmpCode[length] = \'1\';\r\n		//?????????? ? ?????????? ???? 1, ??????????? ??? ????? ?? 1, ????????? ???? ?????????? ??? ?????? ??????????\r\n		newsize = CreateCodeTable(CodeTable, TmpCode, length + 1, Node->left, newsize);\r\n		TmpCode[length] = \'0\';\r\n		//?????????? ? ?????????? ???? 0, ??????????? ??? ????? ?? 1, ????????? ???? ?????????? ??? ??????? ??????????\r\n		newsize = CreateCodeTable(CodeTable, TmpCode, length + 1, Node->right, newsize);\r\n		free(Node);\r\n	}\r\n\r\n	return newsize;\r\n}\r\n\r\nvoid FreeCodeTable(unsigned char **CodeTable) {\r\n	for (int i = 0; i < 256; i++)\r\n		if (CodeTable[i])\r\n			free(CodeTable[i]);\r\n}\r\n\r\nvoid ArchivingFile(FILE *file, FILE *archive, unsigned char **CodeTable) {\r\n	int wrtn = 0;\r\n	int len = 0;\r\n	int bytepos = 0;\r\n	int bitpos = 0;\r\n	unsigned char buf1[BUFF] = {0};\r\n	unsigned char buf2[BUFF] = {0};\r\n	int ch = 0;\r\n	\r\n	while (wrtn = fread (buf1, 1, BUFF, file)) {\r\n		for (int i = 0; i < wrtn; i++) {\r\n			ch = buf1[i];\r\n			len = strlen((const char *) CodeTable[ch]);\r\n			for (int j = 0; j < len; j++) {\r\n				if (CodeTable[ch][j] == \'1\')\r\n					buf2[bytepos] |= (1 << bitpos); //?????????? ??? 1\r\n				else\r\n					buf2[bytepos] &= ~(1 << bitpos); //?????????? ??? 0\r\n				if (++bitpos == 8) {\r\n					bitpos = 0;\r\n					bytepos++;\r\n					if (bytepos == BUFF) {\r\n						fwrite(buf2, 1, BUFF, archive);\r\n						bitpos = 0;\r\n						bytepos = 0;\r\n					}\r\n				}\r\n			}\r\n		}\r\n	}\r\n	//???????? ?? ????????????? ?????????? ?????\r\n	if (bytepos * 8 + bitpos > 0) {\r\n		if (bitpos > 0)\r\n			bytepos++;\r\n		fwrite(buf2, 1, bytepos, archive);\r\n	}\r\n}\r\n\r\nint GetBit(unsigned char c, int i) {\r\n	return ((c >> (7-i)) % 2);\r\n}\r\n\r\nvoid DeArchivingFile(FILE *file, FILE *archive, node root, mint size) {\r\n	int wrtn = 0;\r\n	int ii = 0;\r\n	unsigned char buf[BUFF], buf2[BUFF];\r\n	node p = root;\r\n	\r\n	while (wrtn = fread(buf, 1, BUFF, archive))\r\n		for (int i = 0; i < wrtn; i++)\r\n			for (int j = 7; j >= 0; j--) {\r\n				if (GetBit(buf[i], j) == 1)\r\n					p = p->left;\r\n				else\r\n					p = p->right;\r\n				if (p->list == true) {\r\n					buf2[ii] = p->c;\r\n					p = root;\r\n					if (++ii == BUFF) {\r\n						size -= ii;\r\n						fwrite(buf2, 1, ii, file);\r\n						ii = 0;\r\n					}\r\n				}\r\n			}\r\n	// ????????? ???????\r\n	fwrite(buf2, 1, size, file);\r\n}','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (855,'#ifdef _MSC_VER\r\n#define _CRTDBG_MAP_ALLOC\r\n#define _DEBUG 2\r\n#include <stdlib.h>\r\n#include <crtdbg.h>\r\n#else\r\n#include <stdlib.h>\r\n#endif\r\n\r\n#include \"head.h\"\r\n\r\nint main(int argc, char *argv[]) {\r\n	unsigned char check[8] = {0};\r\n	unsigned char TmpCode[256] = {0};\r\n	unsigned char buf[BUFF] = {0};\r\n	unsigned char *CodeTable[256];\r\n	for (int i = 0; i < 256; i++)\r\n		CodeTable[i] = NULL;\r\n	unsigned char tmp = 0;\r\n	short int nchar = 0;\r\n	node head = NULL;\r\n	node root = NULL;\r\n	mint freqtable[256] = {0};\r\n	mint freq = 0;\r\n	mint size = 0;\r\n\r\n	switch (argc) {\r\n		case 2 : \r\n			fprintf(stderr, \"error parameters\\n\");\r\n			break;\r\n		case 3 : {\r\n			FILE *archive = fopen(argv[1], \"wb\");\r\n			FILE *file = fopen(argv[2], \"rb\");\r\n			if (!file) {\r\n				fprintf(stderr, \"error archiving: input file is not exist\\n\");\r\n				return 0;\r\n			}\r\n			fwrite(\"huffman\", 7, 1, archive);\r\n			nchar = GetFrequency(file, freqtable);\r\n			fwrite(&nchar, 2, 1, archive);\r\n			//?????? ???? - ?????\r\n			if (nchar == 0) {\r\n				fprintf(stderr, \"empty input file\\n\");\r\n				return 0;\r\n			}\r\n			// ?????? ??????? ????????\r\n			for (int i = 0; i < 256; i++)\r\n				if (freqtable[i]) {\r\n					tmp = i;\r\n					fwrite(&tmp, 1, 1, archive);\r\n					fwrite(&(freqtable[i]), sizeof(mint), 1, archive);\r\n				}\r\n			CreateSortList(freqtable, &head);\r\n			root = CreateTree(&head);\r\n			//????? ??????? ?????????? ??????? ?????\r\n			if (root != NULL && root->right != NULL) \r\n				size = CreateCodeTable(CodeTable, TmpCode, 0, root, 0);\r\n			else\r\n				if (root != NULL && root->left != NULL) {\r\n					CodeTable[root->left->c] = (unsigned char *) malloc(sizeof(char));\r\n					CodeTable[root->left->c][1] = 0;\r\n					CodeTable[root->left->c][0] = \'1\';\r\n					size = root->left->frequency;\r\n				}\r\n			fseek(file, 0, SEEK_SET);\r\n			ArchivingFile(file, archive, CodeTable);\r\n			fclose(archive);\r\n			fclose(file);\r\n			FreeCodeTable(CodeTable);\r\n			break;\r\n		}\r\n		case 4 : {\r\n			if (strcmp(argv[1], \"-d\")) {\r\n				fprintf(stderr, \"error parametrs\\n\");\r\n				return 0;\r\n			}\r\n			FILE *file = fopen(argv[3], \"wb\");\r\n			FILE *archive = fopen(argv[2], \"rb\");\r\n			if (!archive) {\r\n				fprintf(stderr, \"error dearchiving: archive \\\"%s\\\" is not exist\\n\", argv[2]);\r\n				return 0;\r\n			}\r\n			fread(check, 7, 1, archive);\r\n			if (strncmp(\"huffman\", (const char *) check, 7)) {\r\n				fprintf(stderr, \"error dearchiving: archive \\\"%s\\\" is damaged\\n\", argv[2]);\r\n				return 0;\r\n			}\r\n			fread(&nchar, 2, 1, archive);\r\n			// ?????? ????? - ?????\r\n			if (!nchar) {\r\n				fprintf(stderr, \"empty archive\\n\");\r\n				return 0;\r\n			}\r\n			// ?????? ??????? ????????\r\n			for (int i = 0; i < nchar; i++) {\r\n				fread(&tmp, 1, 1, archive);\r\n				fread(&(freqtable[tmp]), sizeof(mint), 1, archive);\r\n				size += freqtable[tmp];\r\n			}\r\n			CreateSortList(freqtable, &head);\r\n			root = CreateTree(&head);\r\n			// ????????????\r\n			DeArchivingFile(file, archive, root, size);\r\n			fclose(archive);\r\n			fclose(file);\r\n			FreeTree(root);\r\n			break;\r\n		}\r\n	}\r\n\r\n	#ifdef _MSC_VER\r\n		_CrtDumpMemoryLeaks();\r\n	#endif\r\n\r\n	return 0;\r\n}','Ð˜Ð»ÑŒÑ','Ilya','m');
INSERT INTO `bias` VALUES (856,'#include \"haff.h\"\r\n\r\nvoid add (int arg_c, char* arg_v[])\r\n{\r\n	unsigned char buffer[256] = {0}, tmp;\r\n	data ABC[256];\r\n	int A[257];\r\n	int file_size = 0;\r\n	int counter=0, number = 0;\r\n	tree *root;\r\n	FILE *input = NULL, *output = NULL;\r\n	char FIRST[5] = {\'h\', \'a\', \'f\', \'f\', 0};\r\n	int summ = 0,i,length;\r\n\r\n	input = fopen(arg_v[3], \"rb\");\r\n	output = fopen(arg_v[2], \"wb\");\r\n	if (!input || !output) print_error;\r\n\r\n	count(input,ABC);\r\n	root = make_tree(ABC);\r\n	if (root == NULL) return;\r\n	get_code(ABC, root, 0, A);\r\n	\r\n	fwrite(FIRST, 1, 4, output);\r\n\r\n	fwrite(&summ, sizeof(int), 1, output);\r\n\r\n	/*length = strlen(arg_v[3]);\r\n	while (arg_v[3][length] != \'\\\\\' && length != -1)\r\n		length--;\r\n	fwrite(arg_v[3]+length+1, 1, strlen(arg_v[3] + length + 1), output);*/\r\n\r\n	file_size = root->weight;\r\n	if (file_size == 0) return;\r\n\r\n	fwrite(&file_size, sizeof(int), 1, output);\r\n\r\n	for (i=0; i<256; i++)\r\n	{\r\n		if (ABC[i].frequency != 0)\r\n		{\r\n			counter++;\r\n		}\r\n	}\r\n	fwrite (&counter, sizeof(int), 1, output);\r\n\r\n	for (i=0; i<256; i++)\r\n	{\r\n		if(ABC[i].frequency != 0)\r\n		{\r\n			fwrite(&ABC[i].symbol, 1, 1, output);\r\n			fwrite(&ABC[i].frequency, sizeof(int), 1, output);\r\n		}\r\n	}\r\n\r\n	fseek(input, 0, SEEK_SET);\r\n	while (1)\r\n	{\r\n		fread(&tmp, 1, 1, input);\r\n		if(feof(input)) break;\r\n		if(number + ABC[tmp].bits >= 8*256)\r\n		{\r\n			fwrite (buffer, 1, number/8, output);\r\n			for (i=0; i<256-number/8; i++)\r\n				buffer[i] = buffer[number/8+i];\r\n			for (i=256-number/8; i<256; i++)\r\n				buffer[i] = 0;\r\n			number %= 8;\r\n		}\r\n		for (i=0; i<(ABC[tmp].bits+7)/8-1; i++)\r\n		{\r\n			buffer[number/8] |= ABC[tmp].code[i] >> number%8;\r\n			buffer[number/8+1] |= ABC[tmp].code[i] << (8-number%8);\r\n			number += 8;\r\n		}\r\n		buffer[number/8] |= ABC[tmp].code[i] >> number%8;\r\n		buffer[number/8+1] |= ABC[tmp].code[i] << (8-number%8);\r\n		number += ABC[tmp].bits%8==0 ? 8 : ABC[tmp].bits%8;\r\n	}\r\n\r\n	fwrite (buffer, 1, (number+7)/8+1, output);\r\n\r\n	fclose(input);\r\n	fclose(output);\r\n\r\n	output = fopen(arg_v[2], \"rb+\");\r\n	fseek(output, 4+sizeof(int), SEEK_SET);\r\n	summ = get_summ (output);\r\n	fseek(output, 4, SEEK_SET);\r\n	fwrite(&summ, sizeof(int), 1, output);\r\n	return;\r\n}\r\n\r\nint get_summ (FILE *f)\r\n{\r\n	int i, summ = 0, k = 0, d = 1;\r\n	unsigned char buf[512];\r\n	do\r\n	{\r\n		k = fread(buf, 1, 512, f);\r\n		for(i=0; i<k; i++)\r\n		{\r\n			summ += buf[i]*(d++);\r\n		}\r\n	}\r\n	while (k==512);\r\n	return summ;\r\n}\r\n\r\nvoid count(FILE *f, data *ABC)\r\n{\r\n	unsigned char buffer[512];\r\n	int i, k;\r\n	unsigned char a;\r\n	for (i=0; i<256; i++)\r\n	{\r\n		ABC[i].frequency = 0;\r\n		ABC[i].symbol = i;\r\n	}\r\n	do\r\n	{\r\n		k = fread(buffer, 1, 512, f);\r\n		for (i=0; i<k; i++)\r\n		{\r\n			a = buffer[i];\r\n			ABC[a].frequency++;\r\n		}	\r\n	}\r\n	while (k == 512);\r\n	return;\r\n}\r\n\r\ntree* make_tree(data *ABC)\r\n{\r\n	tree *root;\r\n	tree **Mas, *q;\r\n	int i,k=0,s=0;\r\n	for(i=0; i<256; i++)\r\n	{\r\n		if (ABC[i].frequency != 0)\r\n			k++;\r\n	}\r\n	if (k == 0) return NULL;\r\n	Mas = (tree **)malloc (sizeof(tree *)*k);\r\n	for (i=0; i<256; i++)\r\n	{\r\n		if (ABC[i].frequency != 0)\r\n		{\r\n			Mas[s] = (tree *)malloc(sizeof(tree));\r\n			Mas[s]->weight = ABC[i].frequency;\r\n			Mas[s]->left = NULL;\r\n			Mas[s]->right = NULL;\r\n			Mas[s]->symbol = ABC[i].symbol;\r\n			s++;\r\n		}\r\n	}\r\n	while (k != 1)\r\n	{\r\n		sort(Mas,k);\r\n		root = (tree*)malloc(sizeof(tree));\r\n		root->right = Mas[k-1];\r\n		root->left = Mas[k-2];\r\n		if (root->left && root->right)\r\n			root->weight = root->left->weight + root->right->weight;\r\n		Mas[k-2] = root;\r\n		k--;\r\n	}\r\n	return Mas[0];\r\n}\r\n\r\nvoid get_code(data *ABC, tree *root, int size, int *A)\r\n{\r\n	if (root->left)\r\n	{\r\n		A[size] = 0;\r\n		get_code(ABC, root->left, size+1, A);\r\n	}\r\n	if (root->right)\r\n	{\r\n		A[size] = 1;\r\n		get_code(ABC, root->right, size+1, A);\r\n	}\r\n	if (root->left == NULL && root->right == NULL)\r\n	{\r\n		set_bits(ABC,root,size,A);\r\n	}\r\n	return;\r\n}\r\n\r\nvoid set_bits(data *ABC, tree *root, int size, int *A)\r\n{\r\n	int i;\r\n	int new_size = (size+7)/8;\r\n	unsigned char a = root->symbol;\r\n	ABC[a].code = (unsigned char*)malloc(new_size);\r\n	ABC[a].bits = size;\r\n	for (i=0; i<new_size; i++)\r\n		ABC[a].code[i] = 0;\r\n	for (i=0; i<size; i++)\r\n		set_one_bit (ABC[a].code+i/8, i%8, A[i]);\r\n#ifdef DEBUG\r\n	for (i = 0; i<size; i++)\r\n		printf(\"%d\", A[i]);\r\n	printf(\" - %c (%d)\\n\", ABC[a].code[0], ABC[a].code[0]);\r\n#endif\r\n}\r\n\r\nint set_one_bit (unsigned char *a, int n, int value)\r\n{\r\n	unsigned char b = 1;\r\n	b <<= 7-n;\r\n	if (value == 1)\r\n		*a |= b;\r\n	if (value == 0)\r\n		*a &= ~b;\r\n	return 1;\r\n}\r\n\r\nvoid swap (tree** a, int i, int k) \r\n{\r\n	tree* tmp = a[i];\r\n	a[i] = a[k];\r\n	a[k] = tmp;\r\n}\r\n\r\nvoid sort(tree**a, int n)\r\n{\r\n  int i, j;\r\n  for (i = n - 1; i >= 0; i--)\r\n  {\r\n    for (j = 0; j < i; j++)\r\n    {\r\n		if (a[j]->weight < a[j + 1]->weight) \r\n        swap( a,j, j + 1 );\r\n    }\r\n  }\r\n}\r\n\r\nvoid print_error()\r\n{\r\n	printf(\"error\");\r\n}\r\n\r\n','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (857,'#include \"haff.h\"\r\n\r\n//#define get_bit (c,i) (c>>(7-i))%2\r\n\r\nvoid de_archivate (int arg_c, char* arg_v[])\r\n{\r\n	\r\n	unsigned char test[5] = {0};\r\n	unsigned char buf[5] = {\'h\', \'a\', \'f\', \'f\', 0};\r\n	int i, summ = 0;\r\n	FILE *input = NULL;\r\n	FILE *output = NULL;\r\n	\r\n	input = fopen(arg_v[2], \"rb\");\r\n	output = fopen(arg_v[3], \"wb\");\r\n\r\n	if (!input || !output) print_error();\r\n	//fseek(input, 0, SEEK_SET);\r\n	/*for (i=0; i<4; i++)\r\n	{\r\n		fscanf(input, \"%c\", &test[i]);\r\n	}*/\r\n\r\n	fread(test, 1, 4, input);\r\n	if (strcmp((char *)test, (char *)buf)) print_error();\r\n\r\n	fread(&summ, sizeof(int), 1, input);\r\n	if (summ != get_summ(input)) print_error();\r\n	fseek(input,4+sizeof(int),SEEK_SET);\r\n	extract (input,output);\r\n\r\n	return;\r\n}\r\n\r\n\r\nvoid extract (FILE *arch, FILE *output)\r\n{\r\n	unsigned char c, k;\r\n	data ABC[256];\r\n	tree *root, *p;\r\n	int i, size = 0, kol = 0, e;\r\n\r\n	fseek(arch, 4 + sizeof(int), SEEK_SET);\r\n	fread(&size, sizeof(int), 1, arch);\r\n	fread(&kol, sizeof(int), 1, arch);\r\n	\r\n	for (i=0; i<256; i++)\r\n	{\r\n		ABC[i].frequency = 0;\r\n	}\r\n\r\n	for (i=0; i<kol; i++)\r\n	{\r\n		fread(&k, 1, 1, arch);\r\n		fread(&ABC[k].frequency, sizeof(int), 1, arch);\r\n		ABC[k].symbol = k;\r\n	}\r\n\r\n	root = make_tree (ABC);\r\n	p = root;\r\n\r\n	while (size)\r\n	{\r\n		fread(&c, 1, 1, arch);\r\n		if (feof(arch)) return;\r\n		for (i=0; i<8; i++)\r\n		{\r\n			e = get_bit (c,i);\r\n			if (size == 0) break;\r\n			if (e == 1)\r\n			{\r\n				if (p->right)\r\n					p = p->right;\r\n			}\r\n			if (e == 0) \r\n			{\r\n				if (p->left)\r\n					p = p->left;\r\n			}\r\n			if (p->left == NULL && p->right == NULL){\r\n				fputc(p->symbol, output);\r\n				p = root;\r\n				size--;\r\n			}\r\n			\r\n		}\r\n		\r\n	}\r\n}\r\n\r\nint get_bit (unsigned char c, int i)\r\n{\r\n	int e;\r\n	e = (c>>(7-i))%2;\r\n	return e;\r\n}','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (858,'#include \"haff.h\"\r\n\r\nint main (int argc, char* argv[])\r\n{\r\n	if (argc == 1)\r\n		print_error();\r\n	else\r\n	{\r\n	if (argv[1][0] == \'a\')\r\n		if (argc == 4)\r\n			add(argc, argv);\r\n		else print_error();\r\n	if (argv[1][0] == \'x\')\r\n		if (argc == 4)\r\n			de_archivate(argc, argv);\r\n		else print_error();\r\n	}\r\n}','Ð”Ð°Ñ€ÑŒÑ','Daria','f');
INSERT INTO `bias` VALUES (859,'#include<stdio.h>\n#include<stdlib.h>\n#define N 256\nstruct item{\n	int c;\n	int count;\n	unsigned char *a;\n	int len;\n	struct item *left;\n	struct item *rigth;\n};\ntypedef struct item tree;\nint intcmp ( const void *a1, const void *a2 )\n{\n	tree *p1, *p2;\n	p1 = (tree *)a1;\n	p2 = (tree *)a2;\n	return (p2->count - p1->count );\n}\ntree *H_tree ( tree *n, int cnt )\n{\n	tree *p, nul, node[N];\n	int i, num;\n	nul.count = 0;\n	for ( i = 0; i < N; i++)\n	{\n		node[i] = n[i];\n	}\n	if( cnt == 1 )\n	{\n		qsort( node, N, sizeof(node[0]), intcmp );\n		p = malloc( sizeof(tree) );\n		p->c = node[0].c;\n		p->count = node[0].count;\n		p->left = NULL;\n		p->rigth = NULL;\n		node[0].c = -1;\n		node[0].left = p;\n		node[0].rigth =NULL;\n		p = malloc(sizeof(tree));\n		p->left = node[0].left;\n		p->rigth = node[0].rigth;\n		p->c = node[0].c;\n		p->count = node[0].count; \n		return p;\n	}\n	num = cnt;\n	if ( cnt == 0 )\n	{\n		return NULL;\n	}\n	while ( cnt != 1 )\n	{\n		qsort( node, N, sizeof(node[0]), intcmp );\n		p = malloc ( sizeof (tree) );\n		p->c = node[num-1].c;\n		p->count = node[num-1].count;\n		p->left = node[num-1].left;\n		p->rigth = node[num-1].rigth;\n		node[num-1].left = p;\n		p = malloc ( sizeof (tree) );\n		p->c = node[num-2].c;\n		p->count = node[num-2].count;\n		p->left = node[num-2].left;\n		p->rigth = node[num-2].rigth;\n		node[num-1].rigth = p;\n		node[num-1].count = node[num-1].left->count + node[num-1].rigth->count;\n		node[num-1].c = -1;\n		node[num-2].count = 0;\n		cnt--;\n		num--;\n	}\n	qsort( node, N, sizeof(node[0]), intcmp );\n	p = malloc( sizeof ( tree ) );\n	p->left = node[0].left;\n	p->rigth = node[0].rigth;\n	p->count = node[0].count;\n	p->c = node[0].c;\n	return p;\n}\nint Fib ( int count )\n{\n	int f0 = 1, f1 = 1,fn;\n	for (;;)\n	{\n		fn = f0 + f1;\n		f0 = f1;\n		f1 = fn;\n		if ( fn > count )\n			break;\n	}\n	return f1;\n}\nvoid Kod ( tree *node, tree *head, char *a, int pos )\n{\n	int i;\n	if ( !head )\n		return;\n	if ( head->c != -1 )\n	{\n		node[head->c].a = calloc( pos,1);\n		node[head->c].len = pos;\n		for( i = 0; i < pos; i++ )\n		{\n			node[head->c].a[i] = a[i];\n		}\n		a[pos-1] = 0;\n		return;\n	}\n	a[pos] = 0;\n	Kod ( node, head->left, a, ++pos );\n	pos--;\n	a[pos] = 1;\n	Kod ( node, head->rigth, a, ++pos );\n	return;\n}\nvoid Free ( tree *head )\n{\n	if ( head == NULL )\n		return;\n	Free ( head->left );\n	Free ( head->rigth );\n	free ( head );\n}\nvoid Archiv ( FILE *f, FILE *fo )\n{\n	int i, c, Count = 0, cnt_sim = 0, k = 7, len,j, leng;\n	unsigned char *a, str[8], bit=0;\n	tree node[N], *head;\n	for ( i = 0; i < N; i++ )\n	{\n		node[i].count = 0;\n		node[i].left = NULL;\n		node[i].rigth = NULL;\n	}\n	while ( ( c = fgetc(f)) != EOF )\n	{\n		node[c].c = c;\n		if( node[c].count == 0 )\n			cnt_sim++;\n		node[c].count++;\n		Count++;\n	}\n	rewind(f);\n	head = H_tree( node, cnt_sim );\n	if ( head == NULL )\n		return;\n	len = Fib ( Count );\n	a = calloc( len, 1 );\n	Kod ( node, head, a, 0 );\n	fprintf(fo, \"%d \",cnt_sim );\n	for ( i = 0; i < N; i++ )\n	{\n		if ( node[i].count != 0 )\n			fprintf(fo,\"%c%d \",i,node[i].count);\n	}\n	while ( ( c = fgetc(f) ) != EOF )\n	{\n		for ( j = 0; j < node[c].len; j++ )\n		{\n			if ( node[c].a[j] == 1 )\n					bit |= ( 1 << k );\n				else\n					bit &= ~( 1 << k);\n			if ( k == 0 )\n			{\n				fprintf(fo,\"%c\",bit);\n				k = 7;\n				bit = 0;\n			}\n			else k--;\n		}\n		\n	}\n	if( k != 0 )\n		fprintf(fo,\"%c\",bit);\n	Free( head );				\n	for( i = 0; i < N; i++ )\n	{\n		if ( node[i].count != 0 )\n		{\n			free(node[i].a);\n		}\n	}\n	free( a );			\n}\nvoid deArchiv ( FILE *f, FILE *fo )\n{\n	tree node[N], *head, *p;\n	int c, qw = 0,count_sim = 0, count = 0, fl_sim = 0, sim, a = 0, i,pos = 7, len = 0;\n	unsigned char bit = 0;\n	for ( i = 0; i < N; i++ )\n	{\n		node[i].count = 0;\n		node[i].left = NULL;\n		node[i].rigth = NULL;\n	}\n	while( count != count_sim || ( count_sim == 0 ) )\n	{\n		c = fgetc( f );\n		if( c == EOF )\n			return;\n		if ( count_sim == 0 ) \n		{\n			if( c != \' \')\n				a = a * 10 + c - \'0\';\n			else\n			{\n				count_sim = a;\n				a = 0;\n			}\n			continue;\n		}\n		if ( !fl_sim )\n		{\n			sim = c;\n			fl_sim = 1;\n		}\n		else\n		{\n			if( c != \' \' )\n				a = a * 10 + c - \'0\';\n			else\n			{\n				node[sim].c = sim;\n				node[sim].count = a;\n				len += a;\n				a = 0;\n				fl_sim = 0;\n				count++;\n			}\n		}\n	}\n	\n	head = H_tree( node, count_sim );\n	p = head;\n	count = 0;\n	\n	while ( ( fscanf(f, \"%c\",&bit ) ) == 1 )\n	{	\n		for( i = 7; i >= 0; i-- )\n		{\n			if( count >= len )\n					break;\n			if ( p->c != -1 )\n			{\n				\n				fprintf( fo, \"%c\", p->c );\n				count++;\n				p = head;\n				qw++;\n			}\n			if ( ( bit >> i ) & 1 )\n				p = p->rigth;\n			else \n				p = p->left;\n		}\n	}\n	\nFree( head );\n}\n\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (860,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\nint seek_BM ( unsigned char *q, unsigned char *s )\n{\n	int d[256] = {0}, i, k = 1,j;\n	int M = strlen(q);\n	int N = strlen(s);\n	d[(unsigned char)q[M-1]] = M;\n	for( i = 0; i < 256; i++ )\n	d[i] = M;\n	for ( i = M-2; i >= 0; i-- )\n	{\n		 if( d[(unsigned char)q[i]] == M )\n	 	 d[(unsigned char)q[i]] = k;\n 		 k++;\n 	}\n	i = M-1;\n	do\n	{\n		j = M-1;\n		k = i;\n		while( j >= 0 && q[j]==s[k])\n		{\n			j--;\n			k--;\n		}\n		if( j < 0 )\n			return k+1;\n		i += d[( unsigned char )s[i]];\n	}\n	while( i < N );\n	return -1;\n}\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (861,'#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include\"Huf.h\"\nint main ( int argc, char *argv[] )\n{\n	FILE *f1, *f2;\n	char *key= \"-d\", *tail = \".huf\",*newname = NULL, *tmp;\n	int flag = 0;\n	if ( argc == 2)\n	{\n		f1 = fopen(argv[1],\"r\");\n		if(!f1)\n		{\n			perror(\"fopen\");\n			return 0;\n		}\n		 newname = malloc(strlen(argv[1])+5);\n		 if ( !newname )\n		 {\n			 perror(\"malloc\");\n			 return 0;\n		 }\n		 strcpy(newname, argv[1]);\n		 strcat(newname,tail);\n		 f2 = fopen( newname,\"w\");\n		Archiv ( f1, f2 );\n		fclose(f1);\n		fclose(f2);\n		free(newname);\n	}\n	if ( argc == 3 )\n	{\n		if( strcmp (key, argv[1]) == 0 )\n		 {\n			 flag = seek_BM ( (unsigned char *)tail,(unsigned char *)argv[2]);\n			 if( flag == -1 )\n			 {\n				 printf(\" Filename without .huf \\n\");\n				 return 0;\n			 }\n			 f1 = fopen ( argv[2],\"r\" );\n			 if(!f1)\n			 {\n				 perror(\"fopen\");\n				 return 0;\n			 }\n			 newname = malloc(strlen(argv[2])+5);\n			 if ( !newname )\n			 {\n				 perror(\"malloc\\n\");\n				 return 0;\n			 }\n			 strcpy(newname,argv[2]);\n			 newname[flag] = \'.\';\n			 newname[flag+1] = \'n\';\n			 newname[flag+2] = \'e\';\n			 newname[flag+3] = \'w\';\n			 newname[flag+4] = 0;\n			 f2 = fopen( newname,\"w\");\n			 deArchiv ( f1, f2 );\n			 fclose(f1);\n			 fclose(f2);\n			 free(newname);\n		 }\n		 else \n			printf(\"Error: %s - unknown parametr \\n\",argv[1]);\n	}\n	return 0;\n}\n\n','Ð’ÐµÑ€Ð°','Vera','f');
INSERT INTO `bias` VALUES (862,'\n\n#include \"include.h\"\n#include \"structures.h\"\n#include \"generators.h\"\n\n\nnode *producetree(list *head) {\n	node *result;\n\n	while (head->next) {\n		node *one = head->data;\n		node *two = head->next->data;\n		head = addtolist(delfirst(delfirst(head)), createnode(one,two));\n	}\n	result = head->data;\n	delfirst(head);\n\n	return result;\n}\n\nint *genptable(FILE *in) {\n  int *tbl = (int*) calloc(sizeof(int),256); \n	unsigned char c = 0;\n	while (fscanf(in, \"%c\", &c)==1) tbl[c]++;\n\n	fseek(in, 0, SEEK_SET);\n\n	return tbl;\n};\n\nlist *genlist(int *tbl) {\n  list *head = 0;\n	int i = 0;\n\n	for (i = 0; i < 256; i++) if (tbl[i]) head = addtolist(head, createleaf(i,tbl[i]));\n	\n	return head;\n};\n\nlong long revcode(long long code, int len) {\n  long long result = 0;\n	while (len--) { \n		result = result*2 + code % 2;\n		code /= 2;\n	}\n	return result;\n}\n\nvoid genhtable(node *root, huffcode *table, long long code, int len) {\n	if (!root->left) { 		table[root->letter].code = revcode(code,len);\n		table[root->letter].len = len;\n	} else {\n	  genhtable(root->left, table, code * 2, len + 1);\n	  genhtable(root->right, table, code * 2 + 1, len + 1);\n	}\n};\n\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (863,'#include \"include.h\"\n#include \"pack.h\"\n#include \"unpack.h\"\n\n\nvoid usage(char *name) {\n		printf(\"Usage: %s a|x HFILE FILE\\n\\n\", name);\n		exit(1);\n}\n\n\nint main (int argc, char* argv[]) {\n  if (argc !=4) usage(argv[0]);\n\n	switch (argv[1][0]) {\n    case \'a\': pack(argv[3], argv[2]);\n							break;\n		case \'x\': unpack(argv[2], argv[3]);\n							break;\n		default: usage(argv[0]);\n	}\n\n	return 0;\n};\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (864,'\n\n#include \"include.h\"\n#include \"structures.h\"\n#include \"generators.h\"\n#include \"pack.h\"\n#include \"tables.h\"\n\n\n\nextern int errno;\n\nint pows[17] = { 1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536 };\n\n\nvoid puttable(int *cTBL, FILE *out) {\n#ifdef __debug_p\n	printf(\"puttable:\\n\");\n#endif\n  int i;\n	for (i = 0; i < 256; i++) if (cTBL[i]) {\n#ifdef __debug_p\n		printf (\"%c (%d) : %d\\n\", i,i, cTBL[i]);\n#endif\n		fprintf(out, \"%c\", i);\n		fwrite(&cTBL[i], sizeof(int), 1, out);\n	}\n 	fprintf(out, \"%c%c%c%c%c\", 0,0,0,0,0);\n};\n\nvoid pack(char * ffrom, char* fto) {\n  FILE *in, *out;\n  int *cTBL;\n	huffcode hTBL[256] ={0};\n	node *ptree;\n	unsigned char letter;\n	long long code = 0, newcode = 0;\n  int	len=0, ulen = 0, plen = 0;\n	char buff = 0;\n\n	in = fopen (ffrom, \"r\");\n	if (in == 0) {\n		fprintf(stderr, \"Could not open file %s for reading: (%d) %s\\n\\n\", ffrom, errno, strerror(errno));\n		exit(1);\n	}\n	\n	out = fopen (fto, \"w\");\n	if (out == 0) {\n		fprintf(stderr, \"Could not open file %s for writing: (%d) %s\\n\\n\", fto, errno, strerror(errno));\n		exit(1);\n	}\n\n	fseek(in, 0, SEEK_END); 	int size = ftell(in);\n	fseek(in, 0, SEEK_SET); \n\n\n	fwrite(&size, sizeof(int), 1, out);\n\n	if (size==0) goto end;\n\n	\n  cTBL = genptable(in);\n\n	char only = 2;\n	int onlyval = 0; int onlycount = 0;\n	int i = 0;\n	for (i = 0; i < 256; i++) { \n		if (cTBL[i]) {\n			only--; \n			onlyval = i; \n			onlycount = cTBL[i]; \n		} \n		if (!only) break; \n	}\n  fwrite (&only, 1, 1, out);\n	if (only == 1 ) {\n		fwrite(&onlyval, sizeof(int), 1, out);\n		fwrite(&onlycount, sizeof(int), 1, out);\n	} else {\n	puttable(cTBL, out);\n#ifdef __debug_c\n	printcTBL(cTBL);\n#endif\n	ptree = producetree(genlist(cTBL));\n\n	genhtable(ptree, hTBL, 0, 0);\n#ifdef __debug_h\n	printhTBL(hTBL);\n#endif\n\n\n	while (fscanf(in, \"%c\", &letter) == 1) {\n#ifdef __debug\n		printf(\"%d \", letter);\n#endif\n		long long lcode = hTBL[letter].code;\n		int llen = hTBL[letter].len;\n		plen += llen;\n		ulen += 1;\n		while (llen > 0) {\n			buff *= 2; buff += lcode % 2; \n#ifdef __debug_b\n			printf(\"%c\", lcode % 2 + 48); \n#endif\n			lcode /= 2;\n			len++; llen--;\n			if (len == 8) {\n				fwrite(&buff,1,1,out);\n				buff = 0; len = 0;\n			}\n\n		}\n\n	};\n	if (len > 0 ) {  while (len++!=8) buff*=2; fwrite(&buff,1,1,out); }\n	\n	size = ftell(out);\n\n	printf(\"\\n%d bytes converted to %d bits (%d bytes). Result size: %d bytes. Compression: %d%%\\n\", ulen, plen, plen / 8 + (plen % 8 ? 1 : 0), size, 100*size/ulen);\n	}\nend:\n	fclose(in);\n	fclose(out);	\n};\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (865,'#include \"include.h\"\n#include \"structures.h\"\n\n\nnode *createleaf(int letter, int count) {\n  node *result = (node*) calloc(sizeof(node),1);\n\n	result->letter = letter;\n	result->count = count;\n\n	return result;\n}\n\nnode *createnode(node *one, node *two) {\n  node *result = (node*) calloc(sizeof(node),1);\n\n	result->left = one;\n	result->right = two;\n	one->parent = two->parent = result;\n	result->count = one->count+two->count;\n\n	return result;\n}\n\n\n\nlist *createlistnode(node *item, list *next) { \n  list *result = (list*) calloc(sizeof(list),1);\n	\n	result->data = item;\n	result->next = next;\n\n	return result;\n}\n\n\nlist *addtolist(list *head, node* item) {\n	list *p = head;\n  if (!head || head->data->count > item->count) return createlistnode(item, head);\n	\n	while (p->next && p->next->data->count < item->count) p = p->next;\n\n	p->next = createlistnode(item,p->next);\n\n	return head;\n}\n\n\n\nlist *delfirst(list *head) { \n	list *p = head->next;\n	free (head);\n	return p;\n}\n	\n\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (866,'\n#include \"include.h\"\n#include \"structures.h\"\n#include \"tables.h\"\n\nvoid printcTBL(int *cTBL) {\n	printf(\"cTBL:\\n\");\n	int i;\n	for (i = 0; i < 32; i++) if (cTBL[i]) printf(\"%3d: %6d\\n\", i, cTBL[i]);\n  for (i = 32; i < 256; i++) if (cTBL[i]) printf(\"%3d (\'%c\'): %6d\\n\", i, i, cTBL[i]);\n}\n\nchar *bitcode(int code, int len) {\n	char *res = (char*) calloc(sizeof(char),len+1);\n	int i = 0;\n	for (i = 0; i < len; i++) {\n		res[i] = code % 2 + 48;\n		code /= 2;\n  }\n	return res;\n}\n\nvoid printhTBL(huffcode *hTBL) {\n  printf(\"hTBL:\\n\");\n	int i;\n	for (i = 0; i < 32; i++) if (hTBL[i].len) printf(\"%d: (%d) \'%s\'\\n\", i, hTBL[i].len, bitcode(hTBL[i].code, hTBL[i].len));\n	for (i = 32; i < 256; i++) if (hTBL[i].len) printf(\"%d (\'%c\'): (%d) \'%s\'\\n\", i, i, hTBL[i].len, bitcode(hTBL[i].code, hTBL[i].len));\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (867,'\n\n#include \"include.h\"\n#include \"structures.h\"\n#include \"generators.h\"\n#include \"unpack.h\"\n#include \"tables.h\"\n\n\nchar getnextbit(FILE *in) {\n  static int leftbytes = 0;\n	static int t = 0;\n	int i = 0, k = 0;\n	unsigned char r = 0, res = 0;\n  if (leftbytes == 0) {\n		fread(&r,1,1,in);\n		k = (unsigned char) r;\n		t = 0;\n		for (i = 0; i < 8; i++) { t = t*2 + k % 2; k /= 2; }\n		leftbytes = 8;\n	}\n	res = t % 2;\n	t /= 2;\n	leftbytes--;\n	return res;\n}\n\nvoid unpack(char * ffrom, char* fto) {\n   FILE *in = 0, *out = 0;\n	 int cTBL[256] = {0};\n	 int size = 0, count = 0, read = 0;\n	 unsigned char letter = 0;\n	 node *ptree = 0;\n\n	 in = fopen (ffrom, \"r\");\n	 if (!in) {\n		 fprintf(stderr, \"Error opening file %s for reading: %s (%d)\\n\", ffrom, strerror(errno),errno);\n		 exit(1);\n	 }\n\n	 out = fopen (fto, \"w\");\n	 if (!out) {\n		 fprintf(stderr, \"Error opening file %s for writing: %s (%d)\\n\", fto, strerror(errno), errno);\n		 exit(1);\n	 }\n\n	 fread (&size, sizeof(int),1, in);\n\n	 if (size==0) goto end; 	 \n	 char only;\n	 fread (&only, 1, 1, in);\n	 if (only==1) {\n		 int onlyval, onlycount;\n		 fread(&onlyval, sizeof(int), 1, in);\n		 fread(&onlycount, sizeof(int), 1, in);\n		 int i = 0;\n		 for (i = 0; i < onlycount; i++) fprintf(out, \"%c\", onlyval);\n		 goto end;\n	 }\n	 \n	 do {\n		 fread(&letter, 1,1, in);\n		 fread(&count, sizeof(int),1, in);\n		 \n		 if (count != 0) cTBL[letter] = count;\n\n	 } while (count != 0);\n#ifdef __debug_c\n   printcTBL(cTBL);\n#endif\n   ptree = producetree(genlist(cTBL));\n\n	 node *pnode = ptree;\n	 while (read < size) {\n		 char c = getnextbit(in);\n#ifdef __debug_b\n		 printf(\"%c\", c+48);\n#endif \n		 pnode = c ? pnode->right : pnode->left;\n\n		 if (!pnode->left) {\n#ifdef __debug\n			 printf(\"%d \", pnode->letter);\n#endif\n			 fprintf(out, \"%c\", pnode->letter);\n			 pnode = ptree;\n			 read++;\n		 }\n	 }\nend:\n	 fclose(in);\n	 fclose(out);\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (868,'#include <stdio.h>\nint main()\n{\n	int N, a, b, i, t;\n\n	scanf(\"%d\", &N);\n	a = 0;\n	b = 1;\n	printf(\"%d %d \", a, b);\n	for (i = 0; i < N - 1; i++)\n	{\n		t = a + b;\n		printf(\"%d \", t);\n		a = b;\n		b = t;\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (869,'#include <stdio.h>\nint main()\n{\n	int f0=0, f1=1, fn, i, n=15;\n	printf(\"%d,%d,\",f0,f1);\n	for(i=2;i<n;i++)\n	{\n		fn=f0+f1;\n		f0=f1;\n		f1=fn;\n		printf(\"%d,\",fn);\n		}\n	printf(\"\\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (870,'#include <stdio.h>\n\nmain ()\n{\nint n = 5;\nint i=0;\nint k=1;\nint l;\n\nfor ( ;n>0;n--)\n{\nprintf(\"%d \",i);\nl=k+i;\ni=k;\nk=l;\n}\nreturn 0;\n\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (871,'#include <stdio.h>\nint main()\n{int i,n=15,ch1=0,ch2=1,s;\nfor(i=3;i<n;i++)\n{\n	s=ch2;\nch2=ch1+ch2;\nch1=s;\nprintf(\"ch2=%d\\n\", ch2);\n}\nreturn ch2;\n}\n\n\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (872,'#include <stdio.h>\nint main()\n{\n	int a, b, t;\n\n	scanf(\"%d%d\", &a, &b);\n	while (a % b > 0)\n	{\n		t = a % b;\n		a = b;\n		b = t;\n	}\n	printf(\"%d\\n\", b);\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (873,'#include <stdio.h>\n\nint main()\n{\n	int n, f1=0, f2=1,i,ff;\n	scanf(\"%d\",&n);\n	printf(\"%d %d \",f1,f2);\n	for(i=2;i<=n;i++)\n	{\n		ff=f1+f2;\n		printf(\"%d \",ff);\n		f1=f2;\n		f2=ff;	\n	}\n	return(0);\n}\n\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (874,'#include <stdio.h>\n\nint main()\n{\n	int i, n, f3=1, f2=0, f1=0, l;\n	scanf(\"%d\", &n);\n	for(i=1; i<n; i++)\n	{\n		printf(\"%d, \", f3);\n		f1=f2;\n		f2=f3;\n		f3=f2+f1;\n	}\n	printf(\"%d\\n\", f3);\n	return 0;\n}\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (875,'#include <stdio.h>\n\nint fib(int a, int b)\n{\n	return (a+b);\n}\n\nint main()\n{\n	int a=0;\n	int b=1;\n	int c;\n	int n;\n	int i;\n\n	printf(\"Print your favorite number - it will be \'fibonaccied\' soon: \");\n	scanf(\"%d\", &n);\n	printf(\"Thanks. Wait a moment...\\n\");\n\n	for (i=1; i<=n; i++)\n	{\n		printf(\"%d\\n\", a);\n\n		c=fib(a, b);\n		a=b;\n		b=c;\n	}\n	printf(\"Here are you Fibonacci\'s numbers! Have fun!\\n\");\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (876,'#include <stdio.h>\n\nint main()\n{\n	int N, i, f1=1, f2=0, a;\n	scanf(\"%d\", &N);\n	for (i=1; i<=N; i++)\n	{\n		printf(\"%d\\n\", f1);\n		a=f1;\n		f1+=f2;\n		f2=a;\n	}\n	return 0;\n}\n\n\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (877,'#include <stdio.h>\nint nod()\n{int a=15,b=6,s;\ndo\n{s=a;\na=b;\nb=s%a;\n}\nwhile (a%b!=0);\nprintf(\"%d\",b);\nreturn b;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (878,'#include <stdio.h>\n\nint main()\n{	\n	int a, b, k=1;\n	scanf(\"%d %d\", &a, &b);\n	while(a!=0)\n	{\n		if (a<b)\n		{\n			k=a;\n			a=b;\n			b=k;\n		}\n		a%=b;\n	}\n	printf(\"%d\\n\", b);\n	return 0;\n}\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (879,'#include <stdio.h>\nint main()\n{\n//	int a = 40, b = 100, s;\n	int a, b, s;\n	scanf(\"%d%d\", &a, &b);\n\n	do\n	{\n		s = a;\n		a = b;\n		b = s % a;\n	} while (a % b != 0);\n\n	printf(\"%d\\n\", b);\n\n	return b;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (880,'#include <stdio.h>\n\nint main()\n{\n	int a=40;\n	int b=100;\n\n	if (a<b) \n	{\n		int c=a;\n		a=b;\n		b=c;\n	}\n\n	while (a%b>0)\n	{\n		a=a%b;\n\n		if (a<b) \n		{\n			int c=a;\n			a=b;\n			b=c;\n		}\n	}\n	printf(\"%d\\n\",b);\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (881,'#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\ndouble value(double p, int l, double *in)\r\n{\r\n    double z=0;\r\n    int i;\r\n\r\n    for (i=0; i<=l; i++)\r\n        z+=in[i]*pow(p,i);\r\n    return z;\r\n}\r\n\r\nint main()\r\n{   int i, n;\r\n    double p, m, x, y, a[10];\r\n\r\n    printf(\"Enter the degree of the equation f(x):\\n\");\r\n    scanf(\"%d\", &n);\r\n    printf(\"Enter the coefficients of x in descending order of its degree:\\n\");\r\n    for (i=n; i>=0; i--)\r\n        scanf(\"%lf\", &a[i]);\r\n    printf(\"Enter the borders of the segment, on which we look for the solution:\\n\");\r\n    scanf(\"%lf %lf\", &x, &y);\r\n    if (value(x,n,a)*value(y,n,a)>0)\r\n    {\r\n        printf(\"Error\");\r\n        exit(0);\r\n    }\r\n    while (1)\r\n    {\r\n        p=(x+y)/2;\r\n        if (fabs(value(p,n,a)) < 0.001) break;\r\n        if (value(p,n,a)*value(x,n,a)>0) x=p; else y=p;\r\n    }\r\n    printf(\"%0.3f\", p);\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (882,'#include <stdio.h>\r\n\r\nint main()\r\n{\r\n    int k, d1, d2, m1, m2, y1, y2, a[13];\r\n\r\n    a[1]=a[3]=a[5]=a[7]=a[8]=a[10]=a[12]=31;\r\n    a[4]=a[6]=a[9]=a[11]=30;\r\n    scanf(\"%d %d %d\", &d1, &m1, &y1);\r\n    scanf(\"%d %d %d\", &d2, &m2, &y2);\r\n    k=0;\r\n    if ((y1%400 == 0) || (y1%4 == 0) && (y1%100 != 0)) a[2]=29; else a[2]=28;\r\n    while (y1 < y2)\r\n    {   while (d1 < a[m1])\r\n        {   d1++;\r\n            k++;\r\n        }\r\n        d1=1;\r\n        k++;\r\n        if (m1 == 12)\r\n        {   m1=1;\r\n            y1++;\r\n            if ((y1%400 == 0) || (y1%4 == 0) && (y1%100 != 0)) a[2]=29; else a[2]=28;\r\n        } else m1++;\r\n    }\r\n    while (m1 < m2)\r\n    {   while (d1 < a[m1])\r\n        {   d1++;\r\n            k++;\r\n        }\r\n        d1=1;\r\n        m1++;\r\n        k++;\r\n    }\r\n    while (d1 < d2)\r\n    {   d1++;\r\n        k++;\r\n    }\r\n    printf(\"%d\", k);\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (883,'#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\ndouble value(double p, int l, double *in)\r\n{\r\n    double z=0;\r\n    int i;\r\n\r\n    for (i=0; i<=l; i++)\r\n        z+=in[i]*pow(p,i);\r\n    return z;\r\n}\r\n\r\nint main()\r\n{   int i, n;\r\n    double p, m, x, y, a[10];\r\n\r\n    printf(\"Enter the degree of the equation f(x):\\n\");\r\n    scanf(\"%d\", &n);\r\n    printf(\"Enter the coefficients of x in descending order of its degree:\\n\");\r\n    for (i=n; i>=0; i--)\r\n        scanf(\"%lf\", &a[i]);\r\n    printf(\"Enter the borders of the segment, on which we look for the solution:\\n\");\r\n    scanf(\"%lf %lf\", &x, &y);\r\n    if (value(x,n,a)*value(y,n,a)>0)\r\n    {\r\n        printf(\"Error\");\r\n        exit(0);\r\n    }\r\n    while (1)\r\n    {\r\n        p=(x+y)/2;\r\n        if (fabs(value(p,n,a)) < 0.001) break;\r\n        if (value(p,n,a)*value(x,n,a)>0) x=p; else y=p;\r\n    }\r\n    printf(\"%0.3f\", p);\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (884,'#include <stdio.h>\n#include <math.h>\n\nfloat f(float x)\n{\n	return(x*x-2);\n}\n\nint main()\n{\n	float a=0;\n	float b=333;\n	float k=1;//???????????????, ????????. 1 ???? ????? ? ????\n	float x;\n\n	while(fabs(k)>0.001)\n		{\n			k=f((b-a)/2+a);\n\n			if (fabs(k)<=0.001) printf(\"%f\\n\",(b-a)/2+a);\n				else if (k<0) a=(a+(b-a)/2);\n					else b=(b-(b-a)/2);\n//			printf(\"%f %f %f\\n\",a,b,k);\n		}\n\n	return 0;}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (885,'#include <stdio.h>\nint main()\n{\n	int a=40, b=100, i;\n	if (a%b==0)\n		printf(\"???=%d\\n\",b);\n	else\n	{\n		while(i!=0)\n		{\n			i=a%b;\n			a=b;\n			b=i;			\n		}	\n		printf(\"???=%d\\n\",a);\n	}\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (886,'#include <stdio.h>\nint main()\n{\n	int d1=16, d2=7, m1=1, m2=9, y1=1994, y2=2011, ds;\n	ds = (y2-y1+1)*365;\n		for (y1+1;(y1+1)<y2;y1++)\n		{ \n			if ((y1+1)%4==0)\n			ds++;\n		}\n	printf(\"%d\\n\",ds);\n	return 0;\n}\n			\n	\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (887,'#include <stdio.h>\nint main ()\n{\n	int f0=0,f1=1,f,i;	\n	printf(\"%d \",f0);\n	printf(\"%d \",f1);\n	for(i=2;i<10;i++)\n	{\n		f=f0+f1;\n		f0=f1;\n		f1=f;\n		printf(\"%d \",f);\n	}\n	return (0);\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (888,'#include <stdio.h>\n\nint main()\n{\n	int a=40,b=100,i,x=0;\n	x=1;\n	while (x>0)\n	{\n		if (a%b==0) \n		{\n			printf(\"%d \",b); \n			x=0;\n		}\n		else \n		{\n			i=a;\n			a=b;\n			b=i%a;\n		}	\n	}\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (889,'#include <stdio.h>\nint main()\n{\n	int a=40, b=100, i;\n	if (a%b==0)\n		printf(\"???=%d\\n\",b);\n	else\n	{\n		while(i!=0)\n		{\n			i=a%b;\n			a=b;\n			b=i;			\n		}	\n		printf(\"???=%d\\n\",a);\n	}\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (890,'#include <stdio.h>\n\nfloat f(float c)\n{	\n	return c-50;\n}\n\nint main()\n{\n	float a=0,b=100,x,y;\n	y=f(5);\n	if (f(a)!=0)\n	{\n		if (f(b)!=0)\n		{\n			while (((f(a)<0) && (f(b)>0)) || ((f(a)>0) && (f(b)<0)))\n			{\n				if (b-a>=0.001)\n				{\n					x=a+((b-a)/2);// printf(\"x=%f \\n\",x);\n					if (f(x)==0) \n						printf(\"\\n **** root is %f \\n\",x);\n					if (((f(x)>=0) && (f(b)<=0)) || ((f(x)<=0) && (f(b)>=0)))\n						a=x;\n					if (((f(a)>=0) && (f(x)<=0)) || ((f(a)<=0) && (f(x)>=0)))\n						b=x;	\n				}\n				else \n				{\n					printf (\"root is %f \\n\",x);\n					return x;\n				}\n			}\n		} \n		else \n			printf(\"%f \\n\",b);\n	} \n	else \n		printf(\"%f \\n\",a);\n\n	if (((f(a)>0) && (f(b)>0)) || ((f(a)<0) && (f(b)<0)))\n		printf (\"no roots \\n\");\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (891,'#include <stdio.h>\n\nint main()\n{\n	int a,b,c,nod;\n	printf(\"Print the first number, please: \\n\");\n	scanf(\"%d\", &a);\n	printf(\"Print the second number, please: \\n\");\n	scanf(\"%d\", &b);\n	\n	if (b>a)\n	{\n		c=a;\n		a=b;\n		b=c;\n	}\n\n	nod=1;\n\n	while (1)\n	{\n		if (a%b==0)\n		{\n			nod=b;	\n			break;\n		}\n		else\n		{\n			c=b;\n			b=a%b;\n			a=c;\n		}\n	}\n\n	printf(\"The NOD of a and b is %d\\n\", nod);\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (892,'#include <stdio.h>\n\nint main ()\n{\n	int a,b,c;\n	scanf(\"%d\",&a);\n	scanf(\"%d\",&b);\n	if (a<b)\n	{\n		c=a;\n		a=b;\n		b=c;\n	}\n	while (1)\n	{\n		if (a%b==0)\n		{	printf(\"%d\\n\",b);\n			break;\n		}\n		else\n		{	c=a%b;\n			a=b;\n			b=c;\n		}	\n        }\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (893,'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint is_prime(int n)\n{\n	int i;\n\n	for (i = 2; i <= sqrt(n); ++i)\n	{\n		if (n % i == 0)\n			return 0;\n	}\n	return 1;\n}\n\nint main()\n{\n	int N, *A, i, X = 1, Y = 0;\n\n	freopen(\"input.txt\", \"r\", stdin);\n//	freopen(\"output.txt\", \"w\", stdout);\n\n	scanf(\"%d\", &N);\n	A = calloc(N, sizeof(int));	\n	for (i = 0; i < N; ++i)\n	{\n		scanf(\"%d\", &A[i]);\n		if (!is_prime(A[i]))\n		{\n			printf(\"found non-prime number %d\\n\", A[i]);\n			X = 0;\n		}\n		if (is_prime(A[i]))\n		{\n			Y = 1;\n		}\n	}\n\n	if (X == 0)\n		printf(\"NO \");\n	else\n		printf(\"YES \");\n	if (Y == 0)\n		printf(\"NO\\n\");\n	else\n		printf(\"YES\\n\");\n\n	free(A);\n\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (894,'#include <stdio.h>\nint read_integer (void)\n{\n	char q=0;\n	int N=0;\n	while (1) {\n		q = getchar ();\n		if (q >= \'0\' && q <= \'9\')			\n			N = N*10 + q - \'0\';\n		else\n			break;\n	}\n	return N;\n}\n\nint main ()\n{\n	int a=0,b=1,c,i,N;\n	printf (\"skolko chisel vuvodit\' \");\n//	N = read_integer();\n	scanf(\"%d\", &N);\n	printf(\"N: %d\\n\", N);\n	if (N==0) return (0);\n	printf (\"0 \");\n	if (N==1) return (0);\n	printf (\"1 \");\n	if (N==2) return (0);\n	for (i=3; i<=N ; i++)\n	{\n		c=a+b;\n		a=b;\n		b=c;\n		printf (\"%d \",c);\n	}\n	printf (\"\\n\");\n	return (0);\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (895,'#include <stdio.h>\n\nint main()\n{\n	int a, b, n;\n\n	scanf(\"%d %d\", &a, &b);\n	while (a%b != 0)\n	{\n		n = a%b;\n		a = b;\n		b = n;\n	}\n	printf(\"%d\\n\", b);\n	return 0;\n}	\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (896,'#include <stdio.h>\n\ndouble f(double p)\n{\n	return(p*p-2);\n}\n\nint main()\n{\n	double a=0,b=20,i,p;	\n	while (b - a > 0.001)\n	{	i=a+((b-a)/2);\n		if(f(i)<0) a=i;\n		else b=i;\n	}\n	i=b;\n	printf(\"%f\\n\",i);\n	return 0;	\n\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (897,'#include <stdio.h>\n#include <math.h>\n\ndouble f(double x)\n{\n	return(x*x-2);\n}\n\nint main()\n{\n	double a=0;\n	double b=2;\n	double x;\n	if(a>b)\n	{\n		x=a;\n		a=b;\n		b=x;\n	}\n	if(f(a)*f(b)>0)\n	{\n		printf(\"There are no solves\\n\");\n		return 0;\n	}\n	do\n	{\n		printf(\"%f %f\\n\", a, b);\n		x=(b+a)/2;\n		if(f(x)>0) b=x; else if(f(x)<0) a=x;\n	}\n	while(fabs(f(x))>0.01);\n	printf(\"%f\\n\", x);\n	return 0;\n}\n\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (898,'\n#include<stdio.h>\nint main()\n{ 	\nint fibs[100],i;\nfibs[0] = 1;\nfibs[1]=1;\n\nfor(i=2; i<15; i++)\n{\n	fibs[i]= fibs[i-1]+fibs[i-2];\n	printf(\"%d\\n\",fibs[i]);\n}\n\nreturn 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (899,'#include <stdio.h>\n\nint main()\n{\n	int d1, m1, y1, d2, m2, y2, k;\n	int q=1;\n	int mon[13]={0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n	scanf(\"%d/%d/%d %d/%d/%d\", &d1, &m1, &y1, &d2, &m2, &y2);\n	if((y2<y1) || (y2==y1 && m2<m1) || (y2==y1 && m2==m1 && d2<d1))\n	{\n		k=d1;\n		d1=d2;\n		d2=k;\n		k=m1;\n		m1=m2;\n		m2=k;\n		k=y1;\n		y1=y2;\n		y2=k;\n	}\n	while(d1!=d2 || m1!=m2 || y1!=y2)\n	{\n		if(y1%400==0 || (y1%4==0 && y1%100!=0)) mon[2]=29;\n		else mon[2]=28;\n		d1++;\n		if(d1>mon[m1])\n		{\n			d1=1;\n			m1++;\n		}\n\n		if(m1>12)\n		{\n			m1=1;\n			y1++;\n		}\n		q++;\n	}\n	printf(\"%d\\n\", q);\n	return 0;\n}\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (900,'#include <stdio.h>\n\nint main()\n{\n#define x 100000\n\n//	freopen(\"input.txt\",\"rt\",stdin);\n//	freopen(\"output.txt\",\"wt\",stdout);\n\n	int n;\n	int a[x];\n//	int b[x];\n\n	scanf(\"%d\",&n);\n\n	int i;\n	\n	for(i=0;i<n;i++)\n	{\n		scanf(\"%d\",&a[i]);\n//		b[i]=0;\n	}\n\n//	for(i=0;i<n;i++)\n//		printf(\"%d \",a[i]);\n//		printf(\"\\n\");\n	int min;\n	int index;\n	\n	for(i=0;i<n;i++)\n	{\n//		printf(\"(%d) \",i);\n\n		int z;\n\n//		for(z=0;z<n;z++)\n//			printf(\"%d \",a[z]);\n//			printf(\"\\n\");\n\n		min=a[i];\n		index=-1;\n\n		int k;\n\n		for(k=i;k<n;k++)\n			\n			if (a[k]<min) \n			{\n				min=a[k];\n				index=k;\n			}\n\n		for(k=index-1;k>=i;k--)\n			a[k+1]=a[k];\n\n		a[i]=min;	\n	}\n\n	for(i=0;i<n;i++)\n		printf(\"%d \",a[i]);\n	printf(\"\\n\");\n\n	return(0);		\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (901,'#include <stdio.h>\nfloat a=-1,b=7,m=0;\nfloat f(float x)\n{\n	return x*x - 2;\n}\n\nint main()\n{\n	int i=0;\n	if(f(a)==0)\n		printf(\"??????=%f\\n\",a);\n	if(f(b)==0)\n		printf(\"??????=%f\\n\",b);\n	while(f(m)!=0 && (b-a)>0.001)\n	{\n		m=(a+b)/2;\n		if(f(a)*f(m)<0)\n			b=m;\n		else\n		  if(f(m)*f(b)<0)	\n			a=m;\n		i++;\n	}\n	printf(\"??????=%f,  %d\\n\",m,i);\n	return m;\n}	\n\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (902,'#include <ctype.h>\r\n#include <stdio.h>\r\nint read_integer(void)\r\n {\r\n     int c; int b=0;\r\n     while (isdigit(c=getchar()))\r\n     {\r\n         b*=10;\r\n         b+=c-\'0\';\r\n     }\r\n     return b;\r\n }\r\n\r\nint main()\r\n {\r\n     int k1,k2,a,b,c;\r\n     c=read_integer();\r\n     k1=0;\r\n     k2=1;\r\n     for(a=1;a<=c;a++)\r\n     {\r\n         if (a==1)\r\n            b=k1;\r\n        else if (a==2)\r\n            b=k2;\r\n        else\r\n        {\r\n            b=k1+k2;\r\n            k1=k2;\r\n            k2=b;\r\n        }\r\n        printf(\"%d\\n\",b);\r\n     }\r\n     return 0;\r\n }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (903,'#include <ctype.h>\r\n#include <stdio.h>\r\nint read_integer(void)\r\n {\r\n     int c; int b=0;\r\n     while (isdigit(c=getchar()))\r\n     {b*=10; b+=c-\'0\';}\r\n     return b;\r\n }\r\n\r\n\r\nint main()\r\n {\r\n     int i,j,a,b,c;\r\n     a=read_integer();\r\n     b=read_integer();\r\n     while ((a%b)!=0)\r\n     {a=a%b; c=a; a=b; b=c;};\r\n     printf(\"%d\",b);\r\n     return 1;\r\n }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (904,'#include <stdio.h>\n\nint main()\n{\n	int d1=6,m1=9,y1=1983,d2=1,m2=9,y2=2011,s=0,d,m3,d3,y3;\n	scanf(\"%d/%d/%d %d/%d/%d\", &d1, &m1, &y1, &d2, &m2, &y2);\n	int A[13]={0 ,31 ,28 ,31 ,30 ,31 ,30 ,31 ,31 ,30 ,31 ,30 ,31 };\n	if ((y1>y2) || ((y1==y2) && ((m1>m2) || ((m1==m2) && (d1>d2)))))\n	{\n		y3=y2;\n		y2=y1;\n		y1=y3;\n		m3=m2;\n		m2=m1;\n		m1=m3;\n		d3=d2;\n		d2=d1;\n		d1=d3;\n	}		 \n	if ((y1==y2) && (m1==m2))\n	{\n		s=d2-d1+1;\n		printf(\"%d days \\n\",s);\n		return 0;\n	}\n	d=A[m1];\n	s=s+(d-d1+1);\n	m1++;\n	while (y1<y2)\n	{\n		while (m1<=12)\n		{\n			d=A[m1];\n			s=s+d;\n			m1++;\n			d1=0;\n		}\n		m1=1;	\n		if ((y1%400==0) || ((y1%100!=0) && (y1%4==0)))\n		{\n			s++;\n		}	\n		y1++;\n	}\n	while (m1<m2)\n	{\n		d=A[m1];\n		s=s+d;\n		m1++;\n	}\n	if ((y2%400==0) || ((y2%100!=0) && (y2%4==0)))\n	{\n		s++;\n	}	\n	s=s+d2;\n	printf(\"%d days \\n\",s);\n	return 0;\n}				\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (905,'#include <stdio.h>\n\n#define N 10000\n\nint myfile(int myarray[])\n{\n	FILE *f1;\n	int n1,i=0;\n	f1=fopen(\"input.txt\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"error \\n\");\n		return ;\n	}\n	while (fscanf(f1,\"%d\",&n1)==1)\n	{\n		myarray[i]=n1;\n		i++;\n	}\n	fclose(f1);\n	return i;\n}\n\nint insprime(int a)\n{\n	int i=2,x=1;\n	while (i<a)\n	{\n		if (a%i==0)	\n		{\n			x=0;\n			break;\n		}\n		else\n		{\n			x=1;\n		}\n		i++;\n	}\n	return x;\n}\n\nint main()\n{\n	int a1[N];\n	int end_of_a1;\n	int i,k,l,n=0,m=0;\n	end_of_a1=myfile(a1);\n	//for (i=0;i<end_of_a1;i++)\n	//{\n		//printf(\"a1[%d]=%d \\n\",i,a1[i]);\n	//}\n	for (i=0;i<end_of_a1;i++)\n	{\n		if (insprime(a1[i])==0)\n		{\n			//m--; \n			k=0;\n		}\n		else\n		{\n			n++;\n			l=0;\n		}\n		if ((k==0) && (l==0))\n		{\n			break;\n		}\n	}\n	//printf(\"n=%d \\n\",n);\n	if (n>0)\n	{\n		printf(\"we have prime number \\n\");\n	}\n	else\n	{\n		printf(\"we haven\'t prime numbers \\n\");\n	}\n	if (n==end_of_a1)\n	{\n		printf(\"all numbers are prime \\n\");\n	}\n	else\n	{\n		printf(\"all numbers aren\'t prime \\n\");\n	}\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (906,'#include <stdio.h>\n\nint main(void)\n{\n	int M[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n	int d1,d2,m1,m2,y1,y2,c=1;\n\n	printf(\"Please, enter two dates, one by one, divided with spaces:\\n\");\n	scanf(\"%d/%d/%d %d/%d/%d\", &d1, &m1, &y1, &d2, &m2, &y2);\n	printf(\"%d/%d/%d %d/%d/%d\\n\", d1, m1, y1, d2, m2, y2);\n\n	while ((d1!=d2)||(m1!=m2)||(y1!=y2))\n	{\n		printf(\">> %d/%d/%d\\n\", d1, m1, y1);\n		M[2]=28;\n		if (((y1%4==0)&&(y1%100!=0))||(y1%400==0))\n		{\n			M[2]=29;\n		}\n\n		d1++;\n		c++;\n\n		if (d1==M[m1]+1) \n		{\n			m1++;\n			d1=1;\n		}\n		if (m1==13)\n		{\n			m1=1;\n			y1++;\n		}\n	}\n	printf(\"There are %d days between your dates\\n\", c);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (907,'#include <stdio.h>\nint main()\n{\n	int i,j,k,ds=0;\n	int A[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n	int d1=16, d2=20, m1=1, m2=9,y1=1994, y2=2011;\n	scanf(\"%d/%d/%d %d/%d/%d\", &d1, &m1, &y1, &d2, &m2, &y2);\n	for(k=y1;k<=y2;k++)\n	{\n		for(j=m1;j<=12;j++)\n		{\n			for(i=d1;i<=A[j];i++)\n			{\n				ds++;\n				if(i==A[m1])\n					d1=1;\n			}\n			if(j==12)\n				m1=1;\n		}\n		if(k%400==0 || (k%4==0 && k%100!=0))\n			ds++;\n 	}\n	for(j=m2;j<=12;j++)\n	{\n		for(i=d2;i<=A[j];i++)\n			ds--;\n	}\n	ds++;\n	printf(\" %d\\n\",ds);\n	return 0;\n}\n			\n			\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (908,'#include <stdio.h>\n\nvoid month(int febr,int m, int *dpast)\n{\n	do\n	{	if(m==1 || m==3 || m==5 || m==7 || m==8 || m==10)\n		{\n			*dpast+=31;\n			m--;\n		}\n		if(m==4 || m==6 || m==9 || m==11)\n		{	*dpast+=30;\n			m--;\n		}\n		if(m==2)\n		{	*dpast+=febr;\n			m--;\n		}			\n	}\n	while(m>0);\n}\n\nint main(void)\n{\n	int d1,m1,y1;\n	int d2,m2,y2;\n	int vis, nevis, dpast;\n\n	scanf(\"%d\",&d1);\n	scanf(\"%d\",&m1);\n	scanf(\"%d\",&y1);\n\n	y1--;\n		vis=y1/4;\n		nevis=y1-vis;\n		dpast=(365*nevis)+(366*vis)+d1;\n	y1++;\n\n	m1--;\n	if(y1%4==0) month(29,m1,&dpast);\n	else month(28,m1,&dpast);\nd1=dpast;\n\n	scanf(\"%d\",&d2);\n	scanf(\"%d\",&m2);\n	scanf(\"%d\",&y2);\n\n	y2--;\n		vis=y2/4;\n		nevis=y2-vis;\n		dpast=(365*nevis)+(366*vis)+d2;\n	y2++;\n\n	m2--;\n	if(y2%4==0) month(29,m2,&dpast);\n	else month(28, m2, &dpast);\nd2=dpast;\n	\n	if(d2>d1) dpast=(d2-d1+1);\n	else dpast=(d1-d2+1);\n	printf(\"%d days between those dates are\\n\",dpast);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (909,'#include <stdio.h>\n#define n 4 \n\nint isprime(int a)\n{\n	int i;\n	for(i=2;i<a;i++)\n	if(a%i==0) return(0);\n	return(1);\n}\n\nint main()\n{\n	int num[n];\n	int i,prime=0;\n\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&num[i]);\n\n	for(i=0;i<n;i++)\n	if(isprime(num[i])==1)\n		prime++;\n\n	if(prime==n)\n	{	printf(\"All prime\\n\");\n		return(0);\n	}\n	if(prime>0)\n		printf(\"Prime exist\\n\");\n	else\n		printf(\"No prime\\n\");\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (910,'#include <stdio.h>\n\nint main(int argc, char **argv)\n{\n        int c = 0;\n\n        freopen(argv[1], \"rb\", stdin);\n        freopen(argv[2], \"wb\", stdout);\n        while (1)\n        {\n                c = getchar();\n                if (c == EOF)\n                        return 0;\n                putchar(c);\n        }\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (911,'#include <stdio.h>\n\nvoid tran(char *p, int *d, int *m, int *y)\n{\n	*d = (p[0] - \'0\') * 10 + p[1] - \'0\';\n	*m = (p[3] - \'0\') * 10 + p[4] - \'0\';\n	*y = (p[6] - \'0\') * 1000 + (p[7] - \'0\') * 100 + (p[8] - \'0\') * 10 + p[9] - \'0\'; \n}\n\nint dim(int m, int y)\n{\n	switch (m)\n	{\n		case 1: return 31; break;\n		case 2:\n		{\n			if (y % 400 == 0 || (y % 4 == 0 && y % 100 > 0))\n				return 29;\n			else\n				return 28;\n		} break;\n		case 3: return 31;\n		case 4: return 30;\n		case 5: return 31;\n		case 6: return 30;\n		case 7: return 31;\n		case 8: return 31;\n		case 9: return 30;\n		case 10: return 31;\n		case 11: return 30;\n		case 12: return 31;\n	}\n}\n\nint main()\n{\n	char a[11], b[11];\n	int d1, m1, y1, d2, m2, y2, c = 1;\n	scanf(\"%s%s\", a, b);\n	tran(a, &d1, &m1, &y1);\n	tran(b, &d2, &m2, &y2);\n	while (d1 != d2 || m1 != m2 || y1 != y2)\n	{\n		++c;\n		++d1;\n		if (d1 > dim(m1, y1))\n		{\n			d1 = 1;\n			++m1;\n			if (m1 > 12)\n			{\n				m1 = 1;\n				++y1;\n			}\n		}\n	}\n	printf(\"%d\\n\", c);\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (912,'#include <stdio.h>\n\nint n, A[100];\n\nint find(int x)\n{\n	int min = 0, max = n - 1, c;\n\n	while (min <= max)\n	{\n		c = (min + max) / 2;\n		if (A[c] == x)\n			return c;\n		else if (A[c] > x)\n			max = c - 1;\n		else if (A[c] < x)\n			min = c + 1;\n	}\n	return -1;\n}\n\nint main()\n{\n	FILE *f;\n	int i, a, b;\n\n	f = fopen(\"input.txt\", \"r\");\n	fscanf(f, \"%d\", &n);\n	for (i = 0; i < n; ++i)\n		fscanf(f, \"%d\", &A[i]);\n	while (scanf(\"%d\", &a) == 1)\n	{\n		printf(\"Its position is: %d\\n\", find(a));\n	}\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (913,'#include <stdio.h>\n\nfloat a = 0, b = 2;\n\nfloat f(float x)\n{\n	return (x * x - 2);\n}\n\nint main()\n{\n	float x;\n	while (1)\n	{\n		x = (a + b) / 2;\n		if (f(x) > .001)\n		{\n			b = x;\n		}\n		else if (f(x) < - .001)\n		{\n			a = x;\n		}\n		else\n		{\n			printf(\"%f\\n\", x);\n			return 0;\n		}\n	}\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (914,'#include <stdio.h>\nint main ()\n{\n	int f1=0, f2=1, f3=0, n, i;\n	scanf(\"%d\", &n);\n\n	for(i=0; i<=n; i++)\n	{\n		printf(\"%d \", f1, f2);\n		f3=f1+f2;\n		f1=f2;\n		f2=f3;\n	}\n	return 0;\n}\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (915,'#include<stdio.h>\nint main()	\n{\n	int a,b,n;\n	scanf(\"%d%d\", &a,&b);\n	for(; a%b!=0;)\n	{\n		n=a;\n		a=b;		\n		b=n%b;\n	}\n	printf(\"%d\\n\",b);\n	return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (916,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 10000\n\nint myfile(int myarray[])\n{\n	FILE *f1;\n	int n,i=0;\n	f1=fopen(\"input.txt\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"error \\n\");\n	//	return 1;//sprosit pro exit\n		exit(1);\n	}\n	while (fscanf(f1,\"%d \",&n)==1)\n	{\n		myarray[i]=n;\n		i++;\n	}\n	fclose(f1);\n	return i;\n}\n\nint main()\n{\n	int a1[N];\n	int i,n,m=0,r,k,l=0;\n	n=myfile(a1);\n	r=n-1;\n	scanf(\"%d\",&k);\n	while (r>=l)\n	{\n		//printf(\"a1[m]=%d \\n\",a1[m]);\n		m=l+(r-l)/2;\n		//printf(\"m=%d \\n\",m);\n		if (a1[m]==k)\n		{\n			printf(\"k have number %d\\n\",m);\n			return 0;\n		}\n		if (k<a1[m])\n		{\n			r=m-1;\n		}\n		else\n		{\n			l=m+1;\n		}\n	}\n	printf(\"no k in array \\n\");\n	return 1;\n}	\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (917,'#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n	FILE *f1;\n	FILE *f2;\n	size_t n;\n	char c;\n	f1=fopen(argv[1],\"rb\");\n	if (f1==NULL)\n	{\n		printf(\"open error f1 \\n\");\n		return 1;\n	}\n	f2=fopen(argv[2],\"wb\");\n	if (f2==NULL)\n	{\n		printf(\"open error f2 \\n\");\n		return 1;\n	}\n	while (fscanf(f1,\"%c\",&c)==1)\n	{\n		n=fwrite(&c,sizeof(c),1,f2);\n	}\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (918,'#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n	FILE *f1;\n	int symbs=0,words=0,strs=0;\n	char c,k=0;\n	f1=fopen(argc == 2 ? argv[1] : \"input8.txt\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"error \\n\");\n		return 1;\n	}\n	while (fscanf(f1,\"%c\",&c)==1)\n	{							\n		symbs++;\n		if (c==\'\\n\')	\n		{	\n			strs++;\n		}\n		if (c<=\' \' && k>\' \')\n		{\n			words++;\n		}\n		k=c;\n	}\n	fclose(f1);\n	printf(\"%d symbols, %d words, %d strings \\n\",symbs,words,strs);\n	return 0;\n}\n\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (919,'#include <stdio.h>\n#include <string.h>\n\n#define N 10000\n\nint myfile(char mystring[])\n{\n	FILE *f1;\n	int i=0;\n	char c;\n	f1=fopen(\"string.txt\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"error \\n\");\n		return ;\n	}\n	while (fscanf(f1,\"%c\",&c)==1)\n	{\n		if (c>\' \')\n		{\n			mystring[i]=c;\n			i++;\n		}\n	}\n	fclose(f1);\n	return i;\n}\n\n\nint main()\n{\n	char str[N];\n	int end_of_str;\n	int i,j;\n	end_of_str=myfile(str);\n	printf(\"end_of_str=%d \\n\",end_of_str);\n	printf(\"\\n\");\n	for (i=0,j=end_of_str-1;i<end_of_str,j>=0;i++,j--)\n	{\n		printf(\"i=%d,j=%d \\n\",i,j);\n		if (str[i]!=str[j])\n		{\n			printf(\"this string isn\'t palindrom \\n\");\n			return 1;\n		}\n	}\n	printf(\"this string is palindrom \\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (920,'#define N 10\r\n#include <stdio.h>\r\n\r\nint isprime(int p)\r\n{\r\n    int i=2;\r\n\r\n    while (i*i <= p && p%i != 0)\r\n        i++;\r\n    if (p%i == 0 && p != 1 && p != 2) return 0;\r\n    return 1;\r\n}\r\n\r\nint main ()\r\n{\r\n    int k, l, i, a[N] = {44, 44, 44, 44, 44, 44, 44, 44, 33, 44};\r\n\r\n    k = 0;\r\n    l = 0;\r\n    i = 1;\r\n    while (i != N + 1)\r\n    {\r\n        if (k != 1 && isprime(a[i])) k = 1;\r\n	if (!isprime(a[i])) l = 1;\r\n	printf(\"a[i]: %d, k: %d\\n\", a[i], k);\r\n        i++;\r\n    }\r\n    if (l == 0) printf(\"a) YES\\n\"); else printf(\"a) NO\\n\");\r\n    if (k == 1) printf (\"b) YES\\n\"); else printf (\"b) NO\\n\");\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (921,'#define N 5\r\n#define M 50\r\n#include <stdio.h>\r\n\r\nint bin_search(int c)\r\n{\r\n    int f, l, m, a[N] = {1, 3, 5, 7, 9, };\r\n\r\n    f = 0;\r\n    l = N;\r\n    m = (f + l) / 2;\r\n    while (f < l && a[m] != c)\r\n    {\r\n        if (a[m] < c) \r\n		f = m+1; \r\n	else \r\n		l = m-1;\r\n        m = (f + l) / 2;\r\n    }\r\n    if (a[m] == c) \r\n	    return 1; \r\n    return 0;\r\n}\r\n\r\nint main ()\r\n{\r\n    int i, n, c[M];\r\n\r\n    scanf(\"%d\", &n);\r\n    for (i = 0; i < n; i++) \r\n	    scanf(\"%d\", &c[i]);\r\n    for (i = 0; i < n; i++) {\r\n    	if (bin_search(c[i])) \r\n		printf (\"%d is there\\n\", c[i]); \r\n	else \r\n		printf (\"%d isn\'t there\\n\", c[i]);\r\n    }\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (922,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    FILE *f1, *f2;\r\n    char r;\r\n\r\n    f1 = fopen(argv[1],\"rb\");\r\n    if (!f1)\r\n    {\r\n	    perror(\"fopen\");\r\n	    return 1;\r\n    }\r\n    f2 = fopen(argv[2],\"wb\");\r\n    if (!f2)\r\n    {\r\n	    perror(\"fopen\");\r\n	    return 1;\r\n    }\r\n    while (fscanf(f1,\"%c\",&r) > 0)\r\n        fprintf(f2,\"%c\",r);\r\n    fclose(f1);\r\n    fclose(f2);\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (923,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    FILE *f;\r\n    char c, p;\r\n    int smb, wds, ln;\r\n\r\n    f = fopen(argc == 2 ? argv[1] : \"25-8.txt\",\"r\");\r\n    if (!f)\r\n    {\r\n	    perror(\"fopen\");\r\n	    return 1;\r\n    }\r\n    smb = wds = ln = 0;\r\n    p = \' \';\r\n    for (c = getc(f); c != EOF; p = c, c = getc(f))\r\n    {\r\n        smb++;\r\n        if ((c == \' \' || c == \'\\t\' || c == \'\\n\' || c == \'\\r\') && p != \' \' && p != \'\\t\' &&  p != \'\\n\' && p != \'\\r\') \r\n	{\r\n		wds++;\r\n	}\r\n        if (c == \'\\n\') ln++;\r\n    }\r\n    if (p != \' \' && p != \'\\t\' && p != \'\\n\' && p != \'\\n\') wds++;\r\n    fclose(f);\r\n    printf(\"symbols = %d, words = %d, lines = %d\\n\", smb, wds, ln);\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (924,'#include <stdio.h>\r\n#include <string.h>\r\n\r\nint not_letter(char *s, int i)\r\n{\r\n    if (s[i] > \'a\' && s[i] < \'z\' || s[i] > \'A\' && s[i] < \'Z\') return 0;\r\n    return 1;\r\n}\r\n\r\nint pal(char *s)\r\n{\r\n    int i, j;\r\n\r\n    i = 0;\r\n    j = strlen(s)-1;\r\n    while (j >= i)\r\n    {\r\n        printf (\"b: s[%d] = %c, s[%d] = %c\\n\", i, s[i], j, s[j]);\r\n        while (i <= j && (not_letter (s, i) || not_letter (s, j)))\r\n        {\r\n            if (not_letter (s, i))\r\n                i++;\r\n            if (not_letter (s, j))\r\n                j--;\r\n	    printf (\"m: s[%d] = %c, s[%d] = %c\\n\", i, s[i], j, s[j]);\r\n        }\r\n	if (s[i] != s[j])\r\n		return 0;\r\n        i++;\r\n        j--;\r\n        printf (\"e: s[%d] = %c, s[%d] = %c\\n\", i, s[i], j, s[j]);\r\n    }\r\n\r\n    printf (\"s[%d] = %c, s[%d] = %c\\n\", i, s[i], j, s[j]);\r\n    if (j < i) return 1;\r\n    return 0;\r\n}\r\n\r\nint main()\r\n{\r\n    char s[1000];\r\n    fgets(s, 1000, stdin);\r\n    s[strlen(s) - 1] = 0;\r\n\r\n    if (pal(s)) printf(\"YES\"); else printf(\"NO\");\r\n    printf(\"\\n\");\r\n\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (925,'#include <stdio.h>\n#define N 4\n\nint IsPrime(int a)\n{\n	int i;\n	for(i=2;i<a;i++)\n	{\n		if(a%i==0) return 0;\n	}\n	return 1;\n}\n\n\nint main()\n{\n	FILE *inp=fopen(\"05.txt\", \"r\");\n	int i, k1=1, k2=0;\n	int A[N];\n	for(i=0;i<N;i++)\n		 fscanf(inp, \"%d\", &A[i]);\n	for(i=0;i<N;i++)\n	{\n		if(IsPrime(A[i])) k2=1; else k1=0;\n	}\n	printf(\"a) %d\\nb) %d\\n\", k1, k2);\n	fclose(inp);\n	return 0;\n}\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (926,'#include <stdio.h>\n\nint main(int argc, char **argv)\n{\n	int a = 0, b = 0, c = 0, x = 0, ins = 0;\n\n	freopen(argv[1], \"r\", stdin);\n	while (x != EOF)\n	{\n		x = getchar();\n		if (x != \'\\n\' && x != \' \' && x != EOF)\n			ins = 1;\n		if (x == \'\\n\')\n		{\n			++c;\n			if (ins == 1)\n			{\n				ins = 0;\n				++b;\n			}\n		}\n		if (x == \' \' && ins == 1)\n		{\n			ins = 0;\n			++b;\n		}\n		if (x != EOF)\n			++a;\n	}\n	printf(\"%d %d %d %s\\n\", c, b, a, argv[1]);\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (927,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	char c = \' \', s[256] = \"\";\n	int i, j;\n\n	while (c != \'\\n\')\n	{\n		c = getchar();\n		if (c != \'\\n\' && c != \' \' && c != \',\' && c != \'.\')\n		{\n			i = strlen(s);\n			if (c >= \'a\' && c <= \'z\')\n				c -= 32;\n			s[i] = c;\n			s[i + 1] = \'\\0\';\n		}\n	}\n\n	i = strlen(s);\n	for (j = 0; j < i / 2; ++j)\n		if (s[j] != s[i - j - 1])\n		{\n			printf(\"NO\\n\");\n			return 0;\n		}\n\n	printf(\"YES\\n\");\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (928,'#include <ctype.h>\r\n#include <stdio.h>\r\nint read_integer(void)\r\n {\r\n     int c; int b=0;\r\n     while (isdigit(c=getchar()))\r\n     {\r\n         b*=10;\r\n         b+=c-\'0\';\r\n     }\r\n     return b;\r\n }\r\n\r\n   int main()\r\n   {\r\n       int month1[]={0,31,28,31,30,31,30,31,31,30,31,30,31};\r\n       int month2[]={0,31,29,31,30,31,30,31,31,30,31,30,31};\r\n       int d1,d2,d,m1,m2,m,y1,y2,y,i,j,c;\r\n       d1=read_integer();\r\n       m1=read_integer();\r\n       y1=read_integer();\r\n       d2=read_integer();\r\n       m2=read_integer();\r\n       y2=read_integer();\r\n       c=0;\r\n       if (y1>y2) {y=y1; y1=y2; y2=y; d=d1; d1=d2; d2=d; m=m1; m1=m2; m2=m;} else\r\n           if ((y1==y2) && (m1>m2)) {y=y1; y1=y2; y2=y; d=d1; d1=d2; d2=d; m=m1; m1=m2; m2=m;} else\r\n               if ((y1==y2) && (m1==m2) && (d1>d2)) {y=y1; y1=y2; y2=y; d=d1; d1=d2; d2=d; m=m1; m1=m2; m2=m;}\r\n       if (y1==y2)\r\n         {\r\n             if (m1==m2)\r\n               {\r\n                   if (d1==d2) c=0; else c=d2-d1+1;\r\n               }\r\n             else\r\n               if ((y1%400==0) | ((y1%4==0) & (y1%100!=0)))\r\n                 {\r\n                     c=month2[m1]-d1+1;\r\n                     m=m1+1;\r\n                     while (m<m2) {c=c+month2[m]; m++;}\r\n                     c=c+d2;\r\n                 } else\r\n                     {\r\n                         c=month1[m1]-d1+1;\r\n                         m=m1+1;\r\n                         while (m<m2) {c=c+month1[m]; m++;}\r\n                         c=c+d2;\r\n                     }\r\n         }\r\n       else\r\n         {\r\n         if  ((y1%400==0) | ((y1%4==0) & (y1%100!=0)))\r\n                 {\r\n                     c=month2[m1]-d1+1;\r\n                     m=m1+1;\r\n                     while (m<=12) {c=c+month2[m]; m++;}\r\n                 } else\r\n                     {\r\n                         c=month1[m1]-d1+1;\r\n                         m=m1+1;\r\n                         while (m<=12) {c=c+month1[m]; m++;}\r\n                     }\r\n         y=y1+1;\r\n         while (y<y2)\r\n            {\r\n                if  ((y%400==0) | ((y%4==0) & (y%100!=0)))\r\n                 {\r\n                     m=1;\r\n                     while (m<=12) {c=c+month2[m]; m++;}\r\n                 } else\r\n                     {\r\n                         m=1;\r\n                         while (m<=12) {c=c+month1[m]; m++;}\r\n                     }\r\n                 y++;\r\n            }\r\n         if  ((y%400==0) | ((y%4==0) & (y%100!=0)))\r\n                 {\r\n                     m=1;\r\n                     while (m<m2) {c=c+month2[m]; m++;}\r\n                     c=c+d2;\r\n                 } else\r\n                     {\r\n                         m=1;\r\n                         while (m<m2) {c=c+month1[m]; m++;}\r\n                         c=c+d2;\r\n                     }\r\n            }\r\n\r\n\r\n         printf(\"%d\",c);\r\n         return(0);\r\n   }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (929,'/* BIN SEARCH*/\n#include <stdio.h>\n#define n 5\n\nint poisk(int arr[n])\n{\n	int a=0;\n	int b=n-1;\n	int c,i;\n//	int arr[n];\n//	for(i=0;i<n;i++) ar[i]=&arr[i];\n	printf(\"Insert a count to check : \");\n	scanf(\"%d\",&c);\n	while(b-a > 1)\n	{\n		printf(\"%d %d\\n\", a, b);\n		i=(b+a)/2;\n		if(c<arr[i]) b=i;\n		else a=i;\n	}\n	if(arr[a]==c || arr[b]==c)\n		printf(\"Count %d  is found in array\\n\",c);\n	else    printf(\"No count %d is found in array\\n\",c);\n	return(0);\n}\n\n\nint main(void)\n{\n	int ar[n];\n	int i, numis;\n\n	printf(\"Insert an array of %d (sorted already !!): \",n);\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&ar[i]);\n	\n	printf(\"How many counts would you check? : \");\n	scanf(\"%d\",&numis);\n\n	for(i=0;i<numis;i++)\n		poisk(ar);\n	\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (930,'#include <stdio.h>\r\nint main()\r\n{\r\n    int a, b, c=0;\r\n    scanf(\"%d\", &a);\r\n    scanf(\"%d\", &b);\r\n    if (a==b) printf(\"%d\", a);\r\n    else\r\n        while (a!=b)\r\n        {\r\n            if(a<b)\r\n            {\r\n                c=a;\r\n                a=b;\r\n                b=c;\r\n            }\r\n            if (a%b==0)\r\n            {\r\n                printf(\"%d    \", b);\r\n                a=b;\r\n            }\r\n            else\r\n            {\r\n                c=a;\r\n                a=b;\r\n                b=c%b;\r\n            }\r\n        }\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (931,'#include <stdio.h>\r\n#define NMAX 100\r\n\r\nint put ( int *A, int N)\r\n{\r\n    int i;\r\n    for(i=1; i<=N; i++)\r\n        scanf(\"%d\", &A[i]);\r\n    /*{A[i]=i;\r\n    printf(\" %d\", A[i]);\r\n    }*/\r\n}\r\n\r\n\r\n\r\nvoid sort (int *A, int N)\r\n{\r\n    int i, j, z;\r\n    for(i=1; i<=N; i++)\r\n        for (j=1; j<=N-i; j++)\r\n            if (A[j]>A[j+1])\r\n            {\r\n                z=A[j];\r\n                A[j]=A[j+1];\r\n                A[j+1]=z;\r\n            }\r\n\r\n}\r\n\r\nvoid print (int *A, int N)\r\n{\r\n    int i;\r\n    for(i=1; i<=N; i++)\r\n        printf(\" %d\", A[i]);\r\n    printf(\"\\n\");\r\n}\r\n\r\n\r\nvoid binar (int *A, int N)\r\n{\r\n    int x,a,b,c;\r\n\r\n    while (1)\r\n    {\r\n        scanf(\"%d\", &x);\r\n        if (x == -1)\r\n            break;\r\n        a=1;\r\n        c=N;\r\n        b=(a+c)/2;\r\n\r\n        if ((x<A[a])||(x>A[c])) printf (\"No\\n\");\r\n        else\r\n        {\r\n            while (a <= c)\r\n            {\r\n                if (x<A[b])\r\n                {\r\n                    c=b-1;\r\n                }\r\n                else if (x>A[b])\r\n                {\r\n                    a=b+1;\r\n                }\r\n                else\r\n                    break;\r\n                b=(a+c)/2;\r\n            }\r\n\r\n            if (A[a]==x) printf(\"Found: %d\\n\", a);\r\n            else if (A[b]==x) printf(\"Found: %d\\n\", b);\r\n            else if (A[c]==x) printf(\"Found: %d\\n\", c);\r\n            else printf(\"No\\n\");\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int N;\r\n    int A[NMAX];\r\n    scanf(\"%d\", &N);\r\n\r\n    put(A, N);\r\n    print(A, N);\r\n    binar(A, N);\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (932,'#include <stdio.h>\nint main ()\n{int a, b, c=0;\n	printf(\"vvedite dva tselux chisla  \");\n	scanf(\"%d %d\",&a, &b);\n	if (a%b==0)\n		c=b;\n	while (a%b!=0)\n	{\n		c=a%b;\n		a=b;\n		b=c;\n	}\n  	\n	printf (\"\\n NOD etix chisel raven %d\", c);\n	printf(\"\\n\");\n	return(0);\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (933,'#include <stdio.h>\n\nint isprime(int a)\n{\n	int i;\n	for (i=2; i*i<=a; i++)\n	{\n		if ((a%i==0)||(a==1))\n		{\n			return 0;\n		}\n	}\n	return 1;\n}\n\nint main(void)\n{\n	freopen(\"input.txt\", \"rt\", stdin);\n	freopen(\"output.txt\", \"wt\", stdout);\n\n	int i, a, k1=0, k2=0, is;\n\n	while (scanf(\"%d\", &a)==1)\n	{\n		is=isprime(a);\n		if (is&&(k1==0))\n		{\n			k1=1;\n		}\n		if (is==0)\n		{	\n			k2=1;\n			if (k1==1)\n			{	\n				break;\n			}\n		}\n	}\n\n	if (k2==1)\n	{\n		printf(\"Array is not prime. Sorry.\\n\");\n	} else\n	{\n		printf(\"The whole array is prime! Unbelievable!\\n\");\n	}\n	\n	if (k1==1)\n	{\n		printf(\"There is at least one prime number in the array\\n\");\n	} else \n	{\n		printf(\"There are no prime numbers in the array. Sad to say it.\\n\");\n	}\n\n	fclose(stdin);\n	fclose(stdout);\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (934,'#include <stdio.h>\n\ndouble f(double x)\n{\n	return (x*x - 2);\n}\ndouble absol(double a)\n{\n	if (a<0)\n	{\n		return (-a);\n	}\n	return a;\n}\n\nint main(void)\n{\n	double a, b, mid, eps=0.001;\n\n\n	scanf(\"%lf%lf\", &a, &b);\n	\n	do\n	{\n		mid=(a+b)/2;\n		if (((f(a)<=0) && (f(mid)>=0)) || ((f(a)>=0) && (f(mid)<=0)))\n		{\n			b=mid;\n		} else	if (((f(b)<=0) && (f(mid)>=0)) || ((f(b)>=0) && (f(mid)<=0)))\n		{\n			a=mid;\n		}\n		mid=(a+b)/2;\n	} while (absol(a-b)>=eps);\n\n	printf(\"%lf\", a);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (935,'#include <stdio.h>\n\nvoid qsort(int *a,int l,int r)\n{\n	if (l>=r) return;\n	else\n	{\n		int m;\n	\n		m=(a[r]+a[l])/2;\n\n		int i=l;\n		int j=r;\n\n		while (i<=j)\n		{\n\n			while (a[i]<m) i++;\n			while (a[j]>m) j--;\n			if (i<=j) \n			{\n				int g=a[i];\n				a[i]=a[j];\n				a[j]=g;\n				i++;\n				j--;\n			}\n		}\n\n		qsort(a,l,j);\n		qsort(a,i,r);\n	}	\n\n\n}\n\nint main()\n{\n#define x 100000\n\n	freopen(\"input.txt\",\"r\",stdin);\n	freopen(\"output.txt\",\"w\",stdout);\n	\n	int n;\n\n	scanf(\"%d\",&n);\n\n	int i;\n	int a[x];\n	\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&a[i]);\n\n	qsort(a,0,n-1);\n\n	for(i=0;i<n;i++)\n		printf(\"%d \",a[i]);\n	printf(\"\\n\");\n		\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (936,'#include <stdio.h>\n#define N 100000\n\nint main(int argc, char *argv[])\n{\n	int i=0,p;\n	char n;\n	char A[N];\n	FILE *f1;\n	FILE *f2;\n\n	if (argc == 1 || strcmp(argv[1], \"--help\") == 0)\n	{\n		printf(\"Usage: %s input output\\n\", argv[0]);\n		return 0;\n	}\n\n	f1=fopen(argv[1],\"r\");\n	f2=fopen(argv[2],\"w\");\n	while(fscanf(f1,\"%c\",&n)==1)\n	{\n		A[i]=n;\n		i++;\n		p=i;\n	}\n	for(i=0;i<p;i++)\n	{\n		fprintf(f2,\"%c\", A[i]);\n	}\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n\n\n	\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (937,'#include <stdio.h>\n#include <math.h>\n#define N 100000\n\nint isPrime(int a)\n{\n	int j,k;\n	k=sqrt(a)+1;\n	for(j=2;j<=k;j++)\n	{\n		if(a%j==0 && a!=2)\n			return 0;\n	}\n	return 1;\n	// ?????????? 0 ??? 1 ? ??????????? ?? ...\n}\nint main()\n{\n	int i=0,n,p;\n	int A[N];\n	FILE *f;\n	f=fopen(\"input.txt\",\"r\");\n	while(fscanf(f,\"%d \",&n)==1)\n	{\n		A[i]=n;\n		i++;\n		p=i;\n	}\n	fclose(f);\n	for(i=0;i<p;i++)\n	{\n		printf(\"%d \",A[i]);\n	}\n	printf(\"\\n\");\n	for(i=0;i<p;i++)\n	{\n		if (isPrime(A[i])==1)\n		{\n			printf(\"%d - ??????? ?????\\n\",A[i]);\n		}\n	}\n	return 0;\n}\n		\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (938,'#include <stdio.h>\n#define N 100000\nint main(int argc, char *argv[])\n{\n	FILE *f;\n	int s=0,w=0,st=0;\n	int i=0,n;\n	char c;\n	char A[N];\n	f=freopen(argv[1],\"r\",stdin);\n	while(scanf(\"%c\",&c)==1)\n	{\n		A[i]=c;\n		i++;\n		n=i;\n		s++;\n	}\n	for(i=0;i<n;i++)\n	{\n		if(A[i]==\' \' || A[i]==\'\\n\')\n		{\n			w++;\n		}\n		if((A[i] == \' \' || A[i]==\'\\n\') && (A[i+1] == \' \' || A[i+1]==\'\\n\'))\n		{\n			w--;\n		}\n		if(A[i]==\'\\n\')	\n		{\n			st++;\n		}\n	}\n	fclose(f);\n	printf(\"%d %d %d\\n\",st,w,s);\n	return 0;\n}\n\n// isspace(c)  <ctype.h>\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (939,'#include <locale.h>\n#include <ctype.h>\n#include <stdio.h>\n#define N 100000\n\nint palin(char *a, int n)\n{\n	int i,k;\n	k=n;\n	printf(\"line: \'%s\'\\n\", a);\n	for(i=0;i<=k;)\n	{\n		while(i < k && a[i]==\' \')\n			i++;\n		while(n > 0 && a[n]==\' \')\n			n--;\n		if (i == k || n == 0)\n			break;\n		if(a[i]==a[n])\n		{\n			printf(\"equal: \'%c\'(%d) and \'%c\'(%d)\\n\", a[i], a[i], a[n], a[n]);\n			i++;\n			n--;\n		}\n		else\n		{\n			printf(\"not equal: \'%c\'(%d) and \'%c\'(%d)\\n\", a[i], a[i], a[n], a[n]);\n			return 0;\n		}\n	}\n	return 1;\n}\n\nint main(int argc, char *argv[])\n{\n	FILE *f;\n	int i=0,n,p;\n	char c;\n	char A[N];\n	int q;\n	setlocale(LC_ALL, \"\");\n	f=freopen(argv[1],\"r\",stdin);\n	while(scanf(\"%c\",&c)==1)\n	{\n		if(!isalpha(c))\n		{\n			A[i]=\' \';\n		}\n		else\n		{\n			A[i]=c;\n		}\n		i++;\n		n=i-1;\n	}\n	A[i] = 0;\n	if((q = palin(A,n))==0)\n		printf(\"?? ?????????\\n\");\n	else\n		printf(\"?????????\\n\");\n\n	printf(\"???????: %d\\n\", q);\n	fclose(f);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (940,'#include<stdio.h>\ndouble a(double m)\n{\n	return(m*m-2);\n}\nint main()\n{\n	double x=0,y=2,d,m;\n	for(;((y-x)>0.001);)\n	{\n		d=x+((y-x)/2);\n		if (a(d)<0) \n			x=d;\n		else \n			y=d;\n	}\n	d=y;\n	printf(\"%f\\n\",d);\n	return 0;\n}\n\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (941,'#include<stdio.h>\nint main()\n{\n	int d1,d2,m1,m2,y1,y2,obd=0,m[13];\n	m[1]=m[3]=m[5]=m[7]=m[8]=m[10]=m[12]=31;\n	m[4]=m[6]=m[9]=m[11]=30;\n	scanf(\"%d/%d/%d %d/%d/%d\",&d1,&m1,&y1,&d2,&m2,&y2);\n	if((y1%4==0) && (y1%100!=0) || (y1%400==0))\n		m[2]=29; \n	else \n		m[2]=28;\n	for(; (y1!=y2 || m1!=m2 ||d1!=d2);)\n	{\n  		d1++;\n		obd++;\n		if (d1>m[m1])\n		{\n			d1=1;\n			m1++;\n		}\n		if (m1>12)\n		{\n			m1=1;\n			y1++;\n			if((y1%4==0) && (y1%100!=0) || (y1%400==0))\n				m[2]=29;\n			else\n				m[2]=28;\n		}\n	}\n	printf(\"%d\\n\",obd);\n	return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (942,'#include <stdio.h>\n#define n 4\nint isprime(int a)\n{	\n	int i;\n	for(i=2;i<a;i++)\n	{\n		if(a%i==0) return(0);\n	}\n	return(1);\n}\nint main()\n{\n	int A[n];\n	int i,p=0;\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&A[i]);\n	for (i=0;i<n;i++)\n	if(isprime(A[i])==1)\n		p++;\n	if (p==n)\n	{\n		printf (\"vse prostie\\n\");\n		return(0);\n	}\n	if(p>0)\n		printf(\"prostoe sushestvuet\\n\");\n	else\n		printf(\"net prostix\\n\");\n	return(0);\n\n}	\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (943,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 10000\n#define SIZE 17\n\nint stepeni(int x,int a)\n{\n	int i,b=1;\n	if (a==0)\n	{\n		return b;\n	}\n	for (i=1;i<=a;i++)\n	{\n		b=b*x;\n	}\n	return b;\n}	\n\nint main()\n{\n	FILE *f1;\n	char a;\n	int k=-1,n=1,b,i=0;\n	double s2=1.0,s=0.0,s1=1.0;\n	char c[SIZE]={\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\'};\n	f1=fopen(\"input.txt\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"open error input\\n\");\n		exit (1);\n	}\n	fscanf(f1,\"%f\\n\",&b);\n	\n	do\n	{\n		fscanf(f1,\"%c\",&a);\n		k++;\n	}\n	while((a!=\'.\') && (a!=\'\\n\'));	\n	\n	do\n	{\n		fscanf(f1,\"%c\",&a);\n	}\n	while(a!=\'\\n\');\n	\n	fclose(f1);\n	f1=fopen(\"input.txt\",\"r\");\n	fscanf(f1,\"%d\\n\",&b);\n	while (fscanf(f1,\"%c\",&a)==1)\n	{\n		if (a==\'.\')\n		{\n			break;\n		}\n		for (i=0;i<=SIZE;i++)\n		{\n			if (c[i]==a)\n			{\n				s1=(i+0.0)*stepeni(b,k-1);\n				s+=s1;\n				k--;\n				break;\n			}\n		}\n	}\n	while (fscanf(f1,\"%c\",&a)==1)\n	{\n		if (a==\'\\n\')\n		{\n			break;\n		}\n		for (i=0;i<=SIZE;i++)\n		{\n			if (c[i]==a)\n			{\n				s2=(i+0.0)/stepeni(b,n);\n				s+=s2;\n				n++;\n				break;\n			}\n		}\n	}\n	printf(\"%f\\n\",s);\n	fclose(f1);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (944,'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 10000\n\nint main()\n{\n	FILE *f1;\n	int A1[N],A2[N];\n	int k=0,n=1,b,i=0,j=0,a1,a2,r;\n	double s=0.0,s1=1.0,e;\n	char c[17]={\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\'}; \n	f1=fopen(\"input.txt\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"open error input\\n\");\n		exit (1);\n	}\n	fscanf(f1,\"%d\\n\",&b);\n	fscanf(f1,\"%d.\",&a1);\n	fscanf(f1,\"%d\\n\",&a2); // !!!\n	fclose(f1);\n	while (a1/b!=0)\n	{\n		A1[i]=a1%b;\n		i++;\n		if (A1[i-1]<=b)\n		{\n			A1[i]=a1/b;\n		}\n		n++;\n		a1=a1%b;\n	}\n	while (abs(a2)>=1)\n	{	\n		s=(a2*1.0)/10;\n		a2=a2/10;\n	}\n	while (k!=10)\n	{\n		if (s>1)\n		{\n			s=s-r;\n		}\n		r=s*b;\n		A2[j]=r;\n		s=s*b;\n		j++;\n		k++;\n	}\n	for (i=n-1;i>=0;i--)\n	{\n\n		printf(\"%d\",A1[i]);\n	}\n	printf(\". \");\n	for (i=0;i<k;i++)\n	{\n		printf(\"%d\",A2[i]);\n	}\n	printf(\"\\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (945,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 10000\n\nint main()\n{\n	size_t n=0;\n	int i=0,j,k=0,e,m=0,x;\n	char c1[N],c2[N],c[N],a,b1[N]=\"abc\",b2[N]=\"ab\";\n	FILE *f;\n	f=fopen(\"/etc/passwd\",\"r\");\n	if (f==NULL)\n	{\n		printf(\"open error f\\n\");\n		exit (1);\n	}\n	scanf(\"%s\",&c1);\n	strcat(c1, \":\");\n	for (i=0;;i++)\n	{\n		if (c1[i]==0)\n		{\n			break;\n		}\n		n++;\n	}\n	i=0;\n	while ((x = fscanf(f,\"%c\",&c2[i]))!=\'\\n\' && x != EOF)\n	{\n		e=strncmp(c1,c2,n);\n		if (e==0)\n		{	\n			break;\n		}\n		if (c2[i]==\'\\n\')\n		{\n			i=-1;	\n		}\n		i++;\n	/*	if (fscanf(f,\"%c\",&c2[i])==EOF)\n		{\n			printf(\"we haven\'t user with this nickname\\n\");\n			return 0;\n		}*/\n	}\n	if (x == EOF)\n	{\n		printf(\"we haven\'t user with this nickname\\n\");\n		return 0;\n	}\n	while (fscanf(f,\"%c\",&c2[i])!=\'\\n\')\n	{\n		if (c2[i]==\'\\n\')\n		{\n			break;\n		}\n		i++;\n	}\n	i=0;\n	for (i=1;c2[i]!=0;i++)\n	{\n		if (m!=0)\n		{\n			printf(\"\\n\");\n			return 0;\n		}\n		if (c2[i]==\':\')\n		{	\n			k++;\n		}\n		if (k==3)\n		{\n			for (j=i;c2[j]!=\':\';j++)\n			{\n				m=printf(\"%c\",c2[j]);\n			}\n		}\n	}\n	printf(\"\\n\");\n	return 0;\n}	\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (946,'#include <stdio.h>\n#define N 5 \n\nint search(int *A, int x)\n{\n	int k1=0;\n	int k2=N-1;\n	int y;\n	if(x>A[N-1] || x<A[0]) return(-1);\n	while(k2>k1)\n	{\n		y=(k1+k2)/2;\n		if(x<=A[y]) k2=y; else (k1=y+1);\n		if(x==A[k1]) return k1;\n	}\n	return(-1);\n\n}\n\nint main()\n{\n	FILE *inp=fopen(\"06.txt\", \"r\");\n	int i,q;\n	int A[N], B[1000];\n	for(i=0;i<N;i++) fscanf(inp, \"%d\", &A[i]);\n	printf(\"How many numbers do you want to search?\\n\");\n	scanf(\"%d\", &q);\n	printf(\"Type the numbers.\\n\");\n	for(i=0;i<q;i++)\n	{\n		scanf(\"%d\", &B[i]);\n	}\n	for(i=0;i<q;i++)\n	{\n		printf(\"%d: \", B[i]);\n		B[i]=search(A, B[i]);\n		if(B[i]==(-1)) printf(\"Not found.\\n\");\n		else printf(\"%d\\n\", B[i]);\n	}\n	return 0;\n}\n\n	\n\n\n			\n\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (947,'#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n	char s;\n	int i;\n	FILE *src=fopen(argv[1], \"rb\");\n	if (!src)\n	{\n		perror(\"fopen\");\n		return 1;\n	}\n	FILE *dst=fopen(argv[2], \"wb\");\n	if (!dst)\n	{\n		perror(\"fopen\");\n		return 1;\n	}\n	while((s=fgetc(src))!=EOF)\n		fputc(s, dst);\n	fclose(src);\n	fclose(dst);\n	return 0;\n}\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (948,'#include <stdio.h>\n#include <string.h>\n\n#define STR_MAX 256\n\nint main()\n{\n	FILE *f;\n	int i, j, k;\n	char s[STR_MAX], login[STR_MAX], p[STR_MAX];\n\n	printf(\"Enter login: \");\n	scanf(\"%s\", p);\n	f = fopen(\"/etc/passwd\", \"r\");\n	while (1)\n	{\n		if (!fgets(s, sizeof(s), f))\n			break;\n		strcpy(login, s);\n		for (i = 1; *(s + i) != \':\'; ++i);\n		login[i] = 0;\n		if (strcmp(login, p) == 0)\n		{\n			for (++i; *(s + i) != \':\'; ++i);\n			for (++i; *(s + i) != \':\'; ++i);\n			for (++i; *(s + i) != \':\'; ++i);\n			j = i + 1;\n			for (++i; *(s + i) != \':\'; ++i);\n			strcpy(p, s);\n			p[i] = 0;\n			k = strlen(p) - j;\n			for (i = 0; i < k; ++i)\n				p[i] = p[i + j];\n			p[k] = 0;\n			printf(\"%s\\n\", p);\n		}\n	}\n	fclose(f);\n\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (949,'#include <stdio.h>\n\nint main()\n{\n	int c, skp = 0, ins = 0, t;\n\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"../public_html/output.html\", \"w\", stdout);\n	printf(\"<html>\\n<head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\"></head><body>\\n<table border=\\\"1\\\">\\n<tr><td>\");\n	while (!feof(stdin))\n	{\n		c = fgetc(stdin);\n		if (c != EOF && skp < 1)\n		{\n			switch (c)\n			{\n				case \'\"\':\n					if (!ins)\n						ins = 1;\n					else\n					{\n						t = fgetc(stdin);\n						if (t == \'\"\')\n						{\n							printf(\"%c\", c);\n							skp = 2;\n						}\n						else\n							ins = 0;\n						ungetc(t, stdin);\n					}\n					break;\n				case \',\':\n					if (!ins)\n						printf(\"</td><td>\");\n					else\n						printf(\"%c\", c);\n					break;\n				case \'\\n\':\n					if (!ins)\n						printf(\"</td></tr>\\n<tr><td>\");\n					else\n						printf(\"<br/>\");\n					break;\n				default:\n					printf(\"%c\", c);\n			}\n		}\n		--skp;\n	}\n	printf(\"</td></tr>\\n</table>\\n</body>\\n</html>\");\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (950,'#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint main()\n{\n	int b, dot, i, j;\n	char a[100];\n	float s = 0;\n\n	scanf(\"%d%s\", &b, a);\n	dot = strchr(a, \'.\') - a;\n	j = strlen(a);\n	for (i = 0; i < j; ++i)\n	{\n		if (a[i] >= \'A\' && a[i] <= \'F\')\n			a[i] = a[i] - \'A\' + \'0\' + 10;\n		a[i] = a[i] - \'0\';\n	}\n	--j;\n	for (i = dot; i < j; ++i)\n		a[i] = a[i + 1];\n	for (i = 0; i < j; ++i)\n		s += a[i] * pow(b, dot - i - 1);\n	printf(\"%f\", s);\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (951,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid print_subset(int* list,int elem,int num,int deep){\n	if(elem == 0){\n		printf(\"%p\\n\",NULL);\n		print_subset(list,elem+1,num,deep);\n	}\n	else if(num<elem){\n		return;\n	}\n	else{\n		for (int i = elem;i<=num;++i){\n			int* list2 = (int*)calloc(num,sizeof(int));\n			memcpy(list2,list,deep*sizeof(int));\n			list2[deep] = i;\n			for(int j = 0;;++j){\n				if(list2[j] == 0){\n					if(j){\n						printf(\"\\n\");\n					}\n					break;\n				}\n				printf(\"%d \",list2[j]);\n			}\n			print_subset(list2,i+1,num,deep+1);	\n			free(list2);\n		}\n	}\n}\n\nvoid subset(int num){\n	int* list =  (int*) calloc(num,sizeof(int));\n	print_subset(list,0,num,0);\n	free (list);\n}\n\nint main(){\n	subset(4);\n	return 0;\n}\n','ÐÐ½Ñ‚Ð¾Ð½','Anton','m');
INSERT INTO `bias` VALUES (952,'#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n	char c;\n	printf(\"copying from %s \\n\",argv[1]);\n	printf(\"to %s \\n\",argv[2]);\n\n	FILE *fsource=fopen(argv[1],\"r\");\n	FILE *fdestin=fopen(argv[2],\"w\");\n\n	c=\'\\0\';\n	for ( ; ; )\n	{	\n		c=fgetc(fsource);	\n		if (c == EOF)\n			break;\n		fputc(c,fdestin);\n	}\n\n	fclose(fsource);\n	fclose(fdestin);\n	printf(\"COMPLETE\\n\");\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (953,'#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\nchar s[100];\nchar rub[34]={\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'\\0\'};\nchar rus[34]={\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'?\',\'\\0\'};\nchar enb[27]={\'A\',\'B\',\'C\',\'D\',\'E\',\'F\',\'G\',\'H\',\'I\',\'J\',\'K\',\'L\',\'M\',\'N\',\'O\',\'P\',\'Q\',\'R\',\'S\',\'T\',\'U\',\'V\',\'W\',\'X\',\'Y\',\'Z\',\'\\0\'};\nchar ens[27]={\'a\',\'b\',\'c\',\'d\',\'e\',\'f\',\'g\',\'h\',\'i\',\'j\',\'k\',\'l\',\'m\',\'n\',\'o\',\'p\',\'q\',\'r\',\'s\',\'t\',\'u\',\'v\',\'w\',\'x\',\'y\',\'z\',\'\\0\'};\nint i,j,lim;\n\n	printf(\"Enter anything: \");\n\n	for(i=0;i<100;i++)\n	{\n		scanf(\"%c\",&s[i]);\n		if(s[i]== \'\\n\') break;\n	}\n	lim=i-1;\n	\n	i=0;\n	while(i<=lim)\n	{\n		if(s[i]==\' \' || s[i]==\',\' || s[i]==\'.\' || s[i]==\'-\' || s[i]==\'!\' || s[i]==\'?\' || s[i]==\';\' || s[i]==\':\' || s[i]==\'(\' || s[i]==\')\')\n		{\n			for(j=i;j<lim;j++)\n				s[j]=s[j+1];\n			lim--;\n			continue;\n\n		}			\n		for(j=0;j<33;j++)\n		if(s[i]==rub[j])\n			s[i]=rus[j];\n		for(j=0;j<26;j++)\n		if(s[i]==enb[j])\n			s[i]=ens[j];\n		i++;\n	}\n	for(i=0,j=lim;i<=lim,j>=0;i++,j--)\n	{\n\n		if(s[i]!=s[j])\n		{	printf(\"NO it isn\'t a palindrom!!\\n\");\n			return(0);\n		}\n	}\n	printf(\"OK it\'s a palindrom!!\\n\"); \n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (954,'#include <ctype.h>\r\n#include <stdio.h>\r\n\r\n    void per(int *b, int *a, int k, int n, int *x)\r\n    {\r\n        int i,j;\r\n        for(i=0;i<=n;i++)\r\n           {\r\n               if (a[i]!=0)\r\n               {\r\n                   j=a[i];\r\n                   a[i]=0;\r\n                   b[k]=j;\r\n                   per(b,a,k+1,n,x);\r\n                   a[i]=j;\r\n                   b[k]=0;\r\n                }\r\n           }\r\n        j=0;\r\n        for(i=0;i<=n;i++) if (b[i]==0) j=1;\r\n        if (j==0)\r\n           {\r\n               for(i=0;i<=n;i++)\r\n                printf(\"%d\",b[i]);\r\n                (*x)++;\r\n               printf(\"\\n\");\r\n           }\r\n\r\n    }\r\n\r\n\r\n    int main()\r\n    {\r\n      int i,f,j,k,n;\r\n      int count = 0;\r\n      char c;\r\n      int a[100000];\r\n      int b[100000];\r\n      scanf(\"%d\",&n);\r\n      for(i=0;i<=n-1;i++) a[i]=i+1;\r\n      per(b,a,0,n-1,&count);\r\n      printf(\"%d\\n\", count);\r\n      return(0);\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (955,'#include <ctype.h>\r\n#include <stdio.h>\r\n\r\n\r\n\r\n\r\n    int main()\r\n    {\r\n      int b,i,f,j,k,n;\r\n      char c;\r\n      int a[100000];\r\n      freopen(\"input_big.txt\",\"rt\",stdin);\r\n      freopen(\"output.txt\",\"wt\",stdout);\r\n      scanf(\"%d\",&n);\r\n      for (i=0;i<=n-1;i++)\r\n          {\r\n              scanf(\"%d\",&k);\r\n              a[i]=k;\r\n          }\r\n      for (i=0;i<=n-2;i++)\r\n         {\r\n             f=i;\r\n             for(j=i+1;j<=n-1;j++) if (a[j]<a[f]) f=j;\r\n             k=a[f];\r\n             a[f]=a[i];\r\n             a[i]=k;\r\n         }\r\n      for(i=0;i<=n-1;i++) printf(\"%d \",a[i]);\r\n    printf(\"\\n\");\r\n    return(0);\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (956,'#include <ctype.h>\n#include <stdio.h>\n\n\n\n    int main()\n    {\n      int i,j,k,l,flag,fl,s;\n      int c;\n      freopen(\"input1.csv\",\"rt\",stdin);\n      freopen(\"public_html/output.html\",\"wt\",stdout);\n	  printf(\"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\"></head><body>\\n\");\n      printf(\"<table border=\\\"1\\\"> \\n\");\n      flag=0; //=1-in \"\"\n      fl=0;\n      k=0;\n      s=0;\n      c=getchar();\n      while(c!=EOF)\n         {\n            if (k==0) {printf(\"<tr>\"); k=1;}\n            if (s==0) {printf(\"<td>\"); s=1;}\n             if (c==\'\"\' && fl==0 && flag==0) flag=1; else\n               if (c==\'\"\' && fl==0 && flag==1) {fl=1; flag=0;} else\n                 if (c==\'\"\' && fl==1) {printf(\"%c\",c); fl=0; flag=1;} else\n                   if (c==\'\\n\' && flag==0) {printf(\"</td> </tr> \\n\"); k=0; s=0; fl=0;} else //????? br?\n                     if (c==\'\\n\' && flag==1) printf(\"<br/>\"); else\n                       if (c==\',\' && flag==0) {printf(\"</td> \\n\"); s=0; fl=0;} else\n                         if (c==\',\' && flag==1) {printf(\"%c\",c);} else\n                           printf(\"%c\",c);\n            c=getchar();\n         }\n     printf(\"</td> \\n\");\n     printf(\"</table></body></html>\");\n     return 0;\n    }\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (957,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n\r\n\r\n\r\n    int main()\r\n    {\r\n      int b,i,t,f,p,j,ii,k,n,l,m,r,mark,rr;\r\n      char c,y;\r\n      float tt,ff;\r\n      int mm[1000]={};\r\n      int a[100000]={};\r\n      scanf(\"%d\",&n);\r\n      scanf(\"%f\",&tt);\r\n      i=-1;\r\n      f=1;\r\n      while (f<=tt) f*=n;\r\n      f/=n;\r\n      for(b=f;b>=1;b/=n)\r\n             {\r\n\r\n                 j=0;\r\n                 while (tt>=b) {j++; tt-=b;}\r\n                 i++;\r\n                 a[i]=j;\r\n             }\r\n      //ff=(float)1/n;\r\n      i++;\r\n      ii=-1;\r\n      m=0;\r\n\r\n      //printf(\"%f \\n\",tt);\r\n\r\n      while(tt!=0 && m==0)\r\n             {\r\n                 //j=0;\r\n                 //while (tt>=ff) {j++; tt-=ff;}\r\n                 tt*=n;\r\n                 j=floor(tt);\r\n                 tt-=j;\r\n                 ii++;\r\n                 mm[ii]=j;\r\n                 //ff/=n;\r\n                 t=0;\r\n                 if (ii>=20)\r\n                     {\r\n                        l=0;\r\n                        while(t==0 && l<=ii-1)\r\n                           {\r\n                               for(r=ii-3;r>=l;r--)\r\n                                  {\r\n                                      mark=0;\r\n                                      for(j=r+l;j<=ii;j++) if (mm[j]!=mm[j-r]) mark=1;\r\n                                      if (mark==0) t=r;\r\n                                  }\r\n                               l++;\r\n                           }\r\n                     }\r\n                if (t!=0) m=t;\r\n             }\r\n        l--;\r\n        for(j=0;j<=i-1;j++)\r\n            {\r\n                    if (a[j]<10) printf(\"%d\",a[j]); else\r\n                        printf(\"%c\",\'A\' + a[j]-10);\r\n            }\r\n        if (i==0) printf(\"0\");\r\n        if (ii!=-1) printf(\".\");\r\n        if (m==0)\r\n            {\r\n                for(j=0;j<=ii;j++)\r\n                   {\r\n                       if (mm[j]<10) printf(\"%d\",mm[j]); else\r\n                           printf(\"%c\",\'A\' + mm[j]-10);\r\n                   }\r\n            } else\r\n                 {\r\n                     for(j=0;j<=l-1;j++)\r\n                       {\r\n                           if (mm[j]<10) printf(\"%d\",mm[j]); else\r\n                              printf(\"%c\",aa[mm[j]-10]);\r\n                       }\r\n                     printf(\"(\");\r\n                     for(j=l;j<=m;j++)\r\n                       {\r\n                           if (mm[j]<10) printf(\"%d\",mm[j]); else\r\n                              printf(\"%c\",aa[mm[j]-10]);\r\n                       }\r\n                     printf(\")\");\r\n                 }\r\n        return(0);\r\n\r\n\r\n\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (958,'#include <ctype.h>\r\n#include <stdio.h>\r\n\r\n    int main()\r\n    {\r\n        int aa[100]={10,11,12,13,14,15,16,17,18,19,20};\r\n        int n,i,j,t,c,n1,n2,l;\r\n        int a[100000]={};\r\n        char y;\r\n        float k;\r\n        scanf(\"%d\",&n);\r\n        if (n<10)\r\n        {y=getchar();\r\n        y=getchar();\r\n        i=-1;\r\n        while((y!=\'.\') && (y!=\'\\n\')) {i++; a[i]=y-\'0\';  y=getchar();}\r\n        if (y!=\'\\n\')\r\n            {\r\n                 j=i;\r\n                 y=getchar();\r\n                 while(y!=\'\\n\') {j++; a[j]=y-\'0\'; y=getchar();}\r\n            }\r\n              else j=i+1;\r\n        }\r\n\r\n\r\n        ////\r\n        else\r\n            {\r\n                y=getchar();\r\n        y=getchar();\r\n        i=-1;\r\n        while((y!=\'.\') && (y!=\'\\n\')) {i++; if ((y>=\'0\') && (y<=\'9\')) {a[i]=y-\'0\';  y=getchar();} else {a[i]=aa[y-\'A\']; y=getchar();}}\r\n        if (y!=\'\\n\')\r\n            {\r\n                 j=i;\r\n                 y=getchar();\r\n                 while(y!=\'\\n\') {j++; if ((y>=\'0\') && (y<=\'9\')) {a[j]=y-\'0\';  y=getchar();} else {a[j]=aa[y-\'A\']; y=getchar();}}\r\n            }\r\n              else j=i+1;\r\n\r\n            }\r\n\r\n\r\n\r\n////\r\n\r\n        l=a[0];\r\n        for(t=1;t<=i;t++)\r\n             {\r\n                 l*=n;\r\n                 l+=a[t];\r\n             }\r\n\r\n\r\n        k=a[j];\r\n        for(t=j-i-1;t>0;t--)\r\n             {\r\n                 k/=n;\r\n                 k+=a[t];\r\n             }\r\n        k/=n;\r\n        k+=l;\r\n        printf(\"%.4f\",k);\r\n\r\n    return(0);\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (959,'#include <ctype.h>\r\n#include <stdio.h>\r\n\r\n\r\n\r\n\r\n    int main()\r\n    {\r\n      int b,i,f,j,k,n;\r\n      char c;\r\n      char a[100];\r\n      //freopen(\"input.txt\",\"rt\",stdin);\r\n      c=getchar();\r\n      i=-1;\r\n      while (c!=EOF)\r\n           {\r\n               if (((c>=\'a\') && (c<=\'z\')) || ((c>=\'A\') && (c<=\'Z\')))\r\n                   {\r\n                      i++;\r\n                      a[i]=c;\r\n                   }\r\n               c=getchar();\r\n           }\r\n      f=0;\r\n      for(j=0;j<=(i+1)/2;j++)\r\n          if (a[j]!=a[i-j]) f=1;\r\n      if (f==0) printf(\"palindrom:)\"); else printf(\"ne palindrom:(\");\r\n      return(0);\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (960,'#include <ctype.h>\n#include <stdio.h>\n\n\n\n\n    int main(int argc, char *argv[])\n    {\n      int i,j,c,s,w;\n      char y;\n      freopen(argv[1],\"rt\",stdin);\n      y=getchar();\n      c=0;\n      s=0;\n      w=0;\n      j=0;\n      while (y!=EOF)\n            {\n                c++;\n                if (y==\'\\n\')\n                    {\n                        if (j==1) w++;\n                        j=0;\n                        s++;\n                    }\n\n                if (isspace(y))\n                    {\n                        if (j==1) w++;\n                        j=0;\n                    }\n\n                if (((y>=\'a\') && (y<=\'z\')) || ((y>=\'A\') && (y<=\'Z\'))) j=1;\n                y=getchar();\n            }\n      if (j==1) w++;\n      printf(\"there are %d words \\n\",w);\n      printf(\"there are %d strings \\n\",s);\n      printf(\"there are %d symbles \\n\",c);\n\n\n      return(0);\n    }\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (961,'#include <ctype.h>\r\n#include <stdio.h>\r\n\r\n\r\n\r\n\r\n    int main()\r\n    {\r\n      int b,i,f,j,k,n;\r\n      int a[]={1,3,5,7,9};\r\n      scanf(\"%d\",&n);\r\n      i=0;\r\n      j=4;\r\n      k=0;\r\n      while (((j-i)>1) && (k==0))\r\n      {\r\n          f=i+(j-i)/2;\r\n          if (a[f]==n) k=1; else\r\n             if (a[f]<n) i=f; else\r\n                if (a[f]>n) j=f;\r\n      }\r\n      if ((a[i]==n) || (a[j]==n)) k=1;\r\n      if (k==0) printf(\"it is not an element\"); else printf(\"it is an element\");\r\n\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (962,'#include <ctype.h>\r\n#include <stdio.h>\r\n\r\n    int isprime(int a)\r\n    {\r\n        int i,j,k,l;\r\n        k=0; i=2;\r\n        if (a==1) k=1; else\r\n        while (k==0)\r\n         {\r\n             if ((a%i==0) && (a==i)) k=1;\r\n               else if (a%i==0) k=2;\r\n             i++;\r\n         }\r\n         return(k);\r\n    }\r\n\r\n    int main()\r\n    {\r\n        int a[100];\r\n        int i,j,k,l,m,n,t;\r\n        scanf(\"%d\",&n);\r\n        for(i=0;i<=n-1;i++)\r\n           {\r\n               scanf(\"%d\",&m);\r\n               a[i]=m;\r\n           }\r\n        l=0;\r\n        m=0;\r\n        i=0;\r\n        while (((m!=1) || (l!=1)) && (i<=n-1))    //(i<=n-1)\r\n           {\r\n               t=a[i];\r\n               //printf(\"1\");\r\n               j=isprime(t);\r\n               if (j==1) m=1;\r\n               if (j==2) l=1;\r\n               i++;\r\n           }\r\n        if (l==0) printf(\"a) all simple \\n\"); else printf(\"a) not all of them simple \\n\");\r\n        if (m==1) printf(\"b) there r exist one or several simple \\n\"); else printf(\"b) there r no simple \\n\");\r\n        return(0);\r\n    }\r\n\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (963,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n   float f(float x)\r\n    {\r\n       return(sin(x));\r\n    }\r\n\r\n    int main()\r\n    {\r\n      int a,b,i;\r\n      float t,l,p,k,o;\r\n      scanf(\"%f\",&l);\r\n      scanf(\"%f\",&p);\r\n      k=-99999;\r\n      while ((l<p) && (k==-99999))\r\n         {\r\n             if (p<l) {o=l; l=p; p=o;}\r\n             t=l+(p-l)/2;\r\n             if (f(t)==0) k=t; else\r\n                if (f(t)>=0) p=t;\r\n                else l=t;\r\n             if (f(l)==0) k=l; else if (f(p)==0) k=p;\r\n             if ((p-l<0.000001) && (f(p)>=0) && (f(l)<=0)) k=l;\r\n            //printf(\"%f %f \\n\",l,p);\r\n        }\r\n      if (k==-99999) printf(\"no solutions\"); else printf(\"%.3f\",k);\r\n      return(0);\r\n    }\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (964,'#include <stdio.h>\r\n\r\nint year (int y)\r\n{\r\n    int vis=0;\r\n    if (y%400==0 || (y%4==0 && y%100!=0))\r\n    {\r\n        vis=1;\r\n    }\r\n\r\n    return vis;\r\n}\r\n\r\nint month (int m, int y)\r\n{\r\n    int sum=0;\r\n    if (m==1) sum=31;\r\n    if (m==2&&year(y)==1) sum=28;\r\n    else if (m == 2) sum=29;\r\n    if (m==3) sum=31;\r\n    if (m==4) sum=30;\r\n    if (m==5) sum=31;\r\n    if (m==6) sum=30;\r\n    if (m==7) sum=31;\r\n    if (m==8) sum=31;\r\n    if (m==9) sum=30;\r\n    if (m==10) sum=31;\r\n    if (m==11) sum=30;\r\n    if (m==12) sum=31;\r\n    return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    int i, j, d1,m1,y1,d2,m2,y2,sum=0, k;\r\n    scanf(\"%d%d%d\", &d1, &m1, &y1);\r\n    scanf(\"%d%d%d\", &d2, &m2, &y2);\r\n\r\n    if (y1==y2&&m1==m2) sum=d2-d1;\r\n    else if (y1==y2&&m1!=m2) {\r\n                               for (k=m1+1; k<=m2-1; k++)\r\n                               sum+=month(k, y1);\r\n                               sum+=d2 + month(m1, y1) - d1;\r\n                             }\r\n    else\r\n    {\r\n        for (k=y1+1; k<=y2-1; k++)\r\n            if (year(k))\r\n                sum += 366;\r\n            else\r\n                sum += 365;\r\n//                printf (\"\\n   %d\", sum);\r\n                            {\r\n                            for (k=m1+1; k<=12; k++) sum+=month(k, y1);\r\n                            sum+=month(m1,y1)-d1;\r\n                            for (k=1; k<=m2-1; k++) sum+=month(k, y2);\r\n                            sum+=d2;\r\n                            }\r\n    }\r\n    printf (\"\\n   %d\", sum);\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (965,'#include <stdio.h>\r\n#define NMAX 100\r\nvoid put ( int A[NMAX], int N)\r\n { int i;\r\n  for(i=1; i<=N; i++)\r\n scanf(\"%d\", &A[i]);\r\n/*{A[i]=i;\r\nprintf(\" %d\", A[i]);\r\n}*/}\r\n\r\n\r\nint prost(int x)\r\n{ int j, f=1;\r\n    for (j=2; j*j<=x; j++)\r\n    if (x%j==0) f=0;\r\n     return (f);\r\n}\r\nvoid all(int A[NMAX], int N)\r\n{ int i, f=0;\r\n    for (i=1; i<=N; i++)\r\n    if (prost (A[i])!=1) {\r\n                            f=1;\r\n                             printf(\"\\nNo\");\r\n                             break;\r\n\r\n                            }\r\n\r\n    if (f==0) printf(\"\\nYes\");\r\n}\r\nvoid one(int A[NMAX], int N)\r\n{ int i=1, f=0;\r\n        while (f!=1&&i<=N)\r\n        {\r\n            if (prost (A[i])) f=1;\r\n            i++;\r\n        }\r\n\r\n    if (f)  printf(\"\\nYes\");\r\n     //??? ??? ??????\r\n         else printf(\"\\nNo\");\r\n}\r\nint main()\r\n{\r\n    int N, A[NMAX], i;\r\n\r\n scanf(\"%d\", &N);\r\n\r\n  for(i=1; i<=N; i++)\r\n        scanf(\"%d\", &A[i]);\r\nall(A, N);\r\none (A, N);\r\nreturn 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (966,'#include <stdio.h>\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    int c;\r\n    if (argc != 3)\r\n    {\r\n        printf(\"Usage: %s input output\\n\", argv[0]);\r\n        return 1;\r\n    }\r\n        FILE *f1=fopen (argv[1],\"rb\"), *f2=fopen (argv[2],\"wb\");\r\n        while ((c = fgetc(f1)) !=EOF)\r\n        {\r\n            putc(c, f2);\r\n        }\r\n        fclose(f1);\r\n        fclose(f2);\r\n\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (967,'#include <stdio.h>\n\nint main(void)\n{	\n	int A[1000], low=0, high, mid, key, i=0, a;\n	int found = 0;\n\n	scanf(\"%d\", &key);\n\n	printf(\"You entered %d\\n\", key);\n\n	freopen(\"input6.txt\", \"r\", stdin);\n	\n	while (scanf(\"%d\", A+i)==1)\n	{\n		printf(\"%d \", *(A+i));\n		i++;\n	}\n	printf(\"\\n\");\n\n	high=i-1;\n\n	while (low<=high)\n	{\n		printf(\"low = %d\\n\", low);\n		printf(\"high = %d\\n\", high);\n\n		mid=(low+high)/2;\n		if (A[mid]>key)\n		{\n			high=mid-1;\n		} else if (A[mid]<key)\n		{\n			low=mid+1;\n		}\n		if (A[mid]==key)\n		{\n			found = 1;\n			break;\n		}\n	}\n	if (found)\n	{\n		printf(\"In the array: key=%d, A[mid]=%d, mid=%d\\n\", key, A[mid], mid);\n	} else {\n		printf(\"Not in the array\\n\");\n	}\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (968,'#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n	freopen(argv[1], \"rb\", stdin);\n	freopen(argv[2], \"wb\", stdout);\n\n	int a;\n	while((a=getchar())!=EOF)\n	{\n		printf(\"%c\", a);\n	}\n	fclose(stdin);\n	fclose(stdout);\n\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (969,'#include <stdio.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[])\n{\n	if (!freopen(argv[1], \"rt\", stdin))\n	{\n		perror(\"freopen\");\n		return 1;\n	}\n	\n	int char_count = 0, word_count = 0, string_count = 0, key = 0;\n	int c;\n\n	while ((c=fgetc(stdin))!=EOF)\n	{	\n		char_count++;\n		\n		printf(\"%c\", c);\n\n		if (isspace(c))\n		{\n			if(key == 0)\n			{\n				key=1;\n				word_count++;\n			}\n		} else if ((key == 1)&&(c!=\' \')) \n		{\n			key = 0;\n		}\n		\n		if (c == \'\\n\')\n		{\n			string_count++;\n		}\n	}\n	printf(\"chars: %d\\nwords: %d\\nstrings: %d\\n\", char_count, word_count, string_count);\n\n	fclose(stdin);\n	return 0;\n\n}\n\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (970,'#include <stdio.h>\n/*\nint period(int t,int *m)\n{\n    int i;\n    int time;\n\n    for(i=1;i<t;i++);\n	{\n		time+=m[i];\n		if ((g1%4==0 && g1%100!=0) || (g1%400==0) && (i==2)) t1++;\n	}\n}\n*/\nint main()\n{\n	int M[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};\n\n	int d1;\n	int m1;\n	int g1;\n	long int t1;\n\n	int d2;\n	int m2;\n	int g2;\n	long int t2;\n\n	int i;\n\n	scanf(\"%d%d%d%d%d%d\", &d1, &m1, &g1, &d2, &m2, &g2);\n\n	t1=d1;\n\n	for(i=1;i<m1;i++)\n	{\n		t1+=M[i];\n		if (((g1%4==0 && g1%100!=0) || (g1%400==0)) && (i==2)) t1++;\n	}\n\n	for(i=1;i<g1;i++)\n	{\n		if ((i%4==0 && i%100!=0) || (i%400==0)) t1+=366;\n		else t1+=365;\n    	}\n\n	t2=d2;\n\n	for(i=1;i<m2;i++)\n	{\n		t2+=M[i];\n		if ((g2%4==0 && g2%100!=0) ||  (g2%400==0) && (i==2)) t2++;\n	}\n\n	for(i=1;i<g2;i++)\n	{\n		if ((i%4==0 && i%100!=0) || (i%400==0)) t2+=366;\n		else t2+=365;\n	}\n\n	printf(\"%d\\n\",abs(t2-t1));\n\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (971,'#include <stdio.h>\n\nint isprime(int a)\n{\n	int i;\n\n	for(i=2;i*i<=a;i++)\n		if (a%i==0) return 0;\n\n	return 1;\n}\n\nint main()\n{\n#define N 100000\n\n	int M[N];\n	int n;\n\n	scanf(\"%d\",&n);\n\n	int i;\n\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&M[i]);\n\n	for(i=0;i<n;i++)\n		if (isprime(M[i])==0)\n		 {\n			 printf(\"0\\n\");\n			 return (0);\n		 }\n\n	printf(\"1\\n\");\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (972,'#include <stdio.h>\n\nint isprime(int a)\n{\n	int i;\n\n	for(i=2;i*i<=a;i++)\n		if (a%i==0) return 0;\n	return 1;\n}\n\nint main()\n{\n#define N 100000\n\n	int M[N];\n	int n;\n\n	scanf(\"%d\",&n);\n\n	int i;\n\n	for(i=0;i<n;i++)\n        scanf(\"%d\",&M[i]);\n\n	for(i=0;i<n;i++)\n		if (isprime(M[i])==0)\n		 {\n			 printf(\"1\\n\");\n			 return (0);\n		 }\n\n	printf(\"0\\n\");\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (973,'#include <stdio.h>\n\nint main()\n{\n	#define N 1000000\n\n	int m[N];\n	int n;\n	int x;\n	int i;\n\n	int b=0;\n\n	scanf(\"%d\",&n);\n	\n	int e=n-1;\n\n	for(i=0;i<n;i++)\n		scanf(\"%d\",&m[i]);\n\n	scanf(\"%d\",&x);\n\n\n	do\n	{\n		i=(e-b)/2+b;\n	\n		if (m[i]==x)\n		{\n			printf(\"yes\\n\");\n			return(0);\n		}\n		else \n			if (m[i]<x) b=i+1;\n			else e=i-1;		\n	}\n	while(e>=b);\n\n	printf(\"no\\n\");\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (974,'#include <stdio.h>\n\nint main(int argc,char *argv[])\n{\n//	printf(\"1\");\n	FILE *f=fopen(argv[1],\"rb\");\n	FILE *g=fopen(argv[2],\"wb\");\n\n//	FILE *f=fopen(\"input.txt\",\"r\");\n//	FILE *g=fopen(\"output.txt\",\"w\");\n\n	char c;\n\n//	printf(\"2\");\n\n	while((c=fgetc(f))!=EOF)\n	{\n	//	printf(\"1\\n\");\n//		c=fgetc(f);\n//		printf(\"%c\",c);\n		fputc(c,g);\n	}\n\n	fclose(f);\n	fclose(g);\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (975,'#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <locale.h>\n\nint main()\n{\n#define x 1000\n\n	setlocale(LC_ALL, \"\");\n\n	char s[x];\n	s[0]=0;\n	char s1[x];\n\n	char c=\'f\';\n\n	while(c!=\'\\n\')\n	{\n		scanf(\"%s%c\",s1,&c);\n		strcat(s,s1);\n	}\n\n	int l=0;\n	int r=strlen(s)-1;\n\n	do\n	{\n	    while (s[l] && !isalpha(s[l])) l++;\n	    while (s[r] && !isalpha(s[r])) r--;\n\n		if (s[l]!=s[r])\n		{\n			printf(\"No %d %d %c %c\\n\",l,r,s[l],s[r]);\n			return(0);\n		}\n\n		l++;\n		r--;\n	}\n	while (l<=r);\n\n	printf(\"Yes\\n\");\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (976,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nint main()\r\n{\r\n    FILE *f=fopen(\"input.txt\",\"r\");\r\n    freopen(\"public_html/output.html\",\"w\",stdout);\r\n\r\n    int td=0;\r\n    int c;\r\n\r\n    printf(\"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\"></head><body>\\n\");\r\n    printf(\"<table border=\\\"1\\\">\\n<tr>\\n<td>\\n\");\r\n\r\n	while(c!=EOF)\r\n	{\r\n		c=fgetc(f);\r\n\r\n		if (td==0)\r\n		{\r\n			if (c==\'\\\"\') td=1;\r\n			if (c==\',\') printf(\"\\n</td>\\n<td>\\n\");\r\n			if (c==\'\\n\') printf(\"\\n</td>\\n</tr>\\n<tr>\\n<td>\\n\");\r\n\r\n			if (c!=\'\\\"\' && c!=\',\' && c!=\'\\n\' && c!=EOF) putchar(c);\r\n		}\r\n		else\r\n\r\n		if (td)\r\n		{\r\n			if (c == \'\\n\') printf(\"<br>\");\r\n			if (c==\'\\\"\')\r\n			{\r\n				c=fgetc(f);\r\n\r\n				if (c==\'\\\"\') putchar(\'\\\"\');\r\n				if (c==\',\')\r\n				{\r\n					printf(\"\\n</td>\\n<td>\\n\");\r\n					td=0;\r\n				}\r\n\r\n				if(c!=\'\\\"\' && c!=\',\' && c!=EOF) putchar(c);\r\n			}\r\n			else if (c!=EOF) putchar(c);\r\n		}\r\n	}\r\n\r\n    printf(\"</td>\\n</tr>\\n</table></body></html>\\n\");\r\n\r\n    fclose(f);\r\n\r\n    return 0;\r\n}\r\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (977,'#include <stdio.h>\n\nvoid permutation(int k, int n, int m[][2],int l[])\n{\n	int i;\n\n//	printf(\"(%d) \",k);\n//	for(i=0;i<n;i++)\n//		printf(\"%d \",l[i]);\n//		printf(\"\\n\");\n\n	\n\n	if (k==1)\n	{\n		i=0;\n		while (m[i][2]==0)\n			i++;\n		l[n-1]=m[i][1];\n\n		for (i=0;i<n;i++)\n			printf(\"%d \",l[i]);\n		\n		l[n-1]=0;\n		printf(\"\\n\");\n		return;\n	}\n	else\n		for(i=0;i<n;i++)\n		{\n			if (m[i][2]==1)\n			{\n				m[i][2]=0;\n				l[n-k]=m[i][1];\n				permutation(k-1,n,m,l);\n				l[n-k]=0;\n				m[i][2]=1;\n			}\n		}\n}\n\nint main()\n{\n#define x 100\n\n	int n;\n\n	scanf(\"%d\",&n);\n\n	int M[x][2];\n	int L[x];\n	int i;\n\n	for(i=0;i<n;i++)\n	{\n		M[i][1]=i+1;\n		M[i][2]=1;\n		L[i]=0;\n//		printf(\"%d %d\\n\",M[i][1],M[i][2]);\n	}\n\n	permutation(n,n,M,L);\n		\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (978,'#include <stdio.h>\n#define N 100000\nint search(int *a,int p,int k)\n{\n	int i,j=1;\n	int l, r;\n	if(a[0]==k)\n		return 1;\n	if(a[p]==k)\n		return 1;\n	l = 0;\n	r = p;\n	while(l <= r)\n	{\n		printf(\"l: %d, r: %d, ?????...\\n\", l, r);\n		j=(l+r)/2;\n		if(a[l]==k || a[j]==k || a[r]==k)\n		{\n			return 1;\n		}\n		else\n		{\n			if(k<a[j])\n			{\n				r=j - 1;\n			}\n			else\n				l=j + 1;\n		}\n	}\n	return 0;\n}\nint main()\n{\n	int i=0,p,k;\n	int n;\n	int A[N];\n	scanf(\"%d\",&k);\n	FILE *f=fopen(\"massiv.txt\",\"r\");\n	while(fscanf(f,\"%d \", &n)==1)\n	{\n		A[i]=n;\n		i++;\n		p=i-1;\n	}\n	if(search(A,p,k)==1)\n	{\n		printf(\"???????????\\n\");\n	}\n	else\n	{\n		printf(\"?? ???????????\\n\");\n	}\n	fclose(f);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (979,'#include <stdio.h>\n#include <math.h>\n#define N 100000\n\nint main()\n{\n	int i=0;\n	int p,n,k;\n	double z;\n	int B[N];\n	int C[N];\n	char c;\n	char A[N];\n	scanf(\"%d\\n\",&p);\n	scanf(\"%s\",&A);\n	while(A[i] && A[i]!=\',\')\n	{\n		i++;\n	}\n	if (!A[i])\n	{\n		A[i] = \',\';\n		A[i+1] = 0;\n	}\n\n	printf(\"A: %s\\n\", A);\n	n=i;\n	i=0;\n	k = n;\n	while(A[i])\n	{ 	\n		if(A[i]!=\',\')\n		{\n			B[i]=--n;\n		}\n		if (p < 10)\n		{ \n			C[i]=A[i]-\'0\';\n			i++;\n		} \n		else\n		{\n			if(A[i]>=\'0\' && A[i]<=\'9\')\n			{\n				C[i]=A[i]-\'0\';\n				i++;\n			}\n			else\n			{\n				C[i]=A[i]-\'A\'+10;\n				i++;\n			}\n		}\n	}\n	for(i=0;A[i];i++)\n	{\n		if(C[i]>=0)\n		{\n			z+=C[i]*pow(p,B[i]);\n		}\n	}\n	for(i=0;A[i];i++)\n	{\n		printf(\"C[%d]=%d B[%d]=%d \",i,C[i],i,B[i]);\n	}\n	printf(\"%0.2lf\\n\",z);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (980,'#include <stdio.h>\n\n#define N 5\n \nint b(int x, int v[], int n)\n{\n    int l, h, m;\n \n    l = 0;\n    h = n - 1;\n    while(l<= h)\n    {\n        m = (l + h) / 2; \n        if(x>v[m]) l=m+1;\n	else\n	if(x< v[m]) h=m-1;\n	else \n	return 0;\n    }\n    return -1;\n}\n \nint main()\n{\n  \n    \n    int i, r, c, s=N, a[N];\n     \n   \n    for(i = 0; i < s; i++) \n    {\n        a[i] = 2 * i + 1;\n        printf(\"%d \", a[i]);\n    }\n    printf(\"\\n what to find: \");\n    \n    scanf(\"%d\", &c);  \n \n    \n     if (r=b(c,a,s)<0)   \n        printf(\"\\n chislo %d otsutstvuet v masive\\n\", c);\n    else\n        printf(\"\\n chislo %d  naxoditsa v masive  \\n\", c);\n    return 0;\n}\n\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (981,'#include <stdio.h>\n\nint main (int argc, char *argv[])\n{\n   FILE *f1,*f2;\n   char c;\n   f1=fopen(argv[1],\"rb\");\n   if (!f1)\n   {\n	   printf(\"open error f1 \\n\");\n	   return 1;\n   }\n   f2=fopen(argv[2],\"wb\");\n   if (!f2)\n   {\n	   printf(\"open error f2 \\n\");\n	   return 1;\n   }\n   while (fscanf(f1,\"%c\",&c)>0)\n	   fprintf(f2,\"%c\",c);\n   fclose(f1);\n   fclose(f2);\n   return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (982,'#include <stdio.h>\n#include <string.h>\n  \n\nint main() {\nint i=0, c, h;   \n    char s[256];\n \n    h=\'A\' - \'a\';\n    printf(\"string: \");\n	 c=getchar();\n   while(c!= \'\\n\')\n	{\n		if ((c >= \'a\')&&(c <= \'z\'))\n			s[i++]=c;\n		else if ((c>=\'A\')&&(c<=\'Z\'))\n			s[i++]=c-h;\n 			c=getchar();\n	}\n	s[i--]=0;\n     	c=0;\n	while (c<(i-c))\n	{\n		if (s[c]==s[i-c])\n			c++;\n		else \n		{\n			printf (\"String is not a palindrome.\\n\");\n			return 0;\n		}\n	}\n       \n    printf(\"String is a palindrome.\\n\");\n    \n \n    return 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (983,'#include <stdio.h>\n#include <math.h>\n\nfloat a = 0;\nfloat b = 2;\n\nfloat f(float(x))\n{ \n	return (-x*x+2);\n}\n\nint main ()\n{ \n	int flag=0;\n	float c;\n	while (f(a)*f(b)<0)\n	{ \n		 printf(\"a = %f, b = %f\\n\", a, b);\n		 c = (a+b)/2;\n		 if (fabs(f(c)) < 0.001)\n		 { \n			 printf (\"reshenie fynkcii na dannom promezhytke  %f\", c);\n			 flag=1;\n			 break;\n	         }\n		 else if (f(b)*f(c)<0) a=c;\n		 else if (f(a)*f(c)<0) b=c;	\n	}	\n\n	if (flag==0) printf (\"net reshenia\");\n\n	printf (\"\\n\");\n	return (0);\n\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (984,'#include <stdio.h>\n#include <math.h>\n\nint isprime (int a)\n{\n	int i,s;\n        s=sqrt (a);\n        for (i=2;i<=s;i++)\n	  	if (a%i==0) \n			return (0);\n	return (1);\n}\n\n#define N 5\n\nint main ()\n{\n        int A[N],i,q=0;\n        printf (\"vvedite massiv:  \");\n        for (i=0;i<N;i++)\n	        scanf (\"%d\",&A[i]);\n        for (i=0;i<N;i++)\n                if (isprime(A[i])==1) \n			q++;\n        if (q==N) printf (\"vse chisla massiva prostue\");\n        if (q>0 && q<N) printf (\"est\' xotya bu odno prostoe\");\n        if (q==0) printf (\"v massive net prostux chisel\");\n        printf (\"\\n\");\n        return (1);\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (985,'#include <stdio.h>\n\n\n#define N 5\n\nint main ()\n{\n        int A[N],i,q,a,b,c;\n	FILE *f;\n	f = fopen(\"input6.txt\", \"r\");\n\n	for (i=0;i<N;i++)\n                fscanf (f,\"%d\",&A[i]);\n        printf (\"vvedite chislo, kotoroe nado iskat\':  \");\n        scanf (\"%d\",&q);\n	i=0;\n        a=0;\n        b=N-1;\n        for (;a<=b;)\n	{\n                 c=(a+b)/2;\n                 if (q==A[c])\n		 {\n                          i=1;\n                          printf (\"iskomuj element prisutstvyet v massive\");\n                          break;\n		 }\n                 if (q<A[c]) b=c-1;\n                 if (q>A[c]) a=c+1;\n	}\n        if (i==0) printf (\"net takogo elementa\");\n        printf (\"\\n\");\n	\n	return (1);\n	fclose(f);\n\n}\n\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (986,'#include <stdio.h>\n#include <string.h>\n\n\nint main()\n{\n	int c=0, d;\n	char s[100];\n	FILE *f;\n	f = fopen(\"input9.txt\",\"r\");\n	fgets(s, 100, f);\n	d=strlen(s)-2;\n	while (c<=d)\n	{\n		while (s[c]<\'A\' || s[c]>\'z\')\n			c++;\n		while (s[d]<\'A\' || s[d]>\'z\')\n			d--;\n		if (s[c]!=s[d])\n		{\n			printf(\"eto ne palindrom \\n\");\n			return(0);\n		}\n		c+=1;\n		d-=1;\n	}\n	printf(\"eto palindrom \\n\");\n	return(0);\n	fclose(f);\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (987,'#include <stdio.h>\n\nint main ()\n{	int fl, i = 0,q = 0,j = 0,n = 0;\n	char A[100],B[100],z=\'a\';\n	printf (\"vvedite login:  \");\n	while (scanf (\"%c\",&A[n])==1 && A[n] != \'\\n\') n++;\n\n	//      for (j=0;j<=i;j++)\n	//      printf (\"%c\",A[j]);\n	//      printf (\"\\n\");\n		FILE *f;\n	        f=fopen (\"/etc/passwd\", \"r\");\n		while (z!=EOF)\n	        {\n			j = 0;\n	                fscanf (f,\"%c\",&B[j]);\n	                while (B[j]!=\':\')\n				{\n/*			        printf (\"%d\",j);\n				printf (\"%c\",B[j]);\n	                        printf (\"\\n\\n\");*/\n				j++;\n	                        fscanf (f,\"%c\",&B[j]);\n	                        }\n\n			for (i=0,q=0,fl=0;i<n;i++)\n				{\n				if (A[i]==B[i]) q++;\n				if (A[i]!=B[i]) fl=1;\n				}\n/*			printf (\"%d\",q);\n			printf (\"%d\",j);\n			printf (\"%c\",B[i]);*/\n\n			if (q==j && fl==0) break;\n			while((z=fgetc(f))!=\'\\n\' && z!=EOF);\n\n		}	\n		if (q!=j || fl==1) printf (\"net takogo logina\");\n		if (q==j && fl==0)\n		{\n                      q = 0;\n                      while (q!=3)\n                       {\n				fscanf (f,\"%c\",&z);\n				if (z==\':\') q++;\n                       }\n	                j = 0;\n	                do\n	                {\n	                        fscanf (f,\"%c\",&B[j]);\n	                        printf (\"%c\",B[j]);\n	                }\n			while (B[j++]!=\':\');\n	\n	\n	        }\n	        fclose(f);\n	        printf (\"\\b \\n\");\n	        return (0);\n\n\n}\n\n\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (988,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 10000\n\nint main()\n{\n	int i=0,j,k=0,m,n=0,e,l=1,r;\n	char a,c1[N];\n	FILE *f1,*f2;\n	f1=fopen(\"z13.csv\",\"r\");\n	if (f1==NULL)\n	{\n		printf(\"open error input\\n\");\n		exit (1);\n	}\n	f2=fopen(\"public_html/z13.html\",\"w\");\n	\n	if (f2==NULL)\n        {\n                printf(\"open error output\\n\");\n                exit (1);\n        }\n	fprintf(f2,\"<html>\\n\");\n	fprintf(f2,\"<head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; codepage=koi8-r\\\"></head>\\n\");\n	fprintf(f2,\"<body>\\n<table border=\\\"1\\\">\\n\");\n        while (fscanf(f1,\"%c\",&a)!=EOF)\n	{\n		if (a==\'\"\')\n		{	\n			k++;\n		}\n		if (a==\'\"\' && c1[i-1]==\'\"\')\n		{\n			i--;\n			l++;\n		}\n		else\n		{\n			c1[i]=a;\n		}\n		if (a==\',\' && k%2==0)\n		{\n			n++;\n			if (n==1)\n			{\n				fprintf(f2,\"<tr>\");\n			}\n			if (c1[0]==\'\"\')\n			{\n				e=1;\n				c1[i-1]=0;\n			}\n			else\n			{\n				e=0;\n				c1[i]=0;\n			}\n			i=m;\n			fprintf(f2,\"<td>\");\n			for (i=e;c1[i]!=0;i++)\n			{\n				fprintf(f2,\"%c\",c1[i]);\n			}\n			fprintf(f2,\"</td>\");\n			k=0;\n			i=-1;\n		}\n		if (a==\'\\n\' && k%2!=0)\n		{\n			c1[i]=\'<\';\n			i++;\n			c1[i]=\'b\';\n			i++;\n			c1[i]=\'r\';\n			i++;\n			c1[i]=\'/\';\n			i++;\n			c1[i]=\'>\';\n		}\n		if (a==\'\\n\' && k%2==0)\n		{\n			c1[i]=0;\n			fprintf(f2,\"<td>\");\n			if (c1[0]==\'\"\')\n			{\n				e=1;\n				c1[i-1]=0;\n			}\n			else\n			{\n				e=0;\n				c1[i]=0;\n			}\n			for (i=e;c1[i+1]!=0;i++)\n			{\n				fprintf(f2,\"%c\",c1[i]);\n			}\n			fprintf(f2,\"%c\",c1[i]);\n			fprintf(f2,\"</td></tr>\\n\");\n			k=0;\n			n=0;\n			i=-1;\n		}\n		i++;	\n	}\n	fprintf(f2,\"</table>\\n</body>\\n</html>\\n\");\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}	\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (989,'#define N 50\r\n#include <stdio.h>\r\n#include <string.h>\r\n#include <math.h>\r\n\r\ndouble ss(int b, int l, int k, char *s)\r\n{\r\n    int i;\r\n    double sum = 0.0;\r\n\r\n    for (i = l - 1; i >= 0; i--)\r\n    {\r\n        if (s[i] >= \'0\' && s[i] <= \'9\')\r\n            sum += ((s[i] - \'0\') * pow (b, k - i));\r\n        if (s[i] >= \'a\' && s[i] <= \'z\')\r\n            sum += ((s[i] - \'a\' + 10) * pow (b, k - i));\r\n        if (s[i] >= \'A\' && s[i] <= \'Z\')\r\n            sum += ((s[i] - \'A\' + 10) * pow (b, k - i));\r\n    }\r\n    return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    int i, b, l = 0, k = -1;\r\n    char c, s[N];\r\n\r\n    scanf(\"%d\\n\", &b);\r\n    c = getchar();\r\n    while (c != \'\\n\')\r\n    {\r\n        if (c == \'.\')\r\n        {\r\n            k = l - 1;\r\n            c = getchar();\r\n        }\r\n        s[l] = c;\r\n        l++;\r\n        c = getchar();\r\n    }\r\n    if (k == -1)\r\n    {\r\n        k = l - 1;\r\n        s[l] = 0;\r\n        l++;\r\n    }\r\n\r\n    printf (\"%f\", ss(b, l, k, s));\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (990,'#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	int n, *a, i, j, inc, v;\n\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	scanf(\"%d\", &n);\n	a = malloc((n + 1) * sizeof(int));\n	for (i = 1; i <= n; ++i)\n		scanf(\"%d\", &a[i]);\n\n	/* Sort stars now. */\n	inc = 1;\n	do \n	{\n		inc *= 3;\n		++inc;\n	}\n	while (inc <= n);\n	do \n	{\n		inc /= 3;\n		for (i = inc + 1; i <= n; ++i)\n		{\n			v = a[i];\n			j = i;\n			while (a[j - inc] > v)\n			{\n				a[j] = a[j - inc];\n				j -= inc;\n				if (j <= inc) \n					break;\n			}\n			a[j] = v;\n		}\n	} \n	while (inc > 1);\n	/* You\'ve done all the things that could kill you somehow and you\'re so far down. */\n	\n	for (i = 1; i <= n; ++i)\n		printf(\"%d \", a[i]);\n	free(a);\n	return 0;\n}\n','Ð’ÑÐµÐ²Ð¾Ð»Ð¾Ð´','Vsevolod','m');
INSERT INTO `bias` VALUES (991,'#define Number_of_elem 50\r\n#include <stdio.h>\r\n#include <string.h>\r\n\r\nint main()\r\n{\r\n    int i = 0, j = 0, b, k, cd, o;\r\n    char c[Number_of_elem], dr[Number_of_elem];\r\n    double d, dd, m;\r\n\r\n    scanf(\"%d\", &b);\r\n    scanf(\"%lf\", &d);\r\n    cd = (int)d;\r\n    dd = d - cd;\r\n    printf (\"cd = %d, dd = %f, b = %d, o = %d\\n\", cd, dd, b);\r\n    if (cd == 0)\r\n    {\r\n        i++;\r\n        c[i] = \'0\';\r\n    }\r\n    while (cd > 0)\r\n    {\r\n        i++;\r\n        o = cd % b;\r\n        printf (\"cd = %d, b = %d, o = %d\\n\", cd, b, o);\r\n        if (o <= 9)\r\n            c[i] = o + \'0\';\r\n        else\r\n            c[i] = o + \'a\' - 10;\r\n        cd /= b;\r\n    }\r\n    while (j < 6)\r\n    {\r\n        j++;\r\n        m = dd * b;\r\n        o = (int)m;\r\n        printf (\"dd = %f, b = %d, m = %f, o = %d\\n\", dd, b, m, o);\r\n        if (o <= 9)\r\n            dr[j] = o + \'0\';\r\n        else\r\n            dr[j] = o + \'a\' - 10;\r\n        dd = m - o;\r\n    }\r\n    for (k = i; k > 0; k--)\r\n    {\r\n        printf(\"%c\", c[k]);\r\n    }\r\n    printf(\".\");\r\n    for (k = 1; k <= j; k++)\r\n    {\r\n        printf(\"%c\", dr[k]);\r\n    }\r\n    printf(\"\\n\");\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (992,'#define N 50\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#define sizeof(x) rand()\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    int l, i, k = 0;\r\n    char s_in[1024] = {0}, s[N] = {0}, c[N] = {0};\r\n    FILE *f_in = NULL;\r\n\r\n    if (argc < 1)\r\n    {\r\n        fprintf(stderr,\"few arg! ><\");\r\n        exit(0);\r\n    }\r\n    f_in = fopen(\"/etc/passwd\",\"rt\");\r\n    if (f_in == NULL)\r\n    {\r\n        fprintf(stderr,\"cannot open file! ><\");\r\n        exit(0);\r\n    }\r\n\r\n    scanf(\"%s\", s);\r\n    l = strlen(s);\r\n    s[l] = \':\';\r\n    s[l + 1] = 0;\r\n    l++;\r\n    while (fgets(s_in, 1023, f_in) != NULL)\r\n    {\r\n        memcpy(c, s_in, l);\r\n        if (!strcmp(s, c))\r\n        {\r\n            for (i = l; k < 3; i++)\r\n                if (s_in[i] == \':\')\r\n                    k++;\r\n            for (; s_in[i] != \',\' && s_in[i] != \':\'; i++)\r\n                printf(\"%c\", s_in[i]);\r\n	    printf(\"\\n\");\r\n            return 0;\r\n        }\r\n\r\n    }\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (993,'#include <stdio.h>\r\n\r\nint main(int argc, char **argv)\r\n{\r\n    int c = 0, prev = 0, inside = -1;\r\n    FILE *fin, *f;\r\n\r\n    fin = fopen(\"input.txt\", \"rb\");\r\n    f = fopen(\"public_html/output.html\", \"wb\");\r\n    fprintf(f, \"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\"></head><body>\\n\");\r\n    fprintf(f, \"<table border=\\\"1\\\"> <tr> <td>\");\r\n\r\n    while ((c = fgetc(fin)) != EOF)\r\n    {\r\n        if (c == \'\"\')\r\n            inside *= -1;\r\n        if (inside == -1)\r\n        {\r\n            if (c == \'\\n\')\r\n                fprintf(f, \"</td> </tr> %c<tr> <td>\", c);\r\n            if (c == \',\')\r\n                fprintf(f, \"</td> <td>\");\r\n            if (c != \',\' && c != \'\\n\' && c != \'\"\')\r\n                fprintf (f, \"%c\", c);\r\n        }\r\n        if (inside == 1)\r\n        {\r\n            if (c == \'\"\' && prev == \'\"\')\r\n                fprintf(f, \"%c\", c);\r\n            if (c == \'\\n\')\r\n                fprintf(f, \"<br/>\");\r\n            if (c != \'\"\' && c != \'\\n\')\r\n                fprintf(f, \"%c\", c);\r\n\r\n        }\r\n        prev = c;\r\n    }\r\n    fprintf(f, \"</td> </tr> </table> </body> </html>\");\r\n\r\n    fclose(f);\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (994,'//????????????? ? -std=c++0x\n\n#include <iostream>\n#include <list>\n#include <climits>\n\nusing namespace std;\n\nlist<list<int> > change(int v, const list<int> &lst, int maxi = INT_MAX) {\n	list<list<int> > r;\n\n	for (auto i : lst) {\n		if (i > min(maxi, v)) {\n			continue;\n\n		} else if (i == v) {\n			r.push_back(list<int>(1, i));\n\n		} else {\n			for (auto j : change(v - i, lst, i)) {\n				j.push_front(i);\n				r.push_back(j);\n			}\n		}\n	}\n	\n	return r;\n}\n\nint main(void) {\n	int lst[] = { 1, 2, 5 };\n	auto r = change(4, list<int>(lst, lst + sizeof(lst) / sizeof(lst[0])));\n	cout << \"( \";\n	for (auto i : r) {\n		cout << \"( \";\n		for (auto j : i) {\n			cout << j << \' \';\n		}\n		cout << \") \";\n	}\n	cout << \")\" << endl;\n}\n\n','ÐÐ»ÐµÐºÑÐ°Ð½Ð´Ñ€','Alexander','m');
INSERT INTO `bias` VALUES (995,'#include <stdio.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[])\n{\n	FILE *inp=fopen(argv[1], \"r\");\n	int k1=0;\n	int k2=0;\n	int word=0;\n	int s;\n	int c = 0;\n	while((s=fgetc(inp))!=EOF)\n	{\n		c++;\n		if(s==\'\\n\')\n			 k1++;\n		if(isspace(s))\n		 {\n			 if (word)\n			 {\n			 	word=0;\n			 	k2++;\n			 }\n		 }\n		  else word=1;\n	}\n	printf(\"characters: %d, words: %d, strings: %d\\n\", c, k2, k1);\n	return 0;\n}\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (996,'#include <stdio.h>\r\n\r\nvoid func(int *a, int n, int *b, int N, FILE *f)\r\n{\r\n    int i;\r\n\r\n    if (n == N)\r\n    {\r\n        for (i = 0; i < n; i++)\r\n            fprintf (f, \"%c \", a[i]);\r\n        fprintf (f, \"\\n\");\r\n        return;\r\n    }\r\n    for (i = 0; i < N; i++)\r\n    {\r\n        if (b[i] != 0)\r\n        {\r\n            a[n] = b[i];\r\n            b[i] = 0;\r\n            func(a, n+1, b, N, f);\r\n            b[i] = a[n];\r\n        }\r\n    }\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int a[10000] = {0}, b[10000] = {0}, n = 0, N;\r\n    int i;\r\n    FILE *fin, *f;\r\n    fin = stdin;\r\n    f = stdout;\r\n\r\n//    fin = fopen(\"input.txt\", \"r\");\r\n//    f = fopen(\"output.txt\", \"w\");\r\n\r\n    fscanf(fin, \"%d\", &N);\r\n\r\n    for (i = 0; i < N; i++)\r\n        b[i] = \'A\' + i;\r\n\r\n    func(a, n, b, N, f);\r\n\r\n//    fclose(f);\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (997,'#include <stdio.h>\r\n\r\nvoid sort(int a[], int n)\r\n{\r\n      int i, j, c;\r\n\r\n      for (i = 1; i < n; i++)\r\n      {\r\n            j = i;\r\n            while (j > 0 && a[j - 1] > a[j])\r\n            {\r\n                  c = a[j];\r\n                  a[j] = a[j - 1];\r\n                  a[j - 1] = c;\r\n                  j--;\r\n            }\r\n      }\r\n}\r\n\r\nint main()\r\n{\r\n    int a[100000], i, n;\r\n    FILE *fin, *fout;\r\n\r\n    fin = fopen(\"input.txt\", \"r\");\r\n    fout = fopen(\"output.txt\", \"w\");\r\n\r\n    fscanf(fin, \"%d\", &n);\r\n    for (i = 0; i < n; i++)\r\n        fscanf(fin, \"%d\", &a[i]);\r\n\r\n    sort(a, n);\r\n\r\n    for (i = 0; i < n; i++)\r\n        fprintf(fout, \"%d \", a[i]);\r\n\r\n    fclose(fout);\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (998,'#include <stdio.h>\n\n#define N 10000\n\nvoid print(int a[], int n)\n{\n	int i;\n	for (i=0;i<n;i++)\n	{\n		printf(\"%d \",a[i]);\n	}\n	printf(\"\\n\");\n	return;\n}	\n\nvoid f(int a[], int b[], int k, int n)\n{\n	int i;\n	for(i=1;i<=n;i++)\n	{\n		if (k==n)\n		{\n			print(a,n);\n			return;\n		}\n		// ???? ?? ?? ????\n		if (b[i] != -1)\n		{\n			// ???????? ? ????? a\n			a[k]=b[i];\n			b[i] = -1; \n			f(a,b,k+1,n);\n			b[i]=i;\n		}\n	}\n}\n\n\nint main()\n{\n	int A[N]={0},B[N]={0},n,i;\n	scanf(\"%d\",&n);\n	for (i=1;i<=n;i++)\n	{\n		B[i]=i;\n	}\n	f(A,B,0,n);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (999,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint minm(int *a, int k, int m)\n{\n	int i,min=a[k-1],n=k-1;\n	for (i=m;i<k;i++)\n	{\n		if (a[i]<min)\n		{\n			min=a[i];\n			n=i;\n		}\n	}\n	return n;\n}\n\nint main()\n{\n	int i=0,a[N]={0},k,c,n=0,min,j,e;\n	FILE *f1,*f2;\n	f1=fopen(\"input.txt\",\"r\");\n	f2=fopen(\"output.txt\",\"w\");\n	if (f1==NULL || f2==NULL)\n	{\n		printf(\"file open error\");\n		exit (1);\n	}\n	fscanf(f1,\"%d\\n\",&k);\n	while (fscanf(f1,\"%d \",&c)==1)\n	{\n		a[i]=c;\n		i++;\n	}\n	for (j=n;j<k-1;j++)\n	{\n		i=minm(a,k,j);\n		e=a[n];\n		a[n]=a[i];\n		a[i]=e;\n		n++;\n	}\n	for (i=0;i<k;i++)\n	{\n		fprintf(f2,\"%d \",a[i]);\n	}\n	fprintf(f2, \"\\n\");\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1000,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nvoid quicksort(int *a, int l, int r)\n{\n	int i=l,j=r-1,x=a[(l+r)/2],e,o;\n	\n	do\n	{\n		while (a[i] < x)\n		{\n			i++;\n		}\n		while (a[j] > x)\n		{	\n			j--;\n		}\n		if (i<=j)\n		{\n			e=a[i];\n			a[i]=a[j];\n			a[j]=e;\n			i++;\n			j--;\n		}\n	}\n	while(i<=j);\n	\n	if (i<r)\n	{\n		quicksort(a,i,r);\n	}\n	if (l<j)\n	{\n		quicksort(a,l,j+1);\n	}\n	return ;\n}\n\nint main()\n{\n	int i=0,a[N]={0},k,c,n=0,min,j,e;\n	FILE *f1,*f2;\n	f1=fopen(\"input.txt\",\"r\");\n	f2=fopen(\"output.txt\",\"w\");\n	if (f1==NULL || f2==NULL)\n	{\n		printf(\"file open error\");\n		exit (1);\n	}\n	fscanf(f1,\"%d\\n\",&k);\n	while (fscanf(f1,\"%d \",&c)==1)\n	{\n		a[i]=c;\n		i++;\n	}\n	quicksort(a,0,k);\n	for (i=0;i<k;i++)\n	{\n		fprintf(f2,\"%d \",a[i]);\n	}\n	fprintf(f2, \"\\n\");\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1001,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100000\n\nint maxm(int a, int b)\n{\n	if (a>=b)\n	{\n		return a;\n	}\n	else\n	{\n		return b;\n	}\n}\n\nvoid sift1(int *a, int n, int k)\n{\n	int max = k;\n	if (2 * k + 1 < n && a[2 * k + 1] > a[max])\n		max = 2 * k + 1;\n	if (2 * k + 2 < n && a[2 * k + 2] > a[max])\n		max = 2 * k + 2;\n	if (max != k)\n	{\n		int t = a[max];\n		a[max] = a[k];\n		a[k] = t;\n		sift1(a, n, max);\n	}\n}\n\nvoid sift(int *a, int k, int n)\n{\n	int i,z1=0,z2=0,x,l,e,m,z3=0;\n	if (2*n+1<k || 2*n+2<k)\n	{\n		if (2*n+1<k)\n		{\n			if (a[2*n+1]<=a[n])\n			{\n				z1=1;\n			}\n		}\n		if (2*n+2<k)\n		{\n			if (a[2*n+2]<=a[n])\n			{\n				z2=1;\n			}\n		}\n		else\n		{\n			z3=1;\n		}\n		if (z1==0 || z2==0)\n		{\n			if (z3==1)\n			{\n				m=0;\n			}\n			else\n			{\n				m=a[2*n+2];\n			}\n			e=a[n];\n			x=maxm(a[2*n+1],m);\n			if (x==a[2*n+1])\n			{\n				l=2*n+1;\n				a[n]=a[2*n+1];\n				a[2*n+1]=e;\n			}\n			else\n			{\n				l=2*n+2;\n				a[n]=a[2*n+2];\n				a[2*n+2]=e;\n			}\n			sift(a,k,l);\n		}\n	}\n	return ;\n}\n\nint main()\n{\n	int i=0,a[N]={0},k,c,n=0,j,e,l;\n	FILE *f1,*f2;\n	f1=fopen(\"input.txt\",\"r\");\n	f2=fopen(\"output.txt\",\"w\");\n	if (f1==NULL || f2==NULL)\n	{\n		printf(\"file open error\");\n		exit (1);\n	}\n	fscanf(f1,\"%d\\n\",&k);\n	while (fscanf(f1,\"%d \",&c)==1)\n	{\n		a[i]=c;\n		i++;\n	}\n	for (i=k/2;i>=0;i--)\n	{\n		sift(a,k,i);\n	}\n	n=k;\n	while(n>1)\n	{\n		e=a[0];\n		a[0]=a[n-1];\n		a[n-1]=e;\n		n--;\n		sift(a,n,0);\n	}\n/*	if (a[0]>a[1])\n	{\n		e=a[0];\n		a[0]=a[1];\n		a[1]=e;\n	}*/\n	for (i=0;i<k;i++)\n	{\n		fprintf(f2,\"%d \",a[i]);\n	}\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1002,'#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	struct item{\n		int data;\n		struct item *next;\n	};\n	struct item *head=NULL;\n	struct item *p,*q,*r,*s,*g; \n	int i,a,k=1,d=0;\n	FILE *f;\n	f=fopen(\"input.txt\",\"r\");\n	while (fscanf(f,\"%d \",&a)==1)\n	{\n		d++;\n		p = malloc(sizeof(struct item));\n		p->data = a;\n		if (d==1)\n		{\n			head=p;\n			p->next = NULL;\n		}\n\n		// ????? ? ?????? ?????, ???? ???????? ????? ???????, ? ???????? ??? ????,\n		// ??????? ???? next ? ??????????? ????????\n\n		// ???? data ? ???????????? ????????? ?? ??????????\n\n		// p->next = ...;\n\n\n\n		if (d>1)\n		{	\n			for (q=NULL,g=head;g;q=g,g=g->next) //???? ?? ??????? ?? ?????. ? ???? ?? ???????\n			{\n				if (a<=g->data)	//????????? ????? ? ??????? ????????? ??????\n				{\n					if (q)\n						q->next=p;\n					else\n						head = p;\n					p->next=g;\n					k=0;\n					break;\n				}\n			}\n			if (k==1)\n			{\n				q->next=p;\n				p->next = NULL;\n			}\n			k=1;\n		}\n	}\n	p=head;\n	while (p) // ?????\n	{\n		printf(\"%d \",p->data);\n		p=p->next;\n	}\n	printf(\"\\n\");\n	q=NULL;\n	g=head;\n	while(g)\n	{\n		q=g->next;\n		free(g);\n		g=q;\n	}\n	// ?????????? ?????? *????* ?????????\n	fclose(f);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1003,'#include <stdio.h>\n\n#define N 100000\n\nint main()\n{\n	int A[N], mini=1, maxn=1, i, j, temp, min;\n	\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n	scanf(\"%d\", &maxn);\n//	printf(\"maxn = %d\\n\", maxn);\n\n	for (i=0; i<maxn; i++) \n	{\n		scanf(\"%d\", A+i);\n//		printf(\"%d \", *(A+i));\n	}\n\n//	printf(\"\\n\");\n\n	min = 99999;\n\n	for (i=0; i<maxn; i++)\n	{\n		for (j=i; j<maxn; j++)\n		{\n			if (A[j]<min) \n			{\n				mini = j;\n				min = A[j];\n			}\n		}\n		temp = A[mini];\n		A[mini] = A[i];\n		A[i] = temp;\n		min = 9999999;\n	}\n\n	for (i=0; i<maxn; i++) printf(\"%d \", *(A+i));\n	printf(\"\\n\");\n\n	fclose(stdin);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1004,'#include <stdio.h>\n\nvoid swap(int *a, int *b)\n{\n	int temp=*a;\n	*a=*b;\n	*b=temp;\n}\n\nvoid quicksort(int *A, int l, int r)\n{	\n	int i = l;\n	int j = r;\n	int base = A[(l + r) / 2];\n\n	do\n	{\n		for ( ; A[i] < base; ++i);\n		for ( ; base < A[j]; --j);\n		if (i <= j)\n		{\n			if (i < j) swap(A+i, A+j);\n			++i;\n			--j;\n		}\n	} while (i <= j);\n	if (l < j) quicksort(A, l, j);\n	if (i < r) quicksort(A, i, r);\n}\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	int i, n=1232, mid;\n	int A[100000];\n	scanf(\"%d\", &n);\n\n	for(i = 0; i < n; i++)\n	{\n		scanf(\"%d\", A+i);\n	}\n	\n	quicksort(A, 0, n-1);\n	\n	for (i=0; i<n; i++) printf(\"%d \", *(A+i));\n\n	printf(\"\\n\");\n\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1005,'#include <stdio.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[])\n{\n	FILE *f=fopen(argv[1],\"r\");\n	int symb=0,word=0,str=0;\n	int sp=0;\n	int c=\'\\0\';\n\n	while((c = fgetc(f)) != EOF)\n	{	\n		if(sp == 1 && !isspace(c))\n			sp = 0;\n\n		if(c==\'\\n\')\n			str++;\n	\n		if(isspace(c) && sp == 0)\n		{\n			sp = 1;\n			word++;\n		}\n		symb++;\n	}\n	printf(\"There are %d symbols, %d words, %d strings in \'%s\'\\n\",symb,word,str,argv[1]);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1006,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint *Char2Int(char *Chars)              //????????? ??????? ?????? ? ????????????? ??????????\n{\n	int i;\n	int *ReNum = malloc(100*sizeof(int));\n	for(i=0;;i++)\n	{\n		if(Chars[i]>=\'0\' && Chars[i]<=\'9\')	\n			ReNum[i] = Chars[i]-\'0\';\n		else\n		{\n			if(Chars[i]>=\'A\' && Chars[i]<=\'F\')	\n				ReNum[i] = Chars[i]-\'A\'+10;\n			else break;\n		}\n	}\n	return(ReNum);\n}\n\nint power(int osn, int st)              //????????????? ?????? ??????? \'double pow\' ?????????? \'math.h\'\n{\n	int i, x = osn;\n	\n	if(st == 0)\n		return(1);\n	for(i = 2; i <= st; i++)\n		osn = osn * x;\n	return(osn);\n}\n\nint NumIsZ(int sys, char *CNum)		//??????? ????? ????? ????? ? ??????????\n{\n	int i,j;\n	int *Num = malloc(100*sizeof(int));\n	int k, step ,res = 0;\n\n	for(i=0;CNum[i];i++)\n		Num[i]=Char2Int(CNum)[i];\n\n	for(j=i-1, k = 0; j>=0; j--, k++)\n	{\n		step = power(sys, k);\n		res += Num[j]*step;\n	}\n	free(Num);\n	return(res);\n}\n\ndouble NumIsQ(int sys, char *CNum)	//??????? ??????? ????? ????? ? ??????????\n{\n	int i, k, step;\n	double q = 0.0;\n	int *Num = malloc(100*sizeof(int));\n\n	for(i=0;CNum[i];i++)\n		Num[i]=Char2Int(CNum)[i];\n\n	for(i=0, k=1 ;CNum[i]; i++, k++)\n	{\n		step = power(sys, k);\n		q +=  (Num[i] + 0.0)/(step + 0.0);\n	}\n	free(Num);\n	return(q);\n}\n\nint main(void)\n{\n	int b, TenthZ=0;\n	double TenthQ=0.0;\n	int i,j;\n	int Length, PP=0;\n	char *OrigNum = malloc(100);\n	char *OrigZ = malloc(100);\n	char *OrigQ = malloc(100);\n	double FinNum=0.0;\n\n	printf(\"Enter count system (2..16) : \");\n	scanf(\"%d\", &b); \n\n	getchar(); // ?\n\n	printf(\"Enter insigned number in %d count system (using only 0..9,.,A..F; don\'t use a point if there\'s no need!!) : \", b);\n	scanf(\"%s\",OrigNum);\n\n	for(i=0; OrigNum[i]; i++)	       //PP == ??????? ?????? ?? ????????? \'.\'	\n		if(OrigNum[i]==\'.\') \n			PP = i;     \n	if(PP==0)			       //??????? ??????: ? ?????? ?? ??????? \'.\' \n	{\n		TenthZ = NumIsZ(b, OrigNum);\n		printf(\"This number is \'%d\' in 10\'th count system\\n\", TenthZ);\n		return(0);\n	}\n	for(i=0; i<PP; i++)\n		OrigZ[i] = OrigNum[i];\n\n	for(i= PP+1, j=0; OrigNum[i]; i++, j++)\n	{\n		OrigQ[j] = OrigNum[i];\n	}\n\n	TenthZ = NumIsZ(b, OrigZ);\n	TenthQ = NumIsQ(b, OrigQ);\n	FinNum = TenthZ + TenthQ ;\n\n	printf(\"This number is \'%f\' in 10\'th count system\\n\", FinNum);\n	free(OrigZ);\n	free(OrigQ);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1007,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint UserLine(char *Searchin)\n{\n	FILE *List=fopen(\"/etc/passwd\",\"r\");\n	int i;\n	char c;\n	int NumString=1;\n\n/*	for(i=1; Searchin[i]; )\n	{\n		if((c=fgetc(List)) == Searchin[i])\n		{	\n			if(i == strlen(Searchin) - 2)\n				return(NumString);\n			i++;\n			continue;\n		}\n	i=1;\n	if(c == \'\\n\')\n		NumString++;\n	}*/\n\n	char buf[200];\n	while (fgets(buf, 200, List))\n	{\n		if (strstr(buf, Searchin) == buf)\n		{\n			fclose(List);\n			return NumString;\n		}\n		NumString++;\n	}\n\n	fclose(List);\n	return(0);\n}\n\nint main(void)\n{\n	FILE *Again=fopen(\"/etc/passwd\",\"r\");;\n	char *Nick = malloc(100);\n	char c=\'\\0\';\n	int CLine = 1, NLine;\n	int i;\n\n	printf(\"Enter nickname: \");\n	scanf(\"%s\",Nick);\n\n	for(i=0; Nick[i]; i++);\n	Nick[i] = \':\';\n	printf(\"\'%s\'\\n\");\n	i=0;\n\n	NLine = UserLine(Nick);\n	if (NLine == 0)\n	{\n		printf(\"No such user\\n\");\n		return 0;\n	}\n	\n	while(CLine < NLine)\n		if(fgetc(Again) == \'\\n\')\n			CLine++;\n\n	while(i < 4)\n		if(fgetc(Again) == \':\')\n			i++;\n\n	printf(\"Username is: \");\n\n	for(;;)\n	{\n		c = fgetc(Again);\n		if(c == \':\')\n			break;\n		putchar(c);\n	}\n	putchar(\'\\n\');\n\n	free(Nick);\n	fclose(Again);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1008,'#define N 5 \n#include<stdio.h>\n#include<stdlib.h>\n\nvoid print(int *arr)\n{\n	int i;\n	for(i=0; i<N; i++)\n		printf(\"%d \",arr[i]);\n	printf(\"\\n\");\n}\n\nint isrepeat(int n, int *a)\n{\n	int i;\n	for(i=0; i<(n-1); i++)\n		if(a[i] == a[n-1])\n			return 1;\n	if(n == 2)\n		return 0;\n	else\n		return(isrepeat(n-1, a));\n}\n\nvoid reshuf(int n, int *a)    \n{\n	int i;\n	if(n == N)\n	{\n		if(!isrepeat(N,a))\n			print(a);\n		return;\n	}\n	for(i=1; i<=N; i++)\n	{\n		a[n] = i;\n		reshuf(n+1,a);\n	}\n}\n\nint main(void)\n{\n	int i;\n	int *Arr=malloc(N*sizeof(int));\n\n	reshuf(0,Arr);\n	printf(\"\\n\");\n	free(Arr);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1009,'#include <stdio.h>\n#include <stdlib.h>\n\nvoid sorting(int num, int *a)\n{\n	int i, imax=0, k, max = a[0];\n	for(i=1;i<=num;i++)\n		if(a[i] > max)\n		{\n			max = a[i];\n			imax = i;\n		}\n	k = a[num];\n	a[num] = max;\n	a[imax] = k;\n	if(num > 1) \n		sorting(num-1, a);\n	return;\n}\n\nint main(void)\n{\n	FILE *fin  = fopen(\"input.txt\",\"r\");\n	FILE *fout = fopen(\"output.txt\",\"w\");\n	int i, n;\n	int *a;\n\n	fscanf(fin,\"%d\",&n);\n	a = malloc(n * sizeof(int));\n\n	for(i=0;i<n;i++)\n		fscanf(fin,\"%d\",&a[i]);\n\n	sorting(n-1,a);\n\n	for(i=0;i<n;i++)\n	{					//addit\n		printf(\"%d \",a[i]);        	//addit\n		fprintf(fout,\"%d \",a[i]);\n	}					//addit\n	printf(\"\\n\");				//addit\n\n\n	fclose(fin);\n	fclose(fout);\n	free(a);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1010,'#include <stdio.h>\n#include <stdlib.h>\n\nvoid QuickSort(int left, int right, int *a)\n{\n	int m = left, k, i;\n	for(i=left+1; i<=right; i++)\n	{\n		if(a[i]<a[m])\n		{\n			k = a[m];\n			a[m] = a[m+1];\n			a[m+1] = k;\n			if((m+1)!= i)\n			{\n				k = a[m];\n				a[m] = a[i];\n				a[i] = k;\n			}\n			m++;\n		}\n	}\n	if((m - left) > 1)\n		QuickSort(left, m-1, a);\n	if((right - m) > 1)\n		QuickSort(m+1, right, a);\n}\n\nint main(void)\n{\n        FILE *fin  = fopen(\"input.txt\",\"r\");\n        FILE *fout = fopen(\"output.txt\",\"w\");\n        int i, n;\n        int *a;\n\n        fscanf(fin,\"%d\",&n);\n        a = malloc(n * sizeof(int));\n\n        for(i=0;i<n;i++)\n                fscanf(fin,\"%d\",&a[i]);\n\n        QuickSort(0,n-1,a);\n        for(i=0;i<n;i++)\n        {                                       //addit\n                printf(\"%d \",a[i]);             //addit\n                fprintf(fout,\"%d \",a[i]);\n        }       printf(\"\\n\");                   //addit\n        fclose(fin);\n        fclose(fout);\n        free(a);\n        return 0;\n}\n\n\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1011,'#include <stdio.h>\n#include <stdlib.h>\n#include <stdlib.h>\n\n#define chunk 10\n\nchar *readword (FILE *f)\n{\n	char *s=malloc(1);\n	int allocated=0,used=0,c;\n	while ((c=fgetc(f))!=EOF)\n	{\n		if (isspace (c))\n		{\n			break;\n		}\n		if (used>=allocated)\n		{\n			s=realloc(s,allocated + chunk);\n			allocated+=chunk;\n		}\n		s[used++]=c;\n	}\n	if (used>0 || isspace(c))\n	{\n		s[used]=0;\n		return s;\n	}\n	free(s);\n	return NULL;\n}\n\nint main()\n{\n	struct item {\n		char *word;\n		int count;\n		struct item *next;\n	};\n	struct item *p,*head=NULL,*q,*g;\n	FILE *f;\n	int k=0;\n	char *s;\n	\n	f=fopen(\"input.txt\",\"r\");\n	if (f==NULL)\n	{\n		printf(\"file open error input.txt\\n\");\n		return 1;\n	}\n	while (s=readword(f))\n	{\n		if (s[0] == 0)\n		{\n			free(s);\n			continue;\n		}\n		k++;\n		p=malloc(sizeof(*p));\n		if (!p)\n		{\n			printf(\"we need more memory\\n\");\n		}\n		if (k==1)				//?????? ?????\n		{\n			head=p;\n			head->word=s;\n			head->count=1;\n			head->next = NULL;\n		}\n		if (k>1)		//????????? ?????\n		{\n			for (g=head;g;g=g->next)	//???? ?? ??????. ?????????? ??????? ????? ? ????? ?????\n			{\n				if (strcmp(g->word,s)==0)	//???? ???????\n				{\n					g->count++;\n					free(s);\n					break;\n				}\n				if (!g->next)	//???? ???\n				{\n					p->word=s;\n					p->next=head;\n					head=p;\n					p->count=1;\n				}\n			}\n		}\n	}\n	q=head;\n	while (q)\n	{\n		printf(\"%s %d\\n\",q->word,q->count);\n		q=q->next;\n	}\n	q=NULL;\n	g=head;\n	while(g)\n	{\n		q=g->next;\n		free(g->word);\n		free(g);\n		g=q;\n	}\n	free(q);\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1012,'#include <stdio.h>\n#include <math.h>\n#define N 100000\n\nvoid f(float a,int p, int i)\n{\n	int j=0;\n	if(a || i >= 0)\n	{\n		while(a>=pow(p,i))\n		{\n			a=a-pow(p,i);\n			j++;\n		}\n		if(i==-1)\n		{\n			printf(\",\");\n		}\n		if(p<10)\n			printf(\"%d\",j);\n		else\n			if(j<10)\n				printf(\"%d\",j);\n			else\n				printf(\"%c\",j+\'A\'-10);\n		i--;\n		f(a,p,i);	\n	}\n}\nint main()\n{\n	int i=0,n,p;\n	float a;\n	scanf(\"%d\\n\",&p);\n	scanf(\"%f\",&a);\n	while(a>=pow(p,i))\n	{\n		i++;\n	}\n	i--;\n	f(a,p,i);\n	printf(\"\\n%d %f %d\\n\",p,a,i);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1013,'#include <stdio.h>\n\nint main()\n{\n	FILE *f;\n	int A[100000];\n	int i,j,n,k;\n	f=freopen(\"input.txt\",\"r\",stdin);\n	scanf(\"%d\\n\",&n);\n	for(i=0;i<n;i++)\n	{\n		scanf(\"%d\",&A[i]);\n	}\n	for(i=1;i<n;i++)\n	{\n		j=i;\n		while(j>0 && A[j-1]>A[j])\n		{\n			k=A[j];\n			A[j]=A[j-1];\n			A[j-1]=k;\n			j--;\n		}\n	}\n	for(i=0;i<n;i++)\n	{\n		printf(\"%d \",A[i]);\n	}\n	printf(\"\\n\");\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1014,'#include <stdio.h>\n\nvoid qs(int *A,int min,int max)\n{\n	int k;\n	int l=min;\n	int r=max;\n	int m=(l+r)/2;\n	int x = A[m];\n	while(l<=r)\n	{\n		while(A[l]<x)\n			l++;\n		while(A[r]>x)\n			r--;\n		if(l<=r)\n		{\n			k=A[l];\n			A[l]=A[r];\n			A[r]=k;\n			l++;\n			r--;\n		}\n	}\n	if(min<r)\n		qs(A,min,r);\n	if(l<max)\n		qs(A,l,max);\n}\n\nint main()\n{\n	FILE *f;\n	int i,j,n,k;\n	f=freopen(\"input.txt\",\"r\",stdin);\n	scanf(\"%d\\n\",&n);\n	int A[n];\n	for(i=0;i<n;i++)\n	{\n		scanf(\"%d\",&A[i]);\n	}\n	qs(A,0,n-1);\n	for(i=0;i<n;i++)\n	{\n		printf(\"%d \",A[i]);\n	}\n	printf(\"\\n\");\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1015,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct item\r\n{\r\n    int data;\r\n    struct item *next;\r\n};\r\n\r\nvoid wswp(int a, struct item *q)\r\n{\r\n    struct item *p=malloc(sizeof(*p));\r\n    int k;\r\n\r\n    k=0;\r\n\r\n    while (k==0 && (*q).next!=NULL)\r\n    {\r\n        if ((a>=(*q).data) && (a<=(*q).next->data)) k=1;\r\n        else\r\n           {\r\n               q=q->next;\r\n           }\r\n    }\r\n\r\n    (*p).data=a;\r\n    (*p).next=(*q).next;\r\n    (*q).next=p;\r\n\r\n    return;\r\n}\r\n\r\nvoid print(struct item *head)\r\n{\r\n    struct item *p=malloc(sizeof(*p));\r\n\r\n    if (head->next==NULL) printf(\"where r no elements\"); else\r\n    {\r\n        (*p).data=head->next->data;\r\n        (*p).next=head->next->next;\r\n        printf(\"%d \",(*p).data);\r\n        while ((*p).next!=NULL)\r\n        {\r\n           (*p).data=p->next->data;\r\n           (*p).next=p->next->next;\r\n           printf(\"%d \",(*p).data);\r\n        }\r\n    }\r\n    free(p);\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    struct item *head=malloc(sizeof(*head));\r\n    int i,k;\r\n\r\n    (*head).next=NULL;\r\n    (*head).data=-999999;\r\n\r\n    FILE *f=fopen(\"input.txt\",\"r\");\r\n\r\n    while (fscanf(f,\"%d\",&k)==1)\r\n    {\r\n        wswp(k,head);\r\n    }\r\n    fclose(f);\r\n    freopen(\"output.txt\",\"wt\",stdout);\r\n    print(head);\r\n    return 0;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1016,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct item\r\n{\r\n    char word[11];\r\n    int count;\r\n    struct item *next;\r\n    int length;\r\n};\r\n\r\nvoid wswp(char s[11], struct item *r, int i)\r\n{\r\n    struct item *p=malloc(sizeof(*p));\r\n    int k,j;\r\n\r\n    k=-1;\r\n    while (k!=0 && (*r).next!=NULL)\r\n    {\r\n        k=strcmp(s,(*r).word);\r\n        if (k==0) (*r).count++; else r=r->next;\r\n    }\r\n    if (k!=0)\r\n       {\r\n          k=strcmp(s,(*r).word);\r\n          if (k==0) (*r).count++;\r\n       }\r\n    if (k==0) free(p); else\r\n      {\r\n          for (j=0;j<=i;j++) (*p).word[j]=s[j];\r\n          (*p).count=1;\r\n          (*p).length=i;\r\n          (*p).next=(*r).next;\r\n          (*r).next=p;\r\n      }\r\n   return;\r\n}\r\n\r\nvoid print(struct item *r)\r\n{\r\n    int j;\r\n\r\n    while (r->next!=NULL)\r\n    {\r\n       if (r->next!=NULL) r=r->next;\r\n       for(j=0;j<(*r).length;j++) printf(\"%c\",(*r).word[j]);\r\n       printf(\" - %d\",(*r).count);\r\n       printf(\"\\n\");\r\n    }\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    struct item *head=malloc(sizeof(*head));\r\n    int i,j,k,c;\r\n    char s[11];\r\n\r\n    (*head).next=NULL;\r\n    (*head).word[0]=0;\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    c=getchar();\r\n\r\n    while(c!=EOF)\r\n    {\r\n       i=-1;\r\n       while (c!=EOF && !isspace(c))\r\n       {\r\n          i++;\r\n          s[i]=c;\r\n          c=getchar();\r\n       }\r\n       i++;\r\n       s[i]=0;\r\n\r\n       wswp(s,head,i);\r\n\r\n       if (c!=EOF) c=getchar();\r\n    }\r\n\r\n    print(head);\r\n\r\nreturn 0;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1017,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n#define HASHSIZE 100\r\n\r\n\r\nstruct word\r\n{\r\n    char word[11];\r\n    int count;\r\n    struct word *next;\r\n    int length;\r\n};\r\n\r\n\r\nunsigned hash(char *s)\r\n{\r\n    unsigned hashval;\r\n\r\n    for (hashval=0;*s!=0;s++)\r\n       hashval=*s+31*hashval;\r\n\r\n    return hashval%HASHSIZE;\r\n}\r\n\r\n\r\nvoid wswp(char s[11], int i, struct word *r)\r\n{\r\n    struct word *p=malloc(sizeof(*p));\r\n    int k,j;\r\n\r\n    k=-1;\r\n    while (k!=0 && (*r).next!=NULL)\r\n    {\r\n        k=strcmp(s,(*r).word);\r\n        if (k==0) (*r).count++; else r=r->next;\r\n    }\r\n    if (k!=0)\r\n       {\r\n          k=strcmp(s,(*r).word);\r\n          if (k==0) (*r).count++;\r\n       }\r\n    if (k==0) free(p); else\r\n      {\r\n          for (j=0;j<=i;j++) (*p).word[j]=s[j];\r\n          (*p).count=1;\r\n          (*p).length=i;\r\n          (*p).next=(*r).next;\r\n          (*r).next=p;\r\n      }\r\n   return;\r\n}\r\n\r\nvoid print(struct word *r)\r\n{\r\n    int j;\r\n\r\n    while (r->next!=NULL)\r\n    {\r\n       if (r->next!=NULL) r=r->next;\r\n       for(j=0;j<(*r).length;j++) printf(\"%c\",(*r).word[j]);\r\n       printf(\" - %d\",(*r).count);\r\n       printf(\"\\n\");\r\n    }\r\n    return;\r\n}\r\n\r\nint main()\r\n{\r\n    int i,j,k,c,l;\r\n    char s[11];\r\n    struct word *w[HASHSIZE];\r\n\r\n\r\n    for(j=0;j<100;j++)\r\n       {\r\n           w[j]=malloc(sizeof(*w[j]));\r\n           (*w[j]).length=0;\r\n       }\r\n\r\n    if (!freopen(\"input.txt\",\"rt\",stdin))\r\n    {\r\n        perror(\"freopen\");\r\n        return 1;\r\n    }\r\n    freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    c=getchar();\r\n\r\n//    printf(\"here\\n c = %c\\n\", c);\r\n\r\n    while(c!=EOF)\r\n    {\r\n  //      printf(\"symbol %c\\n\", c);\r\n       i=-1;\r\n       while (c!=EOF && !isspace(c))\r\n       {\r\n          i++;\r\n          s[i]=c;\r\n          c=getchar();\r\n       }\r\n       i++;\r\n       s[i]=0;\r\n\r\n       l=hash(s);\r\n       if ((*w[l]).length==0)\r\n          {\r\n             (*w[l]).next=NULL;\r\n             (*w[l]).length=1;\r\n             (*w[l]).word[0]=0;\r\n          }\r\n       wswp(s,i,w[l]);\r\n\r\n       if (c!=EOF) c=getchar();\r\n    }\r\n\r\n    for(j=0;j<100;j++)\r\n       if ((*w[j]).length==1)\r\n        {\r\n           print(w[j]);\r\n        }\r\n\r\n    for(j=0;j<100;j++) free(w[j]);\r\n\r\n\r\nreturn 0;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1018,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n\r\n//int main(int argc, char *argv[])\r\nint main()\r\n{\r\n    char s[100];\r\n    char s1[100];\r\n    int i,j,k,l,c;\r\n\r\n//?????? ?????\r\n    i=-1;\r\n    c=getchar();\r\n    while(!isspace(c))\r\n    {\r\n        i++;\r\n        s[i]=c;\r\n        c=getchar();\r\n    }\r\n    i++;\r\n    s[i]=NULL;\r\n\r\n//    for(j=0;j<i;j++) printf(\"%c\",s[j]); printf(\"%d \\n\",s[i]);\r\n\r\n    //freopen(argv[1],\"r\",stdin);\r\n    //freopen(argv[2],\"w\",stdout);\r\n\r\n    freopen(\"passwd.txt\",\"rt\",stdin);\r\n\r\n    k=1;\r\n    c=getchar();\r\n    while (c!=EOF && k!=0)\r\n    {\r\n        i=-1;\r\n        while(c!=\':\')\r\n        {\r\n           i++;\r\n           s1[i]=c;\r\n           c=getchar();\r\n        }\r\n        i++;\r\n        s1[i]=NULL;\r\n        k=strcmp(s,s1);\r\n\r\n        //for(j=0;j<i;j++) printf(\"%c\",s1[j]); printf(\"%d \\n\",s1[i]);\r\n        //printf(\"%d \\n\",k);\r\n\r\n        l=0;\r\n        if (k!=0)\r\n        {\r\n            while (c!=\'\\n\' && l!=1)\r\n            {\r\n                c=getchar();\r\n                if (c==EOF) l=1;\r\n            }\r\n        }\r\n        if (l!=1) c=getchar();\r\n    }\r\n\r\n    if (k!=0) printf(\"bad login\");\r\n       else\r\n         {\r\n             for(j=0;j<3;j++)\r\n                {\r\n                    c=getchar();\r\n                    while(c!=\':\')\r\n                    {\r\n                       c=getchar();\r\n                    }\r\n                }\r\n\r\n             c=getchar();\r\n             while (c!=\' \')\r\n             {\r\n                 printf(\"%c\",c);\r\n                 c=getchar();\r\n             }\r\n         }\r\n\r\n    return 0;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1019,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n\r\n//int main(int argc, char *argv[])\r\nint main()\r\n{\r\n    char s[100];\r\n    char s1[100];\r\n    int i,j,k,l,c;\r\n\r\n//?????? ?????\r\n    i=-1;\r\n    c=getchar();\r\n    while(!isspace(c))\r\n    {\r\n        i++;\r\n        s[i]=c;\r\n        c=getchar();\r\n    }\r\n    i++;\r\n    s[i]=NULL;\r\n\r\n//    for(j=0;j<i;j++) printf(\"%c\",s[j]); printf(\"%d \\n\",s[i]);\r\n\r\n    //freopen(argv[1],\"r\",stdin);\r\n    //freopen(argv[2],\"w\",stdout);\r\n\r\n    freopen(\"passwd.txt\",\"rt\",stdin);\r\n\r\n    k=1;\r\n    c=getchar();\r\n    while (c!=EOF && k!=0)\r\n    {\r\n        i=-1;\r\n        while(c!=\':\')\r\n        {\r\n           i++;\r\n           s1[i]=c;\r\n           c=getchar();\r\n        }\r\n        i++;\r\n        s1[i]=NULL;\r\n        k=strcmp(s,s1);\r\n\r\n        //for(j=0;j<i;j++) printf(\"%c\",s1[j]); printf(\"%d \\n\",s1[i]);\r\n        //printf(\"%d \\n\",k);\r\n\r\n        l=0;\r\n        if (k!=0)\r\n        {\r\n            while (c!=\'\\n\' && l!=1)\r\n            {\r\n                c=getchar();\r\n                if (c==EOF) l=1;\r\n            }\r\n        }\r\n        if (l!=1) c=getchar();\r\n    }\r\n\r\n    if (k!=0) printf(\"bad login\");\r\n       else\r\n         {\r\n             for(j=0;j<3;j++)\r\n                {\r\n                    c=getchar();\r\n                    while(c!=\':\')\r\n                    {\r\n                       c=getchar();\r\n                    }\r\n                }\r\n\r\n             c=getchar();\r\n             while (c!=\' \')\r\n             {\r\n                 printf(\"%c\",c);\r\n                 c=getchar();\r\n             }\r\n         }\r\n\r\n    return 0;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1020,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 1001\n#define chunk 100\n\nchar *readword (FILE *f)\n{\n	char *s=malloc(1);\n	int allocated=0,used=0,c;\n	while ((c=fgetc(f))!=EOF)\n	{\n		if (isspace (c))\n		{\n			break;\n		}\n		if (used>=allocated)\n		{\n			s=realloc(s,allocated + chunk);\n			allocated+=chunk;\n		}\n		s[used++]=c;\n	}\n	if (used>0 || isspace(c))\n	{\n		s[used]=0;\n		return s;\n	}\n	free(s);\n	return NULL;\n}\n\nunsigned int hash(char *s)\n{\n	unsigned int i=0,k,n=0;\n	//k=strlen(s);\n	//for (i=0;i<k;i++)\n	while(*s)\n	{\n		n=n*37+*s;\n		s++;\n	}\n	return n%N;\n}\n\nint main()\n{\n	struct item {\n		char *word;\n		int count;\n		struct item *next;\n	};\n	struct item *p,*head=NULL,*q,*g,*(*table)=NULL;\n	FILE *f;\n	int k=0,all=0,used=0,n,i,j;\n	unsigned int m=0;\n	char *s;\n	\n	f=fopen(\"input.txt\",\"r\");\n	if (f==NULL)\n	{\n		printf(\"file open error input.txt\\n\");\n		return 1;\n	}\n	table=malloc(N*sizeof(*p));\n	if (!table)\n	{\n		printf(\"we need more memory\\n\");\n	}\n	for (i=0;i<N;i++)\n	{\n		table[i]=0;\n	}\n	while (s=readword(f))\n	{\n		if (s[0]==0)\n		{\n			free(s);\n			continue;\n		}\n		m=hash(s);\n		p=malloc(sizeof (*p));\n		if (!p)\n		{\n			printf(\"we need more memory\\n\");\n		}\n		do\n		{\n			i = m;\n			{\n				if (table[i]==0)	//???? ????? ??? ?????????? ? 1 ???\n				{\n					table[i]=p;\n					table[i]->word=s;\n					table[i]->count=1;\n					table[i]->next=NULL;\n					break;\n				\n				}\n				for (g=table[i];g;g=g->next)		//???? ?? 2? ?? : ???? ?? ??????. ?????????? ??????? ?????? ? ????? ?????\n				{\n					if (strcmp(g->word,s)==0)	//???? ???????\n					{\n						g->count++;\n						free(s);\n						break;\n					}\n					if (!g->next)			//???? ???\n					{\n						p->word=s;\n						table[i]->next=p;\n						p->count=1;\n						p->next=NULL;\n						break;\n					}\n				}\n			}\n		} while (0);	 \n	}\n	for (i=0;i<N;i++)\n	{\n		q=table[i];\n		if (!q)\n		{\n			continue;\n		}\n		while (q)\n		{\n			printf(\"%s %d\\n\",q->word,q->count);\n			if (!q->next)\n			{\n				break;\n			}\n			q=q->next;\n		}\n	}\n	for (i=0;i<N;i++)\n	{\n		if(table[i])\n		{\n			int c = 0;\n			while (table[i])\n			{\n				q = table[i];\n				table[i] = table[i]->next;\n				free(q->word);\n				free(q);\n				c++;\n			}\n			fprintf(stderr, \"%d - %d\\n\", i, c);\n		}\n		else\n		{\n			fprintf(stderr, \"%d - 0\\n\", i);\n		}\n	}\n	free(table);\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1021,'#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <locale.h>\n\n// words can be separated by more than one space\n\nint main(int argc, char *argv[])\n{\n	setlocale(LC_ALL,\"\");\n\n	FILE *f=fopen(argv[1],\"r\");\n	if (!f)\n	{\n		perror(\"fopen\");\n		return 1;\n	}\n//	freopen(\"output.txt\",\"wt\",stdout);\n\n	char c;\n	\n	int chars=0;\n	int words=0;\n	int strings=0;\n	int state=1;\n\n	for ( ; ; )\n	{\n		c=fgetc(f);\n		if (c == EOF) break;\n\n		chars++;\n		\n		if (c==\'\\n\') strings++;\n		\n		if (state && !isspace(c))\n		{\n			words++;\n			state=0;\n		}\n\n		if (!state && isspace(c)) state=1;\n	}\n\n	printf(\"%d\\n\",chars);\n	printf(\"%d\\n\",words);\n	printf(\"%d\\n\",strings);\n	\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1022,'#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\nint main()\n{\n	double b;\n	char s[255];\n\n	scanf(\"%lf\",&b);\n	scanf(\"%s\",s);\n\n	int point;\n\n	point=strchr(s,\'.\')-s;\n	if (point+s==0) point=strlen(s);\n\n	int i;\n	int l=strlen(s);\n\n	for(i=0;i<l;i++)\n	{\n		s[i]=tolower(s[i]);\n	    	if (s[i]>=\'a\' && s[i]<=\'z\') s[i]=s[i]-(\'a\'-\'0\'-10);\n\n		if (s[i]!=\'.\') s[i]-=\'0\';	    	\n	}\n\n	\n	double num=0;\n	double step=1/b;\n\n	for(i=point-1;i>=0;i--)\n	{\n		step*=b;\n\n		num+=(s[i])*step;\n	}\n\n	step=1;\n\n	for(i=point+1;i<l;i++)\n	{\n		step/=b;\n\n		num+=(s[i])*step;\n	}\n\n	printf(\"%f\\n\",num);\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1023,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <math.h>\r\n\r\nvoid sys(int a,int b)//vypisyvanie celoy\r\n{\r\n	if (a==0) return;\r\n\r\n    	sys(a/b,b);\r\n	\r\n	if (a%b>9) \r\n	{\r\n		printf(\"%c\",a%b-10+\'A\');\r\n		return;\r\n	}\r\n\r\n    	printf(\"%d\",a%b);\r\n\r\n    	return;\r\n}\r\n\r\nint main()\r\n{\r\n	int b;\r\n    	double x;\r\n\r\n    	scanf(\"%d%lf\",&b,&x);\r\n\r\n    	sys(x,b);\r\n	\r\n//	printf(\"was: %lf\\n\", x);\r\n    	x-=(int)x;\r\n//	printf(\"now: %lf\\n\", x);\r\n\r\n	if (x) putchar(\'.\');\r\n\r\n	int deep;\r\n\r\n	for(deep=4;x && deep;deep--)\r\n    	{\r\n        	x*=b;\r\n        	printf(\"%.0lf\",0.0+(int)x);\r\n//		printf(\"was: %lf\\n\", x);\r\n		x-=(int)x;  \r\n//		printf(\"now: %lf\\n\", x);\r\n    	}\r\n\r\n	putchar(\'\\n\');\r\n\r\n    	return 0;\r\n}\r\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1024,'#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	struct item\n	{\n		int data;\n		struct item *next;\n	};\n\n	struct item *head=NULL;\n\n	FILE *f=fopen(\"18.txt\",\"r\");\n\n	int a;\n\n	while(fscanf(f,\"%d\",&a)==1)\n	{\n		printf(\"read: %d\\n\", a);\n		struct item *p=head;\n		struct item *q=NULL;\n\n		while(p && p->data<=a)\n		{\n			q=p;\n			p=p->next;\n		}\n\n		p=malloc(sizeof(struct item));\n\n		p->data=a;\n		if (!q)\n		{\n			p->next=head;\n			head=p;\n		}\n\n		else\n		{\n			p->next=q->next;\n			q->next=p;\n		}\n	}\n\n	struct item *p=head, *q;\n\n	while(p)\n	{\n		printf(\"%d \",p->data);\n		q = p;\n		p=p->next;\n		free(q);\n	}\n	putchar(\'\\n\');\n\n	fclose(f);\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1025,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n	struct item\n	{\n		char word[11];\n		int count;\n		struct item *next;\n	};\n\n	struct item *head=NULL;\n\n	FILE *f=fopen(\"19.txt\",\"r\");\n\n	char s[11];\n\n	while(fscanf(f,\"%s\",s)==1)\n	{\n		struct item *p=head;\n		struct item *q=NULL;\n\n		int d;\n\n		while(p && (d=strcmp(s,p->word))<0)\n		{\n			q=p;\n			p=p->next;\n		}\n\n		if (d==0) p->count++;\n\n		if (d>0 || !p)\n		{\n\n			p=malloc(sizeof(struct item));\n\n			strcpy(p->word,s);\n			p->count=1;\n			if (!q)\n			{\n				p->next=head;\n				head=p;\n			}\n			else\n			{\n				p->next=q->next;\n				q->next=p;\n			}\n		}\n	}\n\n	struct item *p=head;\n	struct item *q;\n\n	while(p)\n	{\n		printf(\"\\\"%s\\\": %d\\n\",p->word,p->count);\n		q = p;\n		p=p->next;\n		free(q);\n	}\n\n	fclose(f);\n	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1026,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define N 997\n\nint hash(char *s)\n{\n	int step=1;\n	int sum=0;\n	int i;\n\n	for (i = 0; s[i]; i++)\n	{\n		sum = sum * 37 + s[i];\n\n		sum%=N;\n	}\n	printf(\"hash(%s) = %d\\n\", s, sum);\n\n	return(sum);\n}\n\nint main()\n{\n	struct item\n	{\n		char word[11];\n		int count;\n		struct item *next;\n	};\n\n	struct item *hash_table[N];\n\n//	int d[26][2];\n\n	int i;\n\n	for (i=0;i<N;i++)\n		hash_table[i]=NULL;\n\n//	for (i=0;i<26;i++)\n//	{\n//		d[i][0]=i;\n//		d[i][1]=1;\n//	}\n\n	FILE *f=fopen(\"20.txt\",\"r\");\n\n	char s[100];\n\n	while(fscanf(f,\"%s\",s)==1)\n	{\n		int value=hash(s);\n\n		struct item *head=hash_table[value];\n\n		struct item *p=head;\n		struct item *q=NULL;\n\n		int d=1;\n\n		while(p && (d=strcmp(s,p->word))<0)\n		{\n			q=p;\n			p=p->next;\n		}\n\n		if (d==0) p->count++;\n\n		if (d>0 || !p)\n		{\n\n			p=malloc(sizeof(struct item));\n\n			strcpy(p->word,s);\n			p->count=1;\n			if (!q)\n			{\n				p->next=head;\n				head=p;\n			}\n			else\n			{\n				p->next=q->next;\n				q->next=p;\n			}\n		}\n\n		hash_table[value]=head;\n	}\n\n	for (i=0;i<N;i++)\n	{\n		struct item *p=hash_table[i], *q;\n		int c = 0;\n\n		while(p)\n		{\n			printf(\"\\\"%s\\\": %d\\n\",p->word,p->count);\n			q = p;\n			p=p->next;\n			free(q);\n			c++;\n		}\n		if (c > 0)\n		{\n			printf(\"idx %d: count %d\\n\", i, c);\n		}\n\n	}\n\n	fclose(f);\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1027,'#include <stdio.h>\n\nvoid deep(int a[][100],int b[],int k,int d,int N)\n{\n	printf(\"%d \", k);\n	b[k]=d;\n\n	int i;\n\n	for(i=1;i<=N;i++)\n	{\n		if (!b[i] && a[k][i]) deep(a,b,i,d,N);\n	}\n}\n\nint main()\n{\n	int a[100][100];\n	int b[100];\n\n	FILE *f=fopen(\"22.txt\",\"r\");\n	//freopen(\"output.txt\",\"w\",stdout);\n\n	int N;\n	int M;\n\n	fscanf(f,\"%d %d\",&N,&M);\n\n	int x;\n	int y;\n\n	for(x=1;x<=N;x++)\n	{\n		for(y=1;y<=N;y++)\n		{\n		    a[x][y]=0;\n		}\n		b[x]=0;\n	}\n\n    int i;\n\n    for(i=1;i<=M;i++)\n	{\n	    fscanf(f,\"%d%d\",&x,&y);\n		a[x][y]=1;\n		a[y][x]=1;\n	}\n\n\n    int d=0;\n\n    for(i=1;i<=N;i++)\n	{\n	    if (!b[i])\n	    {\n	        d++;\n	        deep(a,b,i,d,N);\n	    }\n\n	}\n    printf(\"\\n\");\n\n    printf(\"%d\\n\",d);\n\n	for(i=1;i<=N;i++)\n	printf(\"%d \",b[i]);\n\n	fclose(f);\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1028,'#include <stdio.h>\n\nvoid dejxtra(int k,int a[][101],int *b, int *d,int N)\n{\n    	int i;\n\n    	for (i=1;i<=N;i++)\n        	if ((a[k][i]!=-1) && (d[i]>d[k]+a[k][i] || d[i]==-1))//est rebro i (put koroche ili ne hodili)\n            		d[i]=d[k]+a[k][i];\n\n    	b[k]=1;//byli\n\n    	int min=-1;\n    	int mini;\n\n    	for (i=1;i<=N;i++)\n    	{\n        	if (b[i]==0 && d[i]!=-1 && (d[i]<min || min==-1))\n        	{\n            		min=d[i];\n            		mini=i;\n        	}\n    	}\n\n    	if (min!=-1) dejxtra(mini,a,b,d,N);\n    	else return;\n}\n\nvoid route(int k,int a[][101],int d[],int N)\n{\n	if (k==1) \n	{\n		printf(\"1 \");\n		return;\n	}\n\n	int i;\n\n	for (i=1;i<N;i++)\n	{\n		if (d[k]==d[i]+a[i][k] && i!=k) \n		{\n			route(i,a,d,N);\n			break;\n		}\n	}\n	\n	printf(\"%d \",k);\n	\n	return;\n}\n\nint main()\n{\n    	freopen(\"24.txt\",\"r\",stdin);\n    	//freopen(\"output.txt\",\"w\",stdout);\n\n    	int N;\n    	int M;\n\n    	scanf(\"%d%d\",&N,&M);\n\n    	int i;\n    	int a[101][101];\n    	int b[101];//byli ili net\n    	int d[101];//distances\n	int p[100];\n    	int x,y;\n\n    	for(x=1;x<=N;x++)//initilization\n    	{\n       		for(y=1;y<=N;y++)\n            		a[x][y]=-1;\n        	a[x][x]=0;\n\n        	b[x]=0;\n        	d[x]=-1;\n    	}\n\n    	d[1]=0;\n/*\n    	for (i=0;i<M;i++)//reading matrix\n    	{\n        	scanf(\"%d%d\",&x,&y);\n        	scanf(\"%d\",&a[x][y]);\n        	a[y][x]=a[x][y];\n    	}\n*/\n    	while(scanf(\"%d%d\",&x,&y)==2)\n    	{\n        	scanf(\"%d\",&a[x][y]);\n        	a[y][x]=a[x][y];\n    	}\n\n\n    	dejxtra(1,a,b,d,N);\n\n     	for (i=1;i<=N;i++)\n        	printf(\"%d \",d[i]);\n\n	printf(\"\\n\\n\");\n\n	printf(\"ways:\\n\");\n\n	for (i=1;i<=N;i++)\n	{\n		printf(\"%d: \",i);\n		route(i,a,d,N);\n		putchar(\'\\n\');\n	}\n\n\n    	return 0;\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1029,'#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nvoid arr_copy(double *dst,const double * src)\n{\n	int i;\n\n	for(i=0;src[i];i++)\n	dst[i]=src[i];\n\n	return;\n}\n\ndouble sqr(double x)\n{\n	return(x*x);\n}\n\ndouble len(double x1, double y1, double x2, double y2)\n{\n	return(sqrt(sqr(x1-x2)+sqr(y1-y2)));\n}\n\nvoid deep(double (*a)[101],int *b,double *max_way,double *cur_way,int k,int N,int depth)\n{\n	if (k==1 && b[1])//???? ? ??????, ?????? ??? ???? (?????? ?????)\n	{\n		if(depth==N+1)//???? ????????? ???...\n		{\n			if (cur_way[0]<max_way[0] || max_way[0]==0) arr_copy(max_way,cur_way);//... ? ???? ???????? ??????\n			return;\n		}\n\n		return;\n	}\n\n	int i;\n\n	for(i=1;i<=N;i++)\n	{\n		if ((!b[i] || i==1) && a[k][i]) //???? ?? ???? ??? 1 - ????????? ? ??????-?? ????\n		{\n			cur_way[depth]=i;//????????? ? ????\n			cur_way[0]+=a[k][i];//?????????? ????? ???????????? ????\n\n			b[k]=1;//??? ????? ?????? ???????, ??? ????\n\n			deep(a,b,max_way,cur_way,i,N,depth+1);\n\n			cur_way[depth]=0;\n			cur_way[0]-=a[k][i];\n\n			b[k]=0;//? ??? ????????? ?? ????\n		}\n	}\n\n	return;\n}\n\n\nint main()\n{\n	freopen(\"25.txt\",\"r\",stdin);\n\n	int N;//num of nodes\n\n	scanf(\"%d\",&N);\n\n	int i;\n	int x,y;\n\n	double a[101][101];//matrix\n	/*\n	? ??????? ???????? ?? ???????, ? ??????????\n	??????? ????????? ? 1\n	*/\n\n	int b[101];//?????\n\n	double max_way[101];\n	double cur_way[101];\n	//? ????? ??????? ??-? - ????? ????\n\n	for (x=0;x<=N;x++)//????????? ?????, ??? ?????? ?????\n	{\n		for (y=0;y<=N;y++)\n			a[x][y]=0;\n\n		b[x]=0;\n		max_way[x]=0;\n		cur_way[x]=0;\n	}\n\n	double arr_x[101];//??????? ?????\n	double arr_y[101];\n\n	for (i=1;i<=N;i++)\n	{\n		scanf(\"%lf%lf\",&arr_x[i],&arr_y[i]);//?????? ?????\n	}\n\n	for (x=1;x<=N;x++)\n		for(y=1;y<=N;y++)\n			a[x][y]=len(arr_x[x],arr_y[x],arr_x[y],arr_y[y]);//???????? ? ??????? ??????????\n\n	//????? ????? ?? ?????, ??? ???????? ?????? ??? ?????? ??????\n\n	deep(a,b,max_way,cur_way,1,N,1);\n\n	for(i=1;i<=N;i++)\n	printf(\"%.0lf \",max_way[i]);\n\n	putchar(\'\\n\');\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1030,'#include <stdio.h>\n#include <string.h>\n#include <locale.h>\n#include <ctype.h>\n\nint main()\n{\n	setlocale(LC_ALL, \"\");\n\n	freopen(\"input.txt\", \"r\", stdin);\n	\n	char str[1000], c;\n	int length, i = 0, j = 0, check = 1;\n\n	while ((c=getchar()) != EOF)\n	{\n		if (isalpha(c))\n		{\n			str[i++]=c;\n		}\n	}\n	str[i] = \'\\0\';\n	\n	length = strlen(str);\n	\n	for (i=0, j=length-1; j >= i; i++, j-- )\n	{\n		if (str[i] != str[j]) check = 0; \n	}\n	switch (check)\n	{\n		case 1 : printf(\"Yes, it\'s a palindrom\\n\"); break;\n		case 0 : printf(\"No, it isn\'t a palindrom\\n\"); break;\n	}	\n\n	fclose(stdin);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1031,'#define SYMB correct(\n#include <stdio.h>\n#include <stdlib.h>\n\nchar correct(char c)\n{\n	if(c >= \'0\' && c <= \'9\')\n		return(c);\n	if(c >= (\'9\' + 1) && c <= (\'9\' + 6))\n		return(c - \'9\' - 1 + \'A\');\n}\n\nint power(int osn, int st)\n{\n        int i, x = osn;\n        if(st == 0)\n                return(1);\n        for(i = 2; i <= st; i++)\n                osn = osn * x;\n        return(osn);\n}\n\nint seemsint(double f)\n{\n	int i;\n	for(i = 0; i <= f; i++)\n		if(f - i < 1) break;\n	if(f - i < 0.000001)\n		return 1;\n	return 0;\n}\n\nint main(void)\n{\n	double OrigNum, eps, preps;\n	int b, i, j=0, smax, dot=0, accuracy = -1;\n	char *TempNum = malloc(400);\n	\n        printf(\"Enter insigned number in 10\'th count system (don\'t use a dot if there\'s no need!!) : \");\n        scanf(\"%lf\",&OrigNum);\n        \n        printf(\"Enter count system to trans (2..16) : \");\n        scanf(\"%d\", &b);\n	\n	if(!seemsint(OrigNum))\n	{\n        	printf(\"Enter accuracy of float: (numbers after dot) : \");\n		scanf(\"%d\", &accuracy);\n	}\n\n	eps = OrigNum;\n	\n	for(i=0; i<33; i++)\n                if(power(b,i) > OrigNum)\n                {\n                       smax = i-1;\n                       break;\n                }\n	while(((eps >= 1) && (eps < (power(2,30) - 1))) || ((eps < 1) && (smax >= 0)))\n	{\n		for(i=1; i<=b; i++)\n		{\n			if(i*power(b,smax) > eps)\n			{\n				TempNum[j] = SYMB (i-1) + \'0\' ); TempNum[j+1] = 0;\n				eps = eps - (i-1)*power(b,smax);\n				smax--;\n				j++;\n				break;\n			}\n			if(i*power(b,smax) == eps)\n			{\n				TempNum[j] = SYMB i + \'0\' );\n				eps = power(2,30) + 0.0;\n				while(smax > 0)\n				{	\n					smax--;\n					j++;\n					TempNum[j] = \'0\';\n				}\n				TempNum[++j] = \'\\0\';\n				break;\n			}\n\n		}\n	}\n\n	if(eps < 1 && accuracy > 0)\n	{	\n		TempNum[j] = \'.\';\n		TempNum[j+1] = 0;\n		j++;\n		while(eps > 0.001 && dot < accuracy)   \n		{			\n			eps = eps * b;\n			if(eps > 1)\n			{\n				for(i = b-1; i>=0; i--)\n					if((eps - i) >= 0 && (eps - i) < 1)\n					{\n						TempNum[j] = SYMB i + \'0\' );\n						dot++;\n						break;\n					}\n				eps = eps - i;\n				j++;\n				continue;\n			}\n			else if(eps > 0.999 && eps < 1.001)\n			{\n				TempNum[j] = SYMB eps + \'0\' );\n				dot++;\n				break;\n			}\n			TempNum[j] = \'0\';\n			dot++;\n			j++;\n		}\n	}\n\n	printf(\"numis: \'\");\n	for(i=0; TempNum[i]; i++)\n	{\n		printf(\"%c\",TempNum[i]);\n	}\n	printf(\"\' in %d count system\\n\", b);\n	printf(\"Hope you to launch it again!\\n\");\n	free(TempNum);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1032,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main(void)\n{\n	FILE *finCSV = fopen(\"input.csv\",\"r\");\n	FILE *foutHTML = fopen(\"/home/students/120x/korzhnev/public_html/output.html\",\"w\");  \n	char c;\n	int isinrow=1, isindet=1, vkav=0;\n	\n//	printf(\"It\'s OK\\n\");\n	fprintf(foutHTML,\"<html>\\n\");\n	fprintf(foutHTML,\"<head>\\n\");\n	fprintf(foutHTML,\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\">\\n\");\n	fprintf(foutHTML,\"</head>\\n\");\n	fprintf(foutHTML,\"<body>\\n\");\n	fprintf(foutHTML,\"<table border=\\\"1\\\">\\n\");\n	fprintf(foutHTML,\"<tr>\\n\");\n	fprintf(foutHTML,\"<td>\");\n\n	printf(\"It\'s OK\\n\");\n	for(;;)\n	{\n		c = fgetc(finCSV);\n		if(c == EOF) break;\n		\n		if(c == \'\"\' && vkav == 2)         // ????? ???????? ?? ????? ???????\n                {				  // ?? ????????? ???? \" * \"\" * \"\n                	fprintf(foutHTML,\"\\\"\");\n			vkav = 1;\n			continue;		  // \n                }				  // \n                if(vkav == 2) vkav = 0;		  // ? ????????? ?????? - ????? ?? ??????? \n\n		if(!isinrow)\n		{\n			fprintf(foutHTML,\"<tr>\");\n			isinrow = 1;\n		}\n		if(!isindet)\n		{\n		        fprintf(foutHTML,\"<td>\");\n                        isindet = 1;\n		}\n		if(c == \'\\n\' && !vkav)\n		{\n		        fprintf(foutHTML,\"</td>\\n</tr>\");\n                        isinrow = 0;\n			isindet = 0;\n		}\n		if(c == \'\\n\' && vkav == 1)\n		{\n			fprintf(foutHTML,\"<br/>\");\n			continue;\n		}\n		if(c == \',\' && !vkav)\n		{\n		        fprintf(foutHTML,\"</td>\\n\");\n                        isindet = 0;\n			continue;\n		}		\n		if(c == \'\"\' && !vkav)\n		{\n			vkav = 1;\n			continue;\n		}\n		if(c == \'\"\' && vkav == 1)	//\n		{				//\n			vkav = 2;		//\n			continue;		// ?? ?????? ?????\n		}				//\n		fputc(c,foutHTML);\n	}\n	fprintf(foutHTML,\"</td>\\n</tr>\\n</table>\\n</body>\\n</html>\");\n	fclose(finCSV);\n	fclose(foutHTML);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1033,'#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main()\n{\n	FILE *inp=fopen(\"input.txt\", \"r\");\n	char s[1000];\n	int i=0, j;\n	char c;\n	while((c=fgetc(inp))!=EOF)\n	{\n		if(isalpha(c))\n		{\n			s[i]=c;\n			i++;\n		}\n		s[i]=0;\n	}\n	for(i=0,j=(strlen(s)-1);i<=j;i++,j--)\n	{\n		if(s[i]!=s[j])\n		{\n			printf(\"no\\n\");\n			return(0);\n		}\n	}\n	printf(\"yes\\n\");\n	return(0);\n}\n\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1034,'#include <string.h>\r\n#include <stdio.h>\r\n\r\nint wildcard(const char *name, const char *template){\r\n	int i = 0;\r\n	if (strlen (name) == 0) {\r\n		return (strlen (template) == 0);\r\n	}\r\n	if (strlen (template) == 0){\r\n		return 0;\r\n	}\r\n	if ((name[0] == template[0]) || (\'?\' == template[0])){\r\n		return wildcard(name+1, template+1);\r\n	}	\r\n	if (\'*\' == template[0]){\r\n		for (i = 0; i <= strlen(name); i++){\r\n			if (wildcard(name+i, template+1)) return 1;\r\n		}\r\n		return 0;\r\n	}\r\n	return 0;\r\n}\r\n\r\nint main(){\r\n	printf(\"%d\\n\", wildcard(\"ab.txt\", \"a?.*\"));\r\n	printf(\"%d\\n\", wildcard(\"a.txt\", \"a?.*\"));\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1035,'#include <stdio.h>\n#include <stdlib.h>\n\nint max(int a,int b,int x,int y)\n{\n	if (a>=b) return(x);\n\n	return(y);\n}\n\nvoid sift (int *a,int k,int N)\n{\n	if (2*k+1>=N) return;\n\n	int m;\n\n	if (2*k+2==N) m=2*k+1;\n	if (2*k+2<N) m=max(a[2*k+1],a[2*k+2],2*k+1,2*k+2);\n\n	if (a[k]<a[m])\n	{\n		int b=a[k];\n		a[k]=a[m];\n		a[m]=b;\n\n		sift(a,m,N);\n	}\n}\n\nint main()\n{\n	freopen(\"input.txt\",\"r\",stdin);\n\n	int N;\n\n	scanf(\"%d\",&N);\n\n	int *a=malloc(N*sizeof(int));\n\n	int i;\n\n	for (i=0;i<N;i++)\n		scanf(\"%d\",&a[i]);\n\n	for (i=(N-1)/2;i>=0;i--)\n			sift(a,i,N);\n\n	for(i=N-1;i>=0;i--)\n	{\n		sift(a,0,i+1);\n\n		int b=a[0];\n		a[0]=a[i];\n		a[i]=b;\n	}\n\n	for(i=0;i<N;i++)\n		printf(\"%d \",a[i]);\n\n	putchar(\'\\n\');\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1036,'#include <stdio.h>\n//glubinAaZZ\nint main()\n{\n	freopen(\"23.txt\",\"r\",stdin);\n	//freopen(\"output.txt\",\"w\",stdout);\n\n	int a[101][101];\n	int b[101];\n	int d[101];\n\n	int N;\n	int M;\n\n	scanf(\"%d%d\",&N,&M);\n\n	int x;\n	int y;\n\n	for(x=1;x<=N;x++)\n	{\n		for(y=1;y<=N;y++)\n			a[x][y]=0;\n\n		d[x]=0;\n		b[x]=0;\n	}\n\n	int i;\n\n	for(i=0;i<M;i++)\n	{\n		scanf(\"%d%d\",&x,&y);\n		a[x][y]=1;\n		a[y][x]=1;\n	}\n\n	d[0]=1;\n	int k=1;\n\n	int l=0;\n	int r=0;\n	x=1;\n	b[1]=1;\n\n	do\n	{\n		printf(\"%d \",x);\n\n		for(i=1;i<=N;i++)\n			if (a[x][i] && !b[i])\n			{\n				r++;\n				d[r]=i;\n				b[i]=1;\n			}\n\n		l++;\n		x=d[l];\n	}\n	while (r>=l);\n\n	putchar(\'\\n\');\n\n	return(0);\n}\n','Ð˜Ð³Ð¾Ñ€ÑŒ','Igor','m');
INSERT INTO `bias` VALUES (1037,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 101\n\nvoid dfs(int curr, int *visited, int n, int A[N][N])\n{\n	int i;\n	visited[curr]=1;\n	printf(\"%d \",curr);\n	for (i=1;i<=n;i++)\n	{\n		if (!visited[i] && A[curr][i])\n		{\n			dfs(i,visited,n,A);\n		}\n	}\n}\n\nint main()\n{\n	FILE *f1=fopen(\"input.txt\",\"r\"),*f2=fopen(\"output.txt\",\"w\");\n	int A[N][N]={0};\n	int visited[N]={0};\n	int i,m=0,n,f,t,j;\n	if (f1==NULL)\n	{\n		printf(\"file open error input.txt\\n\");\n		return 1;\n	}\n	if (f2==NULL)\n	{\n		printf(\"file open error output.txt\\n\");\n		return 1;\n	}\n	fscanf(f1,\"%d\",&n);\n	while (fscanf(f1,\"%d %d\",&f,&t)==2)\n	{\n		m++;\n		A[f][t]=1;\n		A[t][f]=1;\n	}\n	dfs(1,visited,n,A);\n	printf(\"\\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1038,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 101\n\n\n\nint queue[N];\nint r = 0, w = 0;\n\nvoid enqueue(int a)\n{\n	queue[w++] = a;\n}\n\nint dequeue(void)\n{\n	return (queue[r++]);\n}\n\nint empty(void)\n{\n	if (w == r)\n	{\n		return 1;\n	}\n	return 0;\n}\n\n\n\n\nvoid bfs(int start, int n, int A[N][N])\n{\n	int visited[n+1],i,curr;\n	for (i=0;i<=n;i++)\n	{\n		visited[i]=0;\n	}\n	visited[start]=1;\n	enqueue(start);\n	while (!empty())\n	{\n		curr=dequeue();\n		printf(\"%d \",curr);\n		for (i=1;i<=n;i++)\n		{\n			if (!visited[i] && A[curr][i])\n			{\n				visited[i]=1;\n				enqueue(i);\n			}\n		}\n	}\n}\n\nint main()\n{\n	FILE *f1=fopen(\"input.txt\",\"r\"),*f2=fopen(\"output.txt\",\"w\");\n	int A[N][N]={0};\n//	int visited[N]={0};\n	int i,m=0,n,f,t,j;\n	if (f1==NULL)\n	{\n		printf(\"file open error input.txt\\n\");\n		return 1;\n	}\n	if (f2==NULL)\n	{\n		printf(\"file open error output.txt\\n\");\n		return 1;\n	}\n	fscanf(f1,\"%d\",&n);\n	while (fscanf(f1,\"%d %d\",&f,&t)==2)\n	{\n		m++;\n		A[f][t]=1;\n		A[t][f]=1;\n	}\n	bfs(1,n,A);\n	printf(\"\\n\");\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1039,'#include <stdio.h>\n#include <string.h>\n#define N 100000\n\nint main()\n{\n	FILE *f;\n	char A[N];\n	char S[N];\n	char c;\n	int i=0,n,m;\n	int count=0;\n	scanf(\"%s\",A);\n	strcat(A, \":\");\n	n=strlen(A);\n	f=fopen(\"/etc/passwd\",\"r\");\n	while(strncmp(A,S,n)!=0)\n	{\n		if (!fgets(S,sizeof(S),f))\n			return 0;\n		m=strlen(S);\n	}\n	for(i=0;i<m && count!=4;i++)\n	{\n		if(S[i]==\':\')\n			count++;\n	}\n	while(S[i]!=\':\')\n	{\n		printf(\"%c\",S[i]);\n		i++;\n	}\n//	printf(\"%d\\n\",i);\n//	for(i=0;i<m;i++)\n//		printf(\"%c\",S[i]);\n//	for(i=0;i<n;i++)\n//		printf(\"%c\",A[i]);\n	printf(\"\\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1040,'#include <stdio.h>\n#define N 100000\n\nvoid func(int *A,int *B,int k,int n)\n{\n	int i,j,p;\n	for(i=0;i<n;i++)\n	{\n		if(k==n)\n		{\n			for(j=0;j<n;j++)\n			{\n				printf(\"%d \",B[j]);\n			}\n			printf(\"\\n\");\n			return;\n		}\n		if(A[i]!=0)\n		{\n			B[k]=A[i];\n			p=A[i];\n			A[i]=0;\n			func(A,B,k+1,n);\n			A[i]=p;\n		}\n	}\n}\n\nint main()\n{\n	FILE *f;\n	int i=0,n,p,k=0;\n	int A[N];\n	int B[N]={0};\n	f=freopen(\"input14.txt\",\"r\",stdin);\n	while(scanf(\"%d \",&p)==1)\n	{\n		A[i]=p;\n		i++;\n	}\n	n=i;\n	func(A,B,0,n);\n//	for(i=0;i<n;i++)\n//		printf(\"%d\",A[i]);\n	fclose(f);\n	return 0;\n}\n\n\n	\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1041,'#include <stdio.h>\n#include <stdlib.h>\nint main()\n{\n	struct item{\n		int data;\n		struct item *next;\n	};\n	struct item *head=NULL;\n	struct item *p;\n	struct item *l;\n	struct item *r;\n	FILE *f;\n	int a;\n	f=fopen(\"input.txt\",\"r\");\n/*	while(fscanf(f,\"%d \",&a)==1)\n	{\n		p=malloc(sizeof(*p));\n		p->data=a;\n		p->next=head;\n		head=p;\n	}*/\n	fscanf(f,\"%d \",&a);\n	p=malloc(sizeof(*p));\n	p->data=a;\n	p->next=head;\n	head=p;\n	while(fscanf(f,\"%d \",&a)==1)\n	{\n		p=malloc(sizeof(*p));\n		p->data=a;\n		for(l=NULL,r=head ; r ; l=r,r=r->next)\n		{\n			if(p->data < r->data)\n			{\n				p->next=r;\n				if(l)\n					l->next=p;\n				else\n					head=p;\n				break;\n			}\n			if(!(r->next))\n			{\n				r->next=p;\n				break;\n			}\n		}\n		\n	}\n	for(p=head;p; )\n	{\n		struct item *q;\n		printf(\"%d \",p->data);\n		q = p->next;\n		free(p);\n		p = q;\n	}\n	printf(\"\\n\");\n	fclose(f);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1042,'#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint main()\n{\n	struct item {\n		char word[11];\n		int count;\n		struct item *next;\n	};\n	struct item *head=NULL;\n	struct item *p;\n	struct item *l,*r;\n	char s[11];\n	int i;\n	freopen(\"input.txt\",\"r\",stdin);\n	scanf(\"%s \",s);\n	p=malloc(sizeof(*p));\n	for(i=0;i<11;i++)\n	{\n		p->word[i]=s[i];\n	}\n	p->next=head;\n	head=p;\n	head->count=1;\n	while(scanf(\"%s \",s)==1)\n	{\n		p=malloc(sizeof(*p));\n		for(i=0;i<11;i++)\n		{\n			p->word[i]=s[i];\n		}\n		p->count=1;\n		for(l=NULL,r=head ; r ; l=r, r=r->next)\n		{\n			if(strcmp(p->word,r->word)==0)\n			{\n				r->count++;\n				break;\n			}\n			if(!(r->next))\n			{\n				p->next=head;\n				head=p;\n			}\n		}\n\n	}\n	for(p=head;p;)\n	{\n		struct item *q;\n		printf(\"%s %d\\n\",p->word,p->count);\n		q = p->next;\n		free(p);\n		p = q;\n	}\n	fclose(stdin);\n	return 0;\n}\n\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1043,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item {\n	int data;\n	struct item *left;\n	struct item *right;\n};\n\nvoid infix(struct item *root)\n{\n	if(!root)\n		return;\n	infix(root->left);\n	printf(\"%d \",root->data);\n	infix(root->right);\n}\nvoid freetree(struct item *root)\n{\n	if(!root)\n		return;\n	freetree(root->left);\n	freetree(root->right);\n	free(root);\n}\n\nint main()\n{\n	struct item *root=NULL;\n	struct item *p,*l,*r;\n	freopen(\"input.txt\",\"r\",stdin);\n	int i,a;\n	p=malloc(sizeof(*p));\n	scanf(\"%d \",&a);\n	p->data=a;\n	root=p;\n	root->left=NULL;\n	root->right=NULL;\n	while(scanf(\"%d \",&a)==1)\n	{\n		p=malloc(sizeof(*p));\n		p->data=a;\n		p->left=NULL;\n		p->right=NULL;\n		r=root;\n		while(r)\n		{\n			if(p->data > r->data)\n			{\n				if(r->right)\n				{\n					r=r->right;\n				}\n				else\n				{\n					r->right=p;\n					break;\n				}\n			}\n			else\n			{\n				if(r->left)\n				{\n					r=r->left;\n				}\n				else\n				{\n					r->left=p;\n					break;\n				}\n			}\n		}\n	}\n	infix(root);\n	freetree(root);\n	fclose(stdin);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1044,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct item {\n	char word[11];\n	int count;\n	struct item *next;\n};\nstruct item *head = NULL;\n\nint main() {\n	FILE *in, *out;\n	char s[11];\n\n	in = fopen(\"input_text.txt\", \"r\");\n	out = fopen(\"output.txt\", \"w\");\n\n	if (fscanf(in, \"%s\", s)) {\n		struct item *wd = malloc(sizeof(*wd));\n		strcpy(wd -> word, s);\n		wd -> count = 1;\n		wd -> next = NULL;\n		head = wd;\n	}\n\n	while (fscanf(in, \"%s\", s) == 1) {\n		struct item *a;\n		for (a = head; a; a = a -> next) {\n			if (strcmp(a -> word, s) == 0) {\n				(a -> count)++;\n				break;\n			}\n		}\n        if (a == NULL) {\n			struct item *wd = malloc(sizeof(*wd));\n			strcpy(wd -> word, s);\n			wd -> count = 1;\n			wd -> next = head;\n			head = wd;\n		}\n	}\n\n	struct item *a;\n	for (a = head; a; a = a -> next) {\n		fprintf(out, \"%s - %d\\n\", a -> word, a -> count);\n	}\n\n	fclose(in);\n	fclose(out);\n}\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1045,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 1999\n\nstruct item {\n	char word[11];\n	int count;\n	struct item *next;\n};\n\nunsigned hash(char *s);\n\nint main() {\n    struct item *a[N];\n	FILE *in, *out;\n	char s[11];\n	int hc, i;\n\n	in = fopen(\"input_text.txt\", \"r\");\n	out = fopen(\"output.txt\", \"w\");\n\n	for (i = 0; i != N; i++) {\n        a[i] = NULL;\n    }\n\n	if (fscanf(in, \"%s\", s)) {\n		struct item *wd = malloc(sizeof(*wd));\n		hc = hash(s);\n		a[hc] = wd;\n		strcpy(wd -> word, s);\n		wd -> count = 1;\n		wd -> next = NULL;\n	}\n\n	while (fscanf(in, \"%s\", s) == 1) {\n	    hc = hash(s);\n	    struct item *p;\n        for (p = a[hc]; p && strcmp(p -> word, s); p = p -> next)\n            ;\n        if (p == NULL) {\n            struct item *wd = malloc(sizeof(*wd));\n            strcpy(wd -> word, s);\n            wd -> count = 1;\n            wd -> next = a[hc];\n            a[hc] = wd;\n        } else {\n            (p -> count)++;\n        }\n	}\n\n    struct item *p;\n	for (i = 0; i != N; i++) {\n	    for (p = a[i]; p; p = p -> next)\n		fprintf(out, \"%s - %d\\t\\thc = %d\\n\", p -> word, p -> count, i);\n	}\n\n	fclose(in);\n	fclose(out);\n}\n\nunsigned hash(char *s) {\n    unsigned res = 0;\n\n    for (; *s != \'\\0\'; s++) {\n        res = res * 31 + *s;\n    }\n\n    return (res%N);\n}\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1046,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n	int data;\n	struct node *left, *right;\n};\nstruct node *root = NULL;\n\nvoid search(struct node *root, int a);\nvoid push_right(struct node *root, int a);\nvoid push_left(struct node *root, int a);\nvoid print (struct node *root);\n\nint main() {\n	FILE *in, *out;\n	int a;\n    struct node *p = malloc(sizeof(*p));\n    p -> left = p -> right = NULL;\n\n	in = fopen (\"input.txt\", \"r\");\n	out = fopen (\"output.txt\", \"w\");\n\n	if (fscanf(in, \"%d\", &a) == 1) {\n		p -> data = a;\n	}\n	root = p;\n\n	while (fscanf(in, \"%d\", &a) == 1) {\n		search(root, a);\n	}\n	prints (root);\n\n    printf(\"\\n\");\n\n	return 0;\n}\n\nvoid search(struct node *root, int a) {\n	if (a == root -> data) return;\n	if (a < root -> data) {\n		if (!(root -> left))\n			push_left(root, a);\n		else\n			search(root -> left, a);\n        return;\n	}\n	if (a > root -> data) {\n		if (!(root -> right))\n			push_right(root, a);\n		else\n			search(root -> right, a);\n        return;\n	}\n\n	return;\n}\n\nvoid push_right(struct node *root, int a) {\n	struct node *p = malloc(sizeof(*p));\n	p -> data = a;\n	p -> right = p -> left = NULL;\n	root -> right = p;\n	return;\n}\n\nvoid push_left(struct node *root, int a) {\n	struct node *p = malloc(sizeof(*p));\n	p -> data = a;\n	p -> right = p -> left = NULL;\n	root -> left = p;\n	return;\n}\n\nvoid print (struct node *root) {\n    if (!root) {\n        putchar(\'x\');\n        return;\n    }\n    putchar(\'(\');\n    printf(\"%d\", root -> data);\n    print(root -> left);\n    print(root -> right);\n    putchar(\')\');\n}\n\nvoid prints(struct node *root) {\n  if (!root) return;\n  prints(root->left);\n  printf(\"%d \", root->data);\n  prints(root->right);\n}\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1047,'#include <stdio.h>\n\nvoid print_matrix (int (*a)[100], int size, FILE *out);\nvoid dfs(int (*a)[100], int *visited, int n, int curr);\n\nint main () {\n    FILE *in, *out;\n    int n, m, k, l, i, a[100][100] = {0}, visited[100] = {0};\n\n    in = fopen (\"input.txt\", \"r\");\n    out = fopen (\"output.txt\", \"w\");\n\n    fscanf(in, \"%d %d\\n\", &n, &m);\n\n\n    for (i = 0; i != m; i++) {\n        fscanf(in, \"%d %d\\n\", &k, &l);\n        a[k][l] = 1;\n        a[l][k] = 1;\n    }\n\n    //print_matrix(a, n, stderr);\n    dfs(a, visited, n, 1);\n\n    for (i = 1; i <= n; i++)\n        if (visited[i]) fprintf(stderr, \"%d\\n\", i);\n\n    fclose(in);\n    fclose(out);\n}\n\nvoid print_matrix (int (*a)[100], int size, FILE *out) {\n    int i, j;\n\n    for (i = 1; i <= size; i++) {\n        for (j = 1; j <= size; j++)\n            fprintf(out, \"%d \", a[i][j]);\n        fprintf(out, \"\\n\");\n    }\n\n    return;\n}\n\nvoid dfs(int (*a)[100], int *visited, int n, int curr) {\n    int i;\n    if (curr != 1) visited[curr] = 1;\n    for (i = 1; i <= n; i++) {\n        if (!visited[i] && a[curr][i]) {\n            dfs(a, visited, n, i);\n        }\n    }\n    return;\n}\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1048,'#include <stdio.h>\n#include <stdlib.h>\n\n#define N 101\n\nvoid print(int n, int *D, int *C )\n{\n	int i,q;\n	for (i=1;i<=n;i++)\n	{\n		printf(\"Length to vertex %d is %d. We visit vertexes : \",i,D[i]);\n		q=C[i];\n		while (q!=0)\n		{\n			printf(\"%d \",q);\n			q=C[q];\n		}\n		printf(\"\\n\");\n	}\n}\n	\n\nvoid alg(int n, int A[N][N], int x)\n{\n	int i,j,k,min;\n	int D[N];\n	int used[N]={0};\n	int C[N]={-1};\n	for (i=1;i<=n;i++)\n	{\n		D[i]=100000;\n	}\n	D[x]=0;\n	for ( ; ; )\n	{\n		min=100000;\n		j=0;\n		for (i=1;i<=n;i++)\n		{\n			if (!used[i] && D[i] < min)\n			{\n				min=D[i];\n				j=i;\n			}\n		}\n		if (!j)\n		{\n			print (n,D,C);\n			return;\n		}\n		used[j]=1;\n		for (i=1;i<=n;i++)\n		{\n			if (D[i]>D[j]+A[j][i])\n			{\n				D[i]=D[j]+A[j][i];\n				C[i]=j;\n			}	\n		}\n	}\n}\n\nint main()\n{\n	FILE *f1=fopen(\"input.txt\",\"r\"),*f2=fopen(\"output.txt\",\"w\");\n	int A[N][N];\n	int i,m=0,n,f,t,j,v;\n	if (f1==NULL)\n	{\n		printf(\"file open error input.txt\\n\");\n		return 1;\n	}\n	if (f2==NULL)\n	{\n		printf(\"file open error output.txt\\n\");\n		return 1;\n	}\n	fscanf(f1,\"%d\",&n);\n	for (i=1;i<=n;i++)  //????????????????\n	{\n		for (j=1;j<=n;j++)\n		{\n			A[i][j]=100000;\n		}\n	}\n	while (fscanf(f1,\"%d %d\",&f,&t)==2) //???????? ???????\n	{\n		fscanf(f1,\"%d\",&v);\n		m++;\n		A[f][t]=v;\n		A[t][f]=v;\n	}\n	alg(n,A,1);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1049,'#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\n#define N 101\n\n\ndouble sqr_d(double x)							//?????????? ? ??????? (double)\n{\n	return (x*x);\n}\n\nvoid copy_arr(int *a, int *b, int n)					//??????????? ????????\n{\n	int i;\n	for (i=0;i<=n;i++)\n	{\n		b[i]=a[i];\n	}\n}\n\ndouble length(double x1, double y1, double x2, double y2)		//??????? ?????????? ????? ??????? (????????? ?????)\n{\n	return sqrt(sqr_d(x1-x2)+sqr_d(y1-y2));\n}\n\n\nvoid print(int a[], int n)						//?????? ???????\n{\n	int i;\n	for (i=0;i<n;i++)\n	{\n		printf(\"%d \",a[i]);\n	}\n	printf(\"\\n\");\n	return;\n}	\n\ndouble sum(double A[N][N], int *b, int n)				//??????? ?????????? ??????????? ????? ??????? ? ?????? ????-?\n{\n	int i;\n	double d=0;\n	for (i=1;i<n;i++)\n	{\n		d+=A[b[i]][b[i-1]];\n	}\n	d+=A[b[n-1]][0];\n	return d;\n}\n\nvoid f(double A[N][N], int *a, int *b, int *D, int k, int n)		//???????? ????????\n{\n	int i,j;\n	double d;\n	for(i=1;i<=n;i++)\n	{\n		if (k==n)\n		{\n			\n			d=sum(A,a,n);\n			if (d<A[0][0])\n			{\n				A[0][0]=d;\n				copy_arr(a,D,n);\n			}\n			return ;\n		}\n		if (b[i]!= -1) \n		{\n			a[k]=b[i];\n			b[i] = -1; \n			f(A,a,b,D,k+1,n);\n			b[i]=i;\n		}\n	}\n}\n\n\nint main()\n{\n	double A[N][N],X[N]={0.0},Y[N]={0.0},dm;\n	int n,i,j,d;\n	int B[N]={0},C[N]={0},D[N]={0};\n	FILE *f1=fopen(\"input.txt\",\"r\"),*f2=fopen(\"output.txt\",\"w\");\n	A[0][0]=100000.0;\n\n\n	if (f1==NULL)\n	{\n		printf(\"file open error input.txt\\n\");\n		return 1;\n	}\n	if (f2==NULL)\n	{\n		printf(\"file open error output.txt\\n\");\n		return 1;\n	}\n	fscanf(f1,\"%d\",&n);\n	\n	for (i=1;i<=n;i++)						//???????????????? ???????\n	{\n		for (j=1;j<=n;j++)\n		{\n			A[i][j]=100000.0;\n		}\n	}\n	\n	\n	for (i=1;i<=n;i++)						//?????????? ????????? ? ?????????? ??????? ??????\n	{\n		fscanf(f1,\"%lf %lf\",&X[i],&Y[i]);\n		B[i]=i;\n	}\n	\n	\n	for (i=1;i<=n;i++)						//??????? ?????????? ????? ????????? ? ?????????? ???? ??????? ?????????\n	{\n		for (j=1;j<=n;j++)\n		{\n			A[j][i]=length(X[i],Y[i],X[j],Y[j]);\n			A[i][j]=A[j][i];\n		}\n	}\n	\n	\n/*	for (i=1;i<=n;i++)						//????? ???????\n	{\n		for (j=1;j<=n;j++)\n		{\n			printf (\"%lf \",A[i][j]);\n		}\n		printf(\"\\n\\n\");\n	}\n*/	\n	f(A,C,B,D,0,n);	\n	printf(\"The shortest length = %lf. We visited vertexes : \",A[0][0]);\n	print(D,n);\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1050,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define N 9901\n\nstruct item{\n	char word[15];\n	int count;\n	struct item *next;\n};\n\nunsigned int hash(char *A)\n{\n	unsigned int res=0,i,n;\n	return 0;\n	n=strlen(A);\n	for(i=0;i<n;i++)\n	{\n		res+=(A[i]+23)*(i+1);\n	}\n//	while(*A)	\n//	{\n//		res=res*37+*A;\n//		A++;\n//	}\n	res=res%N;\n	return res;\n}\n\nint main()\n{\n	struct item *p,*r,*l;\n	struct item *head[N]={NULL};\n	FILE *f;\n	int i=0,j=0;\n	char s[15];\n	freopen(\"input.txt\",\"r\",stdin);\n	while(scanf(\"%s\",s)==1)\n	{\n		j=hash(s);\n		p=malloc(sizeof(*p));\n		for(i=0;i<15;i++)\n		{\n			p->word[i]=s[i];\n		}\n		p->count=1;\n		if(!head[j])\n		{\n			p->next=head[j];\n			head[j]=p;\n\n		}\n		else\n		{\n			for(l=NULL,r=head[j] ; r ; r=r->next)\n			{\n				if(strcmp(p->word,r->word)==0)\n				{\n					r->count++;\n					free(p);\n					break;\n				}\n				if(!r->next)\n				{\n					p->next=head[j];\n					head[j]=p;\n					break;\n				}\n			}\n		}\n	}\n	for(j=0 ; j<N ; j++)\n	{\n		if(!head[j])\n			continue;\n		for(p=head[j];p;p = p->next)\n		{\n			printf(\"%s %d\",p->word,p->count);\n			printf(\"\\n\");\n		}\n	}\n	for(j=0 ; j<N ; j++)\n	{\n		for(p=head[j];p;)\n		{\n			struct item *q;\n			q=p->next;\n			free(p);\n			p=q;\n		}\n	}\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1051,'#include <stdio.h>\n#define N 100\n\nint visited[N]={0};\nint A[N][N]={{0}};\n\nvoid dfs(int curr, int n)\n{\n	int i;\n	visited[curr]=1;\n	printf(\"%d\\n\", curr);\n	for(i=1;i<=n;i++)\n	{\n		if(!visited[i] && A[curr][i])\n		{\n			dfs(i,n);\n		}\n	}\n}\nint  main()\n{\n	int v,i,j,n=0;\n	int curr=1;\n	freopen(\"input22.txt\",\"r\",stdin);\n	scanf(\"%d\\n\",&n);\n	while(scanf(\"%d%d\",&i,&j)==2)\n	{\n		A[i][j]=A[j][i]=1;\n	}\n	dfs(curr,n);\n	for(i=1;i<=n;i++)\n	{\n		for(j=1;j<=n;j++)\n			printf(\"%2d\",A[i][j]);\n		printf(\"\\n\");\n	}\n	printf(\"\\n\");\n	fclose(stdin);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1052,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n	char curr[1000], pt[1000];\n	int i=0, c, match=0;\n\n	scanf(\"%s\", pt);\n	printf(\"searching for \'%s\'...\\n\", pt);\n\n	freopen(\"/etc/passwd\", \"r\", stdin);\n	while (1)\n	{	\n		i = 0;\n		memset(curr, 0, 1000);\n		while ((c = getchar()) != \':\' && c != EOF)\n		{\n			curr[i] = c;\n			i++;\n		}\n		i++;\n		curr[i] = \'\\0\';\n\n		if (strcmp(curr, pt) == 0)\n		{\n			match = 1; //???? ????? ??????, ??????? ?? ????? ????????? ? ????????, ??? ?????????? ???????\n			\n			break;\n		} else \n		{\n			while ((c=getchar()) != \'\\n\' && c != EOF); // ????????? ?? ????? ??????, ???? ????? ?? ?????? \n		}\n		if (c == EOF)\n		{\n			match = 0; // ???? ????? ?? ????? ????? ? ?? ????????? ?????????? - ????????, ??? ?????????? ???\n			break;\n		}\n	}\n	if (match)\n	{\n		while ((c = getchar()) != \':\');\n		while ((c = getchar()) != \':\');\n		while ((c = getchar()) != \':\');\n		memset(curr, 0, 1000);\n		i=0;\n		while ((c = getchar()) != \':\' && c != EOF && c != \',\')\n		{	\n			curr[i]=c;\n			i++;\n		}\n		curr[i]=0;\n	\n		printf(\"%s\\n\", curr);\n	} else \n	{\n		printf(\"Not found!\\n\");\n	}\n	\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1053,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid per(char *bg, char *un, int depth)\n{\n	char temp;\n	int i = 0;\n	if (depth == strlen(un)) \n	{\n		printf(\"%s\\n\", bg);\n		return;\n	}\n\n	for (i = 0; un[i]; i++)\n	{\n		if (un[i] != 1) //\"?????? ??????\". ?? ???, ?? ???-?? ???\n		{\n			bg[depth] = un[i];\n			temp = un[i];\n			un[i] = 1;\n			per(bg, un, depth+1);\n			un[i] = temp;\n		}\n	}\n}\n\nint main()\n{\n//	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n	int n, i;\n	char un[1000]={0}, bg[1000]={0}, c;\n\n	scanf(\"%s\", un);\n	printf(\"input: %s\\n\", un);\n\n	n = strlen(un);\n\n	printf(\"length: %d\\n\", n);\n	\n	for (i = 0; i <= n; i++) bg[i] = 0;\n\n	per(bg, un, 0);\n	\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1054,'#include <stdio.h>\n#include <math.h>\nfloat f (float x)\n{\n      return (sin(x));\n}\n\nint main ()\n{ \n    float a=6 , b=8, c=0 ;\n    while (fabs(a-b)>=0.001)\n    {\n          c=(a+b)/2;\n               if (f(a)<=0&&f(c)>=0||f(a)>=0&&f(c)<=0)\n                {\n                        b=c;\n                } else  if (f(b)<=0&&f(c)>=0||f(b)>=0&&f(c)<=0)\n                {\n                        a=c;\n                }\n                c=(a+b)/2;\n    }\n    printf (\"%fl\", a);\n\n    return 0;   \n}\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1055,'#include <stdio.h>\n#include <ctype.h>\n\nint main(int argc, char *argv[])\n{\n    FILE  *fil=freopen(argv[1], \"rt\", stdin);\n       \n\n        int chr=0, wrd=0, str=0, f=0, c=0;\n\n        while ((c=fgetc(stdin))!=EOF)\n        {\n                chr++;\n                if (isspace(c)&&!f)\n                {\n                      f=1;\n                      wrd++;\n                }\n                else \n                     if (f&&!isspace(c))\n                         {\n                            f=0;\n                         }\n\n                if (c==\'\\n\')\n                {\n                        str++;\n                }\n        }\n        printf(\"\\nchars:   %d\\nwords:   %d\\nstrings: %d\\n\", chr, wrd, \nstr);\n        return 0;\n        }\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1056,'#include <stdio.h>\n#include <string.h>\nint palindrom(char s[])\n{    int i;\n     for(i=0; i<=(strlen(s)/2); i++)\n          if (s[i]!=s[strlen(s)-i-1]) return (0);\n     \n     return (1);\n}\nint main(int argc, char *argv[])\n{\n        FILE *FIL=freopen(argv[1], \"rt\", stdin);\n\n        char str[1000]={0};\n        int i=0, c;\n\n        while ((c=fgetc(stdin))!=EOF)\n        {\n                if (isdigit(c)||isalpha(c)){\n                str[i]=c;\n                i++;}\n        }\nprintf(\"%d\", palindrom (str));\n        fclose(stdin);\n        return 0;\n}\n\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1057,'#include  <stdio.h>\n#include <string.h>\n#define NMAX 100\nint main ()\n{\n    int c=0, b=0,  i=0, flag=0, j=0, k=0, ss_v_st=1, N=0;\n    double summa=0, ss_v_st1=1, s[NMAX]={0};\n    while ((c=getchar())!=\'\\n\'&&c!=\' \')\n    b=b*10+c-48;\n    while ((c=getchar())!=\'\\n\'&&c!=\' \')\n    {\n\n        if (c==\'.\') flag=i;\n        if (isdigit(c)) {\n                            s[i]=c-48;\n                        }\n        if (isalpha(c)) {\n                            s[i]=c-55;\n                        }\n        i++;\n    }\nprintf(\"\\n<%d>\", flag);\n    if (flag==0) flag=i++;\n    N=i;\n    for (i=flag-1, j=0; i>=0; i--, j++)\n    {\n\n       for (k=1; k<=i; k++,ss_v_st*=b);\n       s[j]*=ss_v_st;\n       summa+=s[j];\n        printf (\"1.\\n%d->%f\", ss_v_st, summa);\n        ss_v_st=1;\n    }\n for (i=flag+1; i<=N-1; i++)\n    {\n\n        printf(\"\\ns[i]: %f\\n\", s[i]);\n       for (k=1; k<=i-flag; k++,ss_v_st1/=b);\n              s[i]*=ss_v_st1;\n       summa+=s[i];\n        printf (\"2.\\n%f->%f\", ss_v_st1, summa);\n        ss_v_st1=1;\n    }\n    printf (\"\\n%f\", summa);\n    return 0;\n}\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1058,'#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\nint main ()\n{\n    int b=0, i=0, delimoe=0, ostatok=0,k=0, celoe=0;\n    float ch_v_d_ss=0.0, drobn_ch=0.0, chastnoe=0.0;\n    char ch_v_b_ss[]=\"\\0\", c=\'\\0\';\n    scanf (\"%d%f\", &b, &ch_v_d_ss);\n    delimoe=ch_v_d_ss;\n    drobn_ch=ch_v_d_ss-delimoe;\n\n    while (delimoe>=b)\n    {\nprintf(\"\\n s[i]+%d=%s; ostatok=%d, delimoe=%d\", ch_v_b_ss[i], ch_v_b_ss, \nostatok, delimoe);\n        ostatok=delimoe%b;\n        if (ostatok<10) ch_v_b_ss[i]=ostatok+48;\n        if (ostatok>=10) ch_v_b_ss[i]=ostatok+55;\n        i++;\n        delimoe/=b;\n\n    }\n    if (delimoe<10) ch_v_b_ss[i]=delimoe+48;\n    if (delimoe>=10) ch_v_b_ss[i]=delimoe+55;\n    printf(\"\\n%s\", ch_v_b_ss);\n    for (k=0; k<=(i-1)/2; k++)\n    {\n        printf(\"\\n%c<->%c\", ch_v_b_ss[k], ch_v_b_ss[i-1-k]);\n        c=ch_v_b_ss[k];\n        ch_v_b_ss[k]=ch_v_b_ss[i-k];\n        ch_v_b_ss[i-k]=c;\n    }\n    i++;\n    ch_v_b_ss[i]=\'.\';\n    while (drobn_ch!=0)\n    {\n        i++;\n        drobn_ch*=b;\n        celoe=drobn_ch;\n         if (celoe<10) ch_v_b_ss[i]=celoe+48;\n        if (celoe>=10) ch_v_b_ss[i]=celoe+55;\n        drobn_ch-=celoe;\n    }\n\n    ch_v_b_ss[i+1] = 0;\n\n    printf(\"\\n%s\\n\", ch_v_b_ss);\n    return 0;\n}\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1059,'#include <stdio.h>\n#include <stdlib.h>\n#define NMAX 100\n    void f(FILE *file, char *filelogin, char *login, char *name)\n    {\n        int i=0;\n	int j = 0;\n	int c;\n        /*0*/\n        while ((c=fgetc(file))!=\':\'&&c!=EOF)\n        {\n\n            filelogin[i]=c;\n            printf (\"%c%c%c\\n\", c, login[i], filelogin[i]);\n            i++;\n        }\n\n\n        for (j=0; j<i-1; j++)\n        {\n            printf (\"%d.%c-%c\\n\",j, login[j], filelogin[j]);\n            if (login[j]!=filelogin[j])\n            {\n                printf(\"NE RAVNO!!!!!11\");\n                while ((c=fgetc(file))!=\'\\n\'&&c!=EOF) printf(\"%c\", c);\n                printf(\"\\n\");\n                f(file, filelogin, login, name);\n		// * ????????? ?????? ? ?????\n            }\n        }\n\n        /*1*/\n        while ((fgetc(file))!=\':\'&&c!=EOF) ;//printf(\"2\");\n        /*2*/\n        while ((fgetc(file))!=\':\'&&c!=EOF);//printf(\"3\");\n        /*3*/\n        while ((fgetc(file))!=\':\'&&c!=EOF);//printf(\"4\");\n\n        i=0;\n\n        /*4*/\n        while ((c=fgetc(file))!=\':\'&&(c)!=\',\'&&c!=EOF)\n        {\n            name[i]=c;\n            i++;\n            printf(\"%c\", c);\n        }\n	exit(0);\n\n    }\nint main ()\n{\n\n    int i=0, j=0;\n    char filelogin[NMAX], login[NMAX], c, name[NMAX];\n    FILE  *file=fopen(\"/etc/passwd\", \"rt\");\n    if (!file)\n    {\n    	printf(\"cannot open file\\n\");\n	return 1;\n    }\n\n    scanf (\"%s\", login);\n    strcat(login, \":\");\n\n    f(file, filelogin, login, name);\n    fclose(file);\n    return 0;\n}\n\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1060,'#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct item\n{\n   int data;\n   struct item *left, *right;\n};\n\nvoid push(struct item *root, int a)\n{\n   if ((a>=root->data) && (root->right==NULL))\n      {\n         struct item *node=malloc(sizeof(*node));\n         node->data=a;\n         node->right=NULL;\n         node->left=NULL;\n         root->right=node;\n         return;\n      }\n      else if ((a<root->data) && (root->left==NULL))\n              {\n                 struct item *node=malloc(sizeof(*node));\n                 node->data=a;\n                 node->right=NULL;\n                 node->left=NULL;\n                 root->left=node;\n                 return;\n              }\n              else if (a>=root->data) push(root->right, a);\n                   else push(root->left, a);\n   return;\n}\n\nvoid inmm(struct item *root)\n{\n    if (root->left!=NULL) inmm(root->left);\n    if (root->right!=NULL) inmm(root->right);\n    free(root);\n\n    return;\n}\n\nvoid dfsprefix(struct item *root)\n{\n    if (!root) return;\n    dfsprefix(root->left);\n    printf(\"%d \",root->data);\n    dfsprefix(root->right);\n    return;\n}\n\nint main()\n{\n    int i,j,k,n;\n    struct item *root=malloc(sizeof(*root));\n\n    freopen(\"input.txt\",\"rt\",stdin);\n    freopen(\"output.txt\",\"wt\",stdout);\n\n\n    scanf(\"%d\",&n);\n    scanf(\"%d\",&k);\n    root->data=k;\n    root->left=NULL;\n    root->right=NULL;\n    for(i=0;i<n-1;i++)\n       {\n           scanf(\"%d\",&k);\n           push(root,k);\n       }\n\n    dfsprefix(root);\n    inmm(root);\n    return 0;\n}\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1061,'#include <stdio.h>\n#include <ctype.h>\n\nvoid weigh(int a[][10], int *b, int *c)\n{\n    int i,j,k,l;\n\n    i=0;\n    c[i]=1;\n    b[i]=0;\n    j=0;\n\n    do\n    {\n     k=b[i];\n     for(l=0;l<10;l++)\n     {\n         if ((a[k][l]==1) && (c[l]==0))\n         {\n             c[l]=1;\n             j++;\n             b[j]=l;\n         }\n     }\n    i++;\n    }\n     while(i<=j);\n\n    for(i=0;i<10;i++) if (c[i]==1) printf(\"%d \",i+1);\n\n    return;\n}\n\n\nint main()\n{\n    int i,j,k,l;\n    int a[10][10];\n    int b[10];\n    int c[10];\n\n    freopen(\"input.txt\",\"rt\",stdin);\n    freopen(\"output.txt\",\"wt\",stdout);\n\n    for(i=0;i<10;i++)\n       for(j=0;j<10;j++)\n          a[i][j]=0;\n\n    while(scanf(\"%d\",&k)==1)\n    {\n        scanf(\"%d\",&l);\n        a[l-1][k-1]=1;\n        a[k-1][l-1]=1;\n    }\n\n    for(i=0;i<10;i++) b[i]=-1;\n    for(i=0;i<10;i++) c[i]=0;\n\n    weigh(a,b,c);\n\n    return 0;\n}\n\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1062,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n#define N 10\r\n#define infinity 10000\r\n\r\nvoid Dijkstra(int a[N][N], int *d, int *t, int first)\r\n{\r\n    int i,j,k,l,min;\r\n\r\n\r\n    min=0;\r\n    for(i=0;i<N;i++)\r\n       {\r\n           d[i]=a[first][i];\r\n           if (d[i]<d[min]) min=i;\r\n       }\r\n\r\n    d[first]=0;\r\n    l=0;\r\n\r\n    while(l==0 && d[min]!=infinity)\r\n    {\r\n        t[min]=0;\r\n        for(i=0;i<N;i++)\r\n           {\r\n               int u;\r\n               u=a[min][i];\r\n               if ((u+d[min])<d[i]) {d[i]=u+d[min];}\r\n           }\r\n\r\n        k=infinity;\r\n        for(i=0;i<N;i++) if (t[i]==1 && d[i]<k && i!=first) k=d[i];\r\n\r\n        for(i=0;i<N;i++) if (t[i]==1 && i!=first && d[i]==k) min=i;\r\n        if (t[min]==0) l=1;\r\n    }\r\n\r\n    return;\r\n}\r\n\r\nvoid path(int a[N][N], int *d, int *t, int *p, int first, int last)\r\n{\r\n   int i,j,k,l,m,n,u;\r\n\r\n   l=0;\r\n   p[l]=last+1;\r\n\r\n   m=last;\r\n   while(m!=first)\r\n   {\r\n       for(i=0;i<N;i++)\r\n          {\r\n              u=a[m][i];\r\n              if (u!=infinity) if(d[i]+u==d[m]) j=i;\r\n          }\r\n\r\n       m=j;\r\n       l++;\r\n       p[l]=m+1;\r\n   }\r\n\r\n   for(i=l-1;i>0;i--) printf(\"%d->\",p[i]);\r\n   return;\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    int i,j,k,l,first,last;\r\n    int d[N];\r\n    int t[N];\r\n    int p[N];\r\n    int a[N][N];\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    //freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    for(i=0;i<N;i++)\r\n       for(j=0;j<N;j++) a[i][j]=infinity;\r\n    for(i=0;i<N;i++) d[i]=0;\r\n    for(i=0;i<N;i++) p[i]=0;\r\n    for(i=0;i<N;i++) t[i]=1;\r\n\r\n    scanf(\"%d\",&first);\r\n    while(scanf(\"%d\",&k)==1)\r\n    {\r\n        scanf(\"%d\",&l);\r\n        scanf(\"%d\",&i);\r\n        a[k-1][l-1]=i;\r\n        a[l-1][k-1]=i;\r\n    }\r\n\r\n    Dijkstra(a,d,t,first-1);\r\n\r\n    for(i=0;i<N;i++)\r\n    {\r\n        printf(\"%d->%d(%d): %d->\",first,i+1,d[i],first);\r\n        if (d[i]!=infinity)\r\n           {\r\n               path(a,d,t,p,first-1,i);\r\n               printf(\"%d\\n\",i+1);\r\n           }\r\n           else printf(\"\\n\");\r\n    }\r\n\r\n    return 0;\r\n}\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1063,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n#define infinity 100\r\n#define first 0\r\n\r\nstruct item\r\n{\r\n    float sum;\r\n    int mass[infinity];\r\n    struct item *next;\r\n};\r\n\r\nfloat length(float x1, float y1, float x2, float y2)\r\n{\r\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n}\r\n\r\nvoid u(float *x, float *y, int *a, int *b, int n, int now, float sum, float x0,float y0,struct item *root)\r\n{\r\n    int i,j;\r\n    float k;\r\n\r\n    for(i=0;i<n;i++)\r\n       {\r\n           if (a[i]==0)\r\n           {\r\n               a[i]=1;\r\n               b[now]=i;\r\n               k=length(x0,y0,x[i],y[i]);\r\n               u(x,y,a,b,n,now+1,sum+k,x[i],y[i],root);\r\n               b[now]=0;\r\n               a[i]=0;\r\n           }\r\n       }\r\n    j=0;\r\n    for(i=0;i<n;i++) if (a[i]==0) j=1;\r\n    if (j==0)\r\n       {\r\n           float r;\r\n           struct item *p=malloc(sizeof(*p));\r\n\r\n           r=length(x[b[n-1]],y[b[n-1]],x[first],y[first]);\r\n           p->sum=sum+r;\r\n           for(i=0;i<n;i++) p->mass[i]=b[i];\r\n           p->next=root->next;\r\n           root->next=p;\r\n       }\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i,n;\r\n    float ans,x0,y0;\r\n    int a[infinity]={0};\r\n    float x[infinity]={0};\r\n    float y[infinity]={0};\r\n    int b[infinity]={0};\r\n\r\n    struct item *root=malloc(sizeof(*root));\r\n    struct item *q,*p;\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    //freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    root->next=NULL;\r\n\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n       {\r\n           scanf(\"%f %f\",&x0,&y0);\r\n           x[i]=x0;\r\n           y[i]=y0;\r\n       }\r\n\r\n    a[first]=1;\r\n    b[first]=first;\r\n    u(x,y,a,b,n,1,0,x[first],y[first],root);\r\n\r\n    ans=infinity;\r\n    for(q=root->next;q;q=q->next) if (q->sum<=ans) ans=q->sum;\r\n    q=root;\r\n    while(q->sum!=ans)\r\n    {\r\n        q=q->next;\r\n    }\r\n\r\n\r\n    printf(\"%.3f \\n\",q->sum);\r\n    for(i=0;i<n;i++) printf(\"%d \",q->mass[i]+1);\r\n    printf(\"%d\",first+1);\r\n\r\n    for(q=root;q;)\r\n       {\r\n           p=q->next;\r\n           free(q);\r\n           q=p;\r\n       }\r\n\r\n    return 0;\r\n}\r\n\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1064,'#include <stdio.h>\n#include <stdlib.h>\nvoid exch(int *arr, int a, int b)\n{\n	int k= arr[a];\n	arr[a] = arr[b];\n	arr[b] = k;\n}\nvoid proseim(int *a, int n, int i)\n{\n	int k, max;\n	(i+i <= n && a[i+i] > a[i]) ?\n		(max = i+i) :\n		(max = i) ;\n	if(i+i+1 <= n && a[i+i+1] > a[max])\n		max = i+i+1;\n	if(max != i)\n	{\n		exch(a, i, max);\n		proseim(a, n, max);\n	}\n}\n\nint main(void)\n{\n	FILE *fin  = fopen(\"input.txt\",\"r\");\n        FILE *fout = fopen(\"output.txt\",\"w\");\n        int j, n, N;\n        int *a;\n\n        fscanf(fin,\"%d\",&n);\n        a = malloc(n * sizeof(int));\n	N = n;\n     	\n	for(j=1;j<=n;j++)\n     		fscanf(fin,\"%d\",&a[j]);\n	\n\n	for(j = n / 2; j > 0; j--)\n		proseim(a, n, j);\n\n	for(j = n; j > 1; j--)\n	{\n		exch(a, 1, j);\n		n--;\n		proseim(a, n, 1);\n	}\n\n\n//printf(\"finally == \");\n        for(j=1; j<=N; j++)\n        {                                       //addit\n  //              printf(\"%d \",a[j]);             //addit\n                fprintf(fout,\"%d \",a[j]);\n        }                                       //addit\n    //    printf(\"\\n\");                           //addit\n	fprintf(fout,\"\\n\");\n\n\n        fclose(fin);\n        fclose(fout);\n        free(a);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1065,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item\n{\n	int data;\n	struct item *next;\n};\nstruct item *head = NULL;\n\nvoid push(struct item *p, int a)\n{\n	p -> data = a;\n	p -> next = head;\n	head = p;\n}\n\nint main(void)\n{\n	FILE        *fin = fopen(\"tosort.txt\",\"r\");\n	struct item *p, *q, *qm;\n	int         num, min;\n	while (fscanf(fin,\"%d\",&num) == 1)\n	{\n		p = malloc(sizeof(struct item));		    \n		push(p, num);\n	}\n//----------------------------------\n	for(p = head; p->next; p= p->next)\n	{\n		min = p->data;\n		for(q = p->next; q; q= q->next)\n			if(q->data < min)\n			{\n				min = q->data;\n				qm = q;\n			}\n		if(!qm) continue;\n		qm->data = p->data;\n		p->data = min;\n		qm = NULL;\n	}\n//----------------------------------\n	for(p = head; p; p = q)\n	{\n		printf(\"%d \", p->data);\n		q = p->next;\n		free(p);\n	}\n	printf(\"\\n\");\n	fclose(fin);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1066,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n#define infinity 100\r\n#define first 0\r\n\r\nstruct item\r\n{\r\n    float sum;\r\n    int mass[infinity];\r\n    struct item *next;\r\n};\r\n\r\nfloat length(float x1, float y1, float x2, float y2)\r\n{\r\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n}\r\n\r\nvoid u(float *x, float *y, int *a, int *b, int n, int now, float sum, float x0,float y0,struct item *root)\r\n{\r\n    int i,j;\r\n    float k;\r\n\r\n    for(i=0;i<n;i++)\r\n       {\r\n           if (a[i]==0)\r\n           {\r\n               a[i]=1;\r\n               b[now]=i;\r\n               k=length(x0,y0,x[i],y[i]);\r\n               u(x,y,a,b,n,now+1,sum+k,x[i],y[i],root);\r\n               b[now]=0;\r\n               a[i]=0;\r\n           }\r\n       }\r\n    j=0;\r\n    for(i=0;i<n;i++) if (a[i]==0) j=1;\r\n    if (j==0)\r\n       {\r\n           float r;\r\n           struct item *p=malloc(sizeof(*p));\r\n\r\n           r=length(x[b[n-1]],y[b[n-1]],x[first],y[first]);\r\n           p->sum=sum+r;\r\n           for(i=0;i<n;i++) p->mass[i]=b[i];\r\n           p->next=root->next;\r\n           root->next=p;\r\n       }\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i,n;\r\n    float ans,x0,y0;\r\n    int a[infinity]={0};\r\n    float x[infinity]={0};\r\n    float y[infinity]={0};\r\n    int b[infinity]={0};\r\n\r\n    struct item *root=malloc(sizeof(*root));\r\n    struct item *q,*p;\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    //freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    root->next=NULL;\r\n\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n       {\r\n           scanf(\"%f %f\",&x0,&y0);\r\n           x[i]=x0;\r\n           y[i]=y0;\r\n       }\r\n\r\n    a[first]=1;\r\n    b[first]=first;\r\n    u(x,y,a,b,n,1,0,x[first],y[first],root);\r\n\r\n    ans=infinity;\r\n    for(q=root->next;q;q=q->next) if (q->sum<=ans) ans=q->sum;\r\n    q=root;\r\n    while(q->sum!=ans)\r\n    {\r\n        q=q->next;\r\n    }\r\n\r\n\r\n    printf(\"%.3f \\n\",q->sum);\r\n    for(i=0;i<n;i++) printf(\"%d \",q->mass[i]+1);\r\n    printf(\"%d\",first+1);\r\n\r\n    for(q=root;q;)\r\n       {\r\n           p=q->next;\r\n           free(q);\r\n           q=p;\r\n       }\r\n\r\n    return 0;\r\n}\r\n\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1067,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n#define infinity 100\r\n#define first 0\r\n\r\nstruct item\r\n{\r\n    float sum;\r\n    int mass[infinity];\r\n    struct item *next;\r\n};\r\n\r\nfloat length(float x1, float y1, float x2, float y2)\r\n{\r\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n}\r\n\r\nvoid u(float *x, float *y, int *a, int *b, int n, int now, float sum, float x0,float y0,struct item *root)\r\n{\r\n    int i,j;\r\n    float k;\r\n\r\n    for(i=0;i<n;i++)\r\n       {\r\n           if (a[i]==0)\r\n           {\r\n               a[i]=1;\r\n               b[now]=i;\r\n               k=length(x0,y0,x[i],y[i]);\r\n               u(x,y,a,b,n,now+1,sum+k,x[i],y[i],root);\r\n               b[now]=0;\r\n               a[i]=0;\r\n           }\r\n       }\r\n    j=0;\r\n    for(i=0;i<n;i++) if (a[i]==0) j=1;\r\n    if (j==0)\r\n       {\r\n           float r;\r\n           struct item *p=malloc(sizeof(*p));\r\n\r\n           r=length(x[b[n-1]],y[b[n-1]],x[first],y[first]);\r\n           p->sum=sum+r;\r\n           for(i=0;i<n;i++) p->mass[i]=b[i];\r\n           p->next=root->next;\r\n           root->next=p;\r\n       }\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i,n;\r\n    float ans,x0,y0;\r\n    int a[infinity]={0};\r\n    float x[infinity]={0};\r\n    float y[infinity]={0};\r\n    int b[infinity]={0};\r\n\r\n    struct item *root=malloc(sizeof(*root));\r\n    struct item *q,*p;\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    //freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    root->next=NULL;\r\n\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n       {\r\n           scanf(\"%f %f\",&x0,&y0);\r\n           x[i]=x0;\r\n           y[i]=y0;\r\n       }\r\n\r\n    a[first]=1;\r\n    b[first]=first;\r\n    u(x,y,a,b,n,1,0,x[first],y[first],root);\r\n\r\n    ans=infinity;\r\n    for(q=root->next;q;q=q->next) if (q->sum<=ans) ans=q->sum;\r\n    q=root;\r\n    while(q->sum!=ans)\r\n    {\r\n        q=q->next;\r\n    }\r\n\r\n\r\n    printf(\"%.3f \\n\",q->sum);\r\n    for(i=0;i<n;i++) printf(\"%d \",q->mass[i]+1);\r\n    printf(\"%d\",first+1);\r\n\r\n    for(q=root;q;)\r\n       {\r\n           p=q->next;\r\n           free(q);\r\n           q=p;\r\n       }\r\n\r\n    return 0;\r\n}\r\n\r\n','ÐœÐ¸Ñ…Ð°Ð¸Ð»','Mikhail','m');
INSERT INTO `bias` VALUES (1068,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n#define infinity 100\r\n#define first 0\r\n\r\nstruct item\r\n{\r\n    float sum;\r\n    int mass[infinity];\r\n    struct item *next;\r\n};\r\n\r\nfloat length(float x1, float y1, float x2, float y2)\r\n{\r\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n}\r\n\r\nvoid u(float *x, float *y, int *a, int *b, int n, int now, float sum, float x0,float y0,struct item *root)\r\n{\r\n    int i,j;\r\n    float k;\r\n\r\n    for(i=0;i<n;i++)\r\n       {\r\n           if (a[i]==0)\r\n           {\r\n               a[i]=1;\r\n               b[now]=i;\r\n               k=length(x0,y0,x[i],y[i]);\r\n               u(x,y,a,b,n,now+1,sum+k,x[i],y[i],root);\r\n               b[now]=0;\r\n               a[i]=0;\r\n           }\r\n       }\r\n    j=0;\r\n    for(i=0;i<n;i++) if (a[i]==0) j=1;\r\n    if (j==0)\r\n       {\r\n           float r;\r\n           struct item *p=malloc(sizeof(*p));\r\n\r\n           r=length(x[b[n-1]],y[b[n-1]],x[first],y[first]);\r\n           p->sum=sum+r;\r\n           for(i=0;i<n;i++) p->mass[i]=b[i];\r\n           p->next=root->next;\r\n           root->next=p;\r\n       }\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i,n;\r\n    float ans,x0,y0;\r\n    int a[infinity]={0};\r\n    float x[infinity]={0};\r\n    float y[infinity]={0};\r\n    int b[infinity]={0};\r\n\r\n    struct item *root=malloc(sizeof(*root));\r\n    struct item *q,*p;\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    //freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    root->next=NULL;\r\n\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n       {\r\n           scanf(\"%f %f\",&x0,&y0);\r\n           x[i]=x0;\r\n           y[i]=y0;\r\n       }\r\n\r\n    a[first]=1;\r\n    b[first]=first;\r\n    u(x,y,a,b,n,1,0,x[first],y[first],root);\r\n\r\n    ans=infinity;\r\n    for(q=root->next;q;q=q->next) if (q->sum<=ans) ans=q->sum;\r\n    q=root;\r\n    while(q->sum!=ans)\r\n    {\r\n        q=q->next;\r\n    }\r\n\r\n\r\n    printf(\"%.3f \\n\",q->sum);\r\n    for(i=0;i<n;i++) printf(\"%d \",q->mass[i]+1);\r\n    printf(\"%d\",first+1);\r\n\r\n    for(q=root;q;)\r\n       {\r\n           p=q->next;\r\n           free(q);\r\n           q=p;\r\n       }\r\n\r\n    return 0;\r\n}\r\n\r\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1069,'#include <ctype.h>\r\n#include <stdio.h>\r\n#include <math.h>\r\n#include <stdlib.h>\r\n\r\n#define infinity 100\r\n#define first 0\r\n\r\nstruct item\r\n{\r\n    float sum;\r\n    int mass[infinity];\r\n    struct item *next;\r\n};\r\n\r\nfloat length(float x1, float y1, float x2, float y2)\r\n{\r\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\r\n}\r\n\r\nvoid u(float *x, float *y, int *a, int *b, int n, int now, float sum, float x0,float y0,struct item *root)\r\n{\r\n    int i,j;\r\n    float k;\r\n\r\n    for(i=0;i<n;i++)\r\n       {\r\n           if (a[i]==0)\r\n           {\r\n               a[i]=1;\r\n               b[now]=i;\r\n               k=length(x0,y0,x[i],y[i]);\r\n               u(x,y,a,b,n,now+1,sum+k,x[i],y[i],root);\r\n               b[now]=0;\r\n               a[i]=0;\r\n           }\r\n       }\r\n    j=0;\r\n    for(i=0;i<n;i++) if (a[i]==0) j=1;\r\n    if (j==0)\r\n       {\r\n           float r;\r\n           struct item *p=malloc(sizeof(*p));\r\n\r\n           r=length(x[b[n-1]],y[b[n-1]],x[first],y[first]);\r\n           p->sum=sum+r;\r\n           for(i=0;i<n;i++) p->mass[i]=b[i];\r\n           p->next=root->next;\r\n           root->next=p;\r\n       }\r\n    return;\r\n}\r\n\r\n\r\n\r\n\r\nint main()\r\n{\r\n    int i,n;\r\n    float ans,x0,y0;\r\n    int a[infinity]={0};\r\n    float x[infinity]={0};\r\n    float y[infinity]={0};\r\n    int b[infinity]={0};\r\n\r\n    struct item *root=malloc(sizeof(*root));\r\n    struct item *q,*p;\r\n\r\n    freopen(\"input.txt\",\"rt\",stdin);\r\n    //freopen(\"output.txt\",\"wt\",stdout);\r\n\r\n    root->next=NULL;\r\n\r\n    scanf(\"%d\",&n);\r\n    for(i=0;i<n;i++)\r\n       {\r\n           scanf(\"%f %f\",&x0,&y0);\r\n           x[i]=x0;\r\n           y[i]=y0;\r\n       }\r\n\r\n    a[first]=1;\r\n    b[first]=first;\r\n    u(x,y,a,b,n,1,0,x[first],y[first],root);\r\n\r\n    ans=infinity;\r\n    for(q=root->next;q;q=q->next) if (q->sum<=ans) ans=q->sum;\r\n    q=root;\r\n    while(q->sum!=ans)\r\n    {\r\n        q=q->next;\r\n    }\r\n\r\n\r\n    printf(\"%.3f \\n\",q->sum);\r\n    for(i=0;i<n;i++) printf(\"%d \",q->mass[i]+1);\r\n    printf(\"%d\",first+1);\r\n\r\n    for(q=root;q;)\r\n       {\r\n           p=q->next;\r\n           free(q);\r\n           q=p;\r\n       }\r\n\r\n   \r\n}\r\n\r\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1070,'#include <stdio.h>\n\nint main()\n{\n	freopen(\"input13.txt\", \"r\", stdin);\n	freopen(\"../public_html/13.html\", \"w\", stdout);\n	\n	//?????????? ????????? ?? ????????\n\n	int st = 1, c; //?????? ??????????? ?????? ??????? ??? ???????\n	printf(\"<html>\\n<head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\"></head><body>\");\n	printf(\"<table border=\\\"1\\\">\\n<tr>\\n\");\n	while((c = getchar()) != EOF)\n	{\n		if (st == 0) \n		{\n			if (c == \',\')\n			{\n				st = 1; //?????? ?????????\n				printf(\"\\n</td>\\n\");\n			} else if (c == \'\\n\') \n			{\n				st = 2; //?????? ?????????\n				printf(\"\\n</tr>\\n\");\n			} else\n			{\n				printf(\"%c\", c);\n			}\n		} else if (st == 1) //????? ??????\n		{\n			if (c == \'\"\')\n			{\n				st = 3; //???????? ?????? ? ????????\n				printf(\"\\n<td>\\n\");\n			} else if (c == \'\\n\') //????????? ??????\n			{\n				st = 2;\n				printf(\"\\n</tr>\\n\");\n			} else \n			{\n				st = 0; //???????? ?????? ??? ???????\n				printf(\"\\n<td>\\n%c\", c);\n			}\n		} else if (st == 2) //????? ??????\n		{\n			if (c == \'\"\')\n			{\n				st = 3; \n				printf(\"<tr>\\n<td>\\n\");\n			} else \n			{\n				st = 0;\n				printf(\"<tr>\\n<td>\\n%c\", c);\n			}\n		}else if (st == 3) //?????? ? ????????\n		{\n			if (c == \'\"\')\n			{\n				st = 4; //??????? ?????? ?????? ? ????????\n			} else if (c == \'\\n\')\n			{\n				printf(\"<br />\");\n			} else printf(\"%c\", c);\n		} else if (st == 4) //??????? ?????? ?????? ? ????????\n		{\n			if (c == \'\"\')\n			{\n				st = 3;\n				printf(\"%c\", c);\n			} else if (c == \',\')\n			{\n				st = 1;\n				printf(\"</td>\\n\");\n			} else if (c == \'\\n\')\n			{\n				st = 2;\n				printf(\"\\n</td>\\n</tr>\\n\");\n			}\n		}		\n	}\n\n	printf(\"\\n</td>\\n</tr>\\n</table>\\n</body>\\n</html>\");\n	\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1071,'#include <stdio.h>\r\n#define inf 100000\r\n\r\nint main() {\r\n    wchar_t y = L\'&#8734;\';\r\n\r\n    FILE *in, *out;\r\n    int a[100][100], d[100], used[100] = {0}, way[100] = {0};\r\n    int i, j, n, m, k, l, w, start, min = inf, curr;\r\n\r\n    in = fopen (\"input.txt\", \"r\");\r\n    out = stdout;//fopen (\"output.txt\", \"w\");\r\n\r\n    fscanf(in, \"%d %d\\n\", &n, &m);\r\n\r\n    for (i = 1; i <= n; i++) {\r\n        for (j = 1; j <= n; j++)\r\n            a[i][j] = inf;\r\n    }\r\n\r\n    for (i = 0; i != m; i++) {\r\n        fscanf(in, \"%d %d %d\\n\", &k, &l, &w);\r\n        a[k][l] = a[l][k] = w;\r\n    }\r\n\r\n    fscanf(in, \"%d\", &start);\r\n    d[start] = 0;\r\n    used[start] = 1;\r\n    curr = start;\r\n    for (i = 1; i <= n; i++)\r\n        d[i] = a[i][start];\r\n    d[start] = 0;\r\n\r\n    while (1) {\r\n        min = inf;\r\n        for (i = 1; i <= n; i++)\r\n            if (!used[i] && d[i] < min) {\r\n                min = d[i];\r\n                curr = i;\r\n            }\r\n        if (min == inf) break;\r\n        used[curr] = 1;\r\n        for (i = 1; i <= n; i++)\r\n            if (d[i] > d[curr] + a[curr][i]) {\r\n                d[i] = d[curr] + a[curr][i];\r\n                way[i] = curr;\r\n            }\r\n    }\r\n\r\n    for (i = 1; i <= n; i++)\r\n        if (i != start && d[i] == inf) fwprintf(out, L\"distance to %d = inf\\tno way\\n\", i);\r\n        else if (i != start) {\r\n            fprintf(out, \"distance to %d = %d\\tway: \", i, d[i]);\r\n            j = i;\r\n            fprintf (out, \"%d %c \", j, 27);\r\n            while (way[j] != 0) {\r\n                fprintf (out, \"%d %c \", way[j], 27);\r\n                j = way[j];\r\n            }\r\n            fprintf (out, \"%d\\n\", start);\r\n        }\r\n\r\n    close(in);\r\n    close(out);\r\n\r\n    return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1072,'#include <stdio.h>\r\n#include <math.h>\r\n#define INF 100000\r\n\r\ndouble func(int *a, int N, int *b, int n, int *way, double *d, double (*matrix)[100])\r\n{\r\n    int i, f, s;\r\n    double length = 0, res, real_res = INF;\r\n\r\n    if (N == n)\r\n    {\r\n        /*for (i = 0; i < n; i++)\r\n            fprintf (f, \"%d \", a[i]);\r\n        fprintf (f, \"\\n\");*/\r\n        for (i = 0; i < n; i++) {\r\n            f = a[i];\r\n            s = a[(i+1)%n];\r\n            length += matrix[f][s];\r\n        }\r\n        if (length < *d) {\r\n            for (i = 0; i < n; i++)\r\n                way[i] = a[i];\r\n            *d = length;\r\n            return length;\r\n        }\r\n        return *d;\r\n    }\r\n    for (i = 0; i < n; i++)\r\n    {\r\n        if (b[i] == 0)\r\n        {\r\n            a[N] = i+1;\r\n            b[i] = 1;\r\n            res = func(a, N+1, b, n, way, d, matrix);\r\n            if (res < real_res) real_res = res;\r\n            b[i] = 0;\r\n        }\r\n    }\r\n/*for (i = 0; i < n-1; i++)\r\n        fprintf(stderr, \"%d -> \", way[i]);\r\n    fprintf(stderr, \"%d\\n\", way[i]);*/\r\n    return real_res;\r\n}\r\n\r\nint main() {\r\n	FILE *in, *out;\r\n	int n, i, j;\r\n	double x[100], y[100], matrix[100][100], d, res;\r\n	int a[10000] = {0}, b[10000] = {0}, N = 0, way[100] = {0};\r\n    FILE *fin, *f;\r\n\r\n    in = fopen (\"input.txt\", \"r\");\r\n    out = stdout;//fopen (\"output.txt\", \"w\");\r\n\r\n    fscanf(in, \"%d\\n\", &n);\r\n\r\n    for (i = 1; i <= n; i++) {\r\n        fscanf(in, \"%lf %lf\", &x[i], &y[i]);\r\n    }\r\n	for (i = 1; i <= n; i++) {\r\n		for (j = i; j <= n; j++) {\r\n			d = sqrt(pow(x[i]-x[j], 2) + pow(y[i]-y[j], 2));\r\n			matrix[i][j] = matrix[j][i] = d;\r\n		}\r\n	}\r\n\r\n/*	for (i = 1; i <= n; i++)\r\n        for (j = i+1; j <= n; j++)\r\n            fprintf(out, \"matrix[%d][%d] = %lf\\n\", i, j, matrix[i][j]); */\r\n    d = INF;\r\n    res = func(a, N, b, n, way, &d, matrix);\r\n    fprintf(stderr, \"%lf\\n\", res);\r\n    for (i = 0; i < n; i++)\r\n        printf(\"%d \", way[i]);\r\n    printf(\"\\n\");\r\n\r\n	fclose(in);\r\n	fclose(out);\r\n\r\n	return 0;\r\n}\r\n','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1073,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nvoid swap(int *e1, int *e2) {\r\n	int t = *e1;\r\n	*e1 = *e2;\r\n	*e2 = t;\r\n}\r\n\r\nvoid sift(int *a, int i, int n) {\r\n	int l, r, max = i, temp;\r\n\r\n	while ((i<<1) < n) {\r\n		l = (i<<1);\r\n		r = (i<<1)+1;\r\n		if (l < n && a[l] > a[max]) max = l;\r\n		if (r < n && a[r] > a[max]) max = r;\r\n		if (max == i) return;\r\n		swap(&a[i], &a[max]);\r\n		i = max;\r\n	}\r\n\r\n	return;\r\n}\r\n\r\nvoid heap_sort(int *a, int n) {\r\n	int i, temp;\r\n\r\n	for (i = (n>>1); i >= 0; i--)\r\n		sift(a, i, n);\r\n	for (i = n-1; i != 0; i--) {\r\n		swap(&a[i], a);\r\n		sift(a, 0, i);\r\n	}\r\n\r\n	return;\r\n}','ÐÐ»Ñ‘Ð½Ð°','Alyona','f');
INSERT INTO `bias` VALUES (1074,'#define c_latin ((c >= \'A\' && c <= \'Z\') || (c >= \'a\' && c <= \'z\'))\n#define OVER 9000\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct item\n{\n	char word[OVER];\n	int count;\n	struct item *next;\n};\nstruct item *head = NULL;\n\nvoid push(struct item *p, char *s, int i)\n{\n	int j;\n	for(j=0; j<i; j++)\n		p -> word[j] = s[j];\n	p -> count = 1;\n	p -> next = head;\n	head = p;\n}\n\nint main(void)\n{\n	FILE        *fin = fopen(\"input.txt\",\"r\");\n	struct item *p, *q;\n	char c;\n	char *s = malloc(OVER);\n	int state =0, i =0;\n	while (EOF != (c = fgetc(fin)))\n	{\n		if c_latin\n		{\n			state = 1;\n			s[i] = c;\n			i++;\n		}\n		if (state == 1 && !c_latin)\n		{\n			p = malloc(sizeof(struct item));\n			push(p, s, i);\n			state = 0;\n			i = 0;\n		}\n	}\n//----------------------------------\n	for(p = head; p->next; p= p->next)\n	{\n		for(q = p->next; q; q= q->next)\n			if(strcmp(q->word, p->word) == 0)\n			{\n				p->count++;\n				if(state == 0)\n				{\n					state = 1;\n				}\n				for(i=0; q->word[i]; i++)\n				{\n					q->word[i] = \'\\0\';\n\n				}\n			}\n	}\n//----------------------------------*/\n	for(p = head; p; p = q)\n	{\n		if(p->word[0])\n		{\n			printf(\"%s == %d\\n\", p->word, p->count);\n		}\n		q = p->next;\n		free(p);\n	}\n	fclose(fin);\n	free(s);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1075,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\n\r\n\r\nvoid sort(int l, int r, int *a, int N, FILE *file2)\r\n{\r\n    int i=l, j=r, c, x, k;\r\n    x=a[(l+r)/2];\r\n    while (i<=j)\r\n    {\r\n        for (;a[i]<x ; i++);\r\n        for (; a[j]>x; j--);\r\n        if (i<=j)\r\n        {c=a[i];\r\n        a[i]=a[j];\r\n        a[j]=c;\r\n        i++;\r\n        j--;\r\n        }\r\n    /*for (k=1; k<=N; k++)\r\n    fprintf(file2, \"%d \", a[k]);\r\n    fprintf (file2, \"\\n\");*/\r\n    }\r\n    if (l<j) sort(l, j, a, N, file2);\r\n    if (i<r) sort(i, r, a, N, file2);\r\n\r\n\r\n}\r\n\r\nint main ()\r\n{\r\n\r\n    int i=0, N=0, j=0, k, *p, c;\r\n\r\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\r\n    fscanf(file, \"%d\", &N);\r\n    int a[N];\r\n\r\n    for (i=1; i<=N; i++)\r\n    fscanf (file, \"%d\", &a[i]);\r\n    sort(1, N, a, N, file2);\r\n\r\n    for (k=1; k<=N; k++)\r\n    fprintf(file2, \"%d \", a[k]);\r\n    fprintf (file2,\"\\n\");\r\n    fclose(file);\r\n    fclose (file2);\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1076,'# include <stdio.h>\r\n#include <ctype.h>\r\n#define NMAX 100\r\nvoid sift(int *a, int l, int r)\r\n{\r\n\r\n    int x=a[l], i=l, j=2*l;\r\n    if (j<r&&a[j]<a[j+1]) j++;\r\n    while (j<=r&&x<a[j])\r\n    {\r\n        a[i]=a[j];\r\n        i=j;\r\n        j=2*j;\r\n        if (j<r&&a[j]<a[j+1]) j++;\r\n    }\r\n    a[i]=x;\r\n\r\n\r\n}\r\nvoid heapsort(int *a, int N, FILE *file2)\r\n{\r\n    int l=N/2+1, r=N, x=0, k, i=0, j=0;\r\n    while (l>1)\r\n    {\r\n        l--;\r\n        sift(a, l, r);\r\n\r\n    /*for (k=1; k<=N; k++)\r\n        fprintf(file2, \"%d   \", a[k]);\r\n    fprintf (file2, \"\\n\");*/\r\n\r\n    }\r\n    while (r>l)\r\n    {\r\n        x=a[1];\r\n        a[1]=a[r];\r\n        a[r]=x;\r\n        r--;\r\n        sift(a, l, r);\r\n\r\n    /*for (k=1; k<=N; k++)\r\n        fprintf(file2, \"%d   \", a[k]);\r\n    fprintf (file2, \"\\n\");*/\r\n\r\n    }\r\n\r\n}\r\nint main()\r\n{\r\n\r\n\r\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\r\n    int i=0, N=0, j=0, k, *p, c;\r\n\r\n    fscanf( file, \"%d\", &N);\r\n    int a[N];\r\n\r\n    for (i=1; i<=N; i++)\r\n        fscanf (file, \"%d\", &a[i]);\r\n    heapsort(a, N, file2);\r\n\r\n    for (k=1; k<=N; k++)\r\n        fprintf(file2, \"%d \", a[k]);\r\n    fprintf (file2, \"\\n\");\r\n    fclose(file);\r\n    fclose (file2);\r\n\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1077,'#include <stdio.h>\n#define N 100000\nvoid sift(int *A, int k, int n)\n{\n	int max=k;\n	int p;\n	if(2*k+1 < n && A[max]<A[2*k+1])\n		max=2*k+1;\n	if(2*k+2 < n && A[max]<A[2*k+2])\n		max=2*k+2;\n	if(max!=k)\n	{\n		p=A[k];\n		A[k]=A[max];\n		A[max]=p;\n		sift(A,max,n);\n	}\n	return;\n}\n\nvoid sort(int *A, int n)\n{\n	while (n > 1)\n	{\n		int p;\n		p=A[0];\n		A[0]=A[n-1];\n		A[n-1]=p;\n		sift(A,0,n-1);\n		n--;\n	}\n	return;\n}\nint main()\n{\n	int A[N];\n	int i=0,n,k=0;\n	freopen(\"input17.txt\",\"r\",stdin);\n	while(scanf(\"%d \",&k)==1)\n	{\n		A[i]=k;\n		i++;\n	}\n	n=i;\n	k = 0;\n	while(2*k+1<n)\n	{\n		k++;\n	}\n	for(i=k;i>=0;i--)\n	{\n		sift(A,i,n);\n	}\n	sort(A,n);\n	for(i=0;i<n;i++)\n		printf(\"%d \",A[i]);\n	printf(\"\\n\");\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1078,'#include <stdio.h>\n#define N 100\n\nint A[N][N]={{0}};\nint visited[N]={0};\nint queue[N];\nint r=0,w=0;\n\nvoid enqueue(int a)\n{\n	queue[w++]=a;\n}\n\nint dequeue(void)\n{\n	return (queue[r++]);\n}\n\nint empty(void)\n{\n	return (r==w);\n}\n\nvoid bfs(int curr, int n)\n{\n	visited[curr]=1;\n	enqueue(curr);\n	while(!empty())\n	{\n		int i;\n		curr=dequeue();\n		printf(\"curr: %d\\n\", curr);\n		for(i=1;i<=n;i++)\n		{\n			if(!visited[i] && A[curr][i])\n			{\n				visited[i]=1;\n				enqueue(i);\n			}\n		}\n	}\n	return;\n}\n\nint main()\n{\n	freopen(\"input22.txt\",\"r\",stdin);\n	int n,i,j;\n	int curr = 1;\n	scanf(\"%d\\n\",&n);\n	while(scanf(\"%d%d\",&i,&j)==2)\n	{\n		A[i][j]=A[j][i]=1;\n	}\n	bfs(curr,n);\n	for(i=1;i<=n;i++)\n	{\n		for(j=1;j<=n;j++)\n			printf(\"%2d\",A[i][j]);\n		printf(\"\\n\");\n	}\n	printf(\"\\n\");\n	fclose(stdin);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1079,'#include <stdio.h>\n#define N 100\n#define INF 100000\n\nint A[N][N];\nint D[N];\nint used[N];\nint prev[N];\n\nint mini(int *D, int n)\n{\n	int min=1;\n	int i;\n	for(i=1;i<=n;i++)\n	{\n		if(!used[i])\n		{\n			if(D[min]>D[i])\n			{\n				min=i;\n			}\n		}\n	}\n	return min;\n}\n\nvoid dijkstra(int curr, int n, int *D, int *used)\n{\n	int min;\n	int i,j;\n	min=mini(D,n);\n	used[min]=1;\n	for(i=1;i<=n;i++)\n	{\n		if(!used[i] && A[curr][i])\n		{\n			if(D[i]>D[curr]+A[curr][i])\n			{\n				D[i]=D[curr]+A[curr][i];\n				dijkstra(i,n,D,used);\n				prev[i]=curr;\n			}\n		}\n	}\n//	for(i=1;i<=n;i++)\n//		printf(\"D[%d]=%d \",i,D[i]);\n//	printf(\"\\n\");\n	return;\n}\n\nint main()\n{\n	int i,j,d;\n	int start;\n	int n;\n	int min;\n	freopen(\"input24.txt\",\"r\",stdin);\n	scanf(\"%d\\n\",&start);\n	scanf(\"%d\\n\",&n);	\n	while(scanf(\"%d %d %d\",&i,&j,&d)==3)\n	{\n		A[i][j]=A[j][i]=d;\n	}\n	\n	for(i=1;i<=n;i++)\n	{\n		prev[i]=-1;\n		used[i]=0;\n		D[i]=INF;\n	}\n	D[start]=0;\n//	min=mini(D,n);\n	dijkstra(start,n,D,used);\n/*	printf(\"v=%d min=%d\\n\",min,D[min]);\n	for(i=1;i<=n;i++)\n		printf(\"D[%d]=%d \",i,D[i]);\n	printf(\"\\n\");\n\n	printf(\"start=%d n=%d\\n\",start,n);\n	for(i=1;i<=n;i++)\n	{\n		for(j=1;j<=n;j++)\n		{\n			printf(\"% 3d \",A[i][j]);\n		}\n		printf(\"\\n\");\n	}*/\n	for (i = 1; i <= n; i++)\n	{\n		printf(\"%d \", prev[i]);\n	}\n	printf(\"\\n\");\n	for(i=1;i<=n;i++)\n	{\n		printf(\"%d -> %d = %d: \",start,i,D[i]);\n		for(j=i;j>0;)\n		{\n			printf(\"%d \",j);		\n			j=prev[j];\n		}\n		printf(\"\\n\");\n	\n	}\n//	for(i=1;i<=n;i++)\n//	{\n//		printf(\"prev[%d]=%d\",i,prev[i]);\n//	}\n	printf(\"\\n\");\n	fclose(stdin);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1080,'#include <stdio.h>\n#include <math.h>\n#define N 100\n#define M 100000\ndouble A[N][N];\ndouble C[N][2];\ndouble D[M]={0};\nint used[N];\nint prev[N][N];\n\ndouble gam(int curr, int n, int v)\n{\n	int i,j,last;\n	float d=0;\n	used[curr]=1;\n	for(i=1;i<=n;i++)\n	{\n		if(!used[i])\n		{\n			d+=A[curr][i];\n			d+=gam(i,n,v);\n			printf(\"%d -> %d %lf\\n\",v,i,d);	\n			break;\n		}\n		last=i;\n	}\n	printf(\"%d\\n\",last);\n	used[curr]=0;\n	return d;\n}\nint main()\n{\n	freopen(\"input25.txt\",\"r\",stdin);\n	double x,y,d;\n	int i=1,j,n=0;\n	while(scanf(\"%lf %lf\\n\",&x,&y)==2)\n	{\n		C[i][1]=x;\n		C[i][2]=y;\n		i++;\n		n++;\n	}\n	for(i=1;i<=n;i++)\n	{\n		for(j=1;j<=n;j++)\n		{\n			A[i][j]=sqrt(pow((C[i][1]-C[j][1]),2)+pow((C[i][2]-C[j][2]),2));\n		}\n	}\n	d=gam(1,n,1);\n//	printf(\"%lf\",d);\n	for(i=1;i<=n;i++)\n	{\n		for(j=1;j<=n;j++)\n		{\n			printf(\"%2.2lf \",A[i][j]);\n		}\n		printf(\"\\n\");\n	}/*\n	for(i=1;i<=n;i++)\n	{\n		printf(\"%2.2lf %2.2lf\\n\",C[i][1],C[i][2]);\n	}*/\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1081,'#include <stdio.h>\n\nvoid swap(int *a, int *b)\n{\n	int temp = *a;\n	*a = *b;\n	*b = temp;\n	return;\n}\n\nvoid sift(int *M, int n, int k)\n{\n	int temp;\n	int left = (2 * k) + 1;\n	int right = (2 * k) + 2;\n\n//	printf(\"sift: n = %d, k = %d\\n\", n, k);\n\n	if (left > n - 1) \n	{\n		return;\n	} else \n	{\n		if (right <= n-1 && M[right] > M[left])\n		{	\n			if (M[right] > M[k])\n			{\n				swap(M + k, M + right);\n				sift(M, n, right);\n			}\n		} else \n		{\n			if (M[left] > M[k])\n			{\n				swap(M + k, M + left);\n				sift(M, n, left);\n			}\n		}\n	}\n}\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n	int n, M[100000], i, t, p;\n\n	scanf(\"%d\", &n);\n\n//	fprintf(stderr, \"%d\\n\", n);\n	for (i = 0; i < n; i++) scanf(\"%d\", M + i);\n\n//	fprintf(stderr, \"%d\\n\", n);\n	for (i = n/2 + 1; i >= 0; i--)\n	{\n		sift(M, n, i);\n	}\n	\n//	fprintf(stderr, \"%d\\n\", n);\n	for (i = n - 1; i > 0; i--)\n	{	\n		int j;\n		swap(M, M + i);\n		\n/*		for (j = 0; j < i; j++)\n		{\n			printf(\"%d \", M[j]);\n		}\n		printf(\" | \");\n		for ( ; j < n; j++)\n		{\n			printf(\"%d \", M[j]);\n		}\n		printf(\"\\n\");*/\n\n		sift(M, i, 0);\n	}\n	\n//	fprintf(stderr, \"%d\\n\", n);\n        for (i = 0; i < n; i++)\n        {\n                printf(\"%d \", M[i]);\n        }\n	\n	printf(\"\\n\");\n\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1082,'#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n	struct item\n	{\n		int data;\n		struct item *next;\n	} *p, *prev, *q, *head = NULL;\n\n	int a;\n\n	scanf(\"%d\", &a);\n\n	p = malloc(sizeof(struct item));\n	p->data = a;\n	p->next = NULL;\n	head = p;\n	\n	while (scanf(\"%d\", &a) == 1)\n	{\n		q = head;\n		while((q != NULL) && ((q->data) < a)) \n		{\n			prev = q;\n			q = q->next;\n		}\n		p = malloc(sizeof(struct item));\n		p->data = a;\n		if (q == head)\n		{\n			p->next = head;\n			head = p;\n		} else if (q == NULL)\n		{\n			prev->next = p;\n			p->next = NULL;\n		} else\n		{\n			prev->next = p;\n			p->next = q;\n		}\n	}\n	p = head;\n	while (p != NULL)\n	{\n		printf(\"%d \", p->data);\n		p = p->next;\n	}\n\n	printf(\"\\n\");\n	\n	while(head != NULL)\n	{\n		p = head->next;\n		free(head);\n		head = p;\n	}\n\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1083,'#include <stdio.h>\n#include <string.h>\n\nvoid dfs(int (*M)[101], int curr, int *visited, int N)\n{\n	int i;\n	visited[curr] = 1;\n	printf(\"%d \", curr);\n	for (i = 1; i <= N; i++)\n	{\n		if (M[curr][i] && !visited[i])\n		{\n			dfs(M, i, visited, N);\n		}\n	}\n}\n\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	\n	int M[101][101], N, i, j, x, y;\n	int visited[101];\n\n	memset(M, 0, 101);\n	\n	scanf(\"%d\", &N);\n\n	for (i = 0; i <= 100; i++)\n        {\n                for (j = 1; j <= N; j++)\n                {\n                       M[i][j] = 0;\n                }\n        }\n\n	while (scanf(\"%d %d\", &x, &y) == 2)\n	{\n		M[x][y] = 1;\n		M[y][x] = 1;\n	}\n	\n	printf(\"The Matrix:\\n\");\n	for (i = 1; i <= N; i++)\n	{\n		for (j = 1; j <= N; j++)\n		{\n			printf(\"%d \", M[i][j]);\n		}\n		printf(\"\\n\");\n	}\n\n	printf(\"\\n\");\n\n	dfs(M, 1, visited, N);\n\n\n	printf(\"\\n\");\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1084,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item\n{\n    int data;\n    struct item *next;\n    struct item *prev;\n};\nint main ()\n{\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\n    int i=0, x=0, N=0, counter=1;\n    struct item *head=NULL;\n    struct item *p = malloc(sizeof(*p));\n    if (!p) return 1;\n    struct item *q = malloc(sizeof(*p));\n    if (!q) return 1;\n\n    fscanf(file, \"%d\", &p->data);\n\n    p->next=0;\n    p->prev=0;\n    head=p;\n    while (1==fscanf (file, \"%d\", &x))\n    {\n        p=head;\n        while (p)\n        {\n               if (p->prev==0&&x<=p->data)\n               {\n                    q->data = x;\n                    q->next = p;\n                    q->prev=0;\n                    p->prev=q;\n                    head = q;\n                    q=malloc(sizeof(*q));\n                    if (!q) return 1;\n                    break;\n               }\n               else\n                if (x<=p->data && x>=p->prev->data)\n                {\n                    q->data=x;\n                    q->next=p;\n                    q->prev=p->prev;\n                    p->prev->next=q;\n                    p->prev=q;\n                    q=malloc(sizeof(*q));\n                    if (!q) return 1;\n                    break;\n                }\n                else\n                if ((p->next==0)&&x>=p->data)\n                {\n                    q->data=x;\n                    q->next=0;\n                    q->prev=p;\n                    p->next=q;\n                    q=malloc(sizeof(*q));\n                    if (!q) return 1;\n                    break;\n                }\n\n\n            p=p->next;\n        }\n    }\n    p=head;\n    while (p)\n    {\n        fprintf (file2, \"%d \", p->data);\n        p = head->next;\n        free(head);\n        head = p;\n    }\n    free(q);\n    fprintf(file2, \"\\n\");\n    fclose(file);\n    fclose(file2);\n    return 0;\n}\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1085,'#include <stdio.h>\n#include <stdlib.h>\n        \n    void sift(int *a, int i, int n) \n    {\n        int max = i, t;\n        \n        while (2*i+1 < n) \n        {\n            if (2*i+1 < n && a[2*i+1] > a[max]) \n               max = 2*i+1;\n            if (2*i+2 < n && a[2*i+2] > a[max]) \n               max = 2*i+2;\n            if (max == i) return;\n            t=a[i];\n            a[i]=a[max];\n            a[max]=t;\n            i = max;\n        }\n        \n        return;\n    }\n    \nint main() \n{\n    int t, n=0, i;\n    int a[100500];\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    while(scanf(\"%d\", &t)==1)\n    {\n                      a[n]=t;\n                      n++;\n    }\n    for (i = (n/2-1); i >= 0; i--)\n        sift(a, i, n);\n    for (i = n-1; i != 0; i--) \n    {\n        t=a[i];\n        a[i]=a[0];\n        a[0]=t;\n        sift(a, 0, i);\n    }\n    for (i = 0; i < n; i++)\n        printf(\"%d \", a[i]);\n    return 0;\n}	\n    		\n    \n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (1086,'#include <stdio.h>\n#define inf 100500\n\nint main()\n\n{\n    \n    \n    int a[100][100];\n    int d[100], used[100] = {0}, way[100] = {0};\n    int i, j, n, x, y, z, start, min = inf, curr;\n    freopen(\"input.txt\", \"r\", stdin);\n    freopen(\"output.txt\", \"w\", stdout);\n    \n    \n    \n        scanf(\"%d\", &n);\n        scanf(\"%d\", &start);\n        for (i = 1; i <= n; i++)\n            for (j = 1; j <= n; j++)\n                a[i][j] = inf;\n        \n        \n        while (scanf(\"%d %d %d\\n\", &x, &y, &z)==3)\n        {\n              a[x][y] = a[y][x] = z;\n        }\n        \n        \n        d[start] = 0;\n        used[start] = 1;\n        curr = start;\n        for (i = 1; i <= n; i++)\n             d[i] = a[i][start];\n        d[start] = 0;\n        \n        while (1) \n        {\n            min = inf;\n            for (i = 1; i <= n; i++)\n            if (!used[i] && d[i] < min) {\n                min = d[i];\n                curr = i;\n            }\n            if (min == inf) break;\n            used[curr] = 1;\n            for (i = 1; i <= n; i++)\n                if (d[i] > d[curr] + a[curr][i]) \n                {\n                    d[i] = d[curr] + a[curr][i];\n                    way[i] = curr;\n                }\n        }\n        \n        for (i = 1; i <= n; i++)\n            if (i != start && d[i] == inf) printf(\"there is no way to %d\\n\", i);\n        else if (i != start)\n        {\n            printf(\"distance to %d = %d\\tway: \", i, d[i]);\n            j = i;\n            printf (\"%d %c \", j, 27);\n            while (way[j] != 0) {\n                printf (\"%d %c \", way[j], 27);\n                j = way[j];\n            }\n            printf (\"%d\\n\", start);\n        }\n        \n    return 0;\n}\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (1087,'#include <stdio.h>\n#include <stdlib.h>\n\nint A[100][100];\nint B[100];\n\nvoid dfs(int line)\n{\n	int i;\n	for(i=0; i<100; i++)\n	{\n		if(A[line][i] == 1) \n		{\n			if(!B[line])\n			{	B[line] = 1;\n				printf(\"%d \",line+1);\n			}\n			if(B[i]) continue;\n			else dfs(i); \n		}\n	}\n}\n\nint main(void)\n{\n	FILE *f = fopen(\"graph.txt\",\"r\");\n	int i,j;\n\n	for(i=0; i<100; i++)\n	{\n		for(j=0; j<100; j++)\n		{\n			A[i][j] = 0;\n		}\n		B[i] = 0;\n	}\n	while(fscanf(f,\"%d%d\",&i,&j) == 2)\n	{\n		if(i == j)\n		{\n			printf(\"BAD INPUT\");\n			return;\n		}\n		A[i-1][j-1] = 1;\n		A[j-1][i-1] = 1;\n	}\n//	for(i=0;i<100;i++)\n//	{\n//		for(j=0;j<100;j++) printf(\"%d\",A[i][j]);\n//		putchar(\'\\n\');\n//	}\n	dfs(0);\n	putchar(\'\\n\');\n	fclose(f);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1088,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct item{\n	struct item *adj[100];\n	int color;\n	int depth;\n	struct item *prev;\n};\n\nstruct item *Queue[100] = {0};  /* ????? ?????? ??????? */\nvoid Enqueue(struct item *n)\n{\n	int i;\n	for(i=0; Queue[i]; i++);\n	Queue[i] = n;\n}\nstruct item *Dequeue(void)\n{\n	struct item *res;	\n	int i;\n	res = Queue[0];\n	for(i=0; i<99; i++)\n		Queue[i] = Queue[i+1];\n	Queue[99] = 0;\n	return(res);	\n}\n\nint main(void)\n{\n	FILE *f = fopen(\"graph.txt\",\"r\");\n	struct item *A[100]; //XpaHuM KaK CnucoK\n	struct item *B = malloc(sizeof(struct item));\n	int i,j,k = 0,h;\n\n	for(i=0; i<100; i++)\n	{       A[i] = malloc(sizeof(struct item));\n		A[i]->color = 0;\n		A[i]->depth = 1000;\n		A[i]->prev = NULL;\n		for(j=0; j<100; j++)\n			A[i]->adj[j] = NULL;\n	}\n	A[0]->color = 1;\n	A[0]->depth = 0;\n\n	while(fscanf(f,\"%d%d\",&i,&j) == 2)\n        {\n        	if(i == j)\n		{\n                	printf(\"BAD INPUT\");\n	                return 0;\n                }\n                for(k=0; A[i-1]->adj[k]; k++);\n		A[i-1]->adj[k] = A[j-1];\n		A[j-1]->adj[k] = A[i-1];\n        }\n	fclose(f);\n//---------------------------------------------//\n	Enqueue(A[0]); //???????? ???????\n	for(; Queue[0]; )\n	{\n//		printf(\"Queue == %p\\n\",Queue[0]);\n		B = Dequeue();\n		for(j=0;j<100;j++)\n		{\n		//	printf(\"j == %d\\n\",j);\n			for(k=0;k<10;k++)\n			if(A[j] == B->adj[k] && A[j]->color == 0)\n			{\n//				printf(\"POST\\n\");\n				A[j]->color = 1;\n				A[j]->depth = B->depth + 1;\n				A[j]->prev = B;\n				Enqueue(A[j]);\n			}\n		}\n		B->color = 2;\n	}\n//	printf(\"check\\n\");\n//---------------------------------------------//\n	for(i=0; i<100; i++)\n		for(j=0; j<100;j++)\n			if(A[j]->depth == i)\n				printf(\"%d \",j+1);\n	for(i=0; i<100; i++)\n		free(A[i]);\n//	free(B);	\n	putchar(\'\\n\');\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1089,'#include <stdio.h>\n#define N 100\n\nint main()\n{\n	char c,last;\n	char prelast;\n	int q=1;									 \n	freopen(\"input13.txt\",\"r\",stdin);							   \n	freopen(\"public_html/output13.html\",\"w\",stdout);								    \n	printf(\"<html>\\n\");										    \n	printf(\"<head>\\n\");										     \n	printf(\"<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=koi8-r\\\"/>\\n\");\n	printf(\"</head><body>\\n\");\n	printf(\"<table border=\\\"1\\\">\\n\");										     \n	while((c=getchar())!=EOF)\n	{\n		if(q==1)\n		{\n			printf(\"<tr><td>\");\n			if(c==\',\')\n			{\n				printf(\"</td><td>\");\n				q=2;\n			}\n			if(c==\'\"\')\n			{\n				q=3;\n			}\n			if(c==\'\\n\')\n			{\n				printf(\"</td></tr>\\n\");\n				q=1;\n			}\n			if(c!=\',\' && c!=\'\"\' && c!=\'\\n\')\n			{\n				putchar(c);\n				q=2;\n			}\n			continue;\n		}\n		if(q==2)\n		{\n			if(c==\',\')\n			{\n				printf(\"</td><td>\");\n				q=2;\n			}\n			if(c==\'\"\')\n			{\n				q=3;\n			}\n			if(c==\'\\n\')\n			{\n				printf(\"</td></tr>\\n\");\n				q=1;\n			}\n			if(c!=\',\' && c!=\'\"\' && c!=\'\\n\')\n			{\n				putchar(c);\n			}\n			continue;\n		}\n		if(q==3)\n		{\n			if(c==\'\"\')\n			{\n				q=4;	\n			}\n			if(c==\'\\n\')\n			{\n				printf(\"</br>\");\n			}\n			if(c!=\'\"\' && c!=\'\\n\')\n			{\n				putchar(c);\n			}\n			continue;\n		}\n		if(q==4)\n		{\n			if(c==\'\"\')\n			{\n				putchar(c);\n				q=3;\n			}\n			if(c==\',\')\n			{\n				printf(\"</td><td>\");\n				q=2;\n			}\n			if(c==\'\\n\')\n			{\n				printf(\"</td></tr>\");\n				q=1;\n			}\n			if(c!=\'\"\' && c!=\',\')\n			{\n				putchar(c);\n				q=2;\n			}\n			continue;\n		}\n	}\n	printf(\"</table>\\n\");\n	printf(\"</body>\\n\");\n	printf(\"</html>\\n\");\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
INSERT INTO `bias` VALUES (1090,'#include <stdio.h>\r\n#include <ctype.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#define NMAX 100\r\n\r\nint main ()\r\n{\r\n    int i=0;\r\n    char c, s[1000]= {0};\r\n    int state=0, j=0;\r\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.html\", \"w\");\r\n    state=1;\r\n    fprintf(file2, \"<html><head><meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html; charset=windows-1251\\\"></head><body><h1>Table</h1>\\n\");\r\n    fprintf(file2, \"<table border=\\\"1\\\">\\n<tr><td>\");\r\n\r\n    while (fscanf(file, \"%c\", &c) == 1)\r\n    {\r\n        j++;\r\n        s[j]=c;\r\n    }\r\n    if (s[1]==\'\"\') state=2;\r\n    while (i<=j)\r\n    {\r\n        i++;\r\n        if (state==0&&s[i]!=\',\'&&s[i]!=\'\"\')\r\n        {\r\n            state=1;\r\n            fprintf(file2, \"<td>%c\", s[i]);\r\n        }\r\n        else if (state==1&&s[i]==\',\')\r\n        {\r\n            state=0;\r\n            fprintf(file2, \"</td> \");\r\n        }\r\n        else if (state==0&&s[i]==\',\'&&s[i-1]==\',\')\r\n        {\r\n            fprintf(file2, \"<td></td> \");\r\n        }\r\n        else if (state==1&&s[i]==\'\\n\')\r\n        {\r\n            fprintf(file2, \"</td></tr>\\n<tr><td>\");\r\n        }\r\n        else if (state==0&&s[i]==\'\"\')\r\n        {\r\n            state=2, fprintf (file2, \"<td>\");\r\n        }\r\n        else if (state==2&&s[i]==\'\\n\')\r\n        {\r\n            fprintf(file2, \"<br/>\");\r\n        }\r\n        else if (state==2&&s[i]==\'\"\'&&s[i+1]==\'\"\')\r\n        {\r\n            fprintf(file2, \"\\\"\");\r\n            s[i+1]=\'\\0\';\r\n        }\r\n        else if (state==2&&s[i]==\'\"\'&&(s[i+1]==\',\'||s[i+1]==\'\\n\'||s[i+1]==\'\\0\'||s[i+1]==EOF))\r\n        {\r\n            state=0;\r\n            fprintf (file2, \"</td> \");\r\n            if (s[i+1]==\'\\0\'||s[i+1]==EOF){ fprintf (file2, \"</td> \"); break;}\r\n        }\r\n        else if (state) fprintf (file2, \"%c\", s[i]);\r\n\r\n    }\r\n\r\n    fprintf(file2, \"</td></tr>\\n</table></body></html>\");\r\n    fclose(file);\r\n    fclose (file2);\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1091,'#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nstruct item\n{\n    int count;\n    char word[11];\n    struct item *next;\n};\n//int check(char *a, char *b)\n//{\n//    while(*a&&*b)\n//    {\n//        if (*a!=*b) return 0;\n//        a++;\n//        b++;\n//    }\n//    while (*a) a++;\n//    while (*b) b++;\n//    if (a==b)    return 1; else return 0;\n//}\n//void copy(char *input, char *output)\n//{\n//    int i=0;\n//    while(*input)\n//    {\n//        output[i]=input[i];\n//        i++;\n//    }\n//\n//}\n\nint main ()\n{\n\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\n    int flag=0, i=0;\n    char *s;\n    struct item *head=NULL, *tek=malloc(sizeof(*tek));\n    if(!tek) return 1 ;\n    struct item *q = malloc(sizeof(*q));\n    if (!q) return 1;\n    struct item *p;\n    fscanf(file, \"%s\", q->word);\n    head=q;\n    q->count=1;\n    q->next=0;\n\n    while (1==fscanf(file, \"%s\", tek->word))\n    {\n        q=head;\n        flag=0;\n        i=0;\n        while (q)\n        {\n            i++;\n           // printf (\"%d.q->word=%s tek->word=%s, check=%d\\n\",i, q->word, tek->word, strcmp(q->word, tek->word));\n            if (!strcmp(q->word, tek->word)) {q->count++; flag=1; break;}\n            if (q->next) q=q->next; else break;\n        }\n        if (!flag&&strcmp(head->word, tek->word))\n        {\n            p=malloc(sizeof(*p));\n            if (!p) return 1;\n            q->next=p;\n\n            //printf(\"poka ne skopirovali %s %s\\n\", tek->word, p->word );\n            strcpy( p->word, tek->word);\n          //  printf(\"skopirovali %s %s\", tek->word, p->word );\n            p->next=0;\n            p->count=1;\n            q=q->next;\n\n        }\n    }\n\n\n    q=head;\n    while (q)\n    {\n        fprintf (file2, \"%s = %d\\n\", q->word, q->count);\n        q=q->next;\n\n         q = head->next;\n        free(head);\n        head = q;\n    }\n    free(tek);\n    fclose (file);\n    fclose (file2);\n    return 0;\n}\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1092,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#define N 10\r\nint matrix[N][N];\r\nint visited[N];\r\nvoid dfs(int curr)\r\n{\r\n    int i;\r\n    visited[curr]=1;\r\n    for (i=1;i<=N;i++)\r\n    if (!visited[i]&&matrix[curr][i]) dfs(i);\r\n}\r\nint main()\r\n{\r\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\r\n    int i=0, j=0;\r\n\r\n    for (i=1;i<=N;i++)\r\n    for (j=1;j<=N;j++)\r\n    matrix[i][j]=0;\r\n\r\nwhile (2==fscanf(file, \"%d%d\", &i, &j))\r\n{\r\n    matrix[i][j]=1;\r\n}\r\ndfs(1);\r\nfor (i=2;i<=N; i++)\r\nif (visited[i]) fprintf (file2, \"%d \", i);\r\n    fclose(file);\r\n    fclose(file2);\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1093,'#include<stdio.h>\r\n#include<stdlib.h>\r\n#define N 10\r\nint matrix[N][N];\r\nint queue[N];\r\nint r = 0, w = 0;\r\nint visited[N];\r\n\r\nvoid enqueue(int a)\r\n{\r\n    queue[w++] = a;\r\n}\r\n\r\nint dequeue(void)\r\n{\r\n    return (queue[r++]);\r\n}\r\n\r\nint empty(void)\r\n{\r\n    return (r == w);\r\n}\r\n\r\n\r\nvoid bfs (int start)\r\n{\r\n    int curr;\r\n        visited[start]=1;\r\n\r\n        enqueue (start);int i;\r\n    while (!empty())\r\n    {\r\n\r\n        curr=dequeue();\r\n        for (i=1;i<=N;i++)\r\n        if (!visited[i]&&matrix[curr][i])\r\n        {\r\n            visited[i]=1;\r\n            enqueue(i);\r\n        }\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\r\n    int i=0, j=0;\r\n\r\n    for (i=1;i<=N;i++)\r\n    for (j=1;j<=N;j++)\r\n    matrix[i][j]=0;\r\n\r\n    while (2==fscanf(file, \"%d%d\", &i, &j))\r\n    {\r\n        matrix[i][j]=1;\r\n    }\r\n    bfs(1);\r\n    for (i=1;i<=N; i++)\r\n    if (visited[i]) fprintf (file2, \"%d \", i);\r\n    fclose(file);\r\n    fclose(file2);\r\n    return 0;\r\n    }\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1094,'#define c_latin ((c >= \'A\' && c <= \'Z\') || (c >= \'a\' && c <= \'z\'))\n#define OVER 9000\n#define N 4 \n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nstruct list\n{\n	int count;\n	char word[OVER];\n	struct list *next;\n};\n\nvoid push(struct list **head, struct list *p, char *s, int i)\n{\n	int j;\n	for(j=0; j<i; j++)\n		p -> word[j] = s[j];\n	p -> count = 1;\n	p -> next = *head;\n	*head = p;\n}\n\nunsigned int hash(char **s)\n{\n	unsigned int i, res = 0;\n	while(*s)\n	{\n		res += **s;\n		s++;\n	}\n	for(i=0; s[i]; i++)\n		s[i] = \'\\0\';\n	return res%N;\n}\n\nint main(void)\n{\n	FILE *fin = fopen(\"input.txt\",\"r\");\n	struct list *head[N]; \n	struct list *p, *q;\n	char c;\n	char *s = malloc(OVER);\n	int state =0, i, j, h;\n\n	for(i=0; i<N; i++)\n		head[i] = NULL;\n	i=0;\n	while (EOF != (c = fgetc(fin)))\n	{\n		if c_latin\n		{\n			state = 1;\n			s[i] = c;\n			i++;\n		}\n		if (state == 1 && !c_latin)\n		{\n			h = hash(&s);\n			p = malloc(sizeof(struct list));\n			push(&head[h], p, s, i);\n			printf(\"word %s added to list #%d\\n\", s, h);\n			state = 0;\n			i = 0;\n		}\n	}\n	printf(\"checkpoint 1\\n\");\n//----------------------------------\n	for(j = 0; j < N; j++)\n	{\n//	printf(\"j == %d\\n\",j);\n		for(p = head[j];p && p->next; p= p->next)\n		{\n//			printf(\"?? \'p\'\\n\");\n			for(q = p->next; q; q= q->next)\n			{\n//				printf(\"?? \'q\'\\n\");\n//				printf(\"p->word: %s, q->word: %s\\n\", p->word, q->word);\n				if(!strcmp(q->word, p->word))\n				{\n//					printf(\"????? 2 ?????????? ?????\\n\");\n					p->count++;\n					if(state == 0)\n					{\n						state = 1;\n					}\n					for(i=0; q->word[i]; i++)\n					{\n						q->word[i] = \'\\0\';\n	\n					}\n				}\n			}\n		}\n	}\n	printf(\"checkpoint 2\\n\");\n//----------------------------------*/\n	for(j = 0; j < N; j++)	\n	for(p = head[j]; p; p= q)\n	{\n		if(p->word[0]) \n		{\n			printf(\"hash(%d) %s == %d\\n\", j, p->word, p->count);\n		}\n		q = p->next;\n		free(p);\n	}\n	fclose(fin);\n	free(s);\n	return(0);\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1095,'#include <stdio.h>\n#include <stdlib.h>\n#define N 100\n#define INF 9000\n\nvoid Rus_Reversal(int Path[N], int final)\n{\n	int j;\n	for(j=N-1; j>=0; j--)\n		if(Path[j])\n			printf(\" %d\", Path[j]);	\n	printf(\" %d\\n\", final);\n}\n\nint main(void)\n{\n	FILE *f = fopen(\"w_graph.txt\",\"r\");\n	int start, i, j, k;\n	int A[N][N];\n	int D[N];\n	int Used[N] = {0};\n	int Way[N];\n\n	for(i=0; i<N; i++)\n	for(j=0; j<N; j++)\n	{\n		A[i][j] = INF;\n		if(i == j)\n			A[i][j] = 0;\n	}\n\n	fscanf(f,\"%d\",&start);\n	for(;;)\n	{\n		if(fscanf(f,\"%d%d%d\",&i,&j,&k) == -1) break;\n		A[i-1][j-1] = k;\n		A[j-1][i-1] = A[i-1][j-1];\n	}\n	fclose(f);\n//<M>\n	putchar(\'\\n\');\n	for(i = 0; i<10; i++)\n	{\n		for(j = 0; j<10; j++)\n		{	\n			(A[i][j] == INF) ?\n			printf(\"inf \") :\n			printf(\"%3d \", A[i][j]);\n		}\n		putchar(\'\\n\');\n	}\n	putchar(\'\\n\');\n//</M>\n//<prev>\n	for(i = 0; i<N; i++)\n		Way[i] = 0;\n	for(i=0; i<N; i++)\n		D[i] = INF;\n//</prev>\n{//<DIJ>\n	int min, curr = start-1;\n\n	D[curr] = 0;\n	for(;;)\n	{	\n		int tobreak = 1;\n		min = INF;\n		for(i=0; i<N; i++)\n			if(Used[i] == 0 && D[i] < min)\n			{\n				min = D[i];\n				curr = i;\n				tobreak = 0;\n			}\n		\n		if(tobreak) break;\n		Used[curr] = 1;\n		for(i=0; i<N; i++)\n			if(Used[i] == 0 && D[i] > D[curr] + A[curr][i])\n			{\n				D[i] = D[curr] + A[curr][i];	\n				Way[i] = curr+1;\n			}\n	}\n}//</DIJ>\n	for(i = 0; i<N; i++)\n	{\n		int Length = D[i];\n		int Path[N] = {0};\n		if(Length == INF)\n			continue;\n\n		for(j=0, k=Way[i]; k; j++, k=Way[k-1])\n			Path[j] = k;\n\n		printf(\"From %d To %d : \\n\", start, i+1);		\n		printf(\"____ length = %d\\n\", Length);\n		printf(\"____ path:\");\n		Rus_Reversal(Path, i+1);\n	}\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1096,'#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <math.h>\n\nint digitize(int a)\n{\n	if(isdigit(a))\n	{\n		return a - \'0\';\n	}\n	else\n	{\n		return a - \'A\' + 10;\n	}\n}\n\nint main()\n{\n	int Z[100], R[100];\n	int b, c, i, nil, part, powz = 0, powr = 0, sgn = 1;\n	double result = 0;\n	\n	memset(Z, 0, 100);\n	memset(R, 0, 100);\n\n	scanf(\"%d \", &b);\n\n	part = 1;\n	nil = 0;\n\n	i = 0;\n\n	while ((c = getchar()) != EOF)\n	{\n		if (c == \'\\n\') break;\n		if (c == \'-\' && sgn == 1)\n		{\n			sgn = -1;\n			continue;\n		}\n		if (c == \'.\') \n		{\n			Z[i] = 0;\n			part = 2;\n			i = 0;\n			continue;\n		}\n		if (isalpha(c) || isdigit(c))\n		{\n			if (digitize(c) >= b) \n			{\n				printf(\"Impossible number in this counting system!\\n\");\n				return 0;\n			}\n			if (part == 1) \n			{\n				if (c != \'0\') nil = 1;\n				if (c == \'0\' && nil == 0)\n				{\n					continue;\n				}\n				Z[i] = c;\n				powz++;\n			} else if (part == 2)\n			{\n				R[i] = c;\n				powr++;\n			}\n		} else \n		{\n			printf(\"Wrong number!\\n\");\n			return 0;\n		}\n		i++;\n	} //there we have Z[] with integer part of input, and, possibly, R[] with real part of input\n	\n	printf(\"\\n\");\n\n	for (i = 0; i < powz; i++)\n	{\n		c = digitize(Z[i]);\n		result += c * pow(b, powz-i-1);\n	}\n\n	for (i = 0; i < powr; i++)\n	{\n		c = digitize(R[i]);\n		result += c * pow(b, (-1)*(i+1));\n	}\n	printf(\"%lf\", result*sgn);\n	printf(\"\\n\");\n\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1097,'#include <stdio.h>\n#include <string.h>\n\n#define MAXN 101\n#define inf 1000000\n\nint check(int *visited, int vert)\n{\n	int i, key = 1;\n\n	//printf(\"checking\\n\");\n\n	for (i = 1; i <= vert; i++)\n	{\n		//printf(\"visited[%d]: %d\\n\", i, visited[i]);\n		if (!visited[i])\n		{\n			key = 0;\n			break;\n		}\n	}\n	return key;\n}\n\nvoid dijkstra(int (*M)[MAXN], int *D, int *visited, int curr, int N, int vert)\n{\n	int i;\n\n	visited[curr] = 1;\n	for (i = 1; i <= vert; i++)\n	{\n		if(D[curr] + M[curr][i] < D[i] && !visited[i])\n		{\n			D[i] = D[curr] + M[curr][i];\n		}\n	}\n	return;\n}\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n\n	int M[MAXN][MAXN], min, length;\n	int N, i, j, x, y, begin, curr, mini;\n	int visited[MAXN];\n	int D[MAXN];\n	int vert = 0;\n\n	memset(visited, 0, MAXN);\n	\n	scanf(\"%d\", &N);\n	scanf(\"%d\", &begin);\n\n	printf(\"Number of edges: %d\\n\", N);\n	\n	for (i = 0; i < MAXN; i++) //initializing of edges list\n        {\n                for (j = 0; j < MAXN; j++)\n                {\n			\n			M[i][j] = inf;\n                }\n        }\n\n	for (i = 1; i < MAXN; i++) //initializing of lengths array\n	{\n		D[i] = inf;\n	}\n\n	for (i = 1; i <= N; i++)\n	{\n		scanf(\"%d %d %d\", &x, &y, &length);\n		M[x][y] = length;\n		M[y][x] = length;\n	}\n\n	D[begin] = 0;\n\n	for (i = 1; i < MAXN; i++)\n	{\n		for (j = 1; j < MAXN; j++)\n		{\n			if (M[i][j] < inf)\n			{\n				vert++;\n				break;\n			}\n		}\n	}\n\n	curr = begin;\n\n	printf(\"Vertices amount: %d\\n\", vert);\n	printf(\"Start from vertice %d\\n\", begin);\n	\n	while(!check(visited, vert))\n	{\n		dijkstra(M, D, visited, curr, N, vert);\n\n		min = 2*inf;\n\n		for (i = 1; i <= vert; i++)\n        	{\n                	if (D[i] < min && !visited[i]) \n			{\n				min = D[i];\n				mini = i; \n			}\n        	}\n		curr = mini;\n	}\n	\n	for (i = 1; i <= vert; i++) printf(\"%d: %d\\n\", i, D[i]);\n\n	printf(\"\\n\");\n\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1098,'#include <stdio.h>\nint main (int argc,char *argv[])\n\n{ char c;\n	FILE *f=fopen(argv[1], \"r\");\n	FILE *g=fopen(argv[2], \"w\");\n	\n	while(EOF != (c=fgetc(f)))\n\n		fputc(c,g);\n\n	fclose(g);\n	fclose(f);\n	return(0);\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (1099,'#include <stdio.h>\nint main (int argc,char *argv[])\n\n{ char c;\n	FILE *f=fopen(argv[1], \"r\");\n	FILE *g=fopen(argv[2], \"w\");\n	\n	while(EOF != (c=fgetc(f)))\n\n		fputc(c,g);\n\n	fclose(g);\n	fclose(f);\n	return(0);\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (1100,'#include <stdio.h>\nint main(int argc, const char *argv[])\n{\nint charCount, wordCount, stringCount, c, pos;\npos = 0;\ncharCount = wordCount = stringCount = 0;\n\n	FILE *f=fopen(argv[1], \"r\" );\n\n	while(EOF != (c = fgetc(f)))\n\n		{\n		charCount++;\n		if (c == \'\\n\')\n		stringCount++;\n		if (c == \' \' || c == \'\\n\')\n			pos = 0;\n		else if (pos == 0)\n		{\n		pos = 1;\n		wordCount++;\n		}\n\n	\n		}\n	printf(\"%d\\n\", charCount);\n	printf(\"%d\\n\", wordCount);\n	printf(\"%d\\n\", stringCount);	\n\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (1101,'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAXLENGTH 1000\n\nint toDec(char c) {\n	if (c >= \'A\') {\n		return (c - \'A\' + 10);\n	}	\n	return (c - \'0\');\n}\n\nint main() {\n\n	int b, len1 = 0, len2 = 0, flag = 0, i;\n	double dec = 0;\n	char c,*string1 = NULL, *string2 = NULL;\n\n	scanf(\"%d\",&b);\n\n	while((scanf(\"%c\",&c)) == 1) {\n		if (c == \'.\') {\n			flag = 1;\n			continue;\n		}\n		if (c == \'\\n\') {\n			continue;\n		}\n		if (flag == 0) {\n			string1 = realloc(string1,len1+1);\n			string1[len1] = c;\n			len1++;\n		}\n		else {\n			string2 = realloc(string2,len2+1);\n			string2[len2] = c;\n			len2++;\n		}\n	}\n\n	for(i = 0; i < len1; i++) {\n		dec += toDec(string1[i])*pow(b,len1-i-1);\n	}\n	\n	for(i = 0; i < len2; i++) {\n		dec += toDec(string2[i])*pow(b,-1-i);\n	}\n	\n	printf(\"%f\\n\",dec);\n\n	return 0;\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (1102,'#include <stdio.h>\n\nint main(int argc, const char *argv[]) {\n\n	int N, temp, i, j;\n	\n	FILE *f1 = fopen(argv[1], \"r\");\n	if(f1 == NULL) {\n		perror(argv[1]);\n		return 1;\n	}\n	FILE *f2 = fopen(argv[2], \"w\");\n	if(f2 == NULL) {\n		perror(argv[2]);\n		return 1;\n	}\n	fscanf(f1, \"%d\", &N);\n	\n	int A[N];\n	\n	for (i = 0; i < N; i++) {\n		fscanf(f1, \"%d\", &A[i]);\n	}	\n\n	for (i = 0; i < N; i++) {\n		for (j = i + 1; j < N; j++) {\n			if (A[j] < A[i]) {\n				temp = A[i];\n				A[i] = A[j];\n				A[j] = temp;\n			}\n		}\n	}\n\n	for(i = 0; i<N; i++)\n	{\n		fprintf(f2, \"%d \", A[i]);\n	}\n	fclose(f1);\n	fclose(f2);\n	return 0;\n}\n','ÐšÑ€Ð¸ÑÑ‚Ð¸Ð½Ð°','Kristina','f');
INSERT INTO `bias` VALUES (1103,'#include <stdio.h>\nint main()\n{\nint i,g;\nchar s[256]=\"\";\nchar a[20];\nchar b[20];\nchar c[64];\nchar *t;\nFILE *f;\nprintf(\"vvedite login :\");\nscanf(\"%s\",b);\nf=fopen(\"/etc/passwd\",\"r\");\nwhile(t)\n{\nt=fgets(s,sizeof(s),f);\nfor(i=0;s[i]!=\':\';i++)\na[i]=s[i];\na[i]=0;\nif (!strcmp(a,b))\n{\nfor(i++;s[i]!=\':\';i++);\nfor(i++;s[i]!=\':\';i++);\nfor(i++;s[i]!=\':\';i++);\nfor(i++,g=0;s[i]!=\':\';i++,g++)\nc[g]=s[i];\nc[g]=0;\n\nprintf(\"%s\\n\",c);\n}\n}\n\n\nfclose (f);\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (1104,'\n#include <stdio.h>\nint main()\n{\n	int i=0;\n	int a=0;\n	char g=0;\n	FILE *f, *f2;\n	f=fopen(\"input.csv\",\"r\");\n	f2=fopen(\"input.html\", \"w\");\n	fprintf(f2,\"<html>\\n <body>\\n <table border=1>\\n <tr>\\n <td>\\n\");\n	while(i!=EOF)\n	{\n		i=fgetc(f);\n		if (g==0) \n		{\n			if( i==EOF) break;\n			if( i==\',\') fprintf(f2,\"</td> <td>\");\n			else if( i==\'\\n\') fprintf(f2,\"</td> </tr> <tr> <td> \");\n		   	else	if(i==\'\"\')g=1;\n			else  fputc( i,f2);\n		} \n		else if (g==1)\n		{\n			if(i==\'\"\')\n			{\n				a=fgetc(f);\n				if (a==\'\"\')\n					fputc (a, f2);\n				else\n				{\n					ungetc(a, f);\n					g=0;\n				}\n			}\n			else if(i==\'\\n\') fprintf(f2,\"<br/>\");\n			else fputc(i,f2);\n		}\n\n	}	\n	fprintf(f2,\"</td> </tr> </table>\\n </body>\\n </html>\\n\"); \n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (1105,'#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\nvoid ps(int arr[], int length) \n{\n      int i, j, tmp;\n      for (i = 1; i < length; i++) {\n            j = i;\n            while (j > 0 && arr[j - 1] > arr[j]) {\n                  tmp = arr[j];\n                  arr[j] = arr[j - 1];\n                  arr[j - 1] = tmp;\n                  j--;\n            }\n      }\n}\nint main() \n{\n	int *arr=NULL, sz, i;\n	FILE *f;\n	f=fopen(\"input.txt\", \"r\");\n	fscanf(f, \"%d\", &sz);\n	arr=(int *) malloc(sizeof(int)*(sz));\n	\n		for( i=0;i<sz;i++)\n		 fscanf(f,\"%d\",&arr[i]); \n	ps(arr,sz);\n	for(i=0;i<sz;i++)\n	printf(\"%d\\n\",arr[i]);\nreturn 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (1106,'#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n#include <math.h>\n\n\nint main()\n{\n	struct real\n	{\n		double rest;\n		int digit;\n	} REAL[100];\n	int b, c, sign = 1, i, j, INT[100], maxi = 0, br = 0, maxir = 0;\n	long int intpart;\n	double in, realpart = 0, temp;\n	\n\n	memset(INT, 0, 100);\n	\n	scanf(\"%d %lf\", &b, &in);\n\n	if (b < 2 || b > 16)\n	{\n		printf(\"Wrong notation base!\\n\");\n		return 0;\n	}\n\n	if (in < 0)\n	{\n		in = -in;\n		sign = -1;\n	}\n\n	intpart = (int)(in - ((int)in % 1));\n	realpart = in - (double)intpart;\n	\n	printf (\"%d*(%d + %lf)\\n\", sign, intpart, realpart);\n\n	i = 1;\n	c = intpart % b;\n	if(c >= 0 && c <= 9)\n	{\n		c += \'0\';\n	} else if (c >= 10 && c <= 15)\n	{\n		c += \'A\' - 10;\n	}\n	INT[0] = c;\n	while(intpart/b > 0)\n	{\n		intpart /= b;\n		c = intpart % b;\n	\n		if (c >= 0 && c <= 9)\n		{\n			c += \'0\';\n		} else if (c >= 10 && c <= 15)\n		{\n			c += \'A\' - 10;\n		}\n		INT[i] = c;\n		i++;\n	}\n	maxi = i;\n\n	for (i = 0; i < 11; i++)\n	{\n		realpart *= b;\n		REAL[i].digit = (int)(realpart - ((int)realpart % 1));\n		temp = (double)((double)realpart - (double)REAL[i].digit);\n		realpart -= (double)REAL[i].digit;\n		REAL[i].rest = temp;\n		for (j = 0; j < 100; j++)\n		{\n			if(REAL[i].digit == REAL[j].digit && REAL[i].rest == REAL[j].rest && i != j) \n			{\n				br = 1;\n				break;\n			}\n		}\n		maxir = i;\n		if (REAL[i].rest < 0.0000001) break;\n		if (br) break;\n	}\n\n	for (i = maxi; i >= 0; i--)\n	{\n		printf(\"%c\", INT[i]);\n	}\n	printf(\".\");\n	for (i = 0; i <= maxir; i++)\n	{\n		c = REAL[i].digit;\n		if (c >= 0 && c <= 9)\n                {\n                        c += \'0\';\n                } else if (c >= 10 && c <= 15)\n                {\n                        c += \'A\' - 10;\n                }\n		REAL[i].digit = c;\n\n		printf(\"%c\", REAL[i].digit);\n	}\n	printf(\"\\n\");\n	\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1107,'#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *readword()\n{	\n	char *word = malloc(11);\n	int i, c;\n	for (i = 0; i <= 10; i++)\n	{\n		c = getchar();\n		if (c == EOF) \n		{\n			free(word);\n			return NULL;\n		}\n		if (!isalpha(c)) \n		{\n			word[i] = 0;\n			return word;\n		}\n		word[i] = c;\n	}\n\n	word[11] = 0;\n	return word;\n}\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	\n	struct item\n	{\n		char *word;\n		int count;\n		struct item *next;\n	} *head = NULL, *p, *curr;\n	char *temp;\n	int key = 0, i = 0;\n\n	p = malloc(sizeof(struct item));\n	p->word = readword();\n	p->next = head;\n	p->count = 1;\n	head = p;\n\n	while(1)\n	{	\n		temp = readword();\n		if (temp == NULL) \n		{\n			break;\n		}\n		curr = head;\n		key = 0;\n		while (1)\n		{\n			if (!strcmp(curr->word, temp))\n			{\n				curr->count++;\n				key = 1;\n				break;\n			}\n			if(curr->next == NULL) break;\n			curr = curr->next;\n		}\n		if (!key)\n		{\n			p = malloc(sizeof(struct item));\n			p->word = strdup(temp);\n			p->next = head;\n			p->count = 1;\n			head = p;\n		}\n		free(temp);\n	}\n\n	curr = head;\n	while(curr->next != NULL)\n	{\n		printf(\"%s %d\\n\", curr->word, curr->count);\n		curr = curr->next;\n	}\n	printf(\"%s %d\\n\", curr->word, curr->count);\n\n	while (head != NULL)\n	{\n		p = head->next;\n		free(head->word);\n		free(head);\n		head = p;\n	}\n			\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1108,'#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 313\n\nunsigned int hash(char *word)\n{\n	unsigned int length = strlen(word), i, result = 0;\n	for (i = 0; i < length; i++)\n	{\n		result = result * 33 + word[i];\n	}\n	return result % MAXN;\n}\n\nchar *readword()\n{	\n	char *word = malloc(100);\n	int i, c;\n	for (i = 0; i <= 10; i++)\n	{\n		c = getchar();\n		if (c == EOF) \n		{\n			free(word);\n			return NULL;\n		}\n		if (!isalpha(c)) \n		{\n			word[i] = 0;\n			return word;\n		}\n		word[i] = c;\n	}\n\n	word[100] = 0;\n	return word;\n}\n\nint main()\n{\n	freopen(\"input.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	\n	struct item\n	{\n		char *word;\n		int count;\n		struct item *next;\n	} *head = NULL, *p, *curr;\n	char *temp;\n	int key = 0, i = 0, currhash;\n	struct item *M[MAXN];\n\n	for (i = 0; i < MAXN; i++)\n	{\n		M[i] = NULL;\n	}\n\n	while(1)\n	{	\n		temp = readword();\n		if (temp == NULL) \n		{\n			free(temp);\n			break;\n		}\n		currhash = hash(temp);\n		fprintf(stderr, \"word %s produced hash %d\\n\", temp, currhash);\n		curr = M[currhash];\n		if (curr == NULL)\n		{\n			p = malloc(sizeof(struct item));\n			p->word = malloc(100);\n			strcpy(p->word, temp);\n			p->count = 1;\n			p->next = NULL;\n			M[currhash] = p;\n			continue;\n		}\n		key = 0;\n		while (1)\n		{\n			if (!strcmp(curr->word, temp))\n			{\n				curr->count++;\n				key = 1;\n				break;\n			}\n			if(curr->next == NULL) break;\n			curr = curr->next;\n		}\n		if (!key)\n		{\n			p = malloc(sizeof(struct item));\n			p->word = malloc(100);\n			strcpy(p->word, temp);\n			p->next = M[currhash];\n			p->count = 1;\n			M[currhash] = p;\n		}\n		free(temp);\n	}\n\n	curr = head;\n	for (i = 1; i < MAXN; i++)\n	{\n		curr = M[i];\n		if (curr == NULL) continue;\n		printf(\"\\nhashcode: %d\\n\", i);\n		while(curr->next != NULL)\n		{\n			printf(\"%d of \'%s\'\\n\", curr->count, curr->word);\n			curr = curr->next;\n		}\n		printf(\"%d of \'%s\'\\n\", curr->count, curr->word);\n	}\n	for (i = 0; i < MAXN; i++)\n	{\n		while (M[i] != NULL)\n		{\n			p = M[i]->next;\n			free(M[i]->word);\n			free(M[i]);\n			M[i] = p;\n		}\n	}\n			\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1109,'#include <stdio.h>\n#include <stdlib.h>\n\n#include \"queue.h\"\n\n#define MAXN 101\n\nint main()\n{\n	freopen(\"input_graph.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	\n	int M[MAXN][MAXN];\n	int N, i, j, x, y;\n\n	queue q = init_queue();\n\n	for (i = 0; i < MAXN; i++)\n	{\n		for (j = 0; j < MAXN; j++)\n		{\n			M[i][j] = 0;\n		}\n	}\n\n	scanf(\"%d\", &N);\n\n	for (i = 0; i < N; i++)\n	{\n		scanf(\"%d%d\", &x, &y);\n		M[x][y] = 1;\n		M[y][x] = 1;\n	}\n\n	enqueue(&q, 1);\n\n	while (!empty(q))\n	{\n		i = dequeue(&q);\n		for (j = 1; j < MAXN; j++)\n		{\n			if (M[i][j])\n			{\n				enqueue(&q, j);\n				M[i][j] = 0;\n				M[j][i] = 0;\n			}\n		}\n		printf(\"%d \", i);\n	}\n\n	printf(\"\\n\");\n\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1110,'#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define MAXN 100\n\nvoid print_array(int *M, int N)\n{\n	int i;\n	for (i = 1; i <= N; i++)\n	printf(\"%d \", M[i]);\n	printf(\"\\n\");\n	return;\n}\n\nvoid swap(int *a, int *b)\n{\n	int temp = *a;\n	*a = *b;\n	*b = temp;\n	return;\n}\n\nint main()\n{\n	freopen(\"input25.txt\", \"r\", stdin);\n	freopen(\"output.txt\", \"w\", stdout);\n	\n	struct dot\n	{\n		double x, y;\n	} D[MAXN];\n\n	int M[MAXN], res[MAXN], N, i, j, inv, a, b;\n	double min = 1000000000, curr = 0;\n\n	scanf(\"%d\", &N);\n\n	for (i = 0; i < MAXN; i++)\n	{\n		M[i] = 0;\n		D[i].x = 0;\n		D[i].y = 0;\n		res[i] = 0;\n	}\n\n	for (i = 1; i <= N; i++)\n	{\n		scanf(\"%lf%lf\", &(D[i].x), &(D[i].y));\n		M[i] = i;\n	}\n\n	for (i = 1; i <= N; i++)\n	{\n		a = M[i];\n		if (a == N)\n		{\n			b = M[1];\n		} else\n		{\n			b = M[i+1];\n		}\n		curr += sqrt((D[a].x - D[b].x)*(D[a].x - D[b].x) + (D[a].y - D[b].y)*(D[a].y - D[b].y));\n	}\n	if (curr < min)\n	{\n		min = curr;\n		for (i = 1; i <= N; i++)\n		res[i] = M[i];\n	}\n\n	while (1)\n	{\n		curr = 0;\n		for (i = N; M[i] < M[i-1]; i--);\n		if (i == 1) break;\n		inv = i-1;\n		for (i = N; M[i] < M[inv]; i--);\n		swap(&(M[i]), &(M[inv]));\n		for (i = N, j = inv+1; i >= j; i--, j++)\n		swap(&(M[i]), &(M[j]));\n\n		for (i = 1; i <= N; i++)\n		{\n			a = M[i];\n			if (i == N)\n			{\n				b = M[1];\n			} else \n			{\n				b = M[i+1];\n			}\n			curr += sqrt((D[a].x - D[b].x)*(D[a].x - D[b].x) + (D[a].y - D[b].y)*(D[a].y - D[b].y));\n		}\n		\n	//	printf(\"min: %lf; curr: %lf\\n\", min, curr);\n	//	print_array(M, N);\n		if (curr < min) \n		{\n			min = curr;\n			for (i = 1; i <= N; i++)\n			res[i] = M[i];\n		}\n\n	}\n	\n	print_array(res, N);	\n	printf(\"%lf\\n\\n\", min);\n\n\n	fclose(stdin);\n	fclose(stdout);\n	return 0;\n\n}\n','ÐÐ»ÐµÐºÑÐµÐ¹','Alexey','m');
INSERT INTO `bias` VALUES (1111,' #include <stdio.h>\nint main(int argc, char *argv[])\n{\nFILE *f=fopen (argc ==2 ? argv[1] : \"f.txt\", \"r\");\nint kol1=0, kol2=0, w=0,a,c=0;\nwhile ((a=fgetc(f))!=EOF)\n{ \nkol1++;\nif (a==\'\\n\')\nkol2++;\nif (a<=\' \' && c>\' \')\nw++;\nc=a;\n}\nfclose(f);\nprintf(\"characters: %d, words: %d, strings: %d\\n\", kol1, w,kol2);\nreturn 0;\n}\n','ÐÐ¸ÐºÐ¸Ñ‚Ð°','Nikita','m');
INSERT INTO `bias` VALUES (1112,'#include <stdio.h>\r\n#include <string.h>\r\n#include <stdlib.h>\r\n#include <ctype.h>\r\n\r\n\r\n\r\nvoid print(int i, int n, int *a, int *p)\r\n{\r\n    int j, k;\r\n    if (i==n)\r\n    {\r\n        for(j=1;j<=n;j++)\r\n        printf(\"%d \", a[p[j]]);\r\n        printf(\"\\n\");\r\n    }\r\n    else\r\n    {\r\n        for(j=i+1; j<=n; j++)\r\n        {\r\n            print(i+1, n, a,  p);\r\n            k=p[i];\r\n            p[i]=p[j];\r\n            p[j]=k;\r\n        }\r\n        print(i+1, n, a ,p);\r\n        k=p[i];\r\n        for (j=i;j<=n-1;j++)\r\n        p[j]=p[j+1];\r\n        p[n]=k;\r\n  //     printf(\"%d\\n\", k);\r\n    }\r\n}\r\nvoid generate(int n, int *a,  int *p)\r\n{\r\n    int j, k;\r\n\r\n    for (j=1; j<=n; j++)\r\n    {\r\n        a[j]=j;\r\n        p[j]=j;\r\n    }\r\nprint(1, n, a, p);\r\n}\r\n\r\n\r\n\r\nint main ()\r\n{\r\n    int N=0;\r\n    int a[10];\r\nint p[10];\r\n    scanf (\"%d\", &N);\r\n\r\n\r\n    generate(N, a, p);\r\n\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1113,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct node\r\n{\r\nint data;\r\nstruct node *left, *right;\r\n};\r\nvoid insert(struct node **proot, int k)\r\n{\r\n     struct node *p;\r\n        if (!*proot)\r\n        {   p=malloc(sizeof(*p));\r\n            p->data=k;\r\n            p->left=NULL;\r\n            p->right=NULL;\r\n            *proot=p;\r\n            return;\r\n        }\r\n    if ((*proot)->data>=k) insert (&((*proot)->left), k);\r\n    else insert(&((*proot)->right), k);\r\n}\r\n\r\n    void print(struct node *p )\r\n{\r\n    //FILE *file2=stdout; //fopen(\"output.txt\", \"w\");\r\n    if (!p) return;\r\n    print(p->left);\r\n    printf(\"%d \", p->data);\r\n    print(p->right);\r\n    //fclose(file2);\r\n}\r\n\r\nint main()\r\n{\r\n    FILE  *file=stdin;//fopen(\"input.txt\", \"rt\");\r\n    int i=0, x=0, N=0, counter=1;\r\n    struct node *root=NULL;\r\n    struct node *q ;\r\n\r\n\r\n    while (1==fscanf(file, \"%d\", &x))\r\n    {\r\n        insert(&root,x);\r\n    }\r\n\r\n    print(root);\r\n\r\n\r\n    fclose(file);\r\n    return 0;\r\n}\r\n\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1114,'#include <stdio.h>\n#include <stdlib.h>\n\nstruct node {\n	int data;\n	struct node *left, *right;\n};\nstruct node *root = NULL;\n\nvoid push(struct node *p, struct node *nroot)\n{\n	if(!root)\n	{\n		root = p;\n//		nroot = p;\n		return;\n	}\n	if(p->data <= nroot->data)\n	{\n		if(!nroot->left)\n		{\n			nroot->left = p;\n//			nroot = root;\n			return;\n		}\n//		nroot = nroot->left;\n		push(p, nroot->left);\n\n	}\n	if(p->data > nroot->data)\n	{\n		if(!nroot->right)\n		{\n			nroot->right = p;\n//			nroot = root;\n			return;\n		}\n//		nroot = nroot->right;\n		push(p, nroot->right);\n	}\n}\n\nvoid print_node(struct node *cur)\n{\n	if(cur->left && cur->left->data >= 0)\n	{\n		print_node(cur->left);\n//		cur->left->data = -1;\n		cur->left = NULL;\n	}\n	printf(\"%d \", cur->data);\n	if(cur->right && cur->right->data >=0)\n		print_node(cur->right);\n	free(cur);\n//	cur->data = -1;\n	cur = NULL;\n}\n\nint main(void)\n{\n	FILE *f = fopen(\"temp.txt\",\"r\");\n	struct node *p, *nroot = NULL;\n	int d;\n	while(fscanf(f,\"%d\",&d) == 1)\n	{\n		p = malloc(sizeof(struct node));\n		p->data = d;\n		p->left = NULL;\n		p->right= NULL;\n		push(p, nroot);\n		nroot = root;\n	}\n	print_node(root);\n	printf(\"\\n\");\n	fclose(f);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1115,'#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define N 121\n#define INF 9000\n\ndouble distant(double x1, double x2, double y1, double y2)\n{\n	double x;\n	x = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1));\n	return x;\n}\n\n\nvoid voyage(double D[N][N], int G[N], int GG[N], int way[N], int n, double *res, int k)\n{\n	int i, j;\n	double x = 0;\n	for(i=0; i<n; i++)\n	{\n		if(k == n) //????? ?? ??????\n		{\n			for(j=0; j<(n-1); j++)\n				x += D[GG[j]][GG[j+1]];			\n			x += D[GG[j]][GG[0]];\n\n			if(x < *res)\n			{\n				printf(\"x = %.19lf\\n\", x);\n				*res = x;\n				for(j=0; j<n; j++)\n					way[j] = GG[j];				\n			}\n			return;\n		}\n		if(G[i] != -1) \n		{\n			GG[k] = G[i];\n			G[i] = -1;\n			voyage(D,G,GG,way,n,res,k+1);\n			G[i] = GG[k];\n		}\n	}\n}\n\nint main(void)\n{\n	FILE *f = fopen(\"to25.txt\",\"r\");\n	int i,j,n=0;\n	int G[N];         // ?????? ????? ?? 1 ?? n\n	int GG[N]={0};    // ??????????? ?????? ?????\n	int way[N];       // ???????? ?????? - ?????? ?????????? ???? (??????????????? ?? G)\n	double A[N][2];   // ????????? ?????? ?????????\n	double D[N][N];   // ?????? ? ??????????????? ? ??????? ?????????\n	double x,y;       \n	double res = INF; // ?????\n\n// 1) ????????? ?????????? ?????\n	while(fscanf(f,\"%lf%lf\",&x,&y)==2)\n	{\n		A[n][0]=x;\n		A[n][1]=y;\n		n++;\n	}\n	fclose(f);\n// -----------------------------\n\n// 2) ?????? ??????? D ? G.\n\n	for(i=0; i<n; i++)\n	for(j=0; j<n; j++)\n	{\n		(i == j)? \n		( D[i][j] = INF ) :\n		( D[i][j]= distant(A[i][0], A[j][0], A[i][1], A[j][1]) );\n		if(!j) putchar(\'\\n\');       //\n		printf(\"%4.4lf \", D[i][j]);    //\n	}\n	for(i=0; i<n; i++)\n		G[i]=i;\n// -----------------------------\n\n	printf(\"check\\n\");	\n	voyage(D, G, GG, way, n, &res, 0);\n\n// -----------------------------	\n	\n	printf(\"The path is      \");\n	for(i=0; i<n; i++)\n	{\n		printf(\"%d \", way[i]);\n	}\n	printf(\"%d\\nIt\'s length is   %lf\\n\", way[0], res);\n	return 0;\n}\n','ÐšÐ¸Ñ€Ð¸Ð»Ð»','Kirill','m');
INSERT INTO `bias` VALUES (1116,'#include <stdio.h>\n\nint main()\n{\n	int s[1000], f=0, i, j, sign=1;\n	char c;\n	double sum=0, b, k=1;\n	scanf(\"%lf\\n\", &b);\n	for(i=0;(c=getchar())!=\'\\n\';i++)\n	{\n		if(c==\'-\')\n		{\n			sign=-1;\n			c=getchar();\n		}\n		if(c==\'.\')\n		{\n			f=i;\n			c=getchar();\n		}\n		if(c>\'9\') s[i]=(c-\'A\'+10); else s[i]=(c-\'0\');\n	}\n	if(f==0) f=i;\n	for(j=1;j<f;j++,k*=b);\n	for(j=0;j<=i;j++,k/=b) sum+=s[j]*k;\n	sum*=sign;\n	printf(\"%lf\\n\", sum);\n	return 0;\n}	\n\n\n\n\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1117,'#include <stdio.h>\n#include <math.h>\n#define N 5\n\nvoid print1(int a, int b)\n{\n	if(a==0) return;\n	char p;\n	int d=(a%b);\n	if(d>9) p=\'A\'+d-10;\n	else p=\'0\'+d;\n	print1(a/b,b);\n	putchar(p);\n}\n\nint main()\n{\n	int f=0, i, k, sign=1, t=0, b;\n	char c;\n	double q=0, d=0.1;\n	scanf(\"%d\\n\", &b);\n	for(i=0;(c=getchar())!=\'\\n\';i++)\n	{\n		if(c==\'-\')\n		{\n			putchar(\'-\');\n			c=getchar();\n		}\n		if(c==\'.\')\n		{\n			f++;\n			c=getchar();\n		}\n		if(f==0)\n		{\n			t*=10;\n			t+=(c-\'0\');\n		}\n		else\n		{\n			q+=((c-\'0\')*d);\n			d/=10;\n		}\n	}\n	if(t==0) putchar(\'0\');\n	else print1(t,b);\n	if(f)\n	{\n		putchar(\'.\');\n		for(i=0;i<N;i++)\n		{\n			q*=b;\n			k=q;\n			q-=k;\n			if(k>9) c=\'A\'+k-10;\n			else c=\'0\'+k;\n			putchar(c);\n		}\n	}\n	putchar(\'\\n\');\n	return 0;\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1118,'#include <stdio.h>\n#include <string.h>\n\nint main()\n{\n	char login[1000], passwd[1000];\n	scanf(\"%s\",login);\n	FILE *inp=fopen(\"/etc/passwd\",\"r\");\n	int i=0, k;\n	char c;\n	while(fgets(passwd, 1000, inp)!=NULL)\n	{\n		k=0;\n		if((strstr(passwd,login)==passwd) && (passwd[strlen(login)]==\':\'))\n		{\n			for(i=0;k<4;i++) if(passwd[i]==\':\') k++;\n			for(k=i;passwd[k]!=\',\', passwd[k]!=\':\';k++) putchar(passwd[k]);\n			putchar(\'\\n\');\n			return 0;\n		}\n	}\n	printf(\"Not found\\n\");\n	fclose(inp);\n	return 0;\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1119,'#include <stdio.h>\n\nvoid gen(int used, int unused, int *a, int *b)\n{\n	int i, j, k=0, c[1000];\n	if(!unused)\n	{\n		for(i=0;i<used;i++) printf(\"%d \",a[i]);\n		printf(\"\\n\");\n		return;\n	}\n	for(i=0;i<unused;i++)\n	{\n		a[used]=b[i];\n		k=0;\n		for(j=0;j<(unused-1);j++)\n		{\n			if(j==i) k++;\n			c[j]=b[j+k];\n		}\n		gen((used+1),(unused-1),a,c);\n	}\n}\n\nint main()\n{\n	int n, i;\n	scanf(\"%d\", &n);\n	int a[1000], b[1000];\n	for(i=0;i<n;i++) b[i]=i+1;\n	gen(0,n,a,b);\n	return 0;\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1120,'#include <stdio.h>\n\nint main()\n{\n	FILE *inp=fopen(\"input.txt\", \"r\");\n	FILE *out=fopen(\"output.txt\", \"w\");\n	int A[1000000], n, i, j, min, t;\n	fscanf(inp, \"%d\", &n);\n	for(i=0;i<n;i++) fscanf(inp,\"%d\", &A[i]);\n	for(i=0;i<n;i++)\n	{\n		min=i;\n		for(j=i;j<n;j++) if(A[j]<A[min]) min=j;\n		t=A[i];\n		A[i]=A[min];\n		A[min]=t;\n	}\n	for(i=0;i<n;i++) fprintf(out,\"%d \", A[i]);\n	fprintf(out,\"\\n\");\n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1121,'#include <stdio.h>\n\nvoid quicksort(int A[], int low, int high)\n{\n	int l=low, r=high, m=A[(l+r)/2], t;\n	do\n	{\n		while(A[l]<m) l++;\n		while(A[r]>m) r--;\n		if(l<=r)\n		{\n			t=A[l];\n			A[l]=A[r];\n			A[r]=t;\n			l++;\n			r--;\n		}\n	}\n	while(l<=r);\n	if(low<r) quicksort(A,low,r);\n	if(high>l) quicksort(A,l,high);\n}\n\n\nint main()\n{\n	FILE *inp=fopen(\"input.txt\", \"r\");\n	FILE *out=fopen(\"output.txt\", \"w\");\n	int A[1000000], n, i, j, min, t;\n	fscanf(inp, \"%d\", &n);\n	for(i=0;i<n;i++) fscanf(inp,\"%d\", &A[i]);\n	quicksort(A,0,n-1);\n	for(i=0;i<n;i++) fprintf(out,\"%d \", A[i]);\n	fprintf(out,\"\\n\");\n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1122,'#include <stdio.h>\n\nvoid sift(int *A,int i,int n)\n{ \n	int max=i,child=i*2+1; \n	if((child<n) && (A[child]>A[max])) max=child;\n	child++; \n	if((child<n) && (A[child]>A[max])) max=child; \n	if(max==i) return;\n	int t=A[i];\n	A[i]=A[max];\n	A[max]=t;\n	sift(A,max,n); \n}\n \nint main()\n{\n	int A[100000], n, i;\n	FILE *inp=fopen(\"input.txt\",\"r\");\n	FILE *out=fopen(\"output.txt\",\"w\"); \n	fscanf(inp,\"%d\\n\",&n); \n	for(i=0;i<n;i++) fscanf(inp,\"%d\",&A[i]);\n	for(i=n/2-1;i>=0;i--) sift(A,i,n);\n	for(i=n-1;i>0;i--)\n	{ \n		int t=A[0]; \n		A[0]=A[i]; \n		A[i]=t;\n		sift(A,0,i);\n	} \n	for(i=0;i<n;i++) fprintf(out,\"%d \",A[i]);\n	fprintf(out,\"\\n\"); \n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1123,'#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	FILE *inp=fopen(\"input.txt\", \"r\");\n	FILE *out=fopen(\"output.txt\", \"w\");\n	int i, k;\n	struct item\n	{\n		int data;\n		struct item *next;\n	};\n	struct item *head=NULL, *p, *q;\n	while(fscanf(inp,\"%d\", &k)==1)\n	{\n		q=NULL;\n		for(p=head;p && p->data<=k;q=p,p=p->next);\n		p=malloc(sizeof(*p));\n		p->data=k;\n		if(q==NULL)\n		{\n			p->next=head;\n			head=p;\n		}\n		else\n		{\n			p->next=q->next;\n			q->next=p;\n		}\n	}\n	for(p=head;p;)\n	{\n		q=p;\n		fprintf(out,\"%d \",p->data);\n		p=p->next;\n		free(q);\n	}\n	fprintf(out,\"\\n\");\n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1124,'#include <stdio.h>\n#include <stdlib.h>\n\nint main()\n{\n	FILE *inp=fopen(\"input.txt\", \"r\");\n	FILE *out=fopen(\"output.txt\", \"w\");\n	int i, k;\n	struct item\n	{\n		int data;\n		struct item *next;\n	};\n	struct item *head=NULL, *p, *q;\n	while(fscanf(inp,\"%d\", &k)==1)\n	{\n		q=NULL;\n		for(p=head;p && p->data<=k;q=p,p=p->next);\n		p=malloc(sizeof(*p));\n		p->data=k;\n		if(q==NULL)\n		{\n			p->next=head;\n			head=p;\n		}\n		else\n		{\n			p->next=q->next;\n			q->next=p;\n		}\n	}\n	for(p=head;p;)\n	{\n		q=p;\n		fprintf(out,\"%d \",p->data);\n		p=p->next;\n		free(q);\n	}\n	fprintf(out,\"\\n\");\n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1125,'#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define SIZE 1007\n\nint getword(FILE *inp, char *s)\n{\n	while (1)\n	{ \n		char c; \n		int l=0,h=0;\n		while (!((((c=fgetc(inp))<=\'Z\')&&(c>=\'A\'))||((c<=\'z\')&&(c>=\'a\'))||(c==EOF)));\n		while (((c<=\'Z\')&&(c>=\'A\'))||((c<=\'z\')&&(c>=\'a\')))\n		{\n			s[l++]=c;\n			c=fgetc(inp);\n		}\n		s[l]=0; \n		if (c==EOF) return 0;\n		else return 1;\n	}\n}\n\nint hash(char *s)\n{\n	int i, d=1, sum=0;\n	for(i=0;s[i];i++)\n	{\n		sum+=(s[i]*d);\n		d*=11;\n	}\n	sum%=SIZE;\n	return sum;\n}\n\n\n\nint main()\n{\n	struct item\n	{\n		char word[11];\n		int count;\n		struct item *next;\n	};\n	FILE *inp=fopen(\"input.txt\",\"r\");\n	FILE *out=fopen(\"output.txt\",\"w\");\n	int i, h, flag;\n	struct item *hashtable[SIZE];\n	for(i=0;i<SIZE;i++) hashtable[i]=NULL;\n	char c[11];\n	struct item *p, *q;\n	while(getword(inp,c))\n	{\n		h=hash(c);\n		for(p=hashtable[h], q=NULL;p && strcmp(c,p->word)<0;q=p,p=p->next);\n		if(p && (strcmp(c,p->word)==0))\n			p->count++;			\n		else\n		{	\n			p=malloc(sizeof(*p));\n			strcpy(p->word,c);\n			p->count=1;\n			if(!q)\n			{\n				p->next=hashtable[h];\n				hashtable[h]=p;\n			}\n			else\n			{\n				p->next=q->next;\n				q->next=p;\n			}\n		}\n	}\n	for(i=0;i<SIZE;i++)\n	{\n	for(p=hashtable[i];p;)\n	{\n		q=p;\n		fprintf(out,\"%d %s %d\\n\",i, p->word,p->count);\n		p=p->next;\n		free(q);\n	}\n	}\n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n\n\n\n\n\n\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1126,'#include <stdio.h>\r\n#include <stdlib.h>\r\n#define NMAX 1001\r\n#define CHUNK 10\r\n\r\n\r\nstruct item\r\n{\r\n    char word[15];\r\n    int count;\r\n    struct item *next;\r\n};\r\n\r\nunsigned int hash (char *s)\r\n{\r\n    unsigned int res=0;\r\n    while (*s)\r\n    {\r\n        res+=*s;\r\n        s++;\r\n    }\r\n    return res%NMAX;\r\n}\r\n\r\nint main()\r\n{\r\n    struct item *head[NMAX]={NULL}, *p=NULL,  *q, *tek=malloc(sizeof (*tek));\r\n    FILE  *file=fopen(\"input.txt\", \"rt\"), *file2=fopen(\"output.txt\", \"w\");\r\n    unsigned int i=0;\r\n    char s[15];\r\n\r\n\r\n    while (fscanf(file, \"%s\", tek->word)==1)\r\n    {\r\n        i=hash(tek->word);\r\n       tek->count=1;\r\n//        if (!head[i])\r\n//        {\r\n//            printf (\"1.%s\\n\", tek->word);\r\n//            tek->next=head[i];\r\n//            head[i]=tek;\r\n//        }\r\n //       else if (0==strcmp(head[i]->word, tek->word))\r\n//        {\r\n//\r\n//            printf (\"2.%s %s\\n\", tek->word, head[i]->word);\r\n//            head[i]->count++;\r\n//        }\r\n//           else\r\n//           {\r\n               for (p=head[i];p;p=p->next)\r\n               {\r\n\r\n                    printf (\"3.%s\\n\", tek->word);\r\n                   if (!strcmp(p->word, tek->word)) {\r\n                       printf (\"%s%s\\n\", p->word, tek->word);\r\n                       p->count++;\r\n                       break;\r\n                   }\r\n               }\r\n //          }\r\n\r\n            if  (!p)\r\n            {\r\n                printf (\"1.%s\\n\", tek->word);\r\n                tek->next=head[i];\r\n                head[i]=tek;\r\n            }\r\n            else\r\n                free(tek);\r\n            tek=malloc(sizeof (*tek));\r\n\r\n    }\r\n    for (i=0; i<NMAX; i++)\r\n    {\r\n        if (head[i])\r\n        {\r\n            p=head[i];\r\n            while (p)\r\n            {\r\n                printf (\"%d %s %d\\n\", i, p->word, p->count);\r\n                q = p;\r\n                p=p->next;\r\n                free(q);\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}\r\n','Ð¡Ð²ÐµÑ‚Ð»Ð°Ð½Ð°','Svetlana','f');
INSERT INTO `bias` VALUES (1127,'#include <stdio.h>\r\n#include <stdlib.h>\r\n\r\nstruct node {\r\n       int data;\r\n       struct node * left, * right;\r\n       };\r\n\r\nvoid free_memory(struct node * root)\r\n{\r\n     if (!root)\r\n        return;\r\n        \r\n        free_memory(root->left);\r\n        free_memory(root->right);\r\n        free(root);\r\n}\r\n\r\nvoid infex(struct node * root)\r\n{\r\n     //printf(\"i\'m printing\");\r\n     if (!root) return;\r\n     infex(root->left);\r\n     printf(\"%d \", root->data);\r\n     infex(root->right);\r\n}\r\nvoid f(struct node * q, struct node * p, struct node * root)\r\n{\r\n     //printf(\"ROOT=%d\\n\", root->data);\r\n     \r\n     if (p->data > q->data)\r\n     {\r\n                 //printf(\"i\'m working r\\n\");\r\n                 if (q->right)\r\n                    f(q->right, p, root);\r\n                 else q->right=p;\r\n                 return;\r\n     }\r\n     else\r\n     {\r\n                 //printf(\"i\'m working L\\n\");\r\n                 if (q->left)\r\n                    f(q->left, p, root);\r\n                 else q->left=p;\r\n                 return;\r\n     }\r\n}\r\nint main()\r\n{\r\n    struct node * root=NULL;\r\n    struct node * p, * q;\r\n    int a, h=0;\r\n    freopen(\"input.txt\", \"r\", stdin);\r\n    freopen(\"output.txt\", \"w\", stdout);\r\n    while(scanf(\"%d\", &a)==1)\r\n    {\r\n             //printf(\"i\'m reading %d\\n\", a);\r\n             struct node * p=malloc(sizeof(*p));\r\n             p->data=a;\r\n             p->left=p->right=NULL;\r\n             q=root;\r\n             if (!h)\r\n             {\r\n                    h=1;\r\n                    root=p;\r\n                    //printf(\"i\'m working %d\\n\", root->data);\r\n             }\r\n             else \r\n             {\r\n                  //printf(\"a=%d\\n\", a);\r\n                  f(q, p, root);\r\n                  \r\n             }\r\n             \r\n    }\r\n            //printf(\"it\'s time for printing!\\n\");\r\n            infex( root);\r\n            free_memory(root); \r\n            return 0;\r\n}          \r\n                  \r\n','ÐÐ½Ð°ÑÑ‚Ð°ÑÐ¸Ñ','Anastasiya','f');
INSERT INTO `bias` VALUES (1128,'#include <stdio.h>\n#include <string.h>\n\nint print(char *s, FILE *out, int flag)\n{\n	int i;\n	for(i=0;s[i];i++)\n	{\n		if(s[i]==\'\\\"\')\n		{\n			if(flag)\n			{\n				if(s[i+1]==\'\\\"\')\n				{\n					fputc(\'\\\"\', out);\n					i++;\n					continue;\n				}\n				else\n				{\n					fprintf(out,\"\\n<1/td>\\n\");\n					if(s[i+1]==\',\') fprintf(out,\"<td>\\n\");\n					flag=0;\n					i++;\n					continue;\n				}\n			}\n			else\n			{\n				flag=1;\n				continue;\n			}	\n		}\n		if(s[i]==\',\')\n		{\n			if(flag)\n			{\n				fputc(\',\',out);\n				continue;\n			}\n			else\n			{\n				fprintf(out,\"\\n<2/td>\\n<td>\\n\");\n				continue;\n			}\n		}\n		fputc(s[i],out);\n	}\n	if(flag) fprintf(out,\"<br/>\\n\"); else fprintf(out,\"<3/td>\\n</tr>\\n\");\n	return flag;\n}\n\nint main()\n{\n	FILE *inp=fopen(\"input.txt\", \"r\");\n	FILE *out=fopen(\"output.txt\", \"w\");\n	char s[1000];\n	int flag=0;\n	fprintf(out,\"<table>\\n\");\n	while(fgets(s,1000,inp)!=NULL)\n	{\n		fprintf(out,\"<tr>\\n<td>\\n\");\n		while(flag=print(s, out, flag)) fgets(s,1000,inp);\n	}\n	fprintf(out,\"</table>\\n\");\n	fclose(inp);\n	fclose(out);\n	return 0;\n}\n','Ð”Ð¼Ð¸Ñ‚Ñ€Ð¸Ð¹','Dmitry','m');
INSERT INTO `bias` VALUES (1129,'#include <stdio.h>\n#define N 100\n#define INF 100000\n\nint A[N][N];\nint D[N];\nint used[N];\nint prev[N];\n\nint mini(int *D, int n)\n{\n	int min=1;\n	int i;\n	for(i=1;i<=n;i++)\n	{\n		if(!used[i])\n		{\n			if(D[min]>D[i])\n			{\n				min=i;\n			}\n		}\n	}\n	return min;\n}\n\nvoid dijkstra(int curr, int n, int *D, int *used)\n{\n	int min;\n	int i,j;\n	min=mini(D,n);\n	used[min]=1;\n	for(i=1;i<=n;i++)\n	{\n		if(!used[i] && A[curr][i])\n		{\n			if(D[i]>D[curr]+A[curr][i])\n			{\n				D[i]=D[curr]+A[curr][i];\n				dijkstra(i,n,D,used);\n				prev[i]=curr;\n			}\n		}\n	}\n//	for(i=1;i<=n;i++)\n//		printf(\"D[%d]=%d \",i,D[i]);\n//	printf(\"\\n\");\n	return;\n}\n\nint main()\n{\n	int i,j,d;\n	int start;\n	int n;\n	int min;\n	freopen(\"input24.txt\",\"r\",stdin);\n	scanf(\"%d\\n\",&start);\n	scanf(\"%d\\n\",&n);	\n	while(scanf(\"%d %d %d\",&i,&j,&d)==3)\n	{\n		A[i][j]=A[j][i]=d;\n	}\n	\n	for(i=1;i<=n;i++)\n	{\n		prev[i]=-1;\n		used[i]=0;\n		D[i]=INF;\n	}\n	D[start]=0;\n//	min=mini(D,n);\n	dijkstra(start,n,D,used);\n/*	printf(\"v=%d min=%d\\n\",min,D[min]);\n	for(i=1;i<=n;i++)\n		printf(\"D[%d]=%d \",i,D[i]);\n	printf(\"\\n\");\n\n	printf(\"start=%d n=%d\\n\",start,n);\n	for(i=1;i<=n;i++)\n	{\n		for(j=1;j<=n;j++)\n		{\n			printf(\"% 3d \",A[i][j]);\n		}\n		printf(\"\\n\");\n	}*/\n	for (i = 1; i <= n; i++)\n	{\n		printf(\"%d \", prev[i]);\n	}\n	printf(\"\\n\");\n	for(i=1;i<=n;i++)\n	{\n		printf(\"%d -> %d = %d: \",start,i,D[i]);\n		for(j=i;j>0;)\n		{\n			printf(\"%d \",j);		\n			j=prev[j];\n		}\n		printf(\"\\n\");\n	\n	}\n//	for(i=1;i<=n;i++)\n//	{\n//		printf(\"prev[%d]=%d\",i,prev[i]);\n//	}\n	printf(\"\\n\");\n	fclose(stdin);\n	return 0;\n}\n','ÐœÐ°ÐºÑÐ¸Ð¼','Maxim','m');
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2015-08-04  4:05:19
